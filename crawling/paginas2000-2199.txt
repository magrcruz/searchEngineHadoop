{"url":"Numerical_Recipes","titulo":"Numerical Recipes","contenido":" Numerical Recipes es el titulo generico de una serie de libros sobre algoritmos y analisis numerico de William H. Press, Saul A. Teukolsky, William T. Vetterling y Brian P. Flannery. Se han impreso varias ediciones desde 1986. La edicion mas reciente (2015) se publico en 2007.  Los libros Numerical Recipes versan sobre una variedad de temas que incluyen tanto analisis numerico clasico (interpolacion, integracion, algebra lineal, ecuaciones diferenciales, etc.), procesamiento de se\u00f1ales metodos de Fourier, filtrado), tratamiento estadistico de los datos, y algunos temas de aprendizaje automatico  (modelos oculto de Markov, maquinas de vectores de soporte). El estilo de escritura es accesible y tiene un tono informal. El enfasis esta en la comprension de los fundamentos subyacentes de las tecnicas, no en los refinamientos que pueden, en la practica, se necesitarian para lograr un rendimiento y fiabilidad optimos. Pocos resultados se probaron con cualquier grado de rigor, aunque las ideas detras de las pruebas a menudo se esbozan y se dan referencias.  Practicamente todos los metodos que se estudian tambien estan implementados en un lenguaje de programacion, con el codigo impreso en el libro. El codigo esta tambien comercializado en forma electronica en diferentes lenguajes de programacion.  De acuerdo con el editor, Cambridge University Press, los libros Numerical Recipes son historicamente los de mayor venta sobre metodos de programacion cientificos. En los ultimos a\u00f1os, los libros Numerical Recipes han sido citados en la literatura cientifica mas de 3000 veces por a\u00f1o, segun el ISI Web of Knowledge (por ejemplo, 3962 veces en el a\u00f1o 2008).\u200b  Publicado por primera vez en 1986 con el titulo, \"Numerical Recipes, The Art of Scientific Computing\", que contiene el codigo tanto en Fortran como Pascal; un libro de acompa\u00f1amiento, \"Numerical Recipes Ejemplo libro (Pascal) se publico por primera vez en 1985. (Una nota prefacio de\" Ejemplos \"menciona que el libro principal tambien se publico en 1985, pero la nota oficial en ese libro dice 1986.) Ediciones Suplementarios seguido con el codigo en Pascal, BASIC y C. Numerical Recipes tomaron, desde el principio, una posicion editorial obstinado en desacuerdo con la sabiduria convencional de la comunidad de analisis numerico:  Sin embargo, como se vio despues, la decada de 1980 fueron a\u00f1os fertiles para el lado de \"recuadro negro\", dando bibliotecas importantes como BLAS y LAPACK y entornos integrados como MATLAB y Mathematica. A principios de la decada de 1990, cuando se publico la segunda edicion de Numerical Recipes (con codigo en C, Fortran-77 y Fortran-90), estaba claro que el distrito electoral para Numerical Recipes fue de ninguna manera la mayoria de los cientificos que hacen el calculo, pero solo esa rebanada que vivio entre los analistas numericos mas matematicas y la comunidad en general el uso de entornos integrados. Las versiones Segunda edicion ocuparon un papel estable en este ambiente del lugar.\u200b  A mediados de la decada de 2000, la practica de la computacion cientifica habia sido alterada radicalmente por Internet. Reconociendo que sus libros Numerical Recipes se valoran cada vez mas por su texto explicativo que por sus ejemplos de codigo, los autores ampliaron considerablemente el alcance del libro, y reescribieron significativamente una gran parte del texto. Continuaron incluir codigo, impreso en el libro, ahora en C ++, para cada metodo discutido.\u200b La tercera edicion tambien fue lanzado como un libro electronico,\u200b finalmente puesto a disposicion en la web de forma gratuita (con la vistas limitada pagina) o mediante pago o suscripcion institucional (con vistas paginas ilimitadas).  Teniendo en cuenta el estilo de escritura de los libros, no es de extra\u00f1ar que eran (y siguen siendo hasta cierto punto) controvertidos dentro de la comunidad de analisis numerico. Las primeras criticas se han centrado en la \"supuesta falta de fiabilidad\" ( de hecho, la primera edicion contenia algunos errores), la exclusion de ciertos algoritmos, y la afirmacion de los autores, no siempre correcta, que sus programas son tan eficientes y fiables que las bibliotecas de tipos \"recuadro negro\", como bibliotecas NAG o IMSL. Aunque no menciono Numerical Recipes saber, Whaley et al.\u200b muestran que LAPACK con una biblioteca BLAS altamente optimizado puede ser un orden de magnitud mas rapido que una rutina directamente inspirado por Numerical Recipes. Otro ejemplo, Frigo y Johnson\u200b muestren que el codigo de la transformada rapida de Fourier (FFT) de Numerical Recipes es entre 5 a 40 veces mas lento que las arquitecturas altamente optimizados de programas digitales modernos.  Una segunda critica es que, a pesar de que el codigo esta impreso en los libros, los autores de obras tienen derecho sobre ellos, y no es posible redistribuir los codigos fuente de Numerical Recipes. El codigo comercializado no es compatible con las licencias GPL o similar, a diferencia, por ejemplo, a la GNU Scientific Library. Sin embargo, es posible redistribuir un programa compilado para uso no comercial.\u200b  Una tercera critica se centra en el estilo de codificacion utilizado en los libros, algunas lectores modernos encontraron demasiado influenciado por el estilo del \"fortran\" aun cuando el libro emplea un lenguaje mas orientado a objetos. Sin embargo, los autores defienden su estilo de codificacion muy conciso es necesario por el formato de los libros, que requiere un estilo de codificacion conciso debido a las limitaciones de espacio y facilidad de lectura.\u200b  Los libros difieren en edicion (primera, segunda y tercera) y por el lenguaje de programacion en el que aparece el codigo.  Los libros son publicados por Cambridge University Press. ","snippet":" Numerical Recipes es el titulo generico de una serie de libros sobre algoritmos y analisis numerico de William H. Press, Saul A. Teukolsky, William T. Vetterling y Brian P. Flannery. Se han impreso v","enlaces_salientes":["Numerical_Recipes","Numerical_Recipes","Numerical_Recipes","Idioma_ingl%C3%A9s","An%C3%A1lisis_num%C3%A9rico","Algoritmo","An%C3%A1lisis_num%C3%A9rico","Interpolaci%C3%B3n","Integraci%C3%B3n_num%C3%A9rica","%C3%81lgebra_lineal","Ecuaci%C3%B3n_diferencial","Transformada_r%C3%A1pida_de_Fourier","Filtro_digital","Aprendizaje_autom%C3%A1tico","Modelo_oculto_de_Markov","M%C3%A1quinas_de_vectores_de_soporte","Cambridge_University_Press","Basic_Linear_Algebra_Subprograms","GNU_Scientific_Library","C_(lenguaje_de_programaci%C3%B3n)","Fortran","Pascal_(lenguaje_de_programaci%C3%B3n)","Thomson_Reuters","ISBN","Wayback_Machine","ISBN","ISBN","Connexions","Wayback_Machine","Control_de_autoridades"]}
{"url":"Aut%C3%B3matas_celulares","titulo":"Automata celular","contenido":"Un automata celular (A.C.) es un modelo matematico y computacional para un sistema dinamico que evoluciona en pasos discretos. Es adecuado para modelar sistemas naturales que puedan ser descritos como una coleccion masiva de objetos simples que interactuen localmente unos con otros.  Es un modelo matematico para un sistema dinamico que consiste en una rejilla formada por celdas que pueden cambiar de estado o no dependiendo diversas leyes. Es un espacio regular. Tiene un conjunto de estados finito y cada elemento toma un valor de este conjunto de estados. Presenta una funcion de transicion local que es la regla de evolucion que determina el comportamiento del automata.  La definicion de un A.C. requiere mencionar sus elementos basicos:  Se clasifican principalmente de la siguiente manera:  Son sistemas descubiertos dentro del campo de la fisica computacional por John von Neumann en la decada de 1950. La teoria de los automatas celulares se inicia con su precursor John von Neumann a finales de la decada de 1940 con su libro Theory of Self-reproducing Automata (editado y completado por A. W. Burks).  Aunque John von Neumann puso en practica los AA.CC., estos fueron concebidos en los a\u00f1os 40 por Konrad Zuse y Stanislaw Ulam. Zuse penso en los \u201cespacios de computo\u201d (computing spaces), como modelos discretos de sistemas fisicos. Las contribuciones de Ulam vinieron al final de los 40, poco despues de haber inventado con Nicholas Metropolis el Metodo de Montecarlo.  su caracteristica principal es su capacidad de lograr una serie de propiedades que surgen de la propia dinamica local atreves del tiempo y no desde un inicio. Por lo tanto, no es facil analizar las propiedades globales de un AC desde su comienzo, complejo por naturaleza.  La definicion de un AC requiere mencionar sus elementos basicos:    No existe una definicion formal y matematica aceptada de automata celular; sin embargo, se puede describir a un A.C. como una tupla, es decir, un conjunto ordenado de objetos caracterizado por los siguientes componentes:  Por definicion, un A.C. consiste en una reticula infinita de enteros. Sin embargo, para cuestiones practicas (como en modelos de sistemas fisicos llevados a cabo en ordenadores de memoria finita), se requiere tomar ciertas consideraciones a la hora de implementar un A.C. Por ello, la definicion original se modifica para dar cabida a reticulas finitas en las que las celulas del A.C. interactuen. Esto conlleva la consideracion extra de lo que debe suceder con aquellas celulas que se encuentren en los bordes de la reticula. A la implementacion de una o varias consideraciones especificas se le conoce como condicion de frontera.  Dentro del ambito de los A.C., se pueden implementar numerosas condiciones de frontera, en funcion de lo que el problema real requiera para su modelado. Por ejemplo:  Los A.C. pueden variar en alguna de las caracteristicas antes mencionadas, derivando en automatas celulares no estandar.  Por ejemplo, un A.C. estandar tiene una cuadricula donde se asume que las celulas son cuadros; es decir, que la reticula tiene una geometria cuadrada. Esto no es necesariamente un requisito, y se puede variar el A.C. para presentar una geometria triangular o hexagonal (en A.C. de 2 dimensiones, el cuadrado, el triangulo y el hexagono son las unicas figuras geometricas que llenan el plano).  Tambien puede variarse el conjunto de estados k que cada celula puede tomar, la funcion de transicion f de forma que ya no sea homogenea, utilizar elementos estocasticos (aleatoriedad) en f (lo que se conoce como A.C. probabilistico), variar las vecindades de cada celula, etc.  La complejidad de un automata celular se determina conforme aumenta su dimensionalidad (lineal, plano, espacio, etc), pues el numero de posibles vecinos incrementa de acuerdo a las geometrias o distribuciones espaciales en las que se genere. Para el caso de una dimension cada celula tendra solo 2 vecinos, en dos dimensiones (o plano) contara con 4 vecinos (arriba, abajo, izquierda, derecha), 8 vecinos si se toman en cuenta las diagonales y en 3D llegara a tener hasta posibles 26 vecinos.  La historia de los automatas celulares puede ser clasificada en tres etapas asociadas a los nombres de los cientificos que en cada momento marcaron un punto de inflexion en el desarrollo de la teoria: la era de Von Neumann, la era de John Horton Conway y la era de Stephen Wolfram.  La primera etapa la inicia von Neumann,\u200b quien una vez terminada su participacion en el desarrollo y terminacion de la primera computadora ENIAC tenia en mente desarrollar una maquina con la capacidad de construir a partir de si misma otras maquinas (auto-reproduccion) y soportar comportamiento complejo. Con la ayuda de su amigo Stanislaw Ulam, von Neumann implementa la teoria de los automatas celulares en un vector de dos dimensiones Z \u00d7 Z \\times \\mathbb {Z} } (donde Z } representa el conjunto de los enteros). El vector es llamado el espacio de evoluciones y cada una de las posiciones (llamadas celulas) en el vector toma un valor del conjunto de estados | k | = 29 . La funcion de transicion que determina el comportamiento del automata celular utiliza la vecindad de von Neumann, que consiste en un elemento central x ( i , j ) (llamada celula central) y sus vecinos que son las celulas x ( i , j \u2212 1 ) , x ( i , j + 1 ) , x ( i \u2212 1 , j ) y x ( i + 1 , j ) (es decir, la celula en cuestion y sus celulas vecinas mas proximas, arriba, abajo, izquierda y derecha, respectivamente).  En 1970, John Horton Conway dio a conocer el automata celular que probablemente sea el mas conocido: el Juego de la vida (Life), publicado por Martin Gardner en su columna Mathematical Games en la revista Scientific American.\u200b Life ocupa una cuadricula (lattice bidimensional) donde se coloca al inicio un patron de celulas \"vivas\" o \"muertas\". La vecindad para cada celula son ocho: los vecinos formados por la vecindad de Von Neumann y las cuatro celulas de las dos diagonales (esta vecindad se conoce como vecindad de Moore). De manera repetida, se aplican simultaneamente sobre todas las celulas de la cuadricula las siguientes 3 reglas:  Una de las caracteristicas mas importantes de Life es su capacidad de realizar computo universal, es decir, que con una distribucion inicial apropiada de celulas vivas y muertas, Life se puede convertir en una computadora de proposito general (maquina de Turing).  Stephen Wolfram\u200b ha realizado numerosas investigaciones sobre el comportamiento cualitativo de los A.C. Con base en su trabajo sobre AC unidimensionales, con dos o tres estados, sobre configuraciones periodicas que se presentan en el A.C., observo sus evoluciones para configuraciones iniciales aleatorias. Asi, dada una regla, el A.C. exhibe diferentes comportamientos para diferentes condiciones iniciales.  De esta manera, Wolfram clasifico el comportamiento cualitativo de los A.C. unidimensionales. De acuerdo con esto, un AC pertenece a una de las siguientes clases:  Los automatas celulares pueden ser usados para modelar numerosos sistemas fisicos que se caractericen por un gran numero de componentes homogeneos y que interactuen localmente entre si. De hecho, cualquier sistema real al que se le puedan analogar los conceptos de \"vecindad\", \"estados de los componentes\" y \"funcion de transicion\" es candidato para ser modelado por un A.C.  Las caracteristicas de los automatas celulares haran que dichos modelos sean discretos en tiempo, espacio o ambos, dependiendo de la variante de la definicion de A.C. que se use. Algunos ejemplos de areas en donde se utilizan los automatas celulares son:  El automata celular no trivial mas simple consiste en una reticula unidimensional de celulas que solo pueden tener dos estados (\u00ab\u00a00\u00a0\u00bb o \u00ab\u00a01\u00a0\u00bb), con un vecindario constituido, para cada celula, por ella misma y por las dos celulas adyacentes (23=8 configuraciones posibles). Existen 28=256 modos de definir cual ha de ser el estado de una celula en la generacion siguiente para cada una de estas configuraciones, luego existen 256 automatas celulares diferentes de este tipo.  Consideremos el automata celular definido por la tabla siguiente, que nos da la regla de evolucion:  Se trata de un ejemplo de automata celular creado por John Horton Conway en 1970.  Consiste en un plano infinito lleno por completo \"celulas\" cuadradas, cada una de las cuales puede estar viva o muerta. Asi, cada una de las celulas esta rodeada por otras ocho que denominaremos \"vecinas\", y su estado depende de ellas siguiendo estas sencillas reglas:  La simulacion de este automata muestra interesantes tipos de patrones de comportamiento de las \"celulas\" que son dignas de estudio.  Se trata de un ejemplo de automata celular creado por Christopher Langton en 1986. Consiste en una \"hormiga\" que se desplaza sobre un plano infinito de baldosas cuadradas de color blanco o negro. Se desplaza siguiendo estas sencillas reglas:  El comportamiento desarrollado por esta \"hormiga\" ha sido digno de estudio. Comienza con patrones de movimiento simples, a los que siguen otros caoticos, para terminar siguiendo un patron ciclico que forma una \"calle\" en diagonal por la que avanza ininterrumpidamente la \"hormiga\". ","snippet":"Un automata celular (A.C.) es un modelo matematico y computacional para un sistema dinamico que evoluciona en pasos discretos. Es adecuado para modelar sistemas naturales que puedan ser descritos como","enlaces_salientes":["Aut%C3%B3mata_celular","Aut%C3%B3mata_celular","Aut%C3%B3mata_celular","Juego_de_la_vida","Modelo_matem%C3%A1tico","Modelo_computacional","Sistema_din%C3%A1mico","Discreto","Interacciones_fundamentales","F%C3%ADsica_computacional","John_von_Neumann","A%C3%B1os_1950","A%C3%B1os_1940","John_von_Neumann","A%C3%B1os_1940","Konrad_Zuse","Stanislaw_Ulam","Nicholas_Metropolis","M%C3%A9todo_de_Montecarlo","Matem%C3%A1ticas","Tupla","Ret%C3%ADculo_(orden)","C%C3%A9lula","Entorno_(matem%C3%A1tica)","Topolog%C3%ADa","2D","3D","Frontera_(topolog%C3%ADa)","Circunferencia","Toroide","ENIAC","Stanislaw_Ulam","1970","John_Horton_Conway","Juego_de_la_vida","Martin_Gardner","Scientific_American","Turing_completo","M%C3%A1quina_de_Turing","Stephen_Wolfram","Teor%C3%ADa_del_caos","Sistemas_complejos","Sistema_din%C3%A1mico","Caparaz%C3%B3n_(biolog%C3%ADa)","Tr%C3%A1nsito_vehicular","Gas","L%C3%ADquido","VIH","Percolaci%C3%B3n","Arquitectura_de_computadoras","Red_neuronal_artificial","Regla_30","Juego_de_la_vida","Hormiga_de_Langton","Modelo_Nagel-Schreckenberg","Aut%C3%B3mata_celular_cu%C3%A1ntico","Emergencia_(filosof%C3%ADa)","M%C3%A1quina_de_Turing","Teor%C3%ADa_de_aut%C3%B3matas","Ciudad_Permutaci%C3%B3n","Internet_Archive","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings"]}
{"url":"Computadora_cu%C3%A1ntica","titulo":"Computacion cuantica","contenido":"La computacion cuantica o informatica cuantica\u200b es un paradigma de computacion distinto al de la informatica clasica. Se basa en el uso de cubits (qubits en ingles), una especial combinacion de unos y ceros. Los bits de la computacion clasica pueden estar en 1 o en 0, pero solo un estado a la vez, en tanto que el cubit (quantum bit) puede tener los dos estados simultaneamente. Esto da lugar a nuevas puertas logicas que hacen posibles nuevos algoritmos.  Una misma tarea puede tener diferente complejidad en computacion clasica comparada con la que tiene en computacion cuantica, lo que ha dado lugar a una gran expectacion, ya que algunos problemas intratables pasan a ser tratables. Mientras que un computador clasico equivale a una maquina de Turing,\u200b un ordenador cuantico equivale a una maquina de Turing cuantica.  El enfoque de las computadoras cuanticas es resolver problemas de una manera fundamentalmente nueva. Los investigadores[\u00bfquien?] esperan que con este nuevo enfoque de la computacion puedan comenzar a explorarse algunos problemas que nunca podremos resolver de otra manera.  La doctora Talia Gershon (directora de Estrategia de Investigacion e Iniciativas de Crecimiento en IBM) describe la computacion cuantica, de manera muy general, como una combinacion entre tres factores: la superposicion de giros, el entrelazamiento de dos objetos y la interferencia, la cual ayuda a controlar los estados cuanticos y amplificar los tipos de se\u00f1ales que estan orientados hacia la respuesta correcta, y luego cancelar los tipos de se\u00f1ales que conducen a la respuesta incorrecta.  A medida que evoluciona la tecnologia y se reduce el tama\u00f1o de los transistores para producir microchips cada vez mas peque\u00f1os, esto se traduce en mayor velocidad de proceso. Sin embargo, no se pueden hacer los chips infinitamente peque\u00f1os, ya que hay un limite tras el cual dejan de funcionar correctamente. Cuando se llega a la escala de nanometros, los electrones se escapan de los canales por donde deben circular; a esto se le denomina: efecto tunel.  Una particula clasica, si se encuentra con un obstaculo, no puede atravesarlo y rebota. Pero con los electrones, que son particulas cuanticas y se comportan como ondas, existe la posibilidad de que una parte de ellos pueda atravesar las paredes si son lo suficientemente delgadas; de esta manera la se\u00f1al puede pasar por canales donde no deberia circular. Por ello, el chip deja de funcionar correctamente.  La idea de computacion cuantica surge en 1981, cuando Paul Benioff expuso su teoria para aprovechar las leyes cuanticas en el entorno de la informatica. En vez de trabajar a nivel de voltajes electricos, se trabaja a nivel de cuanto. En la computacion digital, un bit puede tomar solo uno de dos valores: 0 o 1. En cambio, en la computacion cuantica intervienen las leyes de la mecanica cuantica, y la particula puede estar en superposicion coherente: puede ser 0, 1 y puede ser 1 y 0 a la vez (dos estados ortogonales de una particula subatomica). Eso permite que se puedan realizar varias operaciones a la vez, segun el numero de cubits.  El numero de cubits indica la cantidad de bits que pueden estar en superposicion. Con los bits convencionales, si se tenia un registro de tres bits, habia ocho valores posibles y el registro solo podia tomar uno de esos valores. En cambio, si se tiene un vector de tres cubits, la particula puede tomar ocho valores distintos a la vez gracias a la superposicion cuantica. Asi, un vector de tres cubits permitiria un total de ocho operaciones paralelas. Como cabe esperar, el numero de operaciones es exponencial con respecto al numero de cubits.  Para hacerse una idea del gran avance, un computador cuantico de 30 cubits equivaldria a un procesador convencional de 10 teraflops (10 billones de operaciones en coma flotante por segundo), actualmente la supercomputadora convencional Summit tiene la capacidad de procesar 200 petaflops (200 mil billones).  En el modelo de computo tradicional el bit es la unidad minima de informacion, el cual corresponde a un sistema binario, solo puede tomar dos valores, representados por 0 y 1. Es posible usar y combinar mas bits para representar mayor cantidad de informacion.  Por el otro lado, en un sistema de computo cuantico la unidad minima de informacion es el cubit, el cual posee el principio de superposicion cuantica, que permite al cubit tomar diversos valores a la vez, puede ser 0 y 1, o bien es incluso posible que no solo ocurra una superposicion de ambos valores, sino que ocurra una superposicion simultanea de todos los cubits que se esten combinando, un conjunto de dos cubits puede representar una superposicion de valores: 00, 01, 10 y 11 a la vez.\u200b El incremento de la capacidad de superposicion, equivale a una mayor capacidad de representacion de informacion.  El entrelazamiento es una cualidad con la que dos cubits que han sido entrelazados (en una correlacion) pueden ser manipulados para hacer exactamente lo mismo, garantizando que se puedan realizar operaciones en paralelo o simultaneamente. A este principio se le conoce como paralelismo cuantico, y permite que la capacidad de realizar operaciones en paralelo crezcan de manera exponencial en relacion con el numero de cubits con los que puede operar el computador.\u200b  Durante la manipulacion de cubits, se puede realizar una operacion llamada interferencia cuantica, que aprovecha las propiedades de la superposicion para reforzar o cancelar ciertos resultados, mejorando asi la precision y eficiencia de los calculos. [cita\u00a0requerida]  Uno de los obstaculos principales para la computacion cuantica es el problema de la decoherencia cuantica, que causa la perdida del caracter unitario (y, mas especificamente, la reversibilidad) de los pasos del algoritmo cuantico. Los tiempos de decoherencia para los sistemas candidatos, en particular el tiempo de relajacion transversal (en la terminologia usada en la tecnologia de resonancia magnetica nuclear e imagineria por resonancia magnetica), esta tipicamente entre nanosegundos y segundos, a temperaturas bajas. Las tasas de error son tipicamente proporcionales a la razon entre tiempo de operacion frente a tiempo de decoherencia, de forma que cualquier operacion debe ser completada en un tiempo mucho mas corto que el tiempo de decoherencia. Si la tasa de error es lo bastante baja, es posible usar eficazmente la correccion de errores cuantica, con lo cual si serian posibles tiempos de calculo mas largos que el tiempo de decoherencia y, en principio, arbitrariamente largos. Se cita con frecuencia una tasa de error limite de 10\u20134, por debajo de la cual se supone que seria posible la aplicacion eficaz de la correccion de errores cuanticos.  El doctor Steven Girvin (profesor de fisica en el Instituto Cuantico de Yale), cuyo enfoque principal es la correccion de errores cuanticos y tratar de comprender el concepto de tolerancia a fallas, dice que \u00abtodos creen saberlo cuando lo ven, pero nadie en el caso cuantico puede definirlo con precision\u00bb. Asi mismo, menciona que en un sistema cuantico, cuando se observa la tolerancia a fallas o se realizan mediciones, el sistema puede cambiar de una manera que esta fuera de control.  Otro de los problemas principales es la escalabilidad, especialmente teniendo en cuenta el considerable incremento en cubits necesarios para cualquier calculo que implica la correccion de errores. Para ninguno de los sistemas actualmente propuestos es trivial un dise\u00f1o capaz de manejar un numero lo bastante alto de cubits para resolver problemas computacionalmente interesantes hoy en dia.  Aun no se ha resuelto el problema sobre que soporte fisico seria el idoneo para la computacion cuantica. Se ha definido una serie de condiciones que debe cumplir, conocida como la lista de Di Vincenzo, y hay varios candidatos actualmente.  Ingenieros de Google trabajan (2018) en un procesador cuantico llamado \"Bristlecone\".  En 2004, cientificos del Instituto de Fisica aplicada de la Universidad de Bonn publicaron resultados sobre un registro cuantico experimental. Para ello utilizaron atomos neutros que almacenan informacion cuantica, por lo que son llamados \u00abcubits\u00bb por analogia con los \u00abbits\u00bb. Su objetivo actual es construir una puerta cuantica, con lo cual se tendrian los elementos basicos que constituyen los procesadores, que son el corazon de los computadores actuales. Cabe destacar que un chip de tecnologia VLSI contiene actualmente mas de 100\u00a0000 puertas, de manera que su uso practico todavia se presenta en un horizonte lejano.  Cientificos de los laboratorios Max Planck y Niels Bohr publicaron en la revista Nature en noviembre de 2004, resultados sobre la transmision de informacion cuantica a distancias de 100\u00a0km usando la luz como vehiculo,\u200b obteniendo niveles de exito del 70\u00a0%, lo que representa un nivel de calidad que permite utilizar protocolos de transmision con autocorreccion. Actualmente se trabaja en el dise\u00f1o de repetidores, que permitirian transmitir informacion a distancias mayores a las ya alcanzadas.  Los algoritmos cuanticos se basan en un margen de error conocido en las operaciones de base y trabajan reduciendo el margen de error a niveles exponencialmente peque\u00f1os, comparables al nivel de error de las maquinas actuales.  La clase de complejidad BQP estudia el costo de los algoritmos cuanticos con bajo margen de error.  Se ha sugerido el uso de la informatica cuantica como alternativa superior a la computacion clasica para varios problemas, entre ellos:  A comienzos de la decada de 1980, empezaron a surgir las primeras teorias que apuntaban a la posibilidad de realizar calculos de naturaleza cuantica.  Las ideas esenciales de la computacion cuantica surgieron de la mente de Paul Benioff, quien trabajaba en el Laboratorio Nacional Argonne, en Illinois (Estados Unidos). Imagino un ordenador tradicional (maquina de Turing) que trabajaba con algunos principios de la mecanica cuantica.  Richard Feynman, fisico del Instituto de Tecnologia de California (Estados Unidos) y ganador del Premio Nobel en 1965, presento una ponencia durante la Primera Conferencia sobre la Fisica de la Computacion, realizada en el Instituto Tecnologico de Massachusetts (Estados Unidos). Su charla, titulada Simulacion de la fisica con computadoras (Simulating physics with computers), proponia el uso de fenomenos cuanticos para realizar calculos computacionales y exponia que, dada su naturaleza, algunos calculos de gran complejidad se realizarian mas rapidamente en un ordenador cuantico.  David Deutsch, fisico israeli de la Universidad de Oxford (Inglaterra) describio el primer computador cuantico universal, es decir, capaz de simular cualquier otro computador cuantico (principio de Church-Turing ampliado). De este modo, surgio la idea de que un ordenador cuantico podria ejecutar diferentes algoritmos cuanticos.[cita\u00a0requerida]  En esta epoca la teoria empezo a plasmarse en la practica: aparecieron los primeros algoritmos cuanticos, las primeras aplicaciones cuanticas y las primeras maquinas capaces de realizar calculos cuanticos.  1993 - Dan Simon  Desde el departamento de investigacion de Microsoft (Microsoft Research), surgio un problema teorico que demostraba la ventaja practica que tendria un computador cuantico frente a uno tradicional.  Comparo el modelo de probabilidad clasica con el modelo cuantico y sus ideas sirvieron como base para el desarrollo de algunos algoritmos futuros (como el de Shor).  1993 - Charles Benett  Este trabajador del centro de investigacion de IBM en Nueva York descubrio el teletransporte cuantico y que abrio una nueva via de investigacion hacia el desarrollo de comunicaciones cuanticas.  1994-1995 Peter Shor  Este cientifico estadounidense de AT&T Bell Laboratories definio el algoritmo que lleva su nombre y que permite calcular los factores primos de numeros a una velocidad mucho mayor que en cualquier computador tradicional. Ademas su algoritmo permitiria romper muchos de los sistemas de criptografia utilizados actualmente. Su algoritmo sirvio para demostrar a una gran parte de la comunidad cientifica que observaba incredula las posibilidades de la computacion cuantica, que se trataba de un campo de investigacion con un gran potencial. Ademas, un a\u00f1o mas tarde, propuso un sistema de correccion de errores en el calculo cuantico.  1996 - Lov Grover  Invento el algoritmo de busqueda de datos que lleva su nombre, algoritmo de Grover. Aunque la aceleracion conseguida no es tan drastica como en los calculos factoriales o en simulaciones fisicas, su rango de aplicaciones es mucho mayor. Al igual que el resto de algoritmos cuanticos, se trata de un algoritmo probabilistico con un alto indice de acierto.  1997 - Primeros experimentos  En 1997 se iniciaron los primeros experimentos practicos y se abrieron las puertas para empezar a ejecutar todos aquellos calculos y experimentos que habian sido descritos teoricamente hasta entonces. El primer experimento de comunicacion segura usando criptografia cuantica se realiza con exito a una distancia de 23 km. Ademas se realiza el primer teletransporte cuantico de un foton.  1998-1999 Primeros cubits  Investigadores de Los Alamos y el Instituto Tecnologico de Massachusetts consiguen propagar el primer cubit a traves de una solucion de aminoacidos. Supuso el primer paso para analizar la informacion que transporta un cubit. Durante ese mismo a\u00f1o, nacio la primera maquina de 2 cubits, que fue presentada en la Universidad de Berkeley, California (EE.\u00a0UU.). Un a\u00f1o mas tarde, en 1999, en los laboratorios de IBM-Almaden, se creo la primera maquina de 3 cubits y ademas fue capaz de ejecutar por primera vez el algoritmo de busqueda de Grover.  De nuevo IBM, dirigido por Isaac Chuang (Figura 4.1), creo un ordenador cuantico de 5 cubits capaz de ejecutar un algoritmo de busqueda de orden, que forma parte del algoritmo de Shor. Este algoritmo se ejecutaba en un simple paso cuando en un computador tradicional requeriria de numerosas iteraciones. Ese mismo a\u00f1o, cientificos de Laboratorio Nacional de Los Alamos (EE.\u00a0UU.) anunciaron el desarrollo de un ordenador cuantico de 7 cubits. Utilizando un resonador magnetico nuclear se consiguen aplicar pulsos electromagneticos y permite emular la codificacion en bits de los computadores tradicionales.  IBM y la Universidad de Stanford, consiguen ejecutar por primera vez el algoritmo de Shor en el primer computador cuantico de 7 cubits desarrollado en Los Alamos. En el experimento se calcularon los factores primos de 15, dando el resultado correcto de 3 y 5 utilizando para ello 1018 moleculas, cada una de ellas con siete atomos.  El Instituto de Optica e Informacion Cuantica de la universidad de Innsbruck (Austria) anuncio que sus cientificos habian creado el primer qbyte, una serie de 8 cubits utilizando trampas de iones.  Cientificos en Waterloo y Massachusetts dise\u00f1an metodos para mejorar el control del cuanto y consiguen desarrollar un sistema de 12 cubits. El control del cuanto se hace cada vez mas complejo a medida que aumenta el numero de cubits empleados por los computadores.  La empresa canadiense D-Wave Systems habia supuestamente presentado el 13 de febrero de 2007 en Silicon Valley, una primera computadora cuantica comercial de 16 cubits de proposito general; luego la misma compa\u00f1ia admitio que tal maquina, llamada Orion, no es realmente una computadora cuantica, sino una clase de maquina de proposito general que usa algo de mecanica cuantica para resolver problemas.[cita\u00a0requerida]  En septiembre de 2007, dos equipos de investigacion estadounidenses, el National Institute of Standards (NIST) de Boulder y la Universidad de Yale en New Haven consiguieron unir componentes cuanticos a traves de superconductores.  De este modo aparece el primer bus cuantico, y este dispositivo ademas puede ser utilizado como memoria cuantica, reteniendo la informacion cuantica durante un corto espacio de tiempo antes de ser transferido al siguiente dispositivo.  Segun la Fundacion Nacional de Ciencias (NSF) de EE.\u00a0UU., un equipo de cientificos consiguio almacenar por primera vez un cubit en el interior del nucleo de un atomo de fosforo, y pudieron hacer que la informacion permaneciera intacta durante 1,75\u00a0segundos. Este periodo puede ser expansible mediante metodos de correccion de errores, por lo que es un gran avance en el almacenamiento de informacion.  El equipo de investigadores estadounidense dirigido por el profesor Robert Schoelkopf, de la Universidad de Yale, que ya en 2007 habia desarrollado el Bus cuantico, crea ahora el primer procesador cuantico de estado solido, mecanismo que se asemeja y funciona de forma similar a un microprocesador convencional, aunque con la capacidad de realizar solo unas pocas tareas muy simples, como operaciones aritmeticas o busquedas de datos.  Para la comunicacion en el dispositivo, esta se realiza mediante fotones que se desplazan sobre el bus cuantico, circuito electronico que almacena y mide fotones de microondas, aumentando el tama\u00f1o de un atomo artificialmente.  La primera computadora cuantica comercial es vendida por la empresa D-Wave Systems, fundada en 1999, a Lockheed Martin por 10 millones de dolares.\u200b  IBM anuncia que ha creado un chip lo suficientemente estable como para permitir que la informatica cuantica llegue a hogares y empresas. Se estima que en unos 10 o 12 a\u00f1os se puedan estar comercializando los primeros sistemas cuanticos.\u200b  En abril la empresa D-Wave Systems lanza el nuevo computador cuantico D-Wave Two el cual es 500\u00a0000 veces superior a su antecesor D-Wave One, con un poder de calculo de 439 cubits. Realmente el D-Wave Two tuvo graves problemas finalmente, dado que no tenia las mejoras de procesamiento teoricas frente al D-Wave One.\u200b Este fue comparado con un computador basado en el microprocesador Intel Xeon E5-2690 a 2.9 GHz, teniendo en cuenta que lo obteniendo, es decir, el resultado en promedio de 4000 veces superior.\u200b  En 2016, Intel trabaja en el dominio del silicio por el primer ordenador cuantico\u200b  En mayo de 2017, IBM presenta un nuevo procesador cuantico comercial, el mas potente hasta la fecha\u200b de 17 cubits.\u200b  En el CES de 2019, IBM presento el IBM Q System One, el primer ordenador cuantico para uso comercial. En el mismo se combina tanto la computacion cuantica como \u00abtradicional\u00bb para ofrecer un sistema de 20 qubits para su utilizacion en investigaciones y grandes calculos.  El 18 de septiembre, IBM anuncio que lanzara pronto su decimocuarto ordenador cuantico de 53 qubits, el mas grande y potente de forma comercial hasta la fecha.\u200b  El 20 de septiembre, el Financial Times publico por primera vez \u00abGoogle afirma haber alcanzado la supremacia cuantica\u00bb.\u200b  El 9 de noviembre de 2022, en el marco del IBM Quantum Summit, presento Osprey, su procesador cuantico de 433 cubits.  Es un hecho que el computo cuantico revolucionara de manera exponencial diversos sectores, entre ellos destacan las telecomunicaciones; lo cual afectara tambien la criptografia y la seguridad de las comunicaciones en internet. Actualmente hacemos uso de la criptografia asimetrica en cada uno de los sitios web. Pues los dos algoritmos del cifrado asimetrico mas usados son RSA, cuya complejidad de factorizacion es de numeros grandes, y la criptografia basada en la estructura matematica de las curvas elipticas (ECC). Surge como problema que estos metodos de criptografia serian facilmente descifrables para una computadora cuantica. Pues pueden desarrollarse algoritmos que son capaces de aprovechar el paralelismo cuantico para resolver dichos problemas matematicos complejos.  El computo cuantico no acabara con la privacidad en internet, sin embargo, si afectara y hara obsoletos los principales metodos de cifrado actuales, como el RSA y ECC.  Actualmente se estan investigando nuevos esquemas de cifrado asimetrico que garanticen la privacidad en las comunicaciones y que no sean vulnerables a la computacion cuantica. Dichas investigaciones estan agrupadas en 4 grupos principales:  Gracias a las caracteristicas que posee la mecanica cuantica y al principio de incertidumbre de Heisenberg, la criptografia cuantica puede garantizar confidencialidad absoluta al posibilitar el intercambio seguro de claves entre 2 entes, a pesar de que el canal de comunicaciones este siendo escuchado por un externo. Ya que la interaccion de este intruso modificaria la informacion transmitida. Esto es aprovechado por algoritmos que intercambian claves cuanticas; para garantizar (por probabilidad) que solo el emisor y el receptor conocen la clave.\u200b  Como se menciono anteriormente, inicialmente la iniciativa en el avance de la computacion cuantica la tenian las Universidades, siendo sustituido en gran parte por empresas privadas. Por primera vez estamos llegando a ver un nivel de avance tecnologico espectacular en manos privadas en el mundo de la computacion cuantica.\u200b Esto supone un peligro etico con respecto a como va a ser utilizado, con que objetivos, con que supervision y con que sesgos.  Con el fin de utilizar de manera efectiva la computacion cuantica, es crucial que los expertos y los gobiernos aborden las cuestiones eticas y establezcan directrices comunes.\u200b Estas directrices eticas serviran como base para desarrollar una legislacion adecuada que regule el uso responsable de la computacion cuantica, asegurando asi un entorno etico y seguro para su aplicacion.  Existen muchos campos que se beneficiaran con el uso de la computacion cuantica, como la quimica cuantica, la inteligencia artificial, la ciberseguridad y todos los procesos de optimizacion, no obstante, en manos equivocadas, esto supondria un peligro en lugar de un avance,\u200b por lo que es fundamental reflexionar sobre estos retos para garantizar un uso responsable y beneficioso de estas tecnologias.  La capacidad de la computacion cuantica para romper la criptografia convencional plantea dilemas eticos en cuanto a la proteccion de la privacidad individual y la seguridad colectiva. Esto plantea preocupaciones sobre la seguridad de los datos personales y confidenciales, ya que la informacion que actualmente consideramos segura podria volverse vulnerable a los ataques cuanticos. Los avances en la computacion cuantica tambien podrian facilitar la decodificacion de comunicaciones cifradas previamente, lo que podria tener implicaciones en la privacidad de las personas y en el espionaje cibernetico. Por este motivo ya se estan investigando nuevos esquemas de cifrado simetrico.  El desarrollo y mantenimiento de la computacion cuantica es una tarea compleja y costosa. Esto podria generar una brecha tecnologica entre aquellos que tienen acceso a esta tecnologia y aquellos que no. Si unicamente algunos paises, empresas o individuos cuentan con acceso a la computacion cuantica, existe el riesgo de ampliar la desigualdad tecnologica y economica en el mundo. Esta situacion podria tener impactos eticos negativos, como profundizar las divisiones entre ricos y pobres y limitar las oportunidades para aquellos que no tienen acceso a esta tecnologia.\u200b  La computacion cuantica requiere una gran cantidad de recursos, incluida energia, para su funcionamiento. Los sistemas de computacion cuantica necesitan enfriarse a temperaturas extremadamente bajas, lo que consume una cantidad significativa de energia. Esto plantea preocupaciones en relacion con el impacto ambiental de la computacion cuantica a gran escala y su posible contribucion a los desafios del cambio climatico y la sostenibilidad.\u200b  La interseccion entre la inteligencia artificial (IA) y la computacion cuantica tambien plantea desafios eticos adicionales. A medida que se desarrollen algoritmos de IA cuantica mas potentes, es crucial considerar aspectos como la responsabilidad y el control humano sobre las decisiones tomadas por sistemas de IA cuantica, la explicabilidad de los resultados generados por dichos sistemas y las posibles implicaciones de su mal uso.  El avance de la computacion cuantica plantea preocupaciones eticas sobre la manipulacion nociva del genoma humano y para la creacion de nuevos materiales para la guerra.\u200b  Es importante abordar estas preocupaciones desde una perspectiva etica y asegurar que el desarrollo y la implementacion de estas tecnologias se realicen de manera responsable y equitativa. ","snippet":"La computacion cuantica o informatica cuantica\u200b es un paradigma de computacion distinto al de la informatica clasica. Se basa en el uso de cubits (qubits en ingles), una especial combinacion de unos y","enlaces_salientes":["Computaci%C3%B3n_cu%C3%A1ntica","Computaci%C3%B3n_cu%C3%A1ntica","Computaci%C3%B3n_cu%C3%A1ntica","Esfera_de_Bloch","Qubit","Paradigma","Computaci%C3%B3n","C%C3%BAbit","Bit","C%C3%BAbit","Puerta_cu%C3%A1ntica","Algoritmo","Complejidad_computacional","M%C3%A1quina_de_Turing","M%C3%A1quina_de_Turing#M\u00e1quina_de_Turing_cu\u00e1ntica","IBM","Nan%C3%B3metros","Efecto_t%C3%BAnel","Electrones","Ondas","Cuanto","Mec%C3%A1nica_cu%C3%A1ntica","Ortogonalidad_(inform%C3%A1tica)","Exponencial","FLOPS","Bill%C3%B3n","Summit_(superordenador)","Operaciones_de_coma_flotante_por_segundo","C%C3%BAbit","Bit","C%C3%BAbit","Superposici%C3%B3n_cu%C3%A1ntica","Entrelazamiento_cu%C3%A1ntico","Decoherencia_cu%C3%A1ntica","Correcci%C3%B3n_de_errores_cu%C3%A1ntica","Dise%C3%B1o_de_tolerancia_a_fallos","Hardware","Coherencia_cu%C3%A1ntica","Qubit#Representaci\u00f3n_f\u00edsica","Esp%C3%ADn","N%C3%BAcleo_at%C3%B3mico","Mol%C3%A9cula","Disoluci%C3%B3n","Resonancia_magn%C3%A9tica_nuclear","Flujo_el%C3%A9ctrico","SQUID","Ion","Punto_cu%C3%A1ntico","Im%C3%A1n_monomolecular","Computadora_cu%C3%A1ntica_de_Kane","Computaci%C3%B3n_adiab%C3%A1tica_cu%C3%A1ntica","Teorema_adiab%C3%A1tico","Universidad_de_Bonn","Chip","VLSI","Instituto_Max_Planck","Instituto_Niels_Bohr","Nature","Noviembre_de_2004","Algoritmo_cu%C3%A1ntico","Algoritmo_de_Shor","Algoritmo_de_Grover","Algoritmo_de_Deutsch-Jozsa","Computadora_cu%C3%A1ntica_de_Benioff","Computadora_cu%C3%A1ntica_de_Feynman","Computadora_cu%C3%A1ntica_de_Deutsch","Clase_de_complejidad","BQP","Factorizaci%C3%B3n","N%C3%BAmero_entero","Logaritmo_discreto","Richard_Feynman","D%C3%A9cada_de_1980","Laboratorio_Nacional_Argonne","Illinois","Estados_Unidos","M%C3%A1quina_de_Turing","Mec%C3%A1nica_cu%C3%A1ntica","Richard_Feynman","Instituto_de_Tecnolog%C3%ADa_de_California","Premio_Nobel","Instituto_Tecnol%C3%B3gico_de_Massachusetts","David_Deutsch","Universidad_de_Oxford","Inglaterra","Algoritmo_cu%C3%A1ntico","Microsoft_Research","Teletransporte","Peter_Shor","AT%26T","Bell_Laboratories","Criptograf%C3%ADa","Algoritmo_de_Grover","Algoritmo_probabil%C3%ADstico","Fot%C3%B3n","Instituto_Tecnol%C3%B3gico_de_Massachusetts","Amino%C3%A1cidos","Universidad_de_Berkeley","Algoritmo_de_Shor","Resonancia_magn%C3%A9tica_nuclear","IBM","Universidad_de_Stanford","Universidad_de_Innsbruck","Waterloo","D-Wave","Silicon_Valley","Instituto_Nacional_de_Est%C3%A1ndares_y_Tecnolog%C3%ADa","Fundaci%C3%B3n_Nacional_de_Ciencias","Universidad_de_Yale","D-Wave","Lockheed_Martin","IBM","D-Wave","Intel_Xeon","IBM_Q_System_One","C%C3%BAbit","Financial_Times","Supremac%C3%ADa_cu%C3%A1ntica","Telecomunicaci%C3%B3n","Criptograf%C3%ADa","Criptograf%C3%ADa_asim%C3%A9trica","RSA","Criptograf%C3%ADa","RSA","Criptograf%C3%ADa_asim%C3%A9trica","Criptosistema_de_Merkle-Hellman","Mec%C3%A1nica_cu%C3%A1ntica","Principio_de_incertidumbre_de_Heisenberg","Qu%C3%ADmica_cu%C3%A1ntica","Inteligencia_artificial","Ciberseguridad","Ciberespionaje","Cifrado_sim%C3%A9trico","Brecha_digital","Cambio_clim%C3%A1tico","Inteligencia_Artificial_Cu%C3%A1ntica","Genoma_humano","Computaci%C3%B3n_basada_en_ADN","Criptograf%C3%ADa_cu%C3%A1ntica","Electr%C3%B3nica_molecular","Entrelazamiento_cu%C3%A1ntico","Fot%C3%B3nica","Intelligence_Advanced_Research_Projects_Activity","Simulador_cu%C3%A1ntico_universal","Teleportaci%C3%B3n_cu%C3%A1ntica","Informaci%C3%B3n_cu%C3%A1ntica_con_variables_continuas","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","Cambridge_University_Press","Wayback_Machine","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Relatividad","titulo":"Teoria de la relatividad","contenido":"La teoria de la relatividad\u200b\u200b incluye tanto a la teoria de la relatividad especial como la de la relatividad general, formuladas principalmente por Albert Einstein a principios del siglo\u00a0XX, que pretendian resolver la incompatibilidad existente entre la mecanica newtoniana y el electromagnetismo.\u200b  La teoria de la relatividad especial, publicada en 1905, trata de la fisica del movimiento de los cuerpos en ausencia de fuerzas gravitatorias, en el que se hacian compatibles las ecuaciones de Maxwell del electromagnetismo con una reformulacion de las leyes del movimiento. En la teoria de la relatividad especial, Einstein, Lorentz y Minkowski, entre otros, unificaron los conceptos de espacio y tiempo, en un ramado tetradimensional al que se le denomino espacio-tiempo. La relatividad especial fue una teoria revolucionaria para su epoca, con la que el tiempo absoluto de  Newton quedo relegado y conceptos como la invariabilidad en la velocidad de la luz, la dilatacion del tiempo, la contraccion de la longitud y la equivalencia entre masa y energia fueron introducidos. Ademas, con las formulaciones de la relatividad especial, las leyes de la Fisica son invariantes en todos los sistemas de referencia inerciales; como consecuencia matematica, se encuentra como limite superior de velocidad a la de la luz y se elimina la causalidad determinista que tenia la fisica hasta entonces. Hay que indicar que las leyes del movimiento de Newton son un caso particular de esta teoria donde la masa, al viajar a velocidades muy peque\u00f1as, no experimenta variacion alguna en longitud ni se transforma en energia y al tiempo se le puede considerar absoluto.  La teoria de la relatividad general, publicada en 1915, es una teoria de la gravedad que reemplaza a la gravedad newtoniana, aunque coincide numericamente con ella para campos gravitatorios debiles y velocidades \u00abpeque\u00f1as\u00bb. La teoria general se reduce a la teoria especial en presencia de campos gravitatorios. La relatividad general estudia la interaccion gravitatoria como una deformacion en la geometria del espacio-tiempo. En esta teoria se introducen los conceptos de la curvatura del espacio-tiempo como la causa de la interaccion gravitatoria, el principio de equivalencia que dice que para todos los observadores locales inerciales las leyes de la relatividad especial son invariantes y la introduccion del movimiento de una particula por lineas geodesicas. La relatividad general no es la unica teoria que describe la atraccion gravitatoria, pero es la que mas datos relevantes comprobables ha encontrado. Anteriormente, a la interaccion gravitatoria se la describia matematicamente por medio de una distribucion de masas, pero en esta teoria no solo la masa percibe esta interaccion, sino tambien la energia, mediante la curvatura del espacio-tiempo y por eso se necesita otro lenguaje matematico para poder describirla, el calculo tensorial. Muchos fenomenos, como la curvatura de la luz por accion de la gravedad y la desviacion en la orbita de Mercurio, son perfectamente predichos por esta formulacion. La relatividad general tambien abrio otro campo de investigacion en la fisica, conocido como cosmologia y es ampliamente utilizado en la astrofisica.\u200b  El 7 de marzo de 2010, la Academia Israeli de Ciencias exhibio publicamente los manuscritos originales de Einstein (redactados en 1905). El documento, que contiene 46 paginas de textos y formulas matematicas escritas a mano, fue donado por Einstein a la Universidad Hebrea de Jerusalen en 1925 con motivo de su inauguracion.\u200b\u200b\u200b  El supuesto basico de la teoria de la relatividad es que la localizacion de los sucesos fisicos, tanto en el tiempo como en el espacio, son relativos al estado de movimiento del observador: asi, la longitud de un objeto en movimiento o el instante en que algo sucede, a diferencia de lo que sucede en mecanica newtoniana, no son invariantes absolutos, y diferentes observadores en movimiento relativo entre si diferiran respecto a ellos (las longitudes y los intervalos temporales, en relatividad son relativos y no absolutos).  La teoria de la relatividad especial, tambien llamada teoria de la relatividad restringida, fue publicada por Albert Einstein en 1905 y describe la fisica del movimiento en el marco de un espacio-tiempo plano. Esta teoria describe correctamente el movimiento de los cuerpos incluso a grandes velocidades y sus interacciones electromagneticas, se usa basicamente para estudiar sistemas de referencia inerciales (no es aplicable para problemas astrofisicos donde el campo gravitatorio desempe\u00f1a un papel importante).  Estos conceptos fueron presentados anteriormente por Poincare y Lorentz, que son considerados como precursores de la teoria. Si bien la teoria resolvia un buen numero de problemas del electromagnetismo y daba una explicacion del experimento de Michelson y Morley, no proporciona una descripcion relativista adecuada del campo gravitatorio.  Tras la publicacion del articulo de Einstein, la nueva teoria de la relatividad especial fue aceptada en unos pocos a\u00f1os por practicamente la totalidad de los fisicos y los matematicos. De hecho, Poincare o Lorentz habian estado muy cerca de llegar al mismo resultado que Einstein. La forma geometrica definitiva de la teoria se debe a Hermann Minkowski, antiguo profesor de Einstein en la Politecnica de Zurich; acu\u00f1o el termino \u00abespacio-tiempo\u00bb (Raumzeit) y le dio la forma matematica adecuada.[nota 1]\u200b El espacio-tiempo de Minkowski es una variedad tetradimensional en la que se entrelazaban de una manera indisoluble las tres dimensiones espaciales y el tiempo. En este espacio-tiempo de Minkowski, el movimiento de una particula se representa mediante su linea de universo (Weltlinie), una curva cuyos puntos vienen determinados por cuatro variables distintas: las tres dimensiones espaciales ( x , y , z ) y el tiempo ( t ). El nuevo esquema de Minkowski obligo a reinterpretar los conceptos de la metrica existentes hasta entonces. El concepto tridimensional de punto fue sustituido por el de suceso. La magnitud de distancia se reemplaza por la magnitud de intervalo.  La teoria general de la relatividad o relatividad general es una teoria del campo gravitatorio y de los sistemas de referencia generales, publicada por Albert Einstein en 1915 y 1916.  El nombre de la teoria se debe a que generaliza la llamada teoria especial de la relatividad y el principio de relatividad para un observador arbitrario. Los principios fundamentales introducidos en esta generalizacion son el principio de equivalencia, que describe la aceleracion y la gravedad como aspectos distintos de la misma realidad, la nocion de la curvatura del espacio-tiempo y el principio de covariancia generalizado. La teoria de la relatividad general propone que la propia geometria del espacio-tiempo se ve afectada por la presencia de materia, de lo cual resulta una teoria relativista del campo gravitatorio. De hecho la teoria de la relatividad general predice que el espacio-tiempo no sera plano en presencia de materia y que la curvatura del espacio-tiempo sera percibida como un campo gravitatorio.  La intuicion basica de Einstein fue postular que en un punto concreto no se puede distinguir experimentalmente entre un cuerpo acelerado uniformemente y un campo gravitatorio uniforme. La teoria general de la relatividad permitio tambien reformular el campo de la cosmologia.  Einstein expreso el proposito de la teoria de la relatividad general para aplicar plenamente el programa de Ernst Mach de la relativizacion de todos los efectos de inercia, incluso a\u00f1adiendo la llamada constante cosmologica a sus ecuaciones de campo\u200b para este proposito. Este punto de contacto real de la influencia de Ernst Mach fue claramente identificado en 1918, cuando Einstein distingue lo que el bautizo como el principio de Mach (los efectos inerciales se derivan de la interaccion de los cuerpos) del principio de la relatividad general, que se interpreta ahora como el principio de covariancia general.\u200b  En la teoria de la relatividad una particula puntual queda representada por un par ( \u03b3 ( \u03c4 ) , m ) , donde \u03b3 ( \u03c4 ) es una curva diferenciable, llamada linea de universo de la particula, y m es un escalar que representa la masa en reposo. El vector tangente a esta curva es un vector temporal llamado cuadrivelocidad, el producto de este vector por la masa en reposo de la particula es precisamente el cuadrimomento. Este cuadrimomento es un vector de cuatro componentes, tres de estas componentes se denominan espaciales y representan el analogo relativista del momento lineal de la mecanica clasica, la otra componente denominada componente temporal representa la generalizacion relativista de la energia cinetica. Ademas, dada una curva arbitraria en el espacio-tiempo, puede definirse a lo largo de ella el llamado intervalo relativista, que se obtiene a partir del tensor metrico. El intervalo relativista medido a lo largo de la trayectoria de una particula es proporcional al intervalo de tiempo propio o intervalo de tiempo percibido por dicha particula.  Cuando se consideran campos o distribuciones continuas de masa, se necesita algun tipo de generalizacion para la nocion de particula. Un campo fisico posee momentum y energia distribuidos en el espacio-tiempo, el concepto de cuadrimomento se generaliza mediante el llamado tensor de energia-impulso que representa la distribucion en el espacio-tiempo tanto de energia como de momento lineal. A su vez un campo dependiendo de su naturaleza puede representarse por un escalar, un vector o un tensor. Por ejemplo el campo electromagnetico se representa por un tensor de segundo orden totalmente antisimetrico o 2-forma. Si se conoce la variacion de un campo o una distribucion de materia, en el espacio y en el tiempo entonces existen procedimientos para construir su tensor de energia-impulso.  En relatividad, estas magnitudes fisicas son representadas por vectores 4-dimensionales o bien por objetos matematicos llamados tensores, que generalizan los vectores, definidos sobre un espacio de cuatro dimensiones. Matematicamente estos 4-vectores y 4-tensores son elementos definidos del espacio vectorial tangente al espacio-tiempo (y los tensores se definen y se construyen a partir del fibrado tangente o cotangente de la variedad que representa el espacio-tiempo).  Igualmente ademas de cuadrivectores, se definen cuadritensores (tensores ordinarios definidos sobre el fibrado tangente del espacio-tiempo concebido como variedad lorentziana). La curvatura del espacio-tiempo se representa por un 4-tensor (tensor de cuarto orden), mientras que la energia y el momento de un medio continuo o el campo electromagnetico se representan mediante 2-tensores (simetrico el tensor de energia-impulso, antisimetrico el de campo electromagnetico). Los cuadrivectores son de hecho 1-tensores, en esta terminologia. En este contexto se dice que una magnitud es un invariante relativista si tiene el mismo valor para todos los observadores, obviamente todos los invariantes relativistas son escalares (0-tensores), frecuentemente formados por la contraccion de magnitudes tensoriales.  El intervalo relativista puede definirse en cualquier espacio-tiempo, sea este plano como en la relatividad especial, o curvo como en relatividad general. Sin embargo, por simplicidad, discutiremos inicialmente el concepto de intervalo para el caso de un espacio-tiempo plano. El tensor metrico del espacio-tiempo plano de Minkowski se designa con la letra \u03b7 i j } , y en coordenadas galileanas o inerciales toma la siguiente forma:[nota 4]\u200b   g i j = \u03b7 i j = ( c 2 0 0 0 0 \u2212 1 0 0 0 0 \u2212 1 0 0 0 0 \u2212 1 ) =\\eta _{ij}=c^{2}&0&0&0\\\\0&-1&0&0\\\\0&0&-1&0\\\\0&0&0&-1\\\\\\end{pmatrix}}}  El intervalo, la distancia tetradimensional, se representa mediante la expresion d s 2 \\ } , que se calcula del siguiente modo:  Los intervalos pueden ser clasificados en tres categorias: Intervalos espaciales (cuando d s 2 } es negativo), temporales (si d s 2 } es positivo) y nulos (cuando d s 2 = 0 =0} ). Como el lector habra podido comprobar, los intervalos nulos son aquellos que corresponden a particulas que se mueven a la velocidad de la luz, como los fotones: La distancia d l 2 } recorrida por el foton es igual a su velocidad (c) multiplicada por el tiempo d t y por lo tanto el intervalo d s 2 = c 2 d t 2 \u2212 d l 2 =c^{2}dt^{2}-dl^{2}} se hace nulo.  Los intervalos nulos pueden ser representados en forma de cono de luz, popularizados por el celeberrimo libro de Stephen Hawking, Breve Historia del Tiempo. Sea un observador situado en el origen, el futuro absoluto (los sucesos que seran percibidos por el individuo) se despliega en la parte superior del eje de ordenadas, el pasado absoluto (los sucesos que ya han sido percibidos por el individuo) en la parte inferior, y el presente percibido por el observador en el punto 0. Los sucesos que estan fuera del cono de luz no nos afectan, y por lo tanto se dice de ellos que estan situados en zonas del espacio-tiempo que no tienen relacion de causalidad con la nuestra.  Imaginemos, por un momento, que en la galaxia Andromeda, situada a 2,5 millones de a\u00f1os luz de nosotros, sucedio un cataclismo cosmico hace 100\u00a0000\u00a0a\u00f1os. Dado que, primero: la luz de Andromeda tarda 2\u00a0millones de a\u00f1os en llegar hasta nosotros y segundo: nada puede viajar a una velocidad superior a la de los fotones, es evidente, que no tenemos manera de enterarnos de lo que sucedio en dicha Galaxia hace tan solo 100\u00a0000\u00a0a\u00f1os. Se dice, por lo tanto, que el intervalo existente entre dicha hipotetica catastrofe cosmica y nosotros, observadores del presente, es un intervalo espacial ( d s 2 < 0 <0} ), y por lo tanto, no puede afectar a los individuos que en el presente viven en la Tierra: Es decir, no existe relacion de causalidad entre ese evento y nosotros.  El unico problema con esta hipotesis, es que al entrar en un agujero negro, se anula el espacio-tiempo, y como ya sabemos, algo que contenga algun volumen o masa, debe tener como minimo un espacio donde ubicarse, el tiempo en ese caso, no tiene mayor importancia, pero el espacio juega un rol muy importante en la ubicacion de volumenes, por lo que esto resulta muy improbable, pero no imposible para la tecnologia.  Podemos escoger otro episodio historico todavia mas ilustrativo: El de la estrella de Belen, tal y como fue interpretada por Johannes Kepler. Este astronomo aleman consideraba que dicha estrella se identificaba con una supernova que tuvo lugar el a\u00f1o 5\u00a0a.\u00a0C., cuya luz fue observada por los astronomos chinos contemporaneos, y que vino precedida en los a\u00f1os anteriores por varias conjunciones planetarias en la constelacion de Piscis. Esa supernova probablemente estallo miles de a\u00f1os atras, pero su luz no llego a la Tierra sino hasta el a\u00f1o 5\u00a0a.\u00a0C. De ahi que el intervalo existente entre dicho evento y las observaciones de los astronomos egipcios y megaliticos (que tuvieron lugar varios siglos antes de Cristo) sea un intervalo espacial, pues la radiacion de la supernova nunca pudo llegarles. Por el contrario, la explosion de la supernova por un lado, y las observaciones realizadas por los tres magos en Babilonia y por los astronomos chinos en el a\u00f1o 5\u00a0a.\u00a0C. por el otro, estan unidas entre si por un intervalo temporal, ya que la luz si pudo alcanzar a dichos observadores.  El tiempo propio y el intervalo se relacionan mediante la siguiente equivalencia: c d \u03c4 = d s , es decir, el intervalo es igual al tiempo local multiplicado por la velocidad de la luz. Una de las caracteristicas tanto del tiempo local como del intervalo es su invarianza ante las transformaciones de coordenadas. Sea cual sea nuestro punto de referencia, sea cual sea nuestra velocidad, el intervalo entre un determinado evento y nosotros permanece invariante.  Esta invarianza se expresa a traves de la llamada geometria hiperbolica: La ecuacion del intervalo d s tiene la estructura de una hiperbola sobre cuatro dimensiones, cuyo termino independiente coincide con el valor del cuadrado del intervalo ( d s 2 = d t 2 \u2212 d l 2 =dt^{2}-dl^{2}} ), que como se acaba de decir en el parrafo anterior, es constante. Las asintotas de la hiperbola vendrian a coincidir con el cono de luz.  En el espacio-tiempo de Minkowski, las propiedades cinematicas de las particulas se representan fundamentalmente por tres magnitudes: La cuadrivelocidad (o tetravelocidad) , la cuadriaceleracion y el cuadrimomentum (o tetramomentum).  La cuadrivelocidad es un cuadrivector tangente a la linea de universo de la particula, relacionada con la velocidad coordenada de un cuerpo medida por un observador en reposo cualquiera, esta velocidad coordenada se define con la expresion newtoniana d x i / d t /dt} , donde ( t , x 1 , x 2 , x 3 ) ,x^{2},x^{3})\\;} son el tiempo coordenado y las coordenadas espaciales medidas por el observador, para el cual la velocidad newtoniana ampliada vendria dada por ( 1 , v 1 , v 2 , v 3 ) ,v^{2},v^{3})\\,} . Sin embargo, esta medida newtoniana de la velocidad no resulta util en teoria de la relatividad, porque las velocidades newtonianas medidas por diferentes observadores no son facilmente relacionables por no ser magnitudes covariantes. Asi en relatividad se introduce una modificacion en las expresiones que dan cuenta de la velocidad, introduciendo un invariante relativista. Este invariante es precisamente el tiempo propio de la particula que es facilmente relacionable con el tiempo coordenado de diferentes observadores. Usando la relacion entre tiempo propio y tiempo coordenado: d t = \u03b3 d \u03c4 se define la cuadrivelocidad [propia] multiplicando por \u03b3 las de la velocidad coordenada: u \u03b1 = v \u03b1 \u03b3 = d x i / d \u03c4 =v^\\gamma =dx^{i}/d\\tau } .  La velocidad coordenada de un cuerpo con masa depende caprichosamente del sistema de referencia que escojamos, mientras que la cuadrivelocidad propia es una magnitud que se transforma de acuerdo con el principio de covariancia y tiene un valor siempre constante equivalente al intervalo dividido entre el tiempo propio ( d s / d \u03c4 ), o lo que es lo mismo, a la velocidad de la luz c. Para particulas sin masa, como los fotones, el procedimiento anterior no se puede aplicar, y la cuadrivelocidad puede definirse simplemente como vector tangente a la trayectoria seguida por los mismos.  La cuadriaceleracion puede ser definida como la derivada temporal de la cuadrivelocidad ( a i = d u i / d \u03c4 =du^{i}/d\\tau } ). Su magnitud es igual a cero en los sistemas inerciales, cuyas lineas del mundo son geodesicas, rectas en el espacio-tiempo llano de Minkowski. Por el contrario, las lineas del mundo curvadas corresponden a particulas con aceleracion diferente de cero, a sistemas no inerciales.  Junto con los principios de invarianza del intervalo y la cuadrivelocidad, juega un papel fundamental la ley de conservacion del cuadrimomentum. Es aplicable aqui la definicion newtoniana del momentum ( p \u2192 = \u03bc u \u2192 }=\\mu }} ) como la masa (en este caso conservada, \u03bc ) multiplicada por la velocidad (en este caso, la cuadrivelocidad), y por lo tanto sus componentes son los siguientes: ( m , p 1 , p 2 , p 3 ) ,p^{2},p^{3})\\;} , teniendo en cuenta que m = \u03bc \u03b3 . La cantidad de momentum conservado es definida como la raiz cuadrada de la norma del vector de cuadrimomentum. El momentum conservado, al igual que el intervalo y la cuadrivelocidad propia, permanece invariante ante las transformaciones de coordenadas, aunque tambien aqui hay que distinguir entre los cuerpos con masa y los fotones. En los primeros, la magnitud del cuadriomentum es igual a la masa multiplicada por la velocidad de la luz ( | p | = \u03bc c ). Por el contrario, el cuadrimomentum conservado de los fotones es igual a la magnitud de su momentum tridimensional ( | p | = p ).  Como tanto la velocidad de la luz como el cuadrimomentum son magnitudes conservadas, tambien lo es su producto, al que se le da el nombre de energia conservada ( E c o n = | p | c =|p|c} ), que en los cuerpos con masa equivale a la masa multiplicada por la velocidad de la luz al cuadrado ( E c o n = \u03bc c 2 =\\mu c^{2}} , la famosa formula de Einstein) y en los fotones al momentum multiplicado por la velocidad de la luz ( E c o n = p c =pc} )   Componentes \u2192 ( p 0 , p 1 , p 2 , p 3 ) \u2192 ( \u03bc \u03b3 , \u03bc v 1 \u03b3 , \u03bc v 2 \u03b3 , \u03bc v 3 \u03b3 ) \u2192 ( m , p 1 , p 2 , p 3 ) ,p^{1},p^{2},p^{3})\\to (\\mu \\gamma ,\\mu v^{1}\\gamma ,\\mu v^{2}\\gamma ,\\mu v^{3}\\gamma )\\to (m,p^{1},p^{2},p^{3})}   Magnitud del cuadrimomentum \u2192 | p | = p \u2192 \u22c5 p \u2192 = m 2 c 2 \u2212 p 2 = E 2 c 2 \u2212 p 2 }\\cdot }}}=c^{2}-p^{2}}}=}{c^{2}}}-p^{2}}}}  Magnitud en cuerpos con masa \u2192 | p | = p \u2192 \u22c5 p \u2192 = m u \u2192 \u22c5 u \u2192 = \u03bc c }\\cdot }}}=m}\\cdot }}}=\\mu c} Magnitud en fotones (masa = 0) \u2192 | p | = p \u2192 \u22c5 p \u2192 = m 2 c 2 \u2212 p 2 = p 2 = p }\\cdot }}}=c^{2}-p^{2}}}=}}=p}   Energia \u2192 E c o n = c | p | = c p \u2192 \u22c5 p \u2192 = E 2 \u2212 p 2 c 2 =c|p|=c}\\cdot }}}=-p^{2}c^{2}}}}  Energia en cuerpos con masa (cuerpos en reposo, p=0) \u2192 E c o n = m 2 c 4 \u2212 p 2 c 2 \u2192 E c o n = m c 2 =c^{4}-p^{2}c^{2}}}\\to E_{con}=mc^{2}} Energia en fotones (masa en reposo = 0) \u2192 E c o n = m 2 c 4 \u2212 p 2 c 2 = p 2 c 2 = p c =c^{4}-p^{2}c^{2}}}=c^{2}}}=pc}  La aparicion de la Relatividad Especial puso fin a la secular disputa que mantenian en el seno de la mecanica clasica las escuelas de los mecanicistas y los energetistas. Los primeros sostenian, siguiendo a Descartes y Huygens, que la magnitud conservada en todo movimiento venia constituida por el momentum total del sistema, mientras que los energetistas -que tomaban por base los estudios de Leibniz- consideraban que la magnitud conservada venia conformada por la suma de dos cantidades: La fuerza viva, equivalente a la mitad de la masa multiplicada por la velocidad al cuadrado ( m v 2 / 2 /2} ) a la que hoy denominariamos \u00abenergia cinetica\u00bb, y la fuerza muerta, equivalente a la altura por la constante g ( h g ), que corresponderia a la \u00abenergia potencial\u00bb. Fue el fisico aleman Hermann von Helmholtz el que primero dio a la fuerzas leibnizianas la denominacion generica de energia y el que formulo la Ley de conservacion de la energia, que no se restringe a la mecanica, que se extiende tambien a otras disciplinas fisicas como la termodinamica.  La mecanica newtoniana dio la razon a ambos postulados, afirmando que tanto el momentum como la energia son magnitudes conservadas en todo movimiento sometido a fuerzas conservativas. Sin embargo, la Relatividad Especial dio un paso mas alla, por cuanto a partir de los trabajos de Einstein y Minkowski el momentum y la energia dejaron de ser considerados como entidades independientes y se les paso a considerar como dos aspectos, dos facetas de una unica magnitud conservada: el cuadrimomentum.  Tres son las ecuaciones fundamentales que en fisica newtoniana describen el fenomeno de la gravitacion universal: la primera, afirma que la fuerza gravitatoria entre dos cuerpos es proporcional al producto de sus masas e inversamente proporcional al cuadrado de su distancia (1); la segunda, que el potencial gravitatorio ( \u03a6 ) en un determinado punto es igual a la masa multiplicada por la constante G y dividida por la distancia r (2); y la tercera, finalmente, es la llamada ecuacion de Poisson (3), que indica que el laplaciano[nota 5]\u200b del potencial gravitatorio es igual a 4 \u03c0 G \u03c1 , donde \u03c1 es la densidad de masa en una determinada region esferica.   F = G M m r 2 ( 1 ) {r^{2}}}(1)} \u2192 \u03a6 = G M r ( 2 ) {r}}(2)} \u2192 \u0394 \u03a6 = 4 \u03c0 G \u03c1 ( 3 )  Sin embargo, estas ecuaciones no son compatibles con la Relatividad Especial por dos razones:  Por todo ello, resulta necesario prescindir del termino \u03c1 , situado en el lado derecho de la formula de Poisson y sustituirlo por un objeto geometrico-matematico que permanezca invariante ante las transformaciones de Lorentz: Dicho objeto fue definido por Einstein en sus ecuaciones de universo y recibe el nombre de tensor de energia-momentum ( T \u03b1 \u03b2 } ). Sus coeficientes describen la cantidad de tetramomentum p \u03b1 } que atraviesa una hipersuperficie \u03a0 \u03b2 } , normal al vector unitario u \u2192 \u03b2 }^} . De este modo, el tensor de energia momentum puede expresarse mediante la siguiente ecuacion:   p \u03b1 = \u222b \u03a0 T \u03b1 \u03b2 d \u03a0 \u03b2 =\\int _T^d\\Pi _}  O lo que es lo mismo: El componente p \u03b1 } del tetramomentum es igual a la integral de hipersuperficie d \u03a0 \u03b2 } del tensor de tension-energia. En un fluido ideal, del que estan ausentes tanto la viscosidad como la conduccion de calor, los componentes del tetramomentum se calculan de la siguiente forma:   T \u03b1 \u03b2 = ( \u03c1 + P c 2 ) u \u03b1 u \u03b2 \u2212 P g \u03b1 \u03b2 \\,=\\left(\\rho +{P \\over c^{2}}\\right)u^u^-Pg^}  donde \u03c1 es la densidad de masa-energia (masa por unidad de volumen tridimensional), P es la presion hidrostatica, u \u03b1 } es la cuadrivelocidad del fluido, y g \u03b1 \u03b2 } es la matriz inversa del tensor metrico de la variedad.  Ademas, si los componentes del tensor se miden por un observador en reposo relativo respecto al fluido, entonces, el tensor metrico viene constituido simplemente por la metrica de Minkowski:  Puesto que ademas la tetravelocidad del fluido respecto al observador en reposo es:  como consecuencia de ello, los coeficientes del tensor de tension-energia son los siguientes:   T \u03b1 \u03b2 = ( \u03c1 0 0 0 0 \u2212 P 1 0 0 0 0 \u2212 P 2 0 0 0 0 \u2212 P 3 ) =\\rho &0&0&0\\\\0&-P_{1}&0&0\\\\0&0&-P_{2}&0\\\\0&0&0&-P_{3}\\\\\\end{pmatrix}}}  Donde \u03c1 es la densidad de masa, y P i } son los componentes tridimensionales de la presion hidrostatica. Como vemos, el campo gravitatorio tiene dos fuentes diferentes: La masa y el momentum del fluido en cuestion. Los efectos gravitatorios originados por la masa se denominan efectos gravitoelectricos, mientras que aquellos que se deben al momentum reciben el nombre de efectos gravitomagneticos. Los primeros tienen una intensidad c 2 } superior a los segundos, que solo se manifiestan en aquellos casos en los que las particulas del fluido se mueven con una velocidad cercana a la de la luz (se habla entonces de fluidos relativistas): Es el caso de los chorros (jets) que emanan del centro de la galaxia y que se propulsan en las dos direcciones marcadas por el eje de rotacion de este cuerpo cosmico; de la materia que se precipita hacia un agujero negro; y del fluido estelar que se dirige hacia el centro de la estrella cuando esta entra en colapso. En este ultimo caso, durante las fases finales del proceso de contraccion de la estrella, la presion hidrostatica puede llegar a ser tan fuerte como para llegar a acelerar el colapso, en lugar de ralentizarlo.  Podemos, a partir del tensor de tension-energia, calcular cuanta masa contiene un determinado volumen del fluido: Retomando la definicion de este tensor expuesta unas lineas mas arriba, se puede definir al coeficiente T 00 } como la cantidad de momentum p 0 } (esto es, la masa) que atraviesa la hipersuperficie d \u03a0 0 } . En el espacio-tiempo de Minkowski, la hipersuperficie d \u03a0 0 } es aquella region que se define por las tres bases vectoriales normales al vector d x 0 } : \u03a0 0 } es, por tanto, un volumen tridimensional, definido por los vectores base e \u2192 1 }_{1}} (eje x), e \u2192 2 }_{2}} (eje y), y e \u2192 3 }_{3}} (eje z). Podemos por tanto escribir:  Del mismo modo, es posible deducir matematicamente a partir del tensor de tension-energia la definicion newtoniana de presion, introduciendo en la mentada ecuacion cualquier par de indices que sean diferentes de cero:  La hipersuperficie d \u03a0 1 } es aquella region del espacio-tiempo definida por los tres vectores unitarios normales a d x 1 } (se trata de los dos vectores espaciales, e \u2192 2 }_{2}} y e \u2192 3 }_{3}} , correspondientes a los ejes y y z; y del vector temporal e \u2192 0 }_{0}} \u2014o d t , como se prefiera\u2014). Esta definicion nos permite descomponer la integral de hipersuperficie en una integral temporal (cuyo integrando viene definido por d t ) y otra de superficie (esta vez bidimensional, d S ):  Finalmente, derivamos parcialmente ambos miembros de la ecuacion respecto al tiempo, y teniendo en cuenta que la fuerza no es mas que la tasa de incremento temporal del momentum obtenemos el resultado siguiente:  Que contiene la definicion newtoniana de la presion como fuerza ejercida por unidad de superficie.  Las ecuaciones deducidas por el fisico escoces James Clerk Maxwell demostraron que electricidad y magnetismo no son mas que dos manifestaciones de un mismo fenomeno fisico: el campo electromagnetico. Ahora bien, para describir las propiedades de este campo los fisicos de finales del siglo\u00a0XIX debian utilizar dos vectores diferentes, los correspondientes los campos electrico y magnetico.  Fue la llegada de la relatividad especial la que permitio describir las propiedades del electromagnetismo con un solo objeto geometrico, el vector cuadripotencial, cuyo componente temporal se correspondia con el potencial electrico, mientras que sus componentes espaciales eran los mismos que los del potencial magnetico.  De este modo, el campo electrico puede ser entendido como la suma del gradiente del potencial electrico mas la derivada temporal del potencial magnetico:  y el campo magnetico, como el rotacional del potencial magnetico:  Las propiedades del campo electromagnetico pueden tambien expresarse utilizando un tensor de segundo orden denominado tensor de Faraday y que se obtiene diferenciando exteriormente al vector cuadripotencial A \u03b1 }   F \u03b1 \u03b2 = ( 0 E x / c E y / c E z / c \u2212 E x / c 0 B z \u2212 B y \u2212 E y / c \u2212 B z 0 B x \u2212 E z / c B y \u2212 B x 0 ) ; F \u03b2 \u03b1 = ( 0 E x E y E z \u2212 E x 0 B z \u2212 B y \u2212 E y \u2212 B z 0 B x \u2212 E z B y \u2212 B x 0 ) =0&E_{x}/c&E_{y}/c&E_{z}/c\\\\-E_{x}/c&0&B_{z}&-B_{y}\\\\-E_{y}/c&-B_{z}&0&B_{x}\\\\-E_{z}/c&B_{y}&-B_{x}&0\\end{pmatrix}};F_^=0&E_{x}&E_{y}&E_{z}\\\\-E_{x}&0&B_{z}&-B_{y}\\\\-E_{y}&-B_{z}&0&B_{x}\\\\-E_{z}&B_{y}&-B_{x}&0\\end{pmatrix}}}  La fuerza de Lorentz puede deducirse a partir de la siguiente expresion:  Donde q es la carga y u \u03b1 } la cuadrivelocidad de la particula. ","snippet":"La teoria de la relatividad\u200b\u200b incluye tanto a la teoria de la relatividad especial como la de la relatividad general, formuladas principalmente por Albert Einstein a principios del siglo\u00a0XX, que prete","enlaces_salientes":["Teor%C3%ADa_de_la_relatividad","Teor%C3%ADa_de_la_relatividad","Teor%C3%ADa_de_la_relatividad","Relatividad_(desambiguaci%C3%B3n)","Impresi%C3%B3n_de_un_artista","Teor%C3%ADa_de_la_relatividad_especial","Relatividad_general","Albert_Einstein","Mec%C3%A1nica_newtoniana","Electromagnetismo","Teor%C3%ADa_de_la_relatividad_especial","F%C3%ADsica","Gravedad","Ecuaciones_de_Maxwell","Albert_Einstein","Hendrik_Antoon_Lorentz","Hermann_Minkowski","Espacio_(f%C3%ADsica)","Tiempo","Espacio-tiempo","Isaac_Newton","Velocidad_de_la_luz","Dilataci%C3%B3n_del_tiempo","Contracci%C3%B3n_de_Lorentz","Equivalencia_entre_masa_y_energ%C3%ADa","Ley_de_la_f%C3%ADsica","Sistema_de_referencia_inercial","Causalidad_(f%C3%ADsica)","Masa","Relatividad_general","Aproximaci%C3%B3n_para_campos_gravitatorios_d%C3%A9biles","Gravedad","Espacio-tiempo","Curvatura_del_espacio-tiempo","Principio_de_equivalencia","Geod%C3%A9sica","Masa","Energ%C3%ADa","C%C3%A1lculo_tensorial","%C3%93rbita","Mercurio_(planeta)","Cosmolog%C3%ADa","Astrof%C3%ADsica","Academia_Israel%C3%AD_de_Ciencias_y_Humanidades","Universidad_Hebrea_de_Jerusal%C3%A9n","Tiempo","Espacio_(f%C3%ADsica)","Observador","Teor%C3%ADa_de_la_relatividad_especial","Albert_Einstein","F%C3%ADsica","Espacio-tiempo","Sistema_de_referencia_inercial","Henri_Poincar%C3%A9","Hendrik_Antoon_Lorentz","Experimento_de_Michelson_y_Morley","Hermann_Minkowski","Z%C3%BArich","Espacio-tiempo","Espacio-tiempo_de_Minkowski","Variedad_pseudoriemanniana","Cuarta_dimensi%C3%B3n","L%C3%ADnea_de_universo","Relatividad_general","SN_2006gy","Acci%C3%B3n_a_distancia","Velocidad_de_la_luz","Espacio-tiempo","Relatividad_general","Campo_gravitatorio","Albert_Einstein","Teor%C3%ADa_especial_de_la_relatividad","Principio_de_relatividad","Observador","Generalizaci%C3%B3n","Principio_de_equivalencia","Aceleraci%C3%B3n","Gravedad","Curvatura_del_espacio-tiempo","Principio_de_covariancia","Materia","Campo_gravitatorio","Cosmolog%C3%ADa","Ernst_Mach","Inercia","Constante_cosmol%C3%B3gica","Ernst_Mach","Principio_de_Mach","David_Hilbert","L%C3%ADnea_de_universo","Curva","Cuadrivelocidad","Cuadrimomento","Cantidad_de_movimiento","Mec%C3%A1nica_cl%C3%A1sica","Energ%C3%ADa_cin%C3%A9tica","Tensor_m%C3%A9trico","Tiempo_propio","Tensor_de_energ%C3%ADa-impulso","Cantidad_de_movimiento","Campo_(f%C3%ADsica)","Campo_electromagn%C3%A9tico","Forma_diferencial","Magnitud_f%C3%ADsica","Espacio_tangente","Espacio-tiempo","Fibrado_tangente","Espacio_eucl%C3%ADdeo","Espacio-tiempo_de_Minkowski","Longitud","Velocidad","Cuadrivelocidad","Cantidad_de_movimiento","Cuadrimomento","Cuadrivector","Fibrado_tangente","Variedad_lorentziana","Campo_electromagn%C3%A9tico","Tensor_de_energ%C3%ADa-impulso","Observador","Tensor_m%C3%A9trico","Espacio-tiempo_de_Minkowski","Sistema_de_referencia_inercial","Cono_de_luz","Hermann_Minkowski","Cono_de_luz","Stephen_Hawking","Breve_historia_del_tiempo","A%C3%B1os_luz","Agujero_negro","Estrella_de_Bel%C3%A9n","Johannes_Kepler","Supernova","Tiempo_propio","Cuadrivelocidad","Cuadrimomento","Cuadrivelocidad","Cuadriaceleraci%C3%B3n","Cuadrimomento","Cuadrivector","Observador","Invariante_relativista","Tiempo_propio","Hermann_von_Helmholtz","Termodin%C3%A1mica","Tensor_de_energ%C3%ADa-impulso","Ecuaci%C3%B3n_de_Poisson","Conducci%C3%B3n_de_calor","Tensor_de_campo_electromagn%C3%A9tico","Teor%C3%ADa_de_la_relatividad_especial","Tensor_de_campo_electromagn%C3%A9tico","Espacio-tiempo","Cuadrivector","Tensor","F%C3%ADsica","Teor%C3%ADa_de_la_relatividad_especial","Relatividad_general","ISBN","Albert_Einstein","Albert_Einstein","Hermann_Minkowski","Thomas_F._Glick","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Universo","titulo":"Universo","contenido":"El universo es el conjunto de todas las entidades fisicamente detectables que interactuan entre ellas dentro del espacio-tiempo de acuerdo a leyes fisicas bien definidas. Sin embargo, el termino tambien se utiliza informalmente en sentidos contextuales ligeramente diferentes y alude a conceptos como cosmos, mundo, naturaleza o realidad.\u200b Su estudio, en las mayores escalas, es el objeto de la cosmologia, disciplina basada en la astronomia y la fisica, en la cual se describen todos los aspectos de este universo con sus fenomenos. Las ciencias fisicas modelizan el universo como un sistema cerrado que contiene energia y materia adscritas al espacio-tiempo y que se rige fundamentalmente por principios causales. Basandose en observaciones del universo observable, los fisicos intentan describir el continuo espacio-tiempo en el que nos encontramos, junto con toda la materia y energia existentes en el.  Los experimentos sugieren que el universo se ha regido por las mismas leyes fisicas, constantes a lo largo de su extension e historia. Es homogeneo e isotropico. La fuerza dominante en distancias cosmicas es la gravedad, y la relatividad general es actualmente la teoria mas exacta para describirla. Las otras tres fuerzas fundamentales, y las particulas en las que actuan, son descritas por el modelo estandar.  El universo tiene por lo menos tres dimensiones de espacio y una de tiempo, aunque experimentalmente no se pueden descartar dimensiones adicionales. El espacio-tiempo parece estar conectado de forma sencilla, y el espacio tiene una curvatura media muy peque\u00f1a o incluso nula, de manera que la geometria euclidiana es, como norma general, exacta en todo el universo.  La teoria actualmente mas aceptada sobre la formacion del universo fue teorizada por el canonigo belga Georges Lemaitre, a partir de las ecuaciones de Albert Einstein. Lemaitre concluyo (en oposicion a lo que pensaba Einstein) que el universo no era estacionario, sino que tenia un origen. Este es el modelo del Big Bang, que describe la expansion del espacio-tiempo a partir de una singularidad espaciotemporal. El universo experimento un rapido periodo de inflacion cosmica que arraso todas las irregularidades iniciales. A partir de entonces el universo se expandio y se convirtio en estable, mas frio y menos denso. Las variaciones menores en la distribucion de la masa dieron como resultado la segregacion fractal en porciones, que se encuentran en el universo actual como cumulos de galaxias.  Las observaciones astronomicas indican que el universo tiene una edad de 13\u00a0799\u00b121 millones de a\u00f1os (entre 13\u00a0778 y 13\u00a0820 millones de a\u00f1os con un intervalo de confianza del 68%) y por lo menos 93\u00a0000 millones de a\u00f1os luz de extension.\u200b  Debido a que, segun la teoria de la relatividad especial, la materia no puede moverse a una velocidad superior a la velocidad de la luz, puede parecer paradojico que dos objetos del universo puedan haberse separado 93\u00a0000 millones de a\u00f1os luz en un tiempo de unicamente 13\u00a0000 millones de a\u00f1os; sin embargo, esta separacion no entra en conflicto con la teoria de la relatividad general, ya que esta solo afecta al movimiento en el espacio, pero no al espacio mismo, que puede extenderse a un ritmo superior, no limitado por la velocidad de la luz. Por lo tanto, dos galaxias pueden separarse una de la otra mas rapidamente que la velocidad de la luz si es el espacio entre ellas el que se dilata.  Observaciones recientes han demostrado que esta expansion se esta acelerando, y que la mayor parte de la materia y la energia en el universo son las denominadas materia oscura y energia oscura; la materia ordinaria (barionica) solo representaria algo mas del 5\u00a0% del total.\u200b  Las mediciones sobre la distribucion espacial y el desplazamiento hacia el rojo (redshift) de galaxias distantes, la radiacion cosmica de fondo de microondas y los porcentajes relativos de los elementos quimicos mas ligeros apoyan la teoria de la expansion del espacio, y mas en general, la teoria del Big Bang, que propone que el universo en si se origino en un momento especifico en el pasado.  En cuanto a su destino final, las pruebas indican que el universo es la totalidad del espacio y del tiempo, de todas las formas de la materia, la energia, el impulso, las leyes y constantes fisicas que las gobiernan, las cuales parecen apoyar las teorias de la expansion permanente del universo (Big Freeze o Big Rip, Gran Desgarro), que indica que la expansion misma del espacio provocara que llegue un punto en que los atomos mismos se separaran en particulas subatomicas. Otros futuros posibles que se barajan especulan sobre la posibilidad de que la materia oscura pueda ejercer la fuerza de gravedad suficiente para detener la expansion y hacer que toda la materia se comprima nuevamente; algo a que los cientificos denominan el Big Crunch o la Gran Implosion, aunque las ultimas observaciones van en la direccion del Gran Desgarro.  Los cosmologos teoricos y astrofisicos usan de manera diferente el termino universo, designando bien el sistema completo o unicamente una parte de el.\u200b A menudo se emplea el termino el universo para designar la parte observable del espacio-tiempo o el espacio-tiempo entero.  Segun el convenio de los cosmologos, el termino universo se refiere frecuentemente a la parte finita del espacio-tiempo que es directamente observable utilizando telescopios, otros detectores y metodos fisicos, teoricos y empiricos para estudiar los componentes basicos del universo y sus interacciones. Los fisicos cosmologos asumen que la parte observable del espacio comovil (tambien llamado nuestro universo) corresponde a una parte del espacio entero y normalmente no es el espacio entero.  En el caso del universo observable, este puede ser solo una minima porcion del universo existente y, por consiguiente, puede ser imposible saber realmente si el universo esta siendo completamente observado. La mayoria de cosmologos creen que el universo observable es una parte extremadamente peque\u00f1a del universo \u00abentero\u00bb realmente existente y que es imposible ver todo el espacio comovil. En la actualidad se desconoce si esto es correcto, ya que de acuerdo a los estudios de la forma del universo, es posible que el universo observable este cerca de tener el mismo tama\u00f1o que todo el espacio. La pregunta sigue debatiendose.\u200b\u200b  El hecho de que el universo este en expansion se deriva de las observaciones del corrimiento al rojo realizadas en la decada de 1920 y que se cuantifican por la ley de Hubble. Dichas observaciones son la prediccion experimental del modelo de Friedmann-Robertson-Walker, que es una solucion de las ecuaciones de campo de Einstein de la relatividad general, que predicen el inicio del universo mediante el big bang.  El \"corrimiento al rojo\" es un fenomeno observado por los astronomos, que muestra una relacion directa entre la distancia de un objeto remoto (como una galaxia) y la velocidad con la que este se aleja. Si esta expansion ha sido continua a lo largo de la vida del universo, entonces en el pasado estos objetos distantes que siguen alejandose tuvieron que estar una vez juntos. Esta idea da pie a la teoria del Big Bang, el modelo dominante en la cosmologia actual.  Durante la era mas temprana del Big Bang, se cree que el universo era un caliente y denso plasma. Segun avanzaba la expansion, la temperatura decrecia hasta el punto en que se pudieron formar los atomos. En aquella epoca, la energia de fondo se desacoplo de la materia y fue libre de viajar a traves del espacio. La energia remanente continuo enfriandose al expandirse el universo y hoy forma el fondo cosmico de microondas. Esta radiacion de fondo es remarcablemente uniforme en todas las direcciones, circunstancia que los cosmologos han intentado explicar como reflejo de un periodo temprano de inflacion cosmica despues del Big Bang.  El examen de las peque\u00f1as variaciones en el fondo de radiacion de microondas proporciona informacion sobre la naturaleza del universo, incluyendo la edad y composicion. La edad del universo desde el Big Bang, de acuerdo a la informacion actual proporcionada por el WMAP de la NASA, se estima en unos 13,700 millones de a\u00f1os, con un margen de error de un 1\u00a0% (137 millones de a\u00f1os). Otros metodos de estimacion ofrecen diferentes rangos de edad, desde 11\u00a0000 millones a 20\u00a0000 millones.  Hasta hace poco, la primera centesima de segundo era mas bien un misterio, impidiendo a los cientificos describir exactamente como era el universo. Los nuevos experimentos en el RHIC, en el Brookhaven National Laboratory, han proporcionado a los fisicos una luz en esta cortina de alta energia, de tal manera que pueden observar directamente los tipos de comportamiento que pueden haber tenido lugar en ese instante.\u200b  En estas energias, los quarks que componen los protones y los neutrones no estaban juntos, y una mezcla densa supercaliente de cuarks y gluones, con algunos electrones, era todo lo que podia existir en los microsegundos anteriores a que se enfriaran lo suficiente para formar el tipo de particulas de materia que observamos hoy en dia.\u200b  Los rapidos avances acerca de lo que paso despues de la existencia de la materia aportan mucha informacion sobre la formacion de las galaxias. Se cree que las primeras galaxias eran debiles \"galaxias enanas\" que emitian tanta radiacion que separarian los atomos gaseosos de sus electrones. Este gas, a su vez, se estaba calentando y expandiendo, y tenia la posibilidad de obtener la masa necesaria para formar las grandes galaxias que conocemos hoy.\u200b\u200b  El destino final del universo tiene diversos modelos que explican lo que sucedera en funcion de diversos parametros y observaciones. De acuerdo con la teoria general de la relatividad, el destino final mas probable dependera del valor autentico de la densidad de materia. En funcion de ese parametro se barajan dos tipos de finales:  A partir de los a\u00f1os 1990 se comprobo que el universo parece tener una expansion acelerada, hecho que dentro de la relatividad general solo es explicable acudiendo a un mecanismo de tipo constante cosmologica. No se conoce si ese hecho puede dar lugar a un tercer tipo de final.  Si el universo es suficientemente denso, es posible que la fuerza gravitatoria de toda esa materia pueda finalmente detener la expansion inicial, de tal manera que el universo volveria a contraerse, las galaxias empezarian a retroceder, y con el tiempo colisionarian entre si. La temperatura se elevaria, y el universo se precipitaria hacia un destino catastrofico en el que quedaria reducido nuevamente a un punto.  Algunos fisicos han especulado que despues se formaria otro universo, en cuyo caso se repetiria el proceso. A esta teoria se la conoce como la teoria del universo oscilante.  Hoy en dia esta hipotesis parece incorrecta, pues a la luz de los ultimos datos experimentales, el universo se esta expandiendo cada vez mas rapidamente.  El Gran Desgarramiento o Teoria de la Eterna Expansion, en ingles Big Rip, es una hipotesis cosmologica sobre el destino ultimo del universo. Este posible destino final del universo depende de la cantidad de energia oscura existente en el universo. Si el universo contiene suficiente energia oscura, podria acabar en un desgarramiento de toda la materia.  El valor clave es w, la razon entre la presion de la energia oscura y su densidad energetica. A w < -1, el universo acabaria por ser desgarrado. Primero, las galaxias se separarian entre si, luego la gravedad seria demasiado debil para mantener integrada cada galaxia; los sistemas planetarios perderian su cohesion gravitatoria y, en los ultimos minutos, se desbaratarian estrellas y planetas, y los atomos serian destruidos.  Los autores de esta hipotesis calculan que el fin del tiempo ocurriria aproximadamente 3.5\u00d71010 a\u00f1os despues del Big Bang, es decir, dentro de 2.0\u00d71010 a\u00f1os.  Una modificacion de esta teoria, denominada Big Freeze, aunque poco aceptada[cita\u00a0requerida], normalmente afirma que el universo continuaria su expansion sin provocar un Big Rip.  Muy poco se conoce con certeza sobre el tama\u00f1o del universo. Puede tener una longitud de billones de a\u00f1os luz o incluso tener un tama\u00f1o infinito.\u200b Un articulo de 2003\u200b dice establecer una cota inferior de 24 gigaparsecs (78\u00a0000 millones de a\u00f1os luz) para el tama\u00f1o del universo, pero no hay ninguna razon para creer que esta cota esta de alguna manera muy ajustada (Vease forma del universo).  El universo observable (o visible), que consiste en toda la materia y energia que podria habernos afectado desde el Big Bang dada la limitacion de la velocidad de la luz, es ciertamente finito. La distancia comovil al extremo del universo visible ronda los 46,500 millones de a\u00f1os luz en todas las direcciones desde la Tierra. Asi, el universo visible se puede considerar como una esfera perfecta con la Tierra en el centro, y un diametro de unos 93\u00a0000 millones de a\u00f1os luz.\u200b Hay que se\u00f1alar que muchas fuentes han publicado una amplia variedad de cifras incorrectas para el tama\u00f1o del universo visible: desde 13\u00a0700 hasta 180\u00a0000 millones de a\u00f1os luz. (Vease universo observable).  En el universo las distancias que separan los astros son tan grandes que, si las quisieramos expresar en metros, tendriamos que utilizar cifras muy grandes. Debido a ello, se utiliza como unidad de longitud el a\u00f1o luz, que corresponde a la distancia que recorre la luz en un a\u00f1o.  Anteriormente, el modelo de universo mas comunmente aceptado era el propuesto por Albert Einstein en su Relatividad General, en la que propone un universo \"finito pero ilimitado\", es decir, que a pesar de tener un volumen medible no tiene limites, de forma analoga a la superficie de una esfera, que es medible pero ilimitada. Esto era propio de un universo esferico. Hoy, gracias a las ultimas observaciones realizadas por el WMAP de la NASA, se sabe que tiene forma plana. Aunque no se descarta un posible universo plano cerrado sobre si mismo. Estas observaciones sugieren que el universo es infinito.  Una pregunta importante abierta en cosmologia es la forma del universo. Matematicamente, \u00bfque variedad representa mejor la parte espacial del universo?  Si el universo es espacialmente plano, se desconoce si las reglas de la geometria Euclidiana seran validas a mayor escala. Actualmente muchos cosmologos creen que el universo observable esta muy cerca de ser espacialmente plano, con arrugas locales donde los objetos masivos distorsionan el espacio-tiempo, de la misma forma que la superficie de un lago es casi plana. Esta opinion fue reforzada por los ultimos datos del WMAP, mirando hacia las \"oscilaciones acusticas\" de las variaciones de temperatura en la radiacion de fondo de microondas.\u200b  Por otra parte, se desconoce si el universo es conexo. El universo no tiene cotas espaciales de acuerdo al modelo estandar del Big Bang; sin embargo debe ser espacialmente finito (compacto). Esto se puede comprender utilizando una analogia en dos dimensiones: la superficie de una esfera no tiene limite, pero no tiene un area infinita. Es una superficie de dos dimensiones con curvatura constante en una tercera dimension. La 3-esfera es un equivalente en tres dimensiones en el que las tres dimensiones estan constantemente curvadas en una cuarta.  Si el universo fuese compacto y sin cotas, seria posible, despues de viajar una distancia suficiente, volver al punto de partida. Asi, la luz de las estrellas y galaxias podria pasar a traves del universo observable mas de una vez. Si el universo fuese multiplemente conexo y suficientemente peque\u00f1o (y de un tama\u00f1o apropiado, tal vez complejo) entonces posiblemente se podria ver una o varias veces alrededor de el en alguna (o todas) direcciones. Aunque esta posibilidad no ha sido descartada, los resultados de las ultimas investigaciones de la radiacion de fondo de microondas hacen que esto parezca improbable.  Historicamente se ha creido que el universo es de color negro, pues es lo que observamos al momento de mirar al cielo en las noches despejadas. En 2002, sin embargo, los astronomos Karl Glazebrook e Ivan Baldry afirmaron en un articulo cientifico que el universo en realidad es de un color que decidieron llamar cafe con leche cosmico.\u200b\u200b Este estudio se baso en la medicion del rango espectral de la luz proveniente de un gran volumen del universo, sintetizando la informacion aportada por un total de mas de 200.000 galaxias.  Mientras que la estructura esta considerablemente fractalizada a nivel local (ordenada en una jerarquia de racimo), en los ordenes mas altos de distancia el universo es muy homogeneo. A estas escalas la densidad del universo es muy uniforme, y no hay una direccion preferida o significativamente asimetrica en el universo. Esta homogeneidad e isotropia es un requisito de la metrica de Friedman-Lemaitre-Robertson-Walker empleada en los modelos cosmologicos modernos y que se muestra de acuerdo con el principio cosmologico.\u200b  La cuestion de la anisotropia en el universo primigenio fue significativamente contestada por el WMAP, que busco fluctuaciones en la intensidad del fondo de microondas.\u200b Las medidas de esta anisotropia han proporcionado informacion util y restricciones sobre la evolucion del universo.  Hasta el limite de la potencia de observacion de los instrumentos astronomicos, los objetos irradian y absorben la energia de acuerdo a las mismas leyes fisicas a como lo hacen en nuestra propia galaxia.\u200b Basandose en esto, se cree que las mismas leyes y constantes fisicas son universalmente aplicables a traves de todo el universo observable. No se ha encontrado ninguna prueba confirmada que muestre que las constantes fisicas hayan variado desde el Big Bang.\u200b  El universo observable actual parece tener un espacio-tiempo geometricamente plano, conteniendo una densidad masa-energia equivalente a 9,9 \u00d7 10\u221230 gramos por centimetro cubico. Los constituyentes primarios parecen consistir en un 73\u00a0% de energia oscura, 23\u00a0% de materia oscura fria y un 4\u00a0% de atomos. Asi, la densidad de los atomos equivaldria a un nucleo de hidrogeno sencillo por cada cuatro metros cubicos de volumen.\u200b La naturaleza exacta de la energia oscura y la materia oscura fria sigue siendo un misterio. Actualmente se especula con que el neutrino (una particula muy abundante en el universo) tenga, aunque minima, una masa. De comprobarse este hecho, podria significar que la energia y la materia oscura no existen.  Durante las primeras fases del Big Bang, se cree que se formaron las mismas cantidades de materia y antimateria. Materia y antimateria deberian eliminarse mutuamente al entrar en contacto, por lo que la actual existencia de materia (y la ausencia de antimateria) supone una violacion de la simetria CP (Vease Violacion CP), por lo que puede ser que las particulas y las antiparticulas no tengan propiedades exactamente iguales o simetricas,\u200b o puede que simplemente las leyes fisicas que rigen el universo favorezcan la supervivencia de la materia frente a la antimateria.\u200b En este mismo sentido, tambien se ha sugerido que quizas la materia oscura sea la causante de la bariogenesis, al interactuar de distinta forma con la materia que con la antimateria.\u200b  Antes de la formacion de las primeras estrellas, la composicion quimica del universo consistia primariamente en hidrogeno (75\u00a0% de la masa total), con una suma menor de helio-4 (4He) (24\u00a0% de la masa total) y el resto de otros elementos.\u200b Una peque\u00f1a porcion de estos elementos estaba en la forma del isotopo deuterio (\u00b2H), helio-3 (\u00b3He) y litio (7Li).\u200b La materia interestelar de las galaxias ha sido enriquecida sin cesar por elementos mas pesados, generados por procesos de fusion en las estrellas, y diseminados como resultado de las explosiones de supernovas, los vientos estelares y la expulsion de la cubierta exterior de estrellas maduras.\u200b  El Big Bang dejo detras un flujo de fondo de fotones y neutrinos. La temperatura de la radiacion de fondo ha decrecido sin cesar con la expansion del universo y ahora fundamentalmente consiste en la energia de microondas, equivalente a una temperatura de 2,725\u00a0K.\u200b La densidad del fondo de neutrinos actual es de 150 por centimetro cubico.\u200b  Segun la fisica moderna, el universo es un sistema cuantico aislado, un campo unificado de ondas que entra en decoherencia al tutor de la observacion o medicion. En tal virtud, en ultima instancia, el entorno del universo seria no local y no determinista.  Los cosmologos teoricos estudian modelos del conjunto espacio-tiempo que esten conectados, y buscan modelos que sean consistentes con los modelos fisicos cosmologicos del espacio-tiempo en la escala del universo observable. Sin embargo, recientemente han tomado fuerza teorias que contemplan la posibilidad de multiversos o varios universos coexistiendo simultaneamente. Segun la recientemente enunciada Teoria de Multiexplosiones se pretende dar explicacion a este aspecto, poniendo en relieve una posible convivencia de universos en un mismo espacio.\u200b  Cientificos del King's College de Londres lograron recrear las condiciones inmediatamente seguidas al Big Bang a traves del conocimiento adquirido durante dos a\u00f1os de la particula de Higgs y llegaron a la conclusion de que, posiblemente, el universo colapso, hasta dejar de existir casi tan pronto cuando empezo,\u200b lo que plantea la idea de que todo lo que vemos no existe y solo es el pasado de los astros.\u200b  A gran escala, el universo esta formado por galaxias y agrupaciones de galaxias. Las galaxias son agrupaciones masivas de estrellas, y son las estructuras mas grandes en las que se organiza la materia en el universo. A traves del telescopio se manifiestan como manchas luminosas de diferentes formas. A la hora de clasificarlas, los cientificos distinguen entre las galaxias del Grupo Local, compuesto por las treinta galaxias mas cercanas y a las que esta unida gravitacionalmente nuestra galaxia (la Via Lactea), y todas las demas galaxias, llamadas \"galaxias exteriores\".  Las galaxias estan distribuidas por todo el universo y presentan caracteristicas muy diversas, tanto en lo que respecta a su configuracion como a su antiguedad. Las mas peque\u00f1as abarcan alrededor de 400\u00a0000\u00a0millones de estrellas, y las galaxias de mayor tama\u00f1o pueden llegar a abarcar mas de un billon de astros. Estas ultimas pueden tener un diametro de 170\u00a0000\u00a0a\u00f1os\u00a0luz, mientras que las primeras no suelen exceder los 6000\u00a0a\u00f1os\u00a0luz.  Ademas de estrellas y sus astros asociados (planetas, asteroides, etcetera), las galaxias contienen tambien materia interestelar, constituida por polvo y gas en una proporcion que varia entre el 1 y el 10\u00a0% de su masa.  Se estima que el universo puede estar constituido por unos 100\u00a0000\u00a0millones de galaxias, aunque estas cifras varian en funcion de los diferentes estudios.  La creciente potencia de los telescopios, que permite observaciones cada vez mas detalladas de los distintos elementos del universo, ha hecho posible una clasificacion de las galaxias por su forma. Se han establecido asi cinco tipos distintos: galaxias elipticas, lenticulares, espirales, espirales barradas e irregulares.  En forma de elipse o de esferoide, se caracterizan por carecer de una estructura interna definida y por presentar muy poca materia interestelar. Se consideran las mas antiguas del universo, ya que sus estrellas son viejas y se encuentran en una fase muy avanzada de su evolucion.  Las galaxias de este tipo fueron en su momento galaxias espirales, pero consumieron o perdieron gran parte de materia interestelar, por lo que hoy carecen de brazos espirales y solo presenta su nucleo. Aunque a veces existe cierta cantidad de materia interestelar, sobre todo polvo, que se agrupa en forma de disco alrededor de esta. Estas galaxias constituyen alrededor del 3\u00a0% de las galaxias del universo.  Estan constituidas por un nucleo central y dos o mas brazos en espiral, que parten del nucleo. Este se halla formado por multitud de estrellas y apenas tiene materia interestelar, mientras que en los brazos abunda la materia interestelar y hay gran cantidad de estrellas jovenes, que son muy brillantes. Alrededor del 75\u00a0% de las galaxias del universo son de este tipo.  Es un subtipo de galaxia espiral, caracterizado por la presencia de una barra central de la que tipicamente parten dos brazos espirales. Este tipo de galaxias constituyen una fraccion importante del total de galaxias espirales. La Via Lactea es una galaxia espiral barrada.  Incluyen una gran diversidad de galaxias, cuyas configuraciones no responden a las cuatro formas anteriores, aunque tienen en comun algunas caracteristicas, como la de ser casi todas peque\u00f1as y contener un gran porcentaje de materia interestelar. Se calcula que son irregulares alrededor del 5\u00a0% de las galaxias del universo.  La Via Lactea es nuestra galaxia. Segun las observaciones, posee una masa de 1012 masas solares y es de tipo espiral barrada. Con un diametro medio de unos 100\u00a0000 a\u00f1os luz se calcula que contiene unos 200\u00a0000 millones de estrellas, entre las cuales se encuentra el Sol. La distancia desde el Sol al centro de la galaxia es de alrededor de 27\u00a0700 a\u00f1os luz (8,5\u00a0kpc). A simple vista, se observa como una estela blanquecina de forma eliptica, que se puede distinguir en las noches despejadas. Lo que no se aprecian son sus brazos espirales, en uno de los cuales, el llamado brazo de Orion, esta situado nuestro sistema solar, y por tanto la Tierra.  El nucleo central de la galaxia presenta un espesor uniforme en todos sus puntos, salvo en el centro, donde existe un gran abultamiento con un grosor maximo de 16\u00a0000 a\u00f1os luz, siendo el grosor medio de unos 6000 a\u00f1os luz.  Todas las estrellas y la materia interestelar que contiene la Via Lactea, tanto en el nucleo central como en los brazos, estan situadas dentro de un disco de 100\u00a0000 a\u00f1os luz de diametro, que gira sobre su eje a una velocidad lineal superior a los 216\u00a0km/s.\u200b  Tan solo tres galaxias distintas a la nuestra son visibles a simple vista. Esta la Galaxia de Andromeda, visible desde el Hemisferio Norte; la Gran Nube de Magallanes, y la Peque\u00f1a Nube de Magallanes, en el hemisferio sur celeste. El resto de las galaxias no son visibles al ojo desnudo sin ayuda de instrumentos. Si que lo son, en cambio, las estrellas que forman parte de la Via Lactea. Estas estrellas dibujan a menudo en el cielo figuras reconocibles, que han recibido diversos nombres en relacion con su aspecto. Estos grupos de estrellas de perfil identificable se conocen con el nombre de constelaciones. La Union Astronomica Internacional agrupo oficialmente las estrellas visibles en 88 constelaciones, algunas de ellas muy extensas, como Hidra o la Osa Mayor, y otras muy peque\u00f1as como Flecha y Triangulo.  Son los elementos constitutivos mas destacados de las galaxias. Las estrellas son enormes esferas de gas que brillan debido a sus gigantescas reacciones nucleares. Debido a la fuerza gravitatoria, la presion y a la temperatura del interior de una estrella que sea suficientemente intensa, se inicia la fusion nuclear de sus atomos, y comienzan a emitir una luz roja oscura, que despues se mueve hacia el estado superior, que es en el que esta nuestro Sol, para posteriormente, al modificarse las reacciones nucleares interiores, dilatarse y finalmente enfriarse.  Al acabarse el hidrogeno, se originan reacciones nucleares de elementos mas pesados, mas energeticas, que convierten a la estrella en una gigante roja. Con el tiempo, esta se vuelve inestable, a la vez que lanza hacia el espacio exterior la mayor parte del material estelar. Este proceso puede durar 100 millones de a\u00f1os, hasta que se agota toda la energia nuclear, y la estrella se contrae por efecto de la gravedad hasta hacerse peque\u00f1a y densa, en la forma de enana blanca, azul o marron. Si la estrella inicial es varias veces mas masiva que el Sol, su ciclo puede ser diferente, y en lugar de una gigante, puede convertirse en una supergigante y acabar su vida con una explosion denominada supernova. Estas estrellas pueden acabar como estrellas de neutrones. Tama\u00f1os aun mayores de estrellas pueden consumir todo su combustible muy rapidamente, transformandose en una entidad supermasiva llamada agujero negro.  Los pulsares son fuentes de ondas de radio que emiten a periodos regulares. La palabra \u00abpulsar\u00bb significa pulsating radio source (\"fuente de radio pulsante\"). Se detectan mediante radiotelescopios y se requieren relojes de extraordinaria precision para detectar sus cambios de ritmo. Los estudios indican que un pulsar es una estrella de neutrones peque\u00f1a que gira a gran velocidad. El mas conocido esta en la Nebulosa del Cangrejo. Su densidad es tan grande que una muestra de cuasar del tama\u00f1o de una bola de boligrafo tendria una masa de cerca de 100\u00a0000\u00a0toneladas. Su campo magnetico, muy intenso, se concentra en un espacio reducido. Esto lo acelera y lo hace emitir gran cantidad de energia en haces de radiacion que aqui recibimos como ondas de radio.  La palabra \u00abcuasar\u00bb es un acronimo de quasi stellar radio source (\"fuentes de radio casi estelares\"). Se identificaron en la decada de 1950. Mas tarde se vio que mostraban un desplazamiento al rojo mas grande que cualquier otro objeto conocido. La causa era el Efecto Doppler, que mueve el espectro hacia el rojo cuando los objetos se alejan. El primer cuasar estudiado, denominado 3C\u00a0273, esta a 1500\u00a0millones de a\u00f1os luz de la Tierra. A partir de 1980 se han identificado miles de cuasares, algunos alejandose de nosotros a velocidades del 90\u00a0% de la velocidad de la luz.  Se han descubierto cuasares a 12\u00a0000\u00a0millones de a\u00f1os luz de la Tierra; practicamente la edad del universo. A pesar de las enormes distancias, la energia que llega en algunos casos es muy grande, equivalente a la recibida desde miles de galaxias; por ejemplo, el s50014+81 es unas 60\u00a0000\u00a0veces mas brillante que toda la Via Lactea.  Los planetas son cuerpos que giran en torno a una estrella y que, segun la definicion de la Union Astronomica Internacional, deben cumplir ademas la condicion de haber limpiado su orbita de otros cuerpos rocosos importantes, y de tener suficiente masa como para que su fuerza de gravedad genere un cuerpo esferico. En el caso de cuerpos que orbitan alrededor de una estrella que no cumplan estas caracteristicas, se habla de planetas enanos, planetesimales, o asteroides. En nuestro Sistema Solar hay 8 planetas: Mercurio, Venus, Tierra, Marte, Jupiter, Saturno, Urano y Neptuno, considerandose desde 2006 a Pluton como un planeta enano. A finales de 2009, fuera de nuestro Sistema Solar se habian detectado mas de 400 planetas extrasolares, pero los avances tecnologicos estan permitiendo que este numero crezca a buen ritmo.  Los satelites naturales son astros que giran alrededor de los planetas. El unico satelite natural de la Tierra es la Luna, que es tambien el satelite mas cercano al Sol. A continuacion se enumeran los principales satelites de los planetas del sistema solar (se incluye en el listado a Pluton, considerado por la UAI como un planeta enano).  En aquellas zonas de la orbita de una estrella en las que, por diversos motivos, no se ha producido la agrupacion de la materia inicial en un unico cuerpo dominante o planeta, aparecen los discos de asteroides: objetos rocosos de muy diversos tama\u00f1os que orbitan en grandes cantidades en torno a la estrella, chocando eventualmente entre si. Cuando las rocas tienen diametros inferiores a 50\u00a0m se denominan meteoroides. A consecuencia de las colisiones, algunos asteroides pueden variar sus orbitas, adoptando trayectorias muy excentricas que periodicamente les acercan la estrella. Cuando la composicion de estas rocas es rica en agua u otros elementos volatiles, el acercamiento a la estrella y su consecuente aumento de temperatura origina que parte de su masa se evapore y sea arrastrada por el viento solar, creando una larga cola de material brillante a medida que la roca se acerca a la estrella. Estos objetos se denominan cometas. En nuestro sistema solar hay dos grandes discos de asteroides: uno situado entre las orbitas de Marte y Jupiter, denominado el Cinturon de asteroides, y otro mucho mas tenue y disperso en los limites del Sistema Solar, a aproximadamente un a\u00f1o luz de distancia, denominado Nube de Oort.    La teoria general de la relatividad, publicada por Albert Einstein en 1916, implicaba que el cosmos se hallaba en expansion o en contraccion. Pero este concepto era totalmente opuesto a la nocion de un universo estatico, aceptada entonces hasta por el propio Einstein. De ahi que este incluyera en sus calculos lo que denomino \u201cconstante cosmologica\u201d, ajuste mediante el cual intentaba conciliar su teoria con la idea aceptada de un universo estatico e inmutable. Sin embargo, ciertos descubrimientos que se sucedieron en los a\u00f1os 1920 llevaron a Einstein a decir que el ajuste que habia efectuado a su teoria de la relatividad era el \u2018mayor error de su vida\u2019. Dichos descubrimientos se realizaron gracias a la instalacion de un enorme telescopio de 254 centimetros en el monte Wilson (California). Las observaciones formuladas en los a\u00f1os 20 con la ayuda de este instrumento demostraron que el universo se halla en expansion.  Hasta entonces, los mayores telescopios solo permitian identificar las estrellas de nuestra galaxia, la Via Lactea, y aunque se veian borrones luminosos, llamados nebulosas, por lo general se tomaban por remolinos de gas existentes en nuestra galaxia. Gracias a la mayor potencia del telescopio del monte Wilson, Edwin Hubble logro distinguir estrellas en aquellas nebulosas. Finalmente se descubrio que los borrones eran lo mismo que la Via Lactea: galaxias. Hoy se cree que hay entre 50\u00a0000 y 125\u00a0000\u00a0millones de galaxias, cada una con cientos de miles de millones de estrellas.  A finales de los a\u00f1os 20, Hubble tambien descubrio que las galaxias se alejan de nosotros, y que lo hacen mas velozmente cuanto mas lejos se hallan. Los astronomos calculan la tasa de recesion de las galaxias mediante el espectrografo, instrumento que mide el espectro de la luz procedente de los astros. Para ello, dirigen la luz que proviene de estrellas lejanas hacia un prisma, que la descompone en los colores que la integran.  La luz de un objeto es rojiza (fenomeno llamado corrimiento al rojo) si este se aleja del observador, y azulada (corrimiento al azul) si se le aproxima. Cabe destacar que, salvo en el caso de algunas galaxias cercanas, todas las galaxias conocidas tienen lineas espectrales desplazadas hacia el rojo. De ahi infieren los cientificos que el universo se expande de forma ordenada. La tasa de dicha expansion se determina midiendo el grado de desplazamiento al rojo. La conclusion que se ha extraido de la expansion del cosmos se puede ilustrar de la siguiente forma: un cientifico invito al publico a analizar el proceso a la inversa \u2014como una pelicula de la expansion proyectada en retroceso\u2014 a fin de observar la historia primitiva del universo. Visto asi, el cosmos pareceria estar en recesion o contraccion, en vez de en expansion, y retornando finalmente a un unico punto de origen.  El fisico Stephen Hawking concluyo lo siguiente en su libro Agujeros negros y peque\u00f1os universos (y otros ensayos), editado en 1993: \u00abLa ciencia podria afirmar que el universo tenia que haber conocido un comienzo\u00bb. Pero hace a\u00f1os, muchos expertos rechazaban que el universo hubiese tenido principio. El cientifico Fred Hoyle no aceptaba que el cosmos hubiera surgido mediante lo que llamo burlonamente a big bang (\u00abuna gran explosion\u00bb). Uno de los argumentos que esgrimia era que, de haber existido un comienzo tan dinamico, deberian conservarse residuos de aquel acontecimiento en algun lugar del universo: tendria que haber radiacion fosil, por asi decirlo; una leve luminiscencia residual.  El diario The New York Times (8 de marzo de 1998) indico que hacia 1965 \u00ablos astronomos Arno Penzias y Robert Wilson descubrieron la omnipresente radiacion de fondo: el destello residual de la explosion primigenia\u00bb. El articulo a\u00f1adio: \u00abTodo indicaba que la teoria [de la gran explosion] habia triunfado\u00bb.  Pero en los a\u00f1os posteriores al hallazgo se formulo esta objecion: Si el modelo de la gran explosion era correcto, \u00bfPor que no se habian detectado leves irregularidades en la radiacion? (La formacion de las galaxias habria requerido un universo que contase con zonas mas frias y densas que permitieran la fusion de la materia.) En efecto, los experimentos realizados por Penzias y Wilson desde la superficie terrestre no revelaban tales irregularidades.  Por esta razon, la NASA lanzo en noviembre de 1989 el satelite COBE (siglas de Explorador del Fondo Cosmico, en ingles), cuyos descubrimientos se calificaron de cruciales. \u201cLas ondas que detecto su radiometro diferencial de microondas correspondian a las fluctuaciones que dejaron su impronta en el cosmos y que hace miles de millones de a\u00f1os llevaron a la formacion de las galaxias\u201d.  Diferentes palabras se han utilizado a traves de la historia para denotar \"todo el espacio\", incluyendo los equivalentes y las variantes en varios lenguajes de \"cielos\", \"cosmos\" y \"mundo\". El macrocosmos tambien se ha utilizado para este efecto, aunque esta mas especificamente definido como un sistema que refleja a gran escala uno, algunos, o todos estos componentes del sistema o partes. Similarmente, un microcosmos es un sistema que refleja a peque\u00f1a escala un sistema mucho mayor del que es parte.  Aunque palabras como mundo y sus equivalentes en otros lenguajes casi siempre se refieren al planeta Tierra, antiguamente se referian a cada cosa que existia (se podia ver). En ese sentido la utilizaba, por ejemplo, Nicolas Copernico. Algunos lenguajes utilizan la palabra \"mundo\" como parte de la palabra \"espacio exterior\". Un ejemplo en aleman lo constituye la palabra \"Weltraum\".\u200b  En ingles ","snippet":"El universo es el conjunto de todas las entidades fisicamente detectables que interactuan entre ellas dentro del espacio-tiempo de acuerdo a leyes fisicas bien definidas. Sin embargo, el termino tambi","enlaces_salientes":["Universo","Universo","Universo","Universo_(desambiguaci%C3%B3n)","Espectro_visible","Cosmos","Campo_Ultra_Profundo_del_Hubble","A%C3%B1o_luz","Kelvin","Bari%C3%B3n","Materia_oscura","Energ%C3%ADa_oscura","Forma_del_universo","Cosmolog%C3%ADa_f%C3%ADsica","Big_Bang","Teor%C3%ADa_del_Big_Bang","Inflaci%C3%B3n_c%C3%B3smica","Bariog%C3%A9nesis","Nucleos%C3%ADntesis_primordial","Creacionismo","Expansi%C3%B3n_m%C3%A9trica_del_espacio","Expansi%C3%B3n_acelerada_del_universo","Ley_de_Hubble","Corrimiento_al_rojo","Forma_del_universo","Espacio-tiempo","Materia_bari%C3%B3nica","Materia_oscura","Energ%C3%ADa_oscura","Planck_(sat%C3%A9lite)","WMAP","COBE","Albert_Einstein","Edwin_Hubble","Georges_Lema%C3%AEtre","Stephen_Hawking","George_Gamow","F%C3%ADsica_experimental","Espacio-tiempo","Ley_de_la_f%C3%ADsica","Cosmos","Mundo","Naturaleza","Realidad","Cosmolog%C3%ADa","Astronom%C3%ADa","F%C3%ADsica","Ciencias_f%C3%ADsicas","Sistema_cerrado","Energ%C3%ADa","Materia_(f%C3%ADsica)","Causalidad_(f%C3%ADsica)","Universo_observable","Homog%C3%A9neo","Isotr%C3%B3pico","Gravedad","Relatividad_general","Interacciones_fundamentales","Modelo_est%C3%A1ndar_de_f%C3%ADsica_de_part%C3%ADculas","Tiempo","Curvatura_del_espacio-tiempo","Curvatura_media","Geometr%C3%ADa_euclidiana","Georges_Lema%C3%AEtre","Albert_Einstein","Big_Bang","Singularidad_espaciotemporal","Inflaci%C3%B3n_c%C3%B3smica","Fractal","Edad_del_universo","A%C3%B1o_luz","Teor%C3%ADa_de_la_relatividad_especial","Materia","Velocidad","Velocidad_de_la_luz","Objeto_f%C3%ADsico","Relatividad_general","Movimiento_(f%C3%ADsica)","Espacio_(f%C3%ADsica)","Galaxia","Aceleraci%C3%B3n_de_la_expansi%C3%B3n_del_universo","Materia_(f%C3%ADsica)","Energ%C3%ADa","Materia_oscura","Energ%C3%ADa_oscura","Corrimiento_al_rojo","Radiaci%C3%B3n_de_fondo_de_microondas","Elemento_qu%C3%ADmico","Big_Freeze","Big_Rip","Materia_oscura","Teor%C3%ADa_del_Big_Crunch","Universo_observable","Galaxias_Antennae","Telescopio_espacial_Hubble","F%C3%ADsica_te%C3%B3rica","Cosmolog%C3%ADa_f%C3%ADsica","Espacio-tiempo","Telescopio","Sistema_de_referencia_com%C3%B3vil","Forma_del_universo","Teor%C3%ADa_del_Big_Bang","Big_Bang","Expansi%C3%B3n_m%C3%A9trica_del_espacio","Corrimiento_al_rojo","Ley_de_Hubble","Relatividad_general","Big_Bang","Plasma_(estado_de_la_materia)","Fondo_c%C3%B3smico_de_microondas","Inflaci%C3%B3n_c%C3%B3smica","Edad_del_universo","WMAP","NASA","RHIC","Brookhaven_National_Laboratory","Quark","Prot%C3%B3n","Neutr%C3%B3n","Glu%C3%B3n","Protogalaxia","Galaxias_enanas","Destino_final_del_universo","Teor%C3%ADa_general_de_la_relatividad","Expansi%C3%B3n_acelerada_del_universo","Constante_cosmol%C3%B3gica","Big_Crunch","Fuerza_gravitatoria","Universo_oscilante","Big_Rip","Hip%C3%B3tesis_(m%C3%A9todo_cient%C3%ADfico)","Destino_%C3%BAltimo_del_universo","Energ%C3%ADa_oscura","Materia","Raz%C3%B3n_(matem%C3%A1ticas)","Densidad_energ%C3%A9tica","Galaxia","Sistema_planetario","Estrella","Planeta","%C3%81tomo","Big_Freeze","Destino_final_del_universo#Big_Bounce","Universo_oscilante","Universo_observable","Universo_observable","A%C3%B1os_luz","Representaci%C3%B3n_logar%C3%ADtmica","Sistema_Solar","Big_Bang","Parsecs","Forma_del_universo","Velocidad_de_la_luz","Distancia_com%C3%B3vil","Universo_observable","A%C3%B1o_luz","Albert_Einstein","Relatividad_General","WMAP","Forma_del_universo","Estructura_a_gran_escala_del_universo","Grabado_Flammarion","Xilograf%C3%ADa","Par%C3%ADs","Geometr%C3%ADa_Euclidiana","Espacio-tiempo","Espacio_conexo","Espacio_compacto","3-esfera","Radiaci%C3%B3n_de_fondo_de_microondas","Caf%C3%A9_con_leche_c%C3%B3smico","Karl_Glazebrook","Art%C3%ADculo_cient%C3%ADfico","Caf%C3%A9_con_leche_c%C3%B3smico","Galaxia","Radiaci%C3%B3n_de_fondo_de_microondas","Fractal","Isotrop%C3%ADa","M%C3%A9trica_de_Friedman-Lema%C3%AEtre-Robertson-Walker","Principio_cosmol%C3%B3gico","Anisotrop%C3%ADa","Ley_f%C3%ADsica","Densidad","Energ%C3%ADa_oscura","Materia_oscura","Hidr%C3%B3geno","Neutrino","Nebulosa_del_%C3%81guila","Antimateria","Simetr%C3%ADa_CP","Violaci%C3%B3n_CP","Materia_oscura","Bariog%C3%A9nesis","Westerlund_2","Hidr%C3%B3geno","Helio-4","Is%C3%B3topo","Deuterio","Helio-3","Litio","Materia_interestelar","Elemento_qu%C3%ADmico","Fusi%C3%B3n_nuclear","Supernova","Neutrino","Kelvin","Abundancia_de_los_elementos_qu%C3%ADmicos","Multiverso","Universos_paralelos","F%C3%ADsica_te%C3%B3rica","Conjunto_conexo","Universo_observable","King%27s_College_de_Londres","Bos%C3%B3n_de_Higgs","Galaxia","Galaxia_espiral","Telescopio_espacial_Hubble","Galaxia","Estrella","Grupo_Local","V%C3%ADa_L%C3%A1ctea","Medio_interestelar","Galaxia_el%C3%ADptica","Galaxia_lenticular","Galaxia_espiral","Galaxia_espiral_barrada","Galaxia_irregular","V%C3%ADa_L%C3%A1ctea","Sol","A%C3%B1o_luz","Sol","P%C3%A1rsec","Brazo_de_Ori%C3%B3n","Tierra","Constelaci%C3%B3n","Andr%C3%B3meda_(constelaci%C3%B3n)","Galaxia_de_Andr%C3%B3meda","Gran_Nube_de_Magallanes","Peque%C3%B1a_Nube_de_Magallanes","Hemisferio_celeste_sur","V%C3%ADa_L%C3%A1ctea","Constelaci%C3%B3n","Uni%C3%B3n_Astron%C3%B3mica_Internacional","Hidra_(constelaci%C3%B3n)","Osa_Mayor","Sagitta","Triangulum","Estrella","Fusi%C3%B3n_nuclear","Resto_de_supernova","Enana_blanca","Enana_azul_(etapa)","Enana_marr%C3%B3n","Sol","Supernova","Estrella_de_neutrones","Agujero_negro","2MASS","P%C3%BAlsar","Radiotelescopio","Estrella_de_neutrones","Nebulosa_del_Cangrejo","Cu%C3%A1sar","Efecto_Doppler","3C_273","V%C3%ADa_L%C3%A1ctea","Planeta","Uni%C3%B3n_Astron%C3%B3mica_Internacional","Planeta_enano","Planetesimal","Asteroide","Sistema_Solar","Mercurio_(planeta)","Venus_(planeta)","Tierra","Marte_(planeta)","J%C3%BApiter_(planeta)","Saturno_(planeta)","Urano_(planeta)","Neptuno_(planeta)","Plut%C3%B3n_(planeta_enano)","Planeta_extrasolar","Sat%C3%A9lite_natural","Tierra","Luna","Sol","Plut%C3%B3n_(planeta_enano)","Uni%C3%B3n_Astron%C3%B3mica_Internacional","Planeta_enano","Luna","Fobos_(sat%C3%A9lite)","Deimos_(luna)","Metis_(sat%C3%A9lite)","Adrastea_(sat%C3%A9lite)","Amaltea_(sat%C3%A9lite)","Tebe_(sat%C3%A9lite)","%C3%8Do_(sat%C3%A9lite)","Europa_(sat%C3%A9lite)","Gan%C3%ADmedes_(sat%C3%A9lite)","Calisto_(sat%C3%A9lite)","Leda_(sat%C3%A9lite)","Himalia_(sat%C3%A9lite)","Lisitea_(sat%C3%A9lite)","Elara_(sat%C3%A9lite)","Anank%C3%A9_(sat%C3%A9lite)","Carm%C3%A9_(sat%C3%A9lite)","Pas%C3%ADfae_(sat%C3%A9lite)","Sinope_(sat%C3%A9lite)","Pan_(sat%C3%A9lite)","Atlas_(sat%C3%A9lite)","Prometeo_(sat%C3%A9lite)","Pandora_(sat%C3%A9lite)","Epimeteo_(sat%C3%A9lite)","Jano_(sat%C3%A9lite)","Mimas_(sat%C3%A9lite)","Enc%C3%A9lado_(sat%C3%A9lite)","Tetis_(sat%C3%A9lite)","Telesto_(sat%C3%A9lite)","Calipso_(astronom%C3%ADa)","Dione_(sat%C3%A9lite)","Helena_(sat%C3%A9lite)","Rea_(sat%C3%A9lite)","Tit%C3%A1n_(sat%C3%A9lite)","Hiperi%C3%B3n_(sat%C3%A9lite)","J%C3%A1peto_(sat%C3%A9lite)","Febe_(sat%C3%A9lite)","Cordelia_(sat%C3%A9lite)","Ofelia_(sat%C3%A9lite)","Bianca_(sat%C3%A9lite)","Cr%C3%A9sida_(sat%C3%A9lite)","Desd%C3%A9mona_(sat%C3%A9lite)","Julieta_(sat%C3%A9lite)","Porcia_(sat%C3%A9lite)","Rosalinda_(sat%C3%A9lite)","Belinda_(sat%C3%A9lite)","Puck_(sat%C3%A9lite)","Miranda_(sat%C3%A9lite)","Ariel_(sat%C3%A9lite)","Umbriel_(sat%C3%A9lite)","Titania_(sat%C3%A9lite)","Ober%C3%B3n_(sat%C3%A9lite)","N%C3%A1yade_(sat%C3%A9lite)","Talasa_(sat%C3%A9lite)","Despina_(sat%C3%A9lite)","Galatea_(sat%C3%A9lite)","Larisa_(sat%C3%A9lite)","Proteo_(sat%C3%A9lite)","Trit%C3%B3n_(sat%C3%A9lite)","Nereida_(sat%C3%A9lite)","Caronte_(sat%C3%A9lite)","Nix_(sat%C3%A9lite)","Hidra_(sat%C3%A9lite)","Cerbero_(sat%C3%A9lite)","Estigia_(sat%C3%A9lite)","Asteroide","Cometa","C/2014_Q2_(Lovejoy)","Planeta","Asteroide","Meteoroide","Viento_solar","Cometa","Marte_(planeta)","J%C3%BApiter_(planeta)","Cintur%C3%B3n_de_asteroides","A%C3%B1o_luz","Nube_de_Oort","Teor%C3%ADa_general_de_la_relatividad","Albert_Einstein","1916","Constante_cosmol%C3%B3gica","Telescopio","Monte_Wilson","California","Estrella","Galaxia","V%C3%ADa_L%C3%A1ctea","Edwin_Hubble","Nebulosa","Galaxia","Astr%C3%B3nomo","Espectr%C3%B3grafo","Luz","Prisma_(%C3%B3ptica)","Corrimiento_al_rojo","Azul","Corrimiento_al_azul","Rojo","Stephen_Hawking","Ciencia","Fred_Hoyle","The_New_York_Times","Arno_Penzias","Robert_Woodrow_Wilson","Radiaci%C3%B3n_de_fondo","NASA","COBE","Onda","Historia","Cosmos","Macrocosmos","Mundo","Tierra","Nicol%C3%A1s_Cop%C3%A9rnico","Astronom%C3%ADa","Cosmolog%C3%ADa","Ambiplasma","Astrof%C3%ADsica","Albert_Einstein","Astronom%C3%ADa","Big_Bang","Cosmolog%C3%ADa","Cosmolog%C3%ADa_f%C3%ADsica","Cosmovisi%C3%B3n","Destino_final_del_universo","Edad_del_universo","Estructura_del_universo_a_gran_escala","Ley_de_Hubble-Lema%C3%AEtre","Forma_del_universo","Inflaci%C3%B3n_c%C3%B3smica","Expansi%C3%B3n_m%C3%A9trica_del_espacio","M%C3%A9trica_de_Friedman-Lema%C3%AEtre-Robertson-Walker","Microcosmos","Modelo_Lambda-CDM","Carl_Sagan","Multiverso","Origen_del_universo","Panspermia","Principio_cosmol%C3%B3gico","Principio_antr%C3%B3pico","Principio_hologr%C3%A1fico","Teor%C3%ADa_del_Big_Bang","Teor%C3%ADa_del_estado_estacionario","Teor%C3%ADa_de_los_universos_fecundos","Universal_(metaf%C3%ADsica)","Universo_oscilante","Universos_paralelos","Universal_(metaf%C3%ADsica)","Scientific_American","Digital_object_identifier","Jean-Pierre_Luminet","Jean-Pierre_Luminet","Nature","Scientific_American","Digital_object_identifier","Wayback_Machine","ISBN","Albert_Einstein","Wikcionario","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lengua_natural","titulo":"Lengua natural","contenido":"Una lengua natural es una variedad linguistica o forma de lenguaje humano generada espontaneamente en un grupo de hablantes con proposito de comunicarse, a diferencia de otras lenguas, como puedan ser una lengua construida, los lenguajes de programacion o los lenguajes formales usados en el estudio de la logica formal, especialmente la logica matematica. Para servir a su proposito de comunicacion, una lengua natural ha de disponer de una gramatica (sintaxis, morfologia, etc.) y de un lexico. Se suele considerar que las lenguas naturales obedecen a principios de economia y optimidad.  Hay dos tipos de lenguas naturales:  El linguista Charles F. Hockett habla de quince rasgos definitorios de la lengua:  Las lenguas naturales se contraponen a otras formas de lenguaje tanto humanas como no humanas. Asi junto con las lenguas naturales humanas tenemos:  Al contrario que en un lenguaje formal de tipo logico-matematico, donde el significado de una cadena o frase solo esta influido por su aspecto o \u00abforma\u00bb, en los lenguajes naturales la semantica o significado especifico y contextual de sus componentes intervienen en la validez o no de la frase, a\u00f1adiendo complejidad a su estudio.  La linguistica es la rama del saber que se encarga del estudio del lenguaje, entendido como el conjunto de reglas que gobierna cualquier proceso de comunicacion.  Admitiendo la existencia de reglas de comunicacion, la linguistica estructural llego a definir extensivamente una determinada lengua natural como el conjunto de frases que se pueden emitir y utilizar en esa lengua.  A finales de la decada de los a\u00f1os 1950 Noam Chomsky propuso incorporar los lenguajes naturales al tipo de lenguajes susceptibles de ser estudiados por los sistemas formales por medio de gramaticas generativas, que daran lugar a las cadenas o frases validas en un lenguaje dado.  En el siglo\u00a0XX se estudiaron con detalle los sistemas de comunicacion e interaccion social de numerosos animales. Eso llevo a descubrir que muchas de las caracteristicas presentes en las lenguas naturales humanas tambien estaban presentes en el lenguaje animal. Sin embargo un peque\u00f1o numero de caracteristicas parecen exclusivas de las lenguas humanas entre ellas:  Sorprendentemente, el lenguaje animal permite la prevaricacion o la \u00abmentira\u00bb en el sentido de que algunos animales pueden llegar a simular gritos de alarma falsos para confundir a otros individuos.  Con respecto al origen de las lenguas, existen dos posturas basicas:  En ambos casos, despues de la aparicion de una o mas lenguas actuaron procesos de diversificacion o cambio linguistico que aumentaron el numero de lenguas, hasta llegar a los varios miles de lenguas existentes en la actualidad.  La teoria de linguistica de las lenguas criollas y los pidgins sugiere que el proceso de formacion de una lengua natural genuina a partir de un input linguistico adecuado puede llevar tan poco tiempo como una generacion. El caso del idioma de se\u00f1as de Nicaragua creada a partir de un sistema semiotico inconsistente es un ejemplo paradigmatico de como puede formarse una lengua consistente con una gramatica bien fijada, a partir de elementos inconsistentes. ","snippet":"Una lengua natural es una variedad linguistica o forma de lenguaje humano generada espontaneamente en un grupo de hablantes con proposito de comunicarse, a diferencia de otras lenguas, como puedan ser","enlaces_salientes":["Lengua_natural","Lengua_natural","Lengua_natural","Variedad_ling%C3%BC%C3%ADstica","Lenguaje_humano","Lengua_construida","Lenguajes_de_programaci%C3%B3n","L%C3%B3gica_formal","L%C3%B3gica_matem%C3%A1tica","Sintaxis","Morfolog%C3%ADa","L%C3%A9xico","Teor%C3%ADa_de_la_optimidad","Comunicaci%C3%B3n_oral","Fonolog%C3%ADa","Lengua_de_se%C3%B1as","Charles_F._Hockett","Boca_humana","O%C3%ADdo","Idioma_croata","Fonema","De%C3%ADxis","Doble_articulaci%C3%B3n","Fonema","Morfema","Hjelmslev","Gram%C3%A1tica","Competencia_ling%C3%BC%C3%ADstica","Gram%C3%A1tica_generativa","Chomsky","Cambio_ling%C3%BC%C3%ADstico","Gram%C3%A1tica_hist%C3%B3rica","Metalenguaje","Comunicaci%C3%B3n_animal","Constituyente_sint%C3%A1ctico","Lenguaje_formal","Homo_sapiens","L%C3%B3gica_matem%C3%A1tica","Lenguaje_de_programaci%C3%B3n","Sintaxis","Lenguaje_formal","Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Ling%C3%BC%C3%ADstica","Estructuralismo_(ling%C3%BC%C3%ADstica)","Oraci%C3%B3n_(gram%C3%A1tica)","A%C3%B1os_1950","Noam_Chomsky","Sistema_formal","Gram%C3%A1tica_generativa","Zoosemi%C3%B3tica","Origen_de_las_lenguas","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica#Monog\u00e9nesis","Protolengua","Biblia","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica#Polig\u00e9nesis","Cambio_ling%C3%BC%C3%ADstico","Lenguas_criollas","Pidgin","Idioma_de_se%C3%B1as_de_Nicaragua","Gram%C3%A1tica","Lenguas","Procesamiento_de_lenguajes_naturales","Generaci%C3%B3n_de_lenguajes_naturales","Idioma","Morris_Swadesh","Control_de_autoridades","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Variedad_ling%C3%BC%C3%ADstica","titulo":"Variedad linguistica","contenido":"Una variedad o modalidad linguistica es una forma especifica de lengua natural, caracterizada por un conjunto de rasgos linguisticos usados por una determinada comunidad de hablantes vinculados entre si por relaciones sociales, geograficas o culturales.  Las variedades linguisticas son distintas formas que adquiere una misma lengua de acuerdo al lugar en que vive el hablante (esta variedad se denomina dialecto), a su edad (esta variedad se llama cronolecto) y a su grupo social donde tambien influye el nivel de educacion (sociolecto). Las diferencias pueden estar relacionadas con el vocabulario, la entonacion, la pronunciacion o la confeccion de expresiones; y en general se manifiestan mas claramente en la oralidad que en la escritura. De esta forma, cuando se escucha hablar a alguien, es posible suponer en que region reside (si en la zona Metropolitana o la zona rural, por ejemplo), de que grupo etario forma parte (es un ni\u00f1o, un adolescente, un adulto, un anciano, etcetera) y que nivel educativo tiene.  El termino variedad es una forma neutral de referirse a las diferencias linguisticas entre los hablantes de un mismo idioma. Con el uso del termino variedad se pretende evitar la ambiguedad y falta de consenso en el uso de terminos como lengua o dialecto, ya que no existen criterios univocos para decidir cuando dos variedades deben ser consideradas como la misma lengua o dialecto, o como lenguas o dialectos diferentes.  Las variedades pueden ser distinguidas, ademas de por su vocabulario, por diferencias en su gramatica, fonologia y prosodia. Existen diversos factores de variacion posible asociados a la geografia, la evolucion linguistica, los factores sociolinguisticos o el registro linguistico.  Los vulgarismos e idiotismos son a veces considerados como formas de estilo, al estar limitados a variaciones de lexico, mientras que los argots pueden ser incluidos tanto en el concepto de variedad como de estilo.  Algunos estudiosos sostienen que aspectos fisicos y biologicos de los individuos, como la pertenencia a un genero o identidad sexual, pueden constituirse en factores de variacion dentro de una lengua; sin embargo, no existen datos definitivos sobre estos aspectos.\u200b  En sociolinguistica se utilizan ademas, y entre otros, los siguientes terminos, para diferenciar formas del habla que no son compartidas por el conjunto de los hablantes de un idioma o dialecto: ","snippet":"Una variedad o modalidad linguistica es una forma especifica de lengua natural, caracterizada por un conjunto de rasgos linguisticos usados por una determinada comunidad de hablantes vinculados entre ","enlaces_salientes":["Variedad_ling%C3%BC%C3%ADstica","Variedad_ling%C3%BC%C3%ADstica","Variedad_ling%C3%BC%C3%ADstica","Lengua_natural","Idioma","Dialecto","Gram%C3%A1tica","Fonolog%C3%ADa","Prosodia_(ling%C3%BC%C3%ADstica)","Registro_ling%C3%BC%C3%ADstico","Variedades_diat%C3%B3picas","Dialecto","Geolecto","Dialectolog%C3%ADa","Continuo_dialectal","Inteligibilidad_mutua","Espa%C3%B1ol_de_Espa%C3%B1a","Espa%C3%B1ol_de_Am%C3%A9rica","Variedades_diacr%C3%B3nicas","Cambio_ling%C3%BC%C3%ADstico","Espa%C3%B1ol_medio","Castellano_medieval","Variedades_sociales","Sociolecto","Variedades_situacionales","Vulgarismo","Idiotismo_(lenguaje)","L%C3%A9xico","Argot","Estudioso","Sexo","Socioling%C3%BC%C3%ADstica","Idioma","Argot","Edad_biol%C3%B3gica","Adolescencia","Argot","Lenguaje_infantil","Ecolecto","Etnia","Geolecto","Pixueto","Asturiano","Cudillero","Monegasco","Idioma_ligur","Principado_de_M%C3%B3naco","Idiolecto","Lengua_lit%C3%BArgica","Dog%C3%B3n","Mal%C3%AD","Burkina_Faso","%C3%81frica","Lat%C3%ADn","Catolicismo","Sociolecto","Clase_social","Estrato_social","Intercomprensi%C3%B3n","Oxford_University_Press","ISBN","ISBN","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lenguaje_humano","titulo":"Lenguaje","contenido":"Un lenguaje  (del provenzal lenguatge\u200b y del latin lingua) es un sistema de comunicacion estructurado para el que existe un contexto de uso y ciertos principios combinatorios formales. Existen contextos tanto naturales como artificiales.  Desde un punto de vista mas amplio, la comunicacion  indica una caracteristica comun a los humanos y a otros animales (animales no simbolicos) para expresar experiencias mediante el uso de se\u00f1ales y sonidos registrados por los organos de los sentidos. Los seres humanos desarrollan un lenguaje simbolico complejo que se expresa con secuencias sonoras y signos graficos. Por su parte, los animales se comunican a traves de signos sonoros, olfativos y corporales que en muchos casos distan de ser sencillos.  Aunque casi hasta finales del siglo\u00a0XX se establecia taxativamente una diferencia absoluta entre el lenguaje humano y la comunicacion animal, la acumulacion de gran cantidad de estudios[cita\u00a0requerida] (especialmente etologicos) sugieren que muchos animales no humanos, especialmente con areas cerebrales corticales desarrolladas (bonobos, chimpances y otros primates, asi como cetaceos \u2014especialmente delfinidos\u2014, aves \u2014especialmente loros, cuervos, palomas\u2014, elefantes, perros, gatos, equinos, etcetera) poseen formas de comunicacion bastante mas complejas, y mas cercanas al lenguaje humano que lo supuesto por Ivan Pavlov y los reflejos condicionados o los conductistas anglosajones, que reducian las actividades psiquicas a un mero circuito reflejo mecanicista de estimulo-respuesta. En rigor, Pavlov no era tan mecanicista, pero suponia al lenguaje de los animales no humanos como correspondiente a un condicionamiento clasico o primer sistema de se\u00f1ales (basado principalmente en el estimulo-respuesta, tras la reiteracion de un estimulo que se asocia una \u00abrecompensa\u00bb, que implica al circuito de premio-recompensa, o a la ausencia de la misma que genera un habito o habitus, condicionamiento que es tambien comun a la inmensa mayoria de los humanos), mientras que para el ser humano Pavlov supone un segundo sistema de se\u00f1ales, que es un salto cualitativo respecto al primero y que es el lenguaje humano, que es heuristico al estar abierto respecto al ciclo de estimulo-respuesta.\u200b  La facultad del lenguaje no es el resultado de un aprendizaje, sino que es congenita, es decir, nace con el ser humano.\u200b Ademas, se presenta de igual manera en todos los seres humanos, independientemente del momento historico y del lugar geografico, es decir, es universal.\u200b Las lenguas pueden aprenderse y olvidarse, pero la capacidad del lenguaje, no.\u200b  El lenguaje es un conjunto de signos y simbolos. Un signo es un fenomeno relacionable con otro fenomeno. Por ejemplo, la fiebre es un signo de una enfermedad, la caida de nieve es un signo de la estacion de invierno, un camion de bomberos con su sirena es un signo de incendio.\u200b  Un simbolo es un fenomeno, algo que ocurre que la mente relaciona con otro fenomeno. Por ejemplo, un pulgar abajo simboliza algo negativo, la luz roja de un semaforo con un mensaje de detenerse. El elemento que distingue un simbolo de un signo es el caracter deliberativo de su relacion. Los signos que se establecen deliberadamente se llaman simbolos.\u200b  Varios autores han redactado listas de caracteristicas definitorias de que es una lengua natural, algunas de las cuales estan presentes en la comunicacion animal y los lenguajes formales. Sin embargo, solo las lenguas naturales tienen estos quince rasgos de Hockett y, por tanto, esta lista caracteriza lo que es una lengua natural.  Entre los rasgos mas definitorios estan la arbitrariedad (de la relacion entre el signo y el significado, Ferdinand de Saussure), la productividad (que permite producir nuevos mensajes nunca antes realizados) y la estructura jerarquica (segun la cual, las lenguas humanas poseen reglas o principios sintacticos y gramaticales, por lo que las producciones no son aleatorias).  Las lenguas que concretan la facultad humana del lenguaje comparten una serie de caracteristicas:\u200b  La conducta linguistica en los humanos no es de tipo instintivo, sino que debe ser adquirida por contacto o transmision con otros seres humanos, especialmente durante los primeros a\u00f1os de vida, de otro modo se producen casos de ni\u00f1os y ni\u00f1as ferales.[a]\u200b La estructura de las lenguas naturales, que son el resultado concreto de la capacidad humana de desarrollar lenguaje, permite comunicar ideas y emociones por medio de un sistema de sonidos articulados, mediante el cual se hace posible la relacion y el entendimiento entre individuos. El lenguaje humano posibilita la expresion del pensamiento y la exteriorizacion de los deseos y afectividad mediante signos inicialmente sonoros/acusticos y, muy posteriormente en la genesis del lenguaje, signos basados en el par significante/significado. A inicios del siglo\u00a0XX, Ferdinand de Saussure consideraba biyectivos o perfectamente correspondientes al par significante / significado, y luego Jacques Lacan ha considerado que bajo el significante \u00abhay nada\u00bb ya que el significado de cada signo humano discurre (\u00abbajo\u00bb la censura de lo inconsciente) tras el deseo en una cadena metonimica en la cual los significantes constantemente cambian de significado; Lacan ha considerado que la relacion biyectiva o exactamente correspondiente de significante / significado solo se da en el lenguaje de los animales no humanos.\u200b\u200b  La reflexion que Ludwig Wittgenstein emprende sobre el lenguaje lo conduce a reconocer, primero, que todo lenguaje conlleva una forma de vida; existe por tanto una estrecha relacion entre el lenguaje y las condiciones de la existencia humana. En segundo lugar Wittgenstein acerca el lenguaje a la accion al se\u00f1alar que el significado de toda palabra le esta conferido por su uso, por la particular manera de como es utilizada por quienes hacen uso de ella. Ello le confiere un argumento adicional a la defensa del lenguaje ordinario. Pero lo mas importante es el tercer rasgo: Wittgenstein utiliza el camino del lenguaje para penetrar los problemas de la etica, del sentido de vida de los seres humanos.\u200b  El lenguaje humano ha sido calificado como un lenguaje principalmente verbal en contraposicion a la comunicacion no verbal. El lenguaje verbal se denomina asi porque esta constituido por palabras (en latin: verba) es decir, formado a partir de unidades discretas (por ejemplo los fonemas) ordenadas desde el intelecto como se observa en un dialogo o en una conversacion; segun el esquema de R. Jakobson se requiere un emisor (o locutor)  al menos un mensaje, un contexto, un canal o medio (aire por donde se propaga la voz, papel donde se escribe, ondas electromagneticas, etc.), un codigo y obviamente un receptor o alocutor. A este esquema de Jakobson, que parece tener sus origenes en los esquemas triangulares de Peirce, se le suele a\u00f1adir el ruido que puede modificar el esquema.[aclaracion requerida] Paralelo al lenguaje verbal, y existente ya en animales no humanos, se debe siempre tener en cuenta al lenguaje paraverbal caracterizado por la mimica, los gestos, las muecas e incluso las expresiones corporales, especialmente faciales, de origen instintivo: por ejemplo la casi vegetativa e instintiva expresion facial de asco puede mimicamente transformarse en expresion ya intencionada de disgusto o colera.  La capacidad humana para el lenguaje, tal como se refleja en las lenguas naturales, es estudiada por la linguistica.\u200b Hay una progresion historica de las lenguas naturales desde el habla, luego la escritura y, finalmente, la comprension y explicacion de la gramatica.\u200b Desde el punto de vista social e historico, el lenguaje humano ha dado lugar a idiomas que viven, mueren, se mudan de un lugar a otro, y cambian con el paso del tiempo. Cualquier idioma que deja de cambiar o de desarrollarse es categorizado como lengua muerta. Por el contrario, cualquier idioma por el hecho de no ser una lengua muerta, y formar parte de las lenguas vivas o modernas, esta sufriendo continuamente reajustes que acumulativamente son los responsables del llamado cambio linguistico. El lenguaje humano se suele subdividir a partir de F. de Saussure en habla y lengua, en todo caso en ambas dimensiones del lenguaje siempre han de considerarse la sincronia (que puede definirse como el uso contemporaneo [del locutor al alocutor] del lenguaje humano) y de la diacronia (que puede definirse como la casi continua modificacion del lenguaje humano evolucionando a lo largo del tiempo).  Hacer una distincion en principio entre un idioma y otro es por lo general imposible.\u200b Por ejemplo, hay algunos dialectos del aleman que son similares a ciertos dialectos del neerlandes. La transicion entre las lenguas dentro de la misma familia linguistica a veces es progresiva (ver dialecto continuo).  Hay quienes hacen un paralelismo con la biologia, donde no es posible hacer una distincion bien definida entre una especie y la siguiente. En cualquier caso, el desafio real puede ser el resultado de la interaccion entre las lenguas y las poblaciones (ver dialecto o August Schleicher). Los conceptos de Ausbausprache, Abstandsprache y Dachsprache se utilizan para hacer distinciones mas refinadas sobre los grados de diferencia entre las lenguas o dialectos. Al parecer en el lenguaje humano es fundamental la posibilidad de la metafora (substituir una imagen -especialmente una imagen acustica- por otra merced a una semejanza aunque no haya relacion de contiguidad) tal cual lo demuestra Roman Jakobson al estudiar las afasias usando los criterios de sintagma y metonimia establecidos por Ferdinand de Saussure: unas afasias serian metonimicas o sintagmaticas y otras serian metaforicas o paradigmaticas; Jakobson observa la coalescencia entre esto y la tesis propuesta por Sigmund Freud de deslizamiento y condensacion en la actividad onirica, respectivamente y Lacan  en sus estudios parece comprobarlo al considerar que lo inconsciente esta estructurado como un lenguaje, donde una metafora paterna es fundamental para establecer al sujeto desalienado  de la mascara o persona que es el imaginario ego, a partir de esto segun estas opiniones es que el Homo sapiens esta capacitado para tener un principio de realidad y un lenguaje articulado coherente y altamente heuristico en una \u00abcadena metonimica\u00bb. En cambio, segun Lacan, los animales no humanos existentes se encuentran restringidos a lo imaginario aunque lo imaginario -y por ende el lenguaje- de los animales no humanos, segun Lacan, se corresponden con lo real en lugar del apego a la en parte ficcional o eidetica realidad en que se desempe\u00f1a el animal humano; esto es: los animales inteligentes no humanos parece que tienen lenguajes aparentemente no articulados que se corresponden con lo factico del ambiente en que viven mientras que los humanos al oscilar entre los registros de lo Imaginario y lo Real a traves del registro de lo Simbolico (o lenguaje simbolico humano) puede caer en fantasias sin embargo las fantasias le permiten ingenio y una alta capacidad de adaptacion evolutiva mediante la inventiva que tiene por principal medio precisamente al lenguaje simbolico.\u200b  Por otra parte Chomsky ha teorizado que la estructura del lenguaje humano se basa en sintagmas verbales y sintagmas nominales; luego segun el mismo Noam Chomsky (2015) el lenguaje humano es principalmente genetico; los ni\u00f1os (cualquiera sea su sexo) poseen la capacidad innata  del lenguaje verbal sin previa informacion externa (que no este) ya en el genoma humano, por ejemplo a los 2 a\u00f1os de nacido, un infante puede aprender una nueva palabra durante cada hora de vigilia, tal capacidad habria surgido hace 70\u00a0000 a\u00f1os;\u200b en todo caso para lograr plena competencia linguistica (mas alla de las opiniones de Chomsky) el ser humano debe estar bien nutrido por lo menos en el primer a\u00f1o de su vida (alimentado principalmente con proteinas) y estimulado de un modo dialogico por otros humanos en sus primeros 4 a\u00f1os de vida. Tener en cuenta que el pensar consciente humano esta principalmente constituido por conceptos y que los conceptos son parte del lenguaje.  Hay una inmensidad de definiciones sobre que es el lenguaje humano, dependiendo de cada autor en cada epoca y en cada circunstancia. La siguiente es una seleccion de varias de las definiciones que se le ha dado al lenguaje:\u200b  El lenguaje humano se debe a adaptaciones evolutivas que se dan exclusivamente en seres humanos de la especie Homo sapiens.  En los ultimos a\u00f1os, diversas investigaciones han apuntado a que el lenguaje humano, respecto a su parte melodica y la estructuracion de fonemas, tiene un origen evolutivo comun con el lenguaje de los pajaros; incluso, se ha llegado a constatar que los mismos genes que posibilitan el habla humana posibilitan tambien el canto de las aves. Un total de 55 genes muestran un patron similar en la actividad del cerebro de los seres humanos y de aquellas aves capaces de aprender nuevas vocalizaciones y de reordenar los sonidos mas basicos de su canto para transmitir distintos significados. Sin embargo, la parte pragmatica (que es la portadora del contenido del discurso) de nuestro lenguaje habria derivado de nuestros ancestros primates no humanos; y ambas capacidades (melodica y pragmatica) se habrian fundido en algun momento de los ultimos 100 000 a\u00f1os de evolucion, o, segun algunos ultimos experimentos desde al menos los antepasados comunes entre los actuales babuinos y seres humanos. Esto es quizas hasta 7 u 8 millones de a\u00f1os antes del presente. La gran diferencia estriba en que la rama que dio lugar a los actuales Homo sapiens tendria \u2014por seleccion natural\u2014 aun mas desarrolladas las areas del cerebro (ubicadas principalmente en el hemisferio izquierdo) que los actuales babuinos, es decir: un hallazgo sugiere que el ultimo antepasado comun de los seres humanos y los babuinos pudo haber poseido la maquinaria vocal para el habla para dar lugar a la forma del lenguaje humano,\u200b y con ello al origen de las diferentes lenguas (idiomas) que han sido creados por los seres humanos.\u200b El curso del desarrollo del lenguaje tiene por lo menos dos consecuencias determinadas:  El lenguaje humano es asombrosamente flexible. Podemos combinar un numero limitado de sonidos y se\u00f1ales para producir un numero infinito de frases, cada una con un significado distinto. Por ello podemos absorber, almacenar y comunicar una cantidad de informacion prodigiosa acerca del mundo que nos rodea. No obstante, la caracteristica realmente unica de nuestro lenguaje es la capacidad de transmitir informacion acerca de cosas que no existen. Solo los sapiens pueden hablar acerca de tipos enteros de entidades que nunca han visto, ni tocado, ni olido. Las leyendas, los mitos, los dioses y las religiones son producto de \u00abla revolucion cognitiva\u00bb y el lenguaje humano.\u200b  La neurolinguistica es el area disciplinar dependiente de la neuroanatomia que se preocupa por la computacion cerebral del lenguaje humano. Las principales areas del cerebro que se encargan de procesar el lenguaje son areas corticales del hemisferio izquierdo del cerebro:  Sin embargo, aunque normalmente el lenguaje se procesa en el Hemisferio izquierdo, esto se debe solo por la estructura fisica que compone el lenguaje, y no porque \u00abel lenguaje en si\u00bb le sea propio. Ello ya que se ha demostrado que para el silbido turco (un tipo de Lenguaje silbado; basado en la forma silbada del Idioma turco), requiere el uso de los dos hemisferios cerebrales por igual, debido a que la melodia, la frecuencia y el tono, los rasgos del silbido, se procesan en el hemisferio derecho.\u200b  Alteraciones de lenguaje:  Aunque existen otros codigos de comunicacion, el lenguaje verbal es el unico sistema comunicativo capaz de expresar debidamente aquello que se quiere transmitir y el unico que permite elaborar infinitos mensajes.\u200b Esta circunstancia es posible por la doble articulacion del lenguaje.\u200b  Depende del sentido del olfato y en algunas ocasiones del gusto. Estas se\u00f1ales pueden recorrer grandes distancias cuando son transportadas por las corrientes del aire, aunque solo son percibidas a favor del viento. Las sustancias quimicas especificas que producen efectos concretos se llaman feromonas. En las colonias de abejas, por ejemplo, la reina produce una feromona \u00abreal\u00bb que impide el desarrollo de los ovarios de las obreras. Las feromonas tienen una gran importancia en lo relativo a la atraccion sexual.  Las ondas sonoras pueden variar de altura e intensidad con rapidez. Sirven para transmitir mucha informacion. Estas se\u00f1ales viajan en todas direcciones y el receptor las localiza con facilidad.  Por ejemplo, los monos aulladores y algunas aves, ranas y sapos poseen grandes sacos vocales que aumentan considerablemente los sonidos que emiten. En el caso de los sapos, emiten un sonido para atraer a la hembra y otro para \u00abavisar\u00bb a otros que el tambien es macho. Las cigarras que cantan son machos, y lo hacen para atraer a las hembras. Los pollitos emiten sonidos de distinta intensidad en donde avisan a la gallina en distintas situaciones (si estan asustados o si tienen hambre o frio). Los cocodrilos, cuando estan por nacer, emiten sonidos con lo que avisan a su madre y ella destapa el nido subterraneo para que los peque\u00f1os puedan subir a la superficie.  Muchos animales diferentes usan estas se\u00f1ales, que se pueden encender y apagar en un instante, aunque por lo general son utiles en determinadas horas del dia. Suelen ser llamativas o consistir en movimientos bruscos. Por ejemplo, una de las garras del cangrejo violinista macho es mayor que la otra, tiene colores fuertes y la sacude para atraer a las hembras. Los colores y dise\u00f1os de las alas de las mariposas y de los machos de muchas aves atraen a sus compa\u00f1eras en distancias cortas. Cuando vuelan por la noche, los lampiridos machos producen destellos luminosos con se\u00f1ales caracteristicas, mientras que las hembras responden con sus destellos desde el suelo.  La comunicacion tactil se refiere a las se\u00f1ales transmitidas a traves del contacto de la piel o partes exteriores de los seres vivos. Estas se\u00f1ales sirven al alcance de la mano y tienen una gran importancia entre los primates, como una forma de indicacion de amistad y para tranquilizar. El hecho de que un individuo cuide al otro, por ejemplo eliminandole los parasitos indeseables, es su manera de reforzar los lazos familiares y de amistad. Los mecanismos principales son:  Todos los lenguajes buscan transmitir algo a partir de un simbolo determinado y de manera deliberada partiendo del hombre;\u200b en todos los tipos de lenguaje se necesitan los elementos basicos de la comunicacion (emisor, mensaje y receptor) para que pueda llevarse a cabo su objetivo y se construye gracias a los signos.Se clasifican en:\u200b  Actualmente existen tambien otros tipos de lenguaje como el grafico que comunica el mensaje por medio de imagenes (fotografias, dibujos e iconos); el audiovisual que combina las imagenes con los sonidos; y el multimedia que utiliza todos los medios que necesite.  El lenguaje puede ser estudiado segun cuatro dimensiones o aspectos diferentes que definen caracteristicas propias de su naturaleza:  Las personas se comunican por distintos motivos: en algunas ocasiones, solo pretenden transmitir informacion de manera objetiva; en otras, manifiestan sentimientos u opiniones, o pretenden influir en los demas.\u200b  Las diversas finalidades comunicativas pueden sistematizarse, teniendo en cuenta los elementos de la comunicacion, en las funciones del lenguaje.\u200b En un mismo enunciado pueden coexistir varias funciones, pero siempre hay una predominante.\u200b En \u00a1Sientate de una vez!, aunque prevalece la funcion apelativa, tambien esta presente la funcion expresiva, ya que el emisor manifiesta su fastidio.\u200b Este predominio se evidencia en la presencia de determinados rasgos linguisticos, como el modo imperativo y el vocativo.\u200b  El lenguaje se usa para trasmitir una realidad, ya sea afirmativa, negativa o de posibilidad, un deseo, una pregunta, una orden y mas. Dependiendo de como utilicemos las oraciones, podemos distinguir diferentes funciones en el lenguaje:  Siempre se debe considerar al lenguaje como un subconjunto de la informacion, por ejemplo en tal caso Leon Brillouin publico en 1959 Science et theorie de l'information (version en ingles editada por vez primera en 1962) donde son examinadas las relaciones entre estas dos disciplinas. Adopta particularmente un punto de vista de fisico y hace el lazo entre la entropia informacional de Shannon y la entropia estadistica de Boltzmann en donde se arriesga que la informacion (y con la misma el lenguaje) es un factor neguentropico es decir por el cual se puede anular la entropia. ","snippet":"Un lenguaje  (del provenzal lenguatge\u200b y del latin lingua) es un sistema de comunicacion estructurado para el que existe un contexto de uso y ciertos principios combinatorios formales. Existen context","enlaces_salientes":["Lenguaje","Lenguaje","Lenguaje","Lenguaje_inform%C3%A1tico","Desarrollo_del_lenguaje","Psicoling%C3%BC%C3%ADstica","Teotihuac%C3%A1n","M%C3%A9xico","Circa","Habla","Cuneiforme","Lenguaje_escrito","Lengua_de_signos_estadounidense","Braille_(lectura)","Sistema_de_escritura","Idioma_occitano","Lat%C3%ADn","Comunicaci%C3%B3n","Significado","S%C3%ADmbolo","Se%C3%B1al","%C3%93rgano_sensorial","Signo","Lengua_natural","Signo_ling%C3%BC%C3%ADstico","Grafema","Lenguas_de_se%C3%B1as","Ontogenia","Filogenia","Zoosemi%C3%B3tica","Lenguaje_formal","Matem%C3%A1tica","Etholog%C3%ADa","Bonobos","Chimpanc%C3%A9s","Primates","Cet%C3%A1ceos","Delphinidae","Psittacoidea","Corvidae","Columbidae","Iv%C3%A1n_P%C3%A1vlov","Reflejo_condicionado","Conductismo","Mecanicismo","Condicionamiento_cl%C3%A1sico","Est%C3%ADmulo-respuesta","Recompensa","Condicionamiento","Lenguaje_humano","Heur%C3%ADstico","Aprendizaje","Cong%C3%A9nita","Ser_humano","Universal_(metaf%C3%ADsica)","S%C3%ADmbolos","Lengua_natural","Comunicaci%C3%B3n_animal","Lenguaje_formal","Lengua_natural#Caracter\u00edsticas_de_las_lenguas_naturales","Ferdinand_de_Saussure","Onomatopeya","Palabra","Desplazamiento_(vector)","Situaci%C3%B3n_comunicativa","Mentira","Literatura","Ficci%C3%B3n","Reflexividad","Sonido","Receptor_(comunicaci%C3%B3n)","Doble_articulaci%C3%B3n","Monema","Fonema","Productividad","Comunicaci%C3%B3n_animal","Ni%C3%B1o_feral","Entendimiento","Pensamiento","Deseo","Afectividad","Significante","Significado","Jacques_Lacan","Ludwig_Wittgenstein","Comunicaci%C3%B3n_no_verbal","Palabras","Lat%C3%ADn","Fonema","Di%C3%A1logo","Conversaci%C3%B3n","Mensaje","Contexto","Charles_Sanders_Peirce","M%C3%ADmica","Gestos","Expresi%C3%B3n_facial","Asco","Ling%C3%BC%C3%ADstica","Gram%C3%A1tica","Lengua_muerta","Lengua_moderna","Cambio_ling%C3%BC%C3%ADstico","Habla","Idioma","Sincron%C3%ADa","Diacron%C3%ADa","Dialecto","Idioma_alem%C3%A1n","Idioma_neerland%C3%A9s","Familia_ling%C3%BC%C3%ADstica","Biolog%C3%ADa","Poblaci%C3%B3n","Dialecto","August_Schleicher","Ausbausprache_-_Abstandsprache_-_Dachsprache","Met%C3%A1fora","Roman_Jakobson","Afasia","Sintagma","Metonimia","Ferdinand_de_Saussure","Metonimia","Sigmund_Freud","Jacques_Lacan","Nombre_del_Padre","Sujeto_(filosof%C3%ADa)","Alienaci%C3%B3n","Ego","Principio_de_realidad","Heur%C3%ADstica","Lo_imaginario","Lo_real","Eid%C3%A9tica","Realidad","Noam_Chomsky","Sintagma_verbal","Sintagma_nominal","Innatismo","Genoma_humano","Competencia_ling%C3%BC%C3%ADstica","Prote%C3%ADna","Di%C3%A1logo","Concepto","Aleksandr_L%C3%BAriya","John_Broadus_Watson","Noam_Chomsky","Jean_Piaget","Evoluci%C3%B3n_del_lenguaje","Evoluci%C3%B3n_biol%C3%B3gica","Homo_sapiens","P%C3%A1jaro","Gen","Evoluci%C3%B3n_humana","Pragm%C3%A1tica","Papio","Antes_del_presente","Homo_sapiens","Selecci%C3%B3n_natural","Origen_de_las_lenguas","Homo_sapiens","Corteza_cerebral","Hemisferio_cerebral#_Hemisferio_izquierdo","Homo_sapiens","%C3%81rea_de_Broca","%C3%81rea_de_Wernicke","Circunvoluci%C3%B3n_supramarginal","Circunvoluci%C3%B3n_angular","Corteza_auditiva_primaria","Neuroling%C3%BC%C3%ADstica","Corteza_cerebral","Hemisferio_cerebral#Hemisferio_izquierdo","%C3%81rea_de_Broca","%C3%81rea_de_Wernicke","%C3%81reas_de_Brodmann","Lenguaje_silbado","Silbido","Idioma_turco","Habla","Afasia","Alexia_(lenguaje)","Agrafia","Hemisferio_izquierdo","Afon%C3%ADa","Disfon%C3%ADa","Disartria","Pares_craneales","Alcoholismo","Barbit%C3%BArico","Disfemia","Tartamudeo","Neur%C3%B3tico","Disfon%C3%ADa","Depresi%C3%B3n_(psicolog%C3%ADa)","Dislalia","Rotacismo_(ling%C3%BC%C3%ADstica)","Escritura_(ling%C3%BC%C3%ADstica)","Agrafia","Alexia_(lenguaje)","Disgraf%C3%ADa","Esquizofrenia","Parafasia","Per%C3%ADfrasis_(sintaxis)","Logorrea","Mutismo","Palilalia","Taquilalia","Man%C3%ADa","Alcoholismo","Verbigeraci%C3%B3n","Esquizofrenia","Doble_articulaci%C3%B3n_del_lenguaje","Zoosemi%C3%B3tica","Sentido_(percepci%C3%B3n)","Olfato","Feromona","Abeja","Ovario","Ondas_sonoras","Informaci%C3%B3n","Mono","Aves","Rana","Sapo","Cigarra","Cocodrilo","Cangrejo_violinista","Mariposa","Lamp%C3%ADridos","Primates","Ara%C3%B1a","Pisces","Am%C3%A9rica_del_Sur","%C3%81frica","M%C3%ADmica","Nietzsche","Arte","Escritura","Lev_Vygotski","Comunicaci%C3%B3n","Fonolog%C3%ADa","Morfolog%C3%ADa_(ling%C3%BC%C3%ADstica)","Sintaxis","Sem%C3%A1ntica","Pragm%C3%A1tica","Intencionalidad","Funciones_del_lenguaje","Objetiva","Funciones_del_lenguaje","Enunciado","Funci%C3%B3n_apelativa","Funci%C3%B3n_expresiva","Rasgo_gramatical","Modo_imperativo","Opini%C3%B3n","Vocativo","Modo_imperativo","Interrogativo","Exclamativo","Funciones_del_lenguaje#Funci\u00f3n_f\u00e1tica","Muletilla","Latiguillo","Funciones_del_lenguaje#Funci\u00f3n_metaling\u00fc\u00edstica","Funciones_del_lenguaje#Funci\u00f3n_po\u00e9tica","Chiste","Rima","Tropo","Fantas%C3%ADa_(psicolog%C3%ADa)","Imaginaci%C3%B3n","Informaci%C3%B3n","L%C3%A9on_Brillouin","Entrop%C3%ADa_de_Shannon","Neguentrop%C3%ADa","Entrop%C3%ADa","Habla","Lengua_natural","Lenguaje_visual","Lenguaje_figurado","Comunicaci%C3%B3n_no_verbal","Lenguaje_pol%C3%ADtico","Socioling%C3%BC%C3%ADstica","Denotaci%C3%B3n","Educaci%C3%B3n","Esquizofrenia","Hospitalismo","Depresi%C3%B3n_anacl%C3%ADtica","Ren%C3%A9_Spitz","Quiasma","DRAE","Ludwig_Wittgenstein","Tractatus_logico-philosophicus","Realidad","PUF","Oxford_University_Press","ISBN","ISBN","OCLC","Edward_Sapir","Jacques_Lacan","Encyclop%C3%A6dia_Britannica","Jacques_Lacan","Scientific_American","ISBN","Aleksandr_L%C3%BAriya","Elsevier","%C3%89mile_Benveniste","Roman_Jakobson","1941","John_Lyons","Ferdinand_de_Saussure","Curso_de_ling%C3%BC%C3%ADstica_general","Centro_Editor_de_Am%C3%A9rica_Latina","Wikcionario","Familias_de_lenguas","Control_de_autoridades","Wikcionario","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings","Wikcionario"]}
{"url":"Lengua_construida","titulo":"Lengua construida","contenido":"Una lengua construida (tambien llamada idioma artificial o conlang) es un idioma que ha sido total o parcialmente construido, planeado o dise\u00f1ado por seres humanos a partir del estudio de las lenguas naturales \u2015los lenguajes de programacion son lenguajes formales y no son considerados lenguas construidas porque no son idiomas;\u200b tampoco se considera lengua construida la evolucion historica y, por lo tanto, no planeada conscientemente de cualquier lengua natural\u2015.  Las motivaciones que impulsan el surgimiento de estas lenguas no naturales son basicamente dos:  La mayor parte de las lenguas construidas pueden dividirse en tres grupos:  Una clasificacion mas detallada incluye varios factores, tales como su intencion de uso, su proposito de creacion y el origen del vocabulario y la gramatica.[cita\u00a0requerida]  Las lenguas construidas pueden dividirse en dos grandes grupos segun su intencion de uso: lenguas auxiliares y lenguas artisticas. Las primeras buscan ser un medio de comunicacion real entre seres humanos, mientras que las segundas son habladas por personajes ficticios surgidos de la imaginacion u obra del autor de la lengua, sin pretender que sean habladas por personas reales.\u200b  Estos propositos pueden subdividirse:  Inventar una lengua puede tener propositos utilitarios o creativos. Entre los propositos utilitarios se encuentran el proposito de la comunicacion universal, la exploracion de formas de comunicacion, lenguajes secretos, la ambientacion de un escenario de ficcion, etc. Entre los propositos creativos, aquellos inmersos dentro de una creacion mayor (por ejemplo, las lenguas de la Tierra Media como el quenya, de J.\u00a0R.\u00a0R.\u00a0Tolkien) o aquellos que existen per se.  Otro buen numero de lenguas ficcionales las crearon linguistas aficionados, lo cual ha servido tanto de entretenimiento como una manera de comprender ciertos aspectos de la teoria linguistica.  Si bien las lenguas auxiliares suelen tener un proposito utilitario y los idiomas ficticios acostumbran tener un proposito creativo, esta relacion dista de ser univoca, pues una lengua auxiliar puede provenir de la intencion creativa del autor.  Una diferencia entre el idioma klingon, creado por Marc Okrand para el universo de Star Trek, y el sindarin, creado por J.\u00a0R.\u00a0R.\u00a0Tolkien para el universo de la Tierra Media, es que el primero tiene un proposito utilitario, ya que los productores querian una lengua original y diferente para los klingons, mientras que Tolkien invento sus lenguas, caracteristicas de la Tierra Media, para ambientar sus lenguajes, tal como lo describe en su carta El vicio secreto. Esto no demerita la posible calidad artistica de la obra de Okrand ni minimiza la creatividad que desarrollo en su obra.  En el Festival de la Cancion de Eurovision se ha llegado a usar tres veces un idioma artificial. Dos veces, los uso Belgica (en 2003 y 2008) aunque de distinto \u00abidioma\u00bb, nunca teniendo un vocabulario desarrollado y solo utilizado en la cancion, poniendo en duda algun significado concreto o traduccion a algun idioma. Lo mismo sucedio con los Paises Bajos en 2006.  Las lenguas auxiliares parten de un problema, el cual puede resolverse mediante un idioma dise\u00f1ado para ese proposito, mientras que los idiomas ficticios surgen de la inquietud de su creador.  Las lenguas artificiales suelen dividirse en dos tipos, segun el origen de su vocabulario o su gramatica: lenguas a priori y lenguas ''a posteriori''. Una lengua a priori es aquella cuya gramatica y/o vocabulario se crean o se inventan sin referencia a lengua natural alguna. Una lengua a posteriori es aquella cuya gramatica y vocabulario se derivan de una o varias lenguas existentes..\u200b Esta categorizacion, sin embargo, no es absoluta, ya que muchas lenguas construidas pueden denominarse a priori cuando se tienen en cuenta algunos factores linguisticos, y al mismo tiempo a posteriori cuando se consideran otros factores.  El lojban es una lengua con gramatica y vocabulario a priori, pues si bien sus morfemas basicos proceden de elementos comunes o combinados de los cinco idiomas mas hablados (chino, ingles, espa\u00f1ol, hindi y arabe), estos son reconstruidos segun las normas foneticas y gramaticales que se prescriben. Esto, junto con el hecho de que su gramatica busca parecerse a la logica simbolica, es completamente aprioristico.  La lengua universal de Sotos Ochando tambien es un idioma a priori, y lo mismo diversos intentos de lenguas filosoficas, como los de John Wilkins (Essay towards a Real Character, and a Philosophical Language, de 1668) y de George Dalgarno (Ars\u00a0Signorum, de 1661).  Algunas lenguas auxiliares internacionales se han construido \"a priori\". Es el caso de solresol, creado en 1862 por el frances Francois Sudre, y de kotava, creado en 1978 por Staren Fetcey.\u200b  Las lenguas a posteriori se pueden clasificar en esquematicas y naturalistas. Esquematicas son las que toman los elementos basicos de la lengua desde las lenguas naturales y son regularizados segun un esquema predeterminado. Son naturalistas cuando tratan de no ser muy diferentes a las lenguas naturales, sobre todo en su vocabulario, sino algo similar para facilitar su entendimiento rapido, aun sacrificando en parte la regularidad.  El proceso de seleccion de vocabulario puede ser mas o menos sistematico. La interlingua de IALA utiliza un proceso sistematico de seleccion basado en cuatro lenguas basicas y dos lenguas de control. Es adoptada toda palabra comun a por lo menos tres de los idiomas basicos: espa\u00f1ol, frances, ingles e italiano y si solo es comun a dos de estos idiomas, toma el aleman y el ruso como control para decidir que palabra adoptar.  El esperanto es tambien una lengua a posteriori a pesar de no tener un sistema mecanico para seleccionar el vocabulario y de que contiene varios elementos inventados o a priori.  El perciscan es un idioma creado en 2013 que tiene el objetivo de servir como medio de comunicacion entre los paises de lenguas romances sin necesidad de usar el ingles.  Entre las lenguas ficcionales y ficticias, existen tambien dos tipos de lenguas a posteriori.  Del primer grupo es ejemplo Tolkien, quien definio una familia de lenguas partiendo de una lengua madre (a priori) y derivando lenguas hijas utilizando procesos de derivacion similares a los naturales. Estas lenguas derivadas son por ello a posteriori. Este proceso de derivacion se ha aplicado a lenguas existentes para crear \u00abidiomas del futuro\u00bb o lenguas ficcionales, como el brithenig, que seria la lengua que hablarian en el oeste de Inglaterra si el latin hubiese sobrevivido hasta nuestros dias.  Ejemplo del otro tipo de lenguas ficcionales a posteriori es el recurso utilizado en La Guerra de las Galaxias, que consiste en usar elementos de gramatica y vocabulario de lenguas indigenas poco conocidas, para despues combinarlos en formas poco reconocibles.  Un tipo especial de lenguas a posteriori son las lenguas controladas, que son adaptaciones de idiomas naturales buscando una gramatica simple y un vocabulario reducido para permitir que mas personas, que no sean hablantes nativos del idioma base, puedan con poco estudio leer o escuchar textos en la lengua controlada, como por ejemplo el ingles basico. Otro ejemplo es el anglo rom una lengua recientemente inventada cuyo vocabulario se construye partiendo de las raices del latin y que se rige por solo 19\u00a0reglas.  Las lenguas naturales suelen clasificarse segun criterios filogeneticos y tipologicos.  El primero de estos, el filogenetico, no se aplica generalmente a las lenguas artificiales, por tratarse de creaciones humanas deliberadas y no derivar estas lenguas de ningun ancestro o protolengua comun, pero en ocasiones las lenguas artificiales se crean muy deliberadamente como evoluciones de un ancestro construido, y en ese caso si que podria aplicarse el criterio filogenetico o metodo comparativo.  El segundo, el criterio tipologico, por el contrario, siempre es perfectamente aplicable a todas las lenguas artificiales. En ese sentido las lenguas construidas son practicamente tan variadas como las lenguas naturales, aunque en muchas de ellas han predominado los rasgos tipologicos de las lenguas europeas e indoeuropeas, como sucede en el volapuk (1879), el esperanto (1887), el latino sine flexione (1903), etc. Otras lenguas construidas de exito como el klingon uno de cuyos creadores, Marc Okrand, trabajo sobre el idioma mutsun lengua indigena de California de la familia\u00a0uti, parece tener caracteristicas reminiscentes de esa lengua indigena.  La cuestion de si una lengua construida puede o no ser propiedad o estar protegida por las leyes de propiedad intelectual, o si incluso seria posible hacer cumplir esas leyes, es controvertida.  En una demanda de 2015, CBS y Paramount Pictures impugnaron un proyecto de pelicula de fans llamado Axanar, afirmando que el proyecto infringia su propiedad intelectual, que incluia la lengua klingon, entre otros elementos creativos. Durante la controversia, Marc Okrand, el dise\u00f1ador original de la lengua, expreso sus dudas sobre si las reclamaciones de propiedad de Paramount eran validas.\u200b\u200b  David J. Peterson, linguista creador de varias lenguas construidas muy conocidas, como el valyrio y el dothraki, defendio una opinion similar: \"Teoricamente, cualquiera puede publicar cualquier cosa utilizando cualquier lengua que yo haya creado y, en mi opinion, ni yo ni nadie deberia poder hacer nada al respecto\"\u200b  Sin embargo, Peterson tambien expreso su preocupacion por la posibilidad de que los respectivos titulares de los derechos -independientemente de si su titularidad es legitima o no- demanden a las personas que publiquen material en dichas lenguas, especialmente si el autor puede beneficiarse de dicho material.  Ademas, en la plataforma de aprendizaje de idiomas Duolingo se ha publicado material didactico completo sobre lenguas construidas como el alto valyrio y el klingon, de libre acceso, pero esos cursos estan autorizados por los respectivos titulares de los derechos de autor.\u200b Dado que hasta ahora solo se han producido unos pocos litigios de este tipo, el consenso juridico sobre la propiedad de las lenguas sigue siendo incierto.  El Centro Aborigen de Tasmania reclama la propiedad de Palawa kani, un intento de reconstruccion compuesta de hasta una docena de lenguas indigenas extintas de Tasmania, y ha pedido a Wikipedia que elimine su pagina sobre el proyecto. Sin embargo, esta reclamacion carece de respaldo legal.\u200b ","snippet":"Una lengua construida (tambien llamada idioma artificial o conlang) es un idioma que ha sido total o parcialmente construido, planeado o dise\u00f1ado por seres humanos a partir del estudio de las lenguas ","enlaces_salientes":["Lengua_construida","Lengua_construida","Lengua_construida","Conlang","Torre_de_Babel","Idioma","Homo_sapiens","Lengua_natural","Lenguaje_de_programaci%C3%B3n","Lenguaje_formal","Idioma","Comunicaci%C3%B3n_humana","Lojban","L%C3%B3gica_de_predicados","Lengua_auxiliar","Esperanto","Interlingua","Lojban","Simlish","J._R._R._Tolkien","Quenya","Sindarin","Idioma_na%27vi","Na%27vi","Avatar_(pel%C3%ADcula)","Lengua_art%C3%ADstica","Lengua_auxiliar","Lengua_filos%C3%B3fica","Lengua_l%C3%B3gica","Lengua_auxiliar","Lengua_art%C3%ADstica","Lengua_auxiliar","Idioma_intereslavo","Folkspraak","Esperanto","Interlingua","Volap%C3%BCk","Lengua_l%C3%B3gica","Lojban","Loglan","Lengua_filos%C3%B3fica","Toki_pona","L%C3%A1adan","Lingua_ignota","Enoquiano","Lengua_art%C3%ADstica","Sindarin","Idioma_klingon","Idioma_na%27vi","Tierra_Media","J._R._R._Tolkien","Ling%C3%BC%C3%ADstica","Idioma_klingon","Marc_Okrand","Saga_Star_Trek","Sindarin","J._R._R._Tolkien","Tierra_Media","Klingon","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Pa%C3%ADses_Bajos","Lenguas_a_priori","Lengua_natural","John_Wilkins","Lojban","Idioma_chino","Idioma_ingl%C3%A9s","Idioma_espa%C3%B1ol","Idioma_hindi","Idioma_%C3%A1rabe","Lengua_universal_de_Sotos_Ochando","John_Wilkins","George_Dalgarno","Solresol","Fran%C3%A7ois_Sudre","Interlingua_de_IALA","Idioma_espa%C3%B1ol","Idioma_franc%C3%A9s","Idioma_ingl%C3%A9s","Idioma_italiano","Idioma_alem%C3%A1n","Idioma_ruso","Esperanto","Lenguas_romances","Familia_de_lenguas","Brithenig","Idioma_lat%C3%ADn","Star_Wars","Lengua_controlada","Ingl%C3%A9s_b%C3%A1sico","Lengua_natural","Filogenia","Tipolog%C3%ADa_ling%C3%BC%C3%ADstica","Protolengua","M%C3%A9todo_comparativo_(ling%C3%BC%C3%ADstica)","Tipolog%C3%ADa_ling%C3%BC%C3%ADstica","Volap%C3%BCk","Esperanto","Interlingua_de_Peano","Idioma_klingon","Marc_Okrand","Lenguas_ind%C3%ADgenas_de_Am%C3%A9rica","Lenguas_uti","CBS","Paramount_Pictures","Lengua_auxiliar","Reforma_ling%C3%BC%C3%ADstica","Fran%C3%A7ois_Rabelais","Elfos_(Tolkien)","Klingon","Na%27vi","ISBN","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus"]}
{"url":"L%C3%B3gica_formal","titulo":"Logica matematica","contenido":"El lenguaje, tambien llamada logica simbolica, logica teoretica, logica formal o logistica,\u200b es el estudio formal y simbolico de la logica y su aplicacion a algunas areas de la matematica y la ciencia. Comprende la aplicacion de las tecnicas de la logica formal a la construccion y el desarrollo de las matematicas y el razonamiento matematico, y conversamente la aplicacion de tecnicas matematicas a la representacion y el analisis de la logica formal. La investigacion en logica matematica ha jugado un papel crucial en el estudio de los fundamentos de las matematicas.  La logica matematica estudia la inferencia mediante la construccion de sistemas formales como la logica proposicional, la logica de primer orden o la logica modal. Estos sistemas capturan las caracteristicas esenciales de las inferencias validas en los lenguajes naturales, pero al ser estructuras formales susceptibles de analisis matematico, permiten realizar demostraciones rigurosas sobre ellas.  La logica matematica se suele dividir en cuatro areas: teoria de modelos, teoria de la demostracion, teoria de conjuntos y teoria de la computabilidad. La teoria de la demostracion y la teoria de modelos fueron el fundamento de la logica matematica. La teoria de conjuntos se origino en el estudio del infinito por Georg Cantor y ha sido la fuente de muchos de los temas mas desafiantes e importantes de la logica matematica, desde el teorema de Cantor, el axioma de eleccion y la cuestion de la independencia de la hipotesis del continuo, al debate moderno sobre grandes axiomas cardinales. La logica matematica tiene estrechas conexiones con las ciencias de la computacion. La teoria de la computabilidad captura la idea de la computacion en terminos logicos y aritmeticos. Sus logros mas clasicos son la indecidibilidad del Entscheidungsproblem de Alan Turing y su presentacion de la tesis de Church-Turing. Hoy en dia, la teoria de la computabilidad se ocupa principalmente del problema mas refinado de las clases de complejidad (\u00bfcuando es un problema eficientemente solucionable?) y de la clasificacion de los grados de insolubilidad.  La logica matematica tambien estudia las definiciones de nociones y objetos matematicos basicos como conjuntos, numeros, demostraciones y algoritmos. La logica matematica estudia las reglas de deduccion formales, las capacidades expresivas de los diferentes lenguajes formales y las propiedades metalogicas de los mismos.  En un nivel elemental, la logica proporciona reglas y tecnicas para determinar si es o no valido un argumento dado dentro de un determinado sistema formal. En un nivel avanzado, la logica matematica se ocupa de la posibilidad de axiomatizar las teorias matematicas, de clasificar su capacidad expresiva, y desarrollar metodos computacionales utiles en sistemas formales. La teoria de la demostracion y la matematica inversa son dos de los razonamientos mas recientes de la logica matematica abstracta. Debe se\u00f1alarse que la logica matematica se ocupa de sistemas formales que pueden no ser equivalentes en todos sus aspectos, por lo que la logica matematica no es un metodo para descubrir verdades del mundo fisico real, sino solo una fuente posible de modelos logicos aplicables a teorias cientificas, muy especialmente a la matematica convencional.   Por otra parte, la logica matematica no estudia el concepto de razonamiento humano general o el proceso creativo de construccion de demostraciones matematicas mediante argumentos rigurosos pero con lenguaje informal con algunos signos o diagramas, sino solo de demostraciones y razonamientos que se pueden formalizar por completo.  La Mathematics Subject Classification divide la logica matematica en las siguientes areas:  En algunos casos hay conjuncion de intereses con la informatica teorica, pues muchos pioneros de la informatica, como Alan Turing, fueron matematicos y logicos. Asi, el estudio de la semantica de los lenguajes de programacion procede de la teoria de modelos, asi como tambien la verificacion de programas y el caso particular de la tecnica del model checking. Tambien el isomorfismo de Churry-Howard entre pruebas y programas se corresponde con la teoria de pruebas, donde la logica intuicionista y la logica lineal son especialmente significativas.  Algunos sistemas formales como el calculo lambda y la logica combinatoria entre otras han devenido en autenticos lenguajes de programacion, creando nuevos paradigmas como son la programacion funcional y la programacion logica.  Un sistema formal o sistema logico es un sistema abstracto compuesto por un lenguaje formal, axiomas, reglas de inferencia y a veces una semantica formal, que se utiliza para deducir o demostrar teoremas y dar una definicion rigurosa del concepto de demostracion. Un sistema formal es una formalizacion rigurosa y completa del concepto de sistema axiomatico, los cuales se pueden expresar en lenguaje formal o en lenguaje natural formalizado. Al crear un sistema formal se pretende capturar y abstraer la esencia de determinadas caracteristicas del mundo real, en un modelo conceptual expresado en un determinado lenguaje formal. Algunos de los sistemas formales mas conocidos son la logica proposicional, la logica de primer orden y la logica modal.  En la teoria de la demostracion, las demostraciones formales se pueden expresar en el lenguaje de los sistemas formales, consistentes en axiomas y reglas de inferencia. Los teoremas pueden ser obtenidos por medio de demostraciones formales. Este punto de vista de las matematicas ha sido denominado formalista; aunque en muchas ocasiones este termino conlleva una acepcion peyorativa. En ese sentido, David Hilbert creo la metamatematica para estudiar los sistemas formales, entendiendo que el lenguaje utilizado para ello, denominado metalenguaje era distinto del lenguaje del sistema formal que se pretendia estudiar, al que se llama lenguaje objeto.  Un sistema asi es la reduccion de un lenguaje formalizado a meros simbolos, lenguaje formalizado y simbolizado sin contenido material alguno; un lenguaje reducido a mera forma que se expresa mediante formulas que reflejan las relaciones sintacticas entre los simbolos y las reglas de formacion y transformacion que permiten construir las formulas del sistema y pasar de una formula a otra.\u200b  Una teoria axiomatica es un conjunto de formulas en un determinado lenguaje formal y todas las formulas deducibles de dichas expresiones mediante las reglas de inferencia posibles en dicho sistema formal. El objetivo de las teorias axiomaticas es construir sistemas formales que representen las caracteristicas esenciales de ramas enteras de las matematicas. Si se selecciona un conjunto mas amplio o menos amplio de axiomas el conjunto de teoremas deducibles cambian. El interes de la teoria de modelos es que en un modelo en que satisfagan los axiomas de determinada teoria tambien se satisfacen los teoremas deducibles de dicha teoria. Es decir, si un teorema es deducible en una cierta teoria, entonces ese teorema es universalmente valido en todos los modelos que satisfacen los axiomas. Esto es interesante porque en principio la clase de modelos que satisface una cierta teoria es dificil de conocer, ya que las teorias matematicas interesantes en general admiten toda clase infinita de modelos no isomorfos, por lo que su clasificacion en general resulta dificilmente abordable si no existe un sistema formal y un conjunto de axiomas que caracterice los diferentes tipos de modelos.  En el siglo\u00a0XX, Hilbert y otros sostuvieron que la matematica es un sistema formal. Pero en 1931, Kurt Godel demostro que ningun sistema formal con suficiente poder expresivo para capturar la aritmetica de Peano puede ser a la vez consistente y completo. El teorema de la incompletitud de Godel, junto con la demostracion de Alonzo Church de que la matematica tampoco es decidible, termino con el programa de Hilbert. Sin embargo,  a pesar de sus limitaciones, el enfoque sigue siendo ampliamente usado, basicamente porque no se ha encontrado ninguna alternativa mejor al enfoque formalista de Hilbert y la pretension de trabajar en el seno de teorias matematicas explicitamente axiomatizadas, aun con sus limitaciones.  En matematica, teoria de modelos es el estudio de (clases de) estructuras matematicas tales como grupos, cuerpos, grafos, o incluso universos de teoria de conjuntos, en relacion con las teorias axiomaticas y la logica matematica. La teoria de modelos permite atribuir una interpretacion semantica a las expresiones puramente formales de los lenguajes formales. Ademas permite estudiar en si mismos los conjuntos de axiomas, su completitud, consistencia, independencia mutua, y permiten introducir un importante numero de cuestiones metalogicas.  La teoria de la computabilidad o teoria de la recursion es la parte de la computacion que estudia los problemas de decision que se pueden resolver con un algoritmo o equivalentemente con una maquina de Turing. Las preguntas fundamentales de la teoria de la computabilidad son:  La teoria de conjuntos es una rama de la logica matematica que estudia las propiedades y relaciones de los conjuntos: colecciones abstractas de objetos, consideradas como objetos en si mismas. Los conjuntos y sus operaciones mas elementales son una herramienta basica que permite formular de cualquier otra teoria matematica.\u200b  La teoria de los conjuntos es lo suficientemente flexible y general como para construir el resto de objetos y estructuras de interes en matematicas: numeros, funciones, figuras geometricas, etc; gracias a las herramientas de la logica, permite estudiar los fundamentos.  Ademas, la propia teoria de conjuntos es objeto de estudio per se, no solo como herramienta auxiliar, en particular las propiedades y relaciones de los  conjuntos infinitos. En esta disciplina es habitual que se presenten casos de propiedades indemostrables o contradictorias, como la hipotesis del continuo o la existencia de algun cardinal inaccesible. Por esta razon, sus razonamientos y tecnicas se apoyan en gran medida en la logica matematica.\u200b  El desarrollo historico de la teoria de conjuntos se atribuye a Georg Cantor, que comenzo a investigar cuestiones conjuntistas (puras) del infinito en la segunda mitad del siglo\u00a0XIX, precedido por algunas ideas de Bernhard Bolzano e influido por Richard Dedekind. El descubrimiento de las paradojas de la teoria cantoriana de conjuntos, formalizada por Gottlob Frege, propicio los trabajos de Bertrand Russell, Ernst Zermelo y Abraham Fraenkel.\u200b  El uso mas temprano de matematicas y de geometria en relacion con la logica y la filosofia se remonta a los griegos antiguos tales como Euclides, Platon, y Aristoteles. Muchos otros filosofos antiguos y medievales aplicaron ideas y metodos matematicos a sus afirmaciones filosoficas.  En el siglo\u00a0XVIII se hicieron algunos intentos de tratar las operaciones logicas formales de una manera simbolica por parte de algunos filosofos matematicos como Lambert, pero su labor permanecio desconocida y aislada. Tambien por parte de Leibniz  que desarrollo la idea de un calculus ratiocinator, un sistema de reglas para simplificar oraciones compuestas.  A partir de la segunda mitad del siglo\u00a0XIX, la logica seria revolucionada profundamente. En 1847, George Boole publico un breve tratado titulado El analisis matematico de la logica, y en 1854 otro mas importante titulado Las leyes del pensamiento. La idea de Boole fue construir a la logica como un calculo en el que los valores de verdad se representan mediante el F (falsedad) y la V (verdad), y a los que se les aplican operaciones matematicas como la suma y la multiplicacion.  En el ultimo tercio del siglo\u00a0XIX la logica va a encontrar su transformacion mas profunda de la mano de las investigaciones matematicas y logicas, junto con el desarrollo de la investigacion de las estructuras profundas del lenguaje, la linguistica, convirtiendose definitivamente en una ciencia formal. Es una ciencia formal, ya que estudia las ideas y constituye una herramienta conceptual para todas las otras ciencias y areas del conocimiento. y forma parte de un conjunto sistematico de conocimientos racionales y coherentes, que se ocupan del estudio de los procesos logicos y matematicos,  Al mismo tiempo, Augustus De Morgan publica en 1847 su obra Logica formal, donde introduce las leyes de De Morgan e intenta generalizar la nocion de silogismo. Otro importante contribuyente ingles fue John Venn, quien en 1881 publico su libro Logica Simbolica, donde introdujo los famosos diagramas de Venn.  Charles Sanders Peirce y Ernst Schroder tambien hicieron importantes contribuciones.  Sin embargo, la verdadera revolucion de la logica vino de la mano de Gottlob Frege, quien frecuentemente es considerado como el logico mas importante de la historia, junto con Aristoteles. En su trabajo de 1879, la Conceptografia, Frege ofrece por primera vez un sistema completo de logica de predicados y calculo proposicional. Tambien desarrolla la idea de un lenguaje formal y define la nocion de prueba. Estas ideas constituyeron una base teorica fundamental para el desarrollo de las computadoras y las ciencias de la computacion, entre otras cosas. Pese a esto, los contemporaneos de Frege pasaron por alto sus contribuciones, probablemente a causa de la complicada notacion que desarrollo el autor. En 1893 y 1903, Frege publica en dos volumenes Las leyes de la aritmetica, donde intenta deducir toda la matematica a partir de la logica, en lo que se conoce como el proyecto logicista. Su sistema y su aplicacion a la teoria de conjuntos, sin embargo, contenia una contradiccion (la paradoja de Russell).  Logica matematica fue el nombre dado por Giuseppe Peano para esta disciplina. En esencia, es la logica de Aristoteles, pero desde el punto de vista de una nueva notacion, mas abstracta, tomada del algebra.  ] ]  En el siglo\u00a0XX hubo uno de los enormes desarrollos en logica. A partir del siglo\u00a0XX, la logica paso a estudiarse por su interes intrinseco, y no solo por sus virtudes como propedeutica, por lo que se estudio a niveles mucho mas abstractos.  En 1910, Bertrand Russell y Alfred North Whitehead publican Principia mathematica, un trabajo monumental en el que logran gran parte de la matematica a partir de la logica, evitando caer en las paradojas en las que cayo Frege. Se suponia que las teorias matematicas eran tautologias logicas, y el programa debia mostrar esto por medio de una reduccion de la matematica a la logica. Los autores reconocen el merito de Frege en el prefacio. En contraste con el trabajo de Frege, Principia mathematica tuvo un exito rotundo, y llego a considerarse uno de los trabajos de no ficcion mas importantes e influyentes de todo el siglo\u00a0XX. Principia mathematica utiliza una notacion inspirada en la de Giuseppe Peano, parte de la cual todavia es muy utilizada hoy en dia.  En 1912 C. I. Lewis publica Conditionals and the Algebra of Logic, justo despues de los Principia Mathematica de Russell y Whitehead. En 1918 publica A Survey of Symbolic Logic en donde propone un nuevo condicional mas adecuado para recoger el significado de la expresion \u00absi... entonces\u00bb del lenguaje natural. Lewis lo llama implicacion estricta. El nuevo condicional requiere, para ser verdadero, una relacion mas fuerte entre el antecedente y el consecuente que el condicional clasico.  En 1920 David Hilbert propuso de forma explicita un proyecto de investigacion (en metamatematica, como se llamo entonces) que acabo siendo conocido como programa de Hilbert. Queria que la matematica fuese formulada sobre unas bases solidas y completamente logicas. El proyecto fue refutado por los teoremas de incompletitud de Godel. Tanto la declaracion del programa de Hilbert como su refutacion por Godel dependian de su trabajo estableciendo el segundo ambito de la logica matematica, la aplicacion de las matematicas a la logica en la forma de la teoria de la demostracion. A pesar de la naturaleza negativa de los teoremas de la incompletitud, el teorema de la complejidad de Godel, un resultado en la teoria de modelos y otra aplicacion de las matematicas a la logica, puede ser entendido como una demostracion del logismo cercano: toda teoria matematica rigurosamente definida puede ser capturada exactamente por una teoria de primer orden. El calculo de la prueba de Frege es suficiente para describir toda la matematica, aunque no sea equivalente a ella.  El origen de los modelos abstractos de computacion se encuadra en los a\u00f1os 1930 (antes de que existieran los ordenadores modernos), en el trabajo de los logicos Alonzo Church, Kurt Godel, Stephen Kleene, Emil Leon Post, Haskell Curry y Alan Turing. Estos trabajos iniciales han tenido una profunda influencia, tanto en el desarrollo teorico como en abundantes aspectos de la practica de la computacion; previendo incluso la existencia de ordenadores de proposito general, la posibilidad de interpretar programas, la dualidad entre software y hardware, y la representacion de lenguajes por estructuras formales basados en reglas de produccion.  La deduccion natural fue introducida por Gerhard Gentzen en su trabajo Investigaciones sobre la inferencia logica (Untersuchungen uber das logische Schliessen), publicado en 1934-1935.  En los a\u00f1os 1940 Alfred Tarski comenzo a desarrollar junto a sus discipulos el algebra relacional, en la que pueden expresarse tanto la teoria axiomatica de conjuntos como la aritmetica de Peano. Tambien desarrollo junto a sus discipulos las algebras cilindricas, que son a la logica de primer orden lo que el algebra booleana a la logica proposicional. En 1941 publico en ingles uno de los manuales de logica mas acreditados, Introduction to Logic and to the Methodology of Deductive Sciences.  Noam Chomsky en 1956 propone una clasificacion jerarquica de distintos tipos de gramaticas formales que generan lenguajes formales llamada jerarquia de Chomsky.  Si bien a la luz de los sistemas contemporaneos la logica aristotelica puede parecer equivocada e incompleta, Jan \u0141ukasiewicz mostro que, a pesar de sus grandes dificultades, la logica aristotelica era consistente, si bien habia que interpretarse como logica de clases, lo cual no es peque\u00f1a modificacion. Por ello la silogistica practicamente no tiene uso actualmente.  Ademas de la logica proposicional y la logica de predicados, el siglo\u00a0XX vio el desarrollo de muchos otros sistemas formales; entre los que destacan las muchas logicas modales. ","snippet":"El lenguaje, tambien llamada logica simbolica, logica teoretica, logica formal o logistica,\u200b es el estudio formal y simbolico de la logica y su aplicacion a algunas areas de la matematica y la ciencia","enlaces_salientes":["L%C3%B3gica_matem%C3%A1tica","L%C3%B3gica_matem%C3%A1tica","L%C3%B3gica_matem%C3%A1tica","L%C3%B3gica","Ciencia","Fundamentos_de_las_matem%C3%A1ticas","Inferencia","Sistema_formal","L%C3%B3gica_proposicional","L%C3%B3gica_de_primer_orden","L%C3%B3gica_modal","Lenguaje_natural","Demostraci%C3%B3n_matem%C3%A1tica","Teor%C3%ADa_de_modelos","Teor%C3%ADa_de_la_demostraci%C3%B3n","Teor%C3%ADa_de_conjuntos","Teor%C3%ADa_de_la_computabilidad","Georg_Cantor","Teorema_de_Cantor","Axioma_de_elecci%C3%B3n","Hip%C3%B3tesis_del_continuo","Axiomas","Ciencias_de_la_computaci%C3%B3n","Entscheidungsproblem","Alan_Turing","Tesis_de_Church-Turing","Definici%C3%B3n_(matem%C3%A1tica)","Conjunto","N%C3%BAmero","Demostraci%C3%B3n_matem%C3%A1tica","Algoritmo","Metal%C3%B3gica","Teor%C3%ADa_de_la_demostraci%C3%B3n","Razonamiento","Mathematics_Subject_Classification","Filosof%C3%ADa_de_la_matem%C3%A1tica","L%C3%B3gica_modal","L%C3%B3gica_borrosa","Teor%C3%ADa_de_modelos","Teor%C3%ADa_de_la_computabilidad","Teor%C3%ADa_de_conjuntos","Teor%C3%ADa_de_la_demostraci%C3%B3n","Inform%C3%A1tica_te%C3%B3rica","Alan_Turing","Sem%C3%A1ntica","Lenguajes_de_programaci%C3%B3n","Model_checking","Isomorfismo","L%C3%B3gica_intuicionista","L%C3%B3gica_lineal","C%C3%A1lculo_lambda","L%C3%B3gica_combinatoria","Programaci%C3%B3n_funcional","Programaci%C3%B3n_l%C3%B3gica","Sistema_formal","Sistema_formal","Sistema","Objeto_abstracto","Lenguaje_formal","Axioma","Reglas_de_inferencia","Sem%C3%A1ntica_formal","Teorema","Definici%C3%B3n","Demostraci%C3%B3n_en_matem%C3%A1tica","Sistema_axiom%C3%A1tico","Lenguaje_formalizado","Lenguaje_formal","L%C3%B3gica_proposicional","L%C3%B3gica_de_primer_orden","L%C3%B3gica_modal","Teor%C3%ADa_de_la_demostraci%C3%B3n","Demostraci%C3%B3n_matem%C3%A1tica","Axioma","Regla_de_inferencia","Formalismo_matem%C3%A1tico","David_Hilbert","Metamatem%C3%A1tica","Metalenguaje","Lenguaje_objeto","Lenguaje_formalizado","S%C3%ADmbolos","F%C3%B3rmula_(expresi%C3%B3n)","Teor%C3%ADa_(l%C3%B3gica)","Lenguaje_formal","Teor%C3%ADa_de_modelos","Matem%C3%A1tica","Kurt_G%C3%B6del","Aritm%C3%A9tica_de_Peano","Teorema_de_la_incompletitud_de_G%C3%B6del","Alonzo_Church","Programa_de_Hilbert","Inform%C3%A1tica","Teor%C3%ADa_de_la_informaci%C3%B3n","Estad%C3%ADstica","Metal%C3%B3gica","Metal%C3%B3gica","L%C3%B3gica","Sistemas_formales","Consistencia_(l%C3%B3gica)","Decidibilidad","Completitud_sem%C3%A1ntica","Teoremas_de_incompletitud_de_G%C3%B6del","Teorema_de_completitud_de_G%C3%B6del","Teorema_de_L%C3%B6wenheim-Skolem","Teorema_de_compacidad","Teor%C3%ADa_de_modelos","Matem%C3%A1tica","Teor%C3%ADa_de_modelos","Estructura_algebraica","Grupo_(matem%C3%A1tica)","Cuerpo_(matem%C3%A1tica)","Grafo","Teor%C3%ADa_de_conjuntos","Metal%C3%B3gica","Jes%C3%BAs_Padilla_G%C3%A1lvez","ISBN","OCLC","Teor%C3%ADa_de_la_computabilidad","Teor%C3%ADa_de_la_computabilidad","Teor%C3%ADa_de_la_computaci%C3%B3n","Problema_de_decisi%C3%B3n","Algoritmo","M%C3%A1quina_de_Turing","Complejidad_computacional","Teor%C3%ADa_de_conjuntos","Diagrama_de_Venn","Intersecci%C3%B3n_de_conjuntos","Conjunto","Teor%C3%ADa_de_conjuntos","Conjunto","N%C3%BAmero","Funci%C3%B3n_matem%C3%A1tica","Figura_geom%C3%A9trica","Conjunto_infinito","Independencia_l%C3%B3gica","Consistencia_l%C3%B3gica","Hip%C3%B3tesis_del_continuo","Cardinal_inaccesible","Georg_Cantor","Infinito","Bernhard_Bolzano","Richard_Dedekind","Gottlob_Frege","Bertrand_Russell","Ernst_Zermelo","Abraham_Fraenkel","Axiomas_de_Zermelo-Fraenkel","Axioma_de_elecci%C3%B3n","Infinito","Inform%C3%A1tica","Filosof%C3%ADa","Sem%C3%A1ntica_formal","Paradojas","L%C3%B3gica","Filosof%C3%ADa_de_la_matem%C3%A1tica","N%C3%BAmeros_reales","Consistencia_(l%C3%B3gica)","Cardinal_grande","Teor%C3%ADa_de_la_demostraci%C3%B3n","Teor%C3%ADa_de_la_demostraci%C3%B3n","Demostraci%C3%B3n_matem%C3%A1tica","Objeto_matem%C3%A1tico","Estructura_de_datos","Axioma","Regla_de_inferencia","Sintaxis","Teor%C3%ADa_de_modelos","Sem%C3%A1ntica","Teor%C3%ADa_de_modelos","Teor%C3%ADa_de_conjuntos","Teor%C3%ADa_de_la_computabilidad","Fundamentos_de_las_matem%C3%A1ticas","Johann_Heinrich_Lambert","Gottfried_Leibnitz","Calculus_ratiocinator","George_Boole","C%C3%A1lculo","Valor_de_verdad","Operaci%C3%B3n_matem%C3%A1tica","Suma","Multiplicaci%C3%B3n","Augustus_De_Morgan","Leyes_de_De_Morgan","John_Venn","Diagrama_de_Venn","Charles_Sanders_Peirce","Ernst_Schr%C3%B6der","Gottlob_Frege","L%C3%B3gica_de_predicados","C%C3%A1lculo_proposicional_de_Frege","Lenguaje_formal","Demostraci%C3%B3n_matem%C3%A1tica","Computadoras","Ciencias_de_la_computaci%C3%B3n","Matem%C3%A1tica","Logicismo","Teor%C3%ADa_de_conjuntos","Paradoja_de_Russell","Giuseppe_Peano","Arist%C3%B3teles","Notaci%C3%B3n_matem%C3%A1tica","%C3%81lgebra","Proped%C3%A9utica","Bertrand_Russell","Alfred_North_Whitehead","Principia_mathematica","Giuseppe_Peano","Clarence_Irving_Lewis","Implicaci%C3%B3n_estricta","David_Hilbert","Metamatem%C3%A1tica","Programa_de_Hilbert","Matem%C3%A1tica","Teoremas_de_incompletitud_de_G%C3%B6del","Teor%C3%ADa_de_la_demostraci%C3%B3n","Teor%C3%ADa_de_la_computabilidad","Alonzo_Church","Kurt_G%C3%B6del","Stephen_Kleene","Emil_Leon_Post","Haskell_Curry","Alan_Turing","Software","Hardware","Deducci%C3%B3n_natural","Gerhard_Gentzen","Alfred_Tarski","%C3%81lgebra_relacional","Teor%C3%ADa_axiom%C3%A1tica_de_conjuntos","Axiomas_de_Peano","L%C3%B3gica_de_primer_orden","%C3%81lgebra_booleana","L%C3%B3gica_proposicional","Noam_Chomsky","Gram%C3%A1tica_formal","Lenguaje_formal","Jerarqu%C3%ADa_de_Chomsky","L%C3%B3gica_aristot%C3%A9lica","Jan_%C5%81ukasiewicz","L%C3%B3gica_de_clases","L%C3%B3gica_modal","Noci%C3%B3n_primitiva","Funci%C3%B3n_indicatriz","Retroalimentacion","Cibern%C3%A9tica","Teor%C3%ADa_de_sistemas","Emergencia_(filosof%C3%ADa)","Pensamiento_sist%C3%A9mico","Din%C3%A1mica_de_sistemas","Mereolog%C3%ADa","Sistema_complejo","Sistema_din%C3%A1mico","Argumento","L%C3%B3gica_informal","Representaci%C3%B3n_del_conocimiento","L%C3%B3gica","L%C3%B3gica_proposicional","F%C3%B3rmula_bien_formada","Oxford_University_Press","Jes%C3%BAs_Padilla_G%C3%A1lvez","ISBN","ISBN","ISBN","ISBN","Academic_Press","ISBN","Cambridge_University_Press","ISBN","Nueva_York","Springer_Science%2BBusiness_Media","ISBN","Singapore","ISBN","George_Boolos","Cambridge_University_Press","ISBN","Oxford_University_Press","ISBN","Zentralblatt_MATH","ISBN","ISBN","Boston","Chapman_%26_Hall","ISBN","New_York_City","Springer_Science%2BBusiness_Media","ISBN","Digital_object_identifier","Munich","Oxford_University_Press","ISBN","Springer_Science%2BBusiness_Media","ISBN","Digital_object_identifier","ISBN","Boston","ISBN","Amsterdam","Elsevier","ISBN","Cambridge_University_Press","ISBN","Springer_Science%2BBusiness_Media","ISBN","Stephen_Cole_Kleene","Stephen_Cole_Kleene","ISBN","ISBN","ISBN","Stefan_Banach","Alfred_Tarski","Digital_object_identifier","Dordrecht","Springer_Science%2BBusiness_Media","ISBN","Digital_object_identifier","Semantic_Scholar","Digital_object_identifier","Lewis_Carroll","ISBN","Richard_Dedekind","Richard_Dedekind","Oxford_University_Press","Abraham_Fraenkel","Gottlob_Frege","Gottlob_Frege","J._L._Austin","Gerhard_Gentzen","Semantic_Scholar","Digital_object_identifier","Kurt_G%C3%B6del","Kurt_G%C3%B6del","Semantic_Scholar","Digital_object_identifier","Kurt_G%C3%B6del","Semantic_Scholar","Digital_object_identifier","Kurt_G%C3%B6del","Digital_object_identifier","Solomon_Feferman","Jean_van_Heijenoort","Cambridge,_Massachusetts","Harvard_University_Press","ISBN","David_Hilbert","Madrid","ISBN","David_Hilbert","Leipzig","David_Hilbert","Semantic_Scholar","Digital_object_identifier","David_Hilbert","Paul_Bernays","Springer_Science%2BBusiness_Media","ISBN","Jahrbuch_%C3%BCber_die_Fortschritte_der_Mathematik","Mathematical_Reviews","Stephen_Kleene","JSTOR","Digital_object_identifier","Nikolai_Lobachevsky","ISBN","Leopold_L%C3%B6wenheim","ISSN","Semantic_Scholar","Digital_object_identifier","Jean_van_Heijenoort","Moritz_Pasch","Giuseppe_Peano","Richard_Swineshead","Alfred_Tarski","Santa_Monica,_California","RAND_Corporation","Alan_Turing","Proceedings_of_the_London_Mathematical_Society","Digital_object_identifier","Handle_System","Ernst_Zermelo","Semantic_Scholar","Digital_object_identifier","Ernst_Zermelo","Mathematische_Annalen","ISSN","Semantic_Scholar","Digital_object_identifier","Ernst_Zermelo","Semantic_Scholar","Digital_object_identifier","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Morfolog%C3%ADa","titulo":"Morfologia","contenido":"Morfologia puede referirse a:  Ademas, puede hacer referencia a: pen-,fa-,cab- ","snippet":"Morfologia puede referirse a:  Ademas, puede hacer referencia a: pen-,fa-,cab- ","enlaces_salientes":["Morfolog%C3%ADa","Morfolog%C3%ADa","Morfolog%C3%ADa","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Morfolog%C3%ADa_(biolog%C3%ADa)","Morfolog%C3%ADa_(dise%C3%B1o)","Geomorfolog%C3%ADa","Morfolog%C3%ADa_matem%C3%A1tica","Wikcionario","Diccionario_de_la_lengua_espa%C3%B1ola"]}
{"url":"L%C3%A9xico","titulo":"Lexico","contenido":"El lexico es el conjunto de palabras que conforma un determinado lecto y, por extension, tambien se denomina asi a los diccionarios que los recogen.\u200b Un sinonimo habitual de lexico es vocabulario, definido como el conjunto de palabras que forman parte de un idioma o lenguaje especifico o son conocidas por una persona o entidad especifica.\u200b En un sentido amplio, el concepto es extensible a los lenguajes de programacion.  Las disciplinas que se ocupan del lexico son varias: lexicografia, semantica, semiotica, pragmatica, filosofia del lenguaje.  El vocabulario de un idioma refleja el medio fisico y social de sus hablantes porque es un inventario de las ideas, los intereses y las ocupaciones de la comunidad. Las lenguas se adaptan a las preocupaciones, los intereses y las vivencias de los hablantes. Conocer una lengua es conocer el lexico, saber usarlo, y tambien conocer y saber utilizar las reglas que controlan la combinacion correcta de los elementos. Las situaciones sociales son muy diversas, conocer una lengua es conocer las convenciones sociales que controlan el uso de ella en distintas situaciones.  Los miembros de una comunidad usan las palabras, en general, con el mismo significado; de otro modo resultaria muy dificil el entendimiento. El comportamiento linguistico es una parte del conjunto de modelos sociales de conducta que caracterizan a los grupos humanos: cada uno de ellos tiene unas costumbres y unas convenciones distintas.  El lexico puede clasificarse desde el punto de vista de su origen historico o amplitud de uso en:  Desde el punto de vista de la funcion:  Las palabras que forman parte de las categorias lexicas pueden combinarse entre si para dar lugar a nuevas palabras, para ello las lenguas del mundo usan diversos procedimientos:  Segun su naturaleza, las unidades del lexico pueden distinguirse entre:\u200b  Las unidades lexicas distinguen tres tipos de rasgos (no todos los modelos gramaticales utilizan los mismos rasgos lexicos. Lo que se da a continuacion es una generalizacion):  En un diccionario tradicional tipico, las entradas se identifican mediante una forma base o \"canonica\" de la palabra. Esta forma canonica varia segun el idioma: los verbos en ingles se representan mediante la raiz no flexionada, mientras en frances o espa\u00f1ol se representan con el infinitivo del verbo. Ademas de la definicion estos diccionarios tradicionales incluyen en cada entrada informacion adicional como la pronunciacion, la categoria gramatical o su etimologia.  El lexico o diccionario empleado en la traduccion automatica presenta algunas diferencias, al compararlo con uno tradicional. Algunos programas de traduccion automatica cuentan unicamente con diccionarios de formas flexionadas, es decir, listas de palabras con todas las formas e informacion gramaticales correspondientes. Un lexico de esta forma contendria las palabras comer, comida, comiendo, comido por separado, como unidades diferenciadas. Esta aproximacion no es nada eficiente en lenguas como el espa\u00f1ol, que posee una flexion rica y compleja. En estos casos, el lexico suele proporcionar una raiz a partir de la cual el componente morfologico se encargara de generar las formas apropiadas.  Este lexico para la traduccion automatica debe suministrar la informacion necesaria para el analisis sintactico y semantico:  A menudo estos dos ultimos tipos de informacion se emplean conjuntamente a la hora de definir, por ejemplo, una subcategoria en terminos de restricciones de seleccion. Esta informacion ayuda a determinar el contexto en el que pueden aparecer las palabras. Asi, por ejemplo, el verbo amar restringe la seleccion de su sujeto, de manera que este debe ser animado.  Ademas, un lexico empleado en la traduccion automatica debe aportar informacion relativa a la correspondencia entre las unidades lexicas de distintas lenguas. Debido a la complejidad que puede entra\u00f1ar esta tarea, muchos sistemas optan por establecer una separacion entre dos tipos de informacion: por un lado, la informacion necesaria para el analisis o produccion de textos en una lengua particular y, por otro lado, la informacion relativa a las correspondencias lexicas entre dos pares de lenguas. Estas correspondencias incluyen las condiciones en las que se produce la equivalencia:  La adquisicion del lexico (tanto en el primer idioma como en los segundos o extranjeros), es un proceso muy complejo. La primera distincion que debemos hacer es entre vocabulario pasivo y vocabulario activo. El primero es el vocabulario que el sujeto entiende sin ayuda o con muy poca ayuda, pero que no es capaz de utilizar autonomamente. El segundo, es el vocabulario que el sujeto comprende sin problemas, pero que ademas, es capaz de utilizar cuando lo necesita y sin necesidad de ayuda. Parece claro, por tanto, que el vocabulario mas amplio de una persona es el vocabulario pasivo, y parece claro tambien, que si una persona no tiene una palabra \u00abalmacenada\u00bb en su vocabulario pasivo, dificilmente esa palabra podra llegar a formar parte de su vocabulario activo. Uno de los defensores de esta teoria fue Tracey Terrell, coautor de Natural Approach, y que invirtio un gran esfuerzo en intentar explicar este proceso de adquisicion linguistica. Terrell afirma que una forma primero se \u00abliga\u00bb (binding en ingles), es decir, se relaciona una forma con su significado. Este proceso parece ser un proceso paulatino y relativamente \u00ablento\u00bb, ya que no seria un aprendizaje sino una adquisicion. Una vez la forma ya esta \u00abligada\u00bb, el sujeto deberia ir intentando \u00abacceder\u00bb (accessing en ingles) a esa forma en repetidas ocasiones. Las primeras veces requerira de mucho tiempo, y posiblemente de cierta ayuda, pero ese tiempo o esa necesidad de ayuda se ira reduciendo paulatinamente. Cuantas mas veces ese sujeto intente acceder a esa forma, mas \u00abaccesible\u00bb estara.  El lexico pasivo mas accesible para los hablantes se registra en diccionarios llamados lexicos disponibles. El lexico activo de mayor uso se compendia en lexicos basicos.\u200b ","snippet":"El lexico es el conjunto de palabras que conforma un determinado lecto y, por extension, tambien se denomina asi a los diccionarios que los recogen.\u200b Un sinonimo habitual de lexico es vocabulario, def","enlaces_salientes":["L%C3%A9xico","L%C3%A9xico","L%C3%A9xico","Lexico","Variedad_ling%C3%BC%C3%ADstica","Lenguaje_de_programaci%C3%B3n","Lexicograf%C3%ADa","Sem%C3%A1ntica","Semi%C3%B3tica","Pragm%C3%A1tica","Filosof%C3%ADa_del_lenguaje","Extranjerismo","Registro_ling%C3%BC%C3%ADstico","Habla","Categor%C3%ADa_l%C3%A9xica","Referente","Categor%C3%ADa_funcional","Composici%C3%B3n_(ling%C3%BC%C3%ADstica)","Derivaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Paras%C3%ADntesis","Categor%C3%ADa_l%C3%A9xica","Sustantivo","Verbo","Adjetivo","Categor%C3%ADa_funcional","Conjunci%C3%B3n_(gram%C3%A1tica)","Art%C3%ADculo_(gram%C3%A1tica)","Sustantivo","Verbo","Preposici%C3%B3n","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","Nombre","Traducci%C3%B3n_autom%C3%A1tica","Idioma","Palabra","Palabra","Natural_approach","Idioma_ingl%C3%A9s","Lexicograf%C3%ADa","Gram%C3%A1tica","Jerga","ISBN","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Art_%26_Architecture_Thesaurus"]}
{"url":"Teor%C3%ADa_de_la_optimidad","titulo":"Teoria de la optimidad","contenido":"La teoria de la optimidad (abreviado OT o TO) es un modelo linguistico, usable en todos los niveles (fonologia, morfologia, sintaxis, semantica), cuya premisa basica es que las expresiones linguisticas admiten cierta variabilidad subyacente y las formas que presenta una lengua son precisamente las formas que han pasado una serie de filtros o restricciones, siendo las formas observadas \"optimas\" en el sentido de que son precisamente las formas que satisfacen mejor las restricciones de cada lengua. Asi, una lengua difiere de otra ademas de en su lexicon, inventario fonologico o input combinable de entrada en la ordenacion relativa de las restricciones. El hecho de que la jerarquia de restricciones varie de una lengua a otra explicaria las diferencias gramaticales entre ellas. Incluso el cambio historico en las lenguas es explicable como una alteracion del orden de las restricciones.  La teoria de la optimidad fue propuesta originalmente por Alan Prince y Paul Smolensky en 1993, y fue posteriormente ampliada por Prince y J. McCarthy.\u200b Si bien la mayor parte del trabajo original se concentro en problemas de fonologia, posteriormente ha demostrado ser aplicable al ambito de la sintaxis y al de la semantica linguistica.  Los tres ingredientes basicos que la teoria de la optimidad usa para investigar un determinado fenomeno linguistico son los siguientes:  La teoria de la optimidad (TO) asume que estos tres ingredientes son universales. Las diferencias gramaticales entre las diferentes lenguas se deben a diferencias de orden en el conjunto CON. Asi, dentro de la TO, el proceso de adquisicion del lenguaje puede ser descrito como un proceso por el cual el ni\u00f1o aprende el orden relativo de las restricciones y hace conjeturas sobre el verdadero orden de dichas restricciones en la lengua de los adultos.  La teoria de la optimidad supone que no hay restricciones especificas del idioma en la entrada. A esto se le llama riqueza de la base. Cada gramatica puede manejar todas las entradas posibles. Por ejemplo, un idioma sin grupos consonanticos debe poder manejar una entrada como /flask/. Los idiomas sin grupos consonanticos difieren en como resolveran este problema; algunos se epentetizaran (por ejemplo, [falasak], o [falasaka] si todas las codas estan prohibidas) y algunos se eliminaran (por ejemplo, [fas], [fak], [las], [lak]).  GEN es libre de generar cualquier cantidad de candidatos de salida, sin importar cuanto se desvien de la entrada. Esto se llama libertad de analisis. La gramatica (clasificacion de restricciones) del idioma determina cual de los candidatos sera evaluado como optimo por\u00a0EVAL.  En la Teoria de la optimidad, cada restriccion es universal. CON es el mismo en todos los idiomas. Hay dos tipos basicos de restricciones:  Cada una juega un papel crucial en la teoria. Las restricciones de marcacion motivan los cambios de la forma subyacente, y las restricciones de fidelidad evitan que cada entrada se realice como una forma completamente sin marcar (como [ba]).  La naturaleza universal de\u00a0CON hace algunas predicciones inmediatas sobre la tipologia del lenguaje. Si las gramaticas difieren solo por tener diferentes clasificaciones de\u00a0CON, entonces el conjunto de posibles lenguajes humanos esta determinado por las restricciones que existen. La Teoria de la optimalidad predice que no puede haber mas gramaticas que permutaciones del ranking de\u00a0CON. El numero de clasificaciones posibles es igual a la factorial del numero total de restricciones, lo que da origen al termino tipologia factorial. Sin embargo, puede que no sea posible distinguir todas estas gramaticas potenciales, ya que no se garantiza que todas las restricciones tengan un efecto observable en todos los idiomas. Dos ordenes totales en las restricciones de\u00a0CON podrian generar el mismo rango de asignaciones de entrada y salida, pero difieren en la clasificacion relativa de dos restricciones que no entran en conflicto entre si. Como no hay forma de distinguir estas dos clasificaciones, se dice que pertenecen a la misma gramatica. Una gramatica en la TO es equivalente a un antimatroide.\u200b Si se permiten clasificaciones con empates, entonces el numero de posibilidades es un numero de Bell ordenado en lugar de una factorial, lo que permite un numero significativamente mayor de posibilidades.\u200b  McCarthy y Prince (1995) proponen tres familias basicas de restricciones de fidelidad:  Cada uno de los nombres de las restricciones puede tener el sufijo \"-IO\" o \"-BR\", que significa entrada/salida y base/reduplicante, respectivamente, el ultimo de los cuales se usa en el analisis de reduplicacion, si se desea. F en IDENT (F) se sustituye por el nombre de un rasgo distintivo, como en IDENT-IO (voz).  MAX y\u00a0DEP reemplazan PARSE y FILL propuestos por Prince & Smolensky (1993), que establecian que \"los segmentos subyacentes deben analizarse en la estructura de la silaba\" y \"las posiciones de las silabas deben llenarse con segmentos subyacentes\", respectivamente. PARSE y FILL cumplen esencialmente las mismas funciones que\u00a0MAX y\u00a0DEP, pero se diferencian en que solo evaluan la salida y no la relacion entre la entrada y la salida, que es bastante caracteristica de las restricciones de marcado. Esto se deriva del modelo adoptado por Prince & Smolensky conocido como teoria de la contencion, que supone que los segmentos de entrada no realizados por la salida no se eliminan, sino que se \"dejan sin analizar\" por una silaba. El modelo propuesto por McCarthy y Prince (1995, 1999), conocido como teoria de la correspondencia, lo reemplazo como marco estandar.  McCarthy & Prince (1995) tambien proponen:  Las restricciones de marcacion introducidas por Prince y Smolensky (1993) incluyen:  Las definiciones precisas en la literatura varian. Algunas restricciones se utilizan a veces como una \"restriccion de cobertura\", en sustitucion de un conjunto de restricciones que no se conocen por completo ni son importantes.   ","snippet":"La teoria de la optimidad (abreviado OT o TO) es un modelo linguistico, usable en todos los niveles (fonologia, morfologia, sintaxis, semantica), cuya premisa basica es que las expresiones linguistica","enlaces_salientes":["Teor%C3%ADa_de_la_optimidad","Teor%C3%ADa_de_la_optimidad","Teor%C3%ADa_de_la_optimidad","Ling%C3%BC%C3%ADstico","Fonolog%C3%ADa","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Sintaxis","Sem%C3%A1ntica","Lexic%C3%B3n","Fonolog%C3%ADa","Sintaxis","Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Relaci%C3%B3n_de_orden","Adquisici%C3%B3n_del_lenguaje","Gram%C3%A1tica","Ep%C3%A9ntesis","Tipolog%C3%ADa_ling%C3%BC%C3%ADstica","Factorial","Met%C3%A1tesis","ISBN","OCLC","ISBN","OCLC","ISSN","Semantic_Scholar","Digital_object_identifier","JSTOR","Cambridge_University_Press","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Comunicaci%C3%B3n_oral","titulo":"Comunicacion oral","contenido":"La comunicacion oral se establece entre dos o mas personas, tiene como medio de transmision el habla y como codigo un idioma.  Cada tecnica empleada con el fin de intercambiar las ideas tiene un campo de aplicacion muy variado, entre los que figuran: el personal, social, profesional, politico o cientifico, entre otros. Sea cual sea el momento, el lugar o la circunstancia, comunicarse es un proceso inevitable del ser humano.  La comunicacion oral permite a los individuos realizar las acciones de la vida cotidiana, formarse como persona e integrarse  en la vida social.\u200b  La pragmatica de Peter Strawson y John Searle considera que \u00abacto de habla\u00bb se refiere usualmente a lo mismo que se designa con \u00abacto ilocutivo\u00bb, termino a su vez acu\u00f1ado por John L. Austin en \u00bfComo hacer cosas con palabras? (1962).  De acuerdo con Austin, el \u00abacto ilocutivo\u00bb se da en la medida en que la enunciacion constituye, por si misma, cierto acto, entendido como transformacion de las relaciones entre los interlocutores o con los referentes. Un ejemplo clasico es que al decir \u00ablo prometo\u00bb o \u00absi, acepto\u00bb (en una ceremonia matrimonial) estamos, a la vez que hablando, realizando el acto. En este sentido, el \"acto de habla\", es decir, la emision del enunciado puede realizarse en forma oral o escrita, siempre y cuando se lleve a cabo la realizacion de una accion mediante palabras.  El efectuar un acto de habla, expresando una oracion correcta gramaticalmente y con sentido, implica un compromiso con el entorno. Un acto de habla puede ser: solicitar informacion, ofrecer, disculparse, expresar indiferencia, expresar agrado o desagrado, amenazar, invitar, rogar, etc. El acto de habla consta de tres niveles elementales:  Tambien, los actos de habla se pueden dividir en dos tipos:  Searle, quien siguio el analisis de Austin sobre los enunciados de accion o \u00abperformativos\u00bb y se centro en lo que aquel habia llamado actos ilocucionarios (actos que se realizan diciendo algo), desarrollo la idea de que diversas oraciones con el mismo contenido proposicional pueden diferir en su fuerza ilocucional, segun se presenten como una aseveracion, una pregunta, una orden o una expresion de deseo.  Segun Searle, las fuerzas ilocucionales de un acto de habla pueden describirse siguiendo reglas o condiciones especificables, dadas tanto por las circunstancias como por el proposito que se sigue en diferentes actos ilocucionarios.  Paul Grice formulo su estado de fase de cooperacion para toda actividad de intercambio, pero lo especifico en referencia a la comunicacion oral: \u00abHaz tu contribucion conversacional tal y como es requerida en el momento en que ocurre y de acuerdo con la finalidad previamente aceptada del intercambio en que te hayas implicado\u00bb.  Al ocuparnos del principio de cooperacion de Paul Grice entendemos que el principal objetivo del filosofo ingles era el descubrimiento de unas reglas pragmaticas presentes en cualquier lenguaje discursivo que posibiliten dicho acto linguistico. De este modo podemos establecer una especie de acuerdo entre los interlocutores que desarrollan una conversacion, ya sea escrita o dialogada, por el cual delimitan y definen un \u00abcontrato linguistico\u00bb que posee unas \u00abmaximas\u00bb determinadas. Acudiendo expresamente a las palabras del propio Paul Grice encontramos la siguiente afirmacion:  Segun Grice, existen cuatro maximas implicativas que deben cumplirse para llevar a cabo una buena comunicacion oral:  Aunque existen ciertas ocasiones en las que esta permitido incumplir estas maximas:  El proceso de competencia pragmatica es nombrado por Noam Chomsky, en un articulo de 1978, como complemento a la competencia gramatical, que era desde 1957 una de las ideas fundamentales del generativismo. La psicologia cognitiva diferencia entre conductismo y cognitivismo. Para fundamentar la perspectiva cognitiva del lenguaje, Noam Chomsky propuso tres ideas fundamentales:  La diferencia es que el estructuralismo siempre asumio que la descripcion del sistema, aunque fuera el objetivo, solo podia lograrse desde los datos del habla. El generativismo, en cambio, en su empe\u00f1o por rechazar lo que fuera \u201cconductual\u201d, ignora los datos concretos en su pretension de describir solo la competencia. La clave estaria en la introspeccion del linguista. Se asume que el linguista es hablante, y por tanto tiene acceso a las estructuras profundas y su criterio como hablante es aceptado con valor metalinguistico.  Estas dos estructuras estan alojadas en el cerebelo, en una parte muy conocida como la glandula pilial; es necesario el consumo de agua natural para no alterar esta glandula y asi mejore significativamente nuestro analisis en la estructura profunda y desarrollar mas nuestra estructura superficial.   ","snippet":"La comunicacion oral se establece entre dos o mas personas, tiene como medio de transmision el habla y como codigo un idioma.  Cada tecnica empleada con el fin de intercambiar las ideas tiene un campo","enlaces_salientes":["Comunicaci%C3%B3n_oral","Comunicaci%C3%B3n_oral","Comunicaci%C3%B3n_oral","Oralidad","Individuo","Relaci%C3%B3n_social","Pragm%C3%A1tica","Peter_Frederick_Strawson","John_Searle","John_L._Austin","Gram%C3%A1tica","Paul_Grice","Noam_Chomsky","Generativismo","Cognitivismo","Dicotom%C3%ADas_de_Saussure","Estructuralismo_(ling%C3%BC%C3%ADstica)","Alalia","Coprolalia","Dislalia","Ecolalia","Habla","Silbido","Oxford_University_Press","ISBN","Harvard_University_Press","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Gemeinsame_Normdatei","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa"]}
{"url":"Fonolog%C3%ADa","titulo":"Fonologia","contenido":"La fonologia es la rama de la linguistica que estudia el sistema de los sonidos de la lengua en general, y de cada lengua en particular, incluyendo las silabas, la entonacion, la acentuacion, etc., a un nivel abstracto o mental. La fonologia se complementa por lo tanto con la fonetica, que estudia los sonidos del habla en si mismos, desde los puntos de vista acustico, articulatorio y perceptivo, y de manera menos dependiente de cada lengua en particular.\u200b  La fonologia describe una parte de una lengua oral, el llamado nivel fonologico, que se completa con los niveles morfologico (estructura interna de las palabras), sintactico (interaccion entre palabras para formar frases) y semantico o lexico (significados).  El numero de sonidos articulatoriamente diferentes de una lengua puede ser muy elevado. Asi por ejemplo una /s/ puede tener mayor grado o menor grado de sonoridad segun aparezca ante sorda o sonora, como sucede en espa\u00f1ol en el par esperar - esmerar(se); igualmente una /k/ se articula generando una oclusion mas adelante o mas atras en la cavidad oral segun la vocal siguiente, como sucede en el par quiero - cucurucho. Esas diferencias sutiles, aunque medibles empiricamente, generalmente son irrelevantes en este nivel de estudio, ya que son articulaciones secundarias automaticas y no permiten distinguir unas palabras de otras, son por lo tanto terreno de la fonetica mas que de la fonologia.\u200b\u200b Asi, aunque la diferencia entre el sonido /k/ de quitar [ki\u02c8ta\u027e] y el sonido /k/ de catar [ka\u02c8ta\u027e] no es relevante, si lo son otras diferencias como la /p/ de pitar y la /k/ de quitar. En el primer caso, donde la diferencia es irrelevante para la diferenciacion, se dice que es alofonica, mientras que en el segundo caso es relevante y se dice que es fonemica. Los linguistas usan los corchetes [ ] para representar con diferente grado de detalle las transcripciones foneticas (alofonicas) de los sonidos, mientras que se usan las barras / / para representar la transcripcion fonemica. En una transcripcion fonetica se usan signos concretos para cada diferencia medible, mientras que en una transcripcion fonemica solo tienen signos diferentes los sonidos que son fonologicamente contrastivos (y por tanto susceptibles de llevar a diferencias de significado).  Se denominan pares minimos a aquellas palabras que significan cosas distintas pero difieren la una de la otra tan solo en un sonido. Por ejemplo \"casa\" y \"tasa\". La existencia de pares minimos es un principio general para identificar el inventario fonologico de una lengua.\u200b En su forma fuerte \u00absi existen dos pares minimos que difieren en un sonido segmental, implica que esos dos sonidos segmentales son realizaciones de fonemas diferentes\u00bb. Este principio es criticable y puede ser substituido en su forma debil \u00absi existen dos pares minimos que difieren en un sonido segmental, implica que esos las representaciones subyacentes en fonemas deben diferentes\u00bb (pudiendo diferir ambas en mas de un fonema, por ejemplo en ruso la version fuerte llevaria a un inventario fonologico muy grande muy superior al tama\u00f1o del alfabeto, mientras que el segundo permite introducir un fonema palatalizador abstracto y a un inventario fonologico de tama\u00f1o similar al alfabeto).  El sistema fonologico de una lengua esta formado por un inventario de fonemas y un conjunto de reglas de aplicacion automatica que da la pronunciacion de cada cadena admisible de fonemas. Debe tenerse presente que el sistema fonologico puede admitir diversas representaciones, un inventario peque\u00f1o con mas reglas, o un inventario mas grande con menos reglas (vease por ejemplo los diferentes analisis para las vocales del ingles). En el enfoque generativista, un sistema fonologico se puede representar por un par:   F = ( F , R ) }=(F,})}  Donde:  Por ejemplo, la palabra del espa\u00f1ol /DeDo/ , con la aplicacion de las reglas pasa a ser: [de\u00f0o] (donde la primera /D/ se articula como oclusiva [d] y la segunda como aproximante [\u00f0]). La fonologia, vista segun el enfoque formal del generativismo, es el estudio de los sistemas fonologicos.  Otro hecho que debe tenerse en cuenta es que los mismos sonidos segmentales pueden estar asignados a fonemas diferentes. Asi, los alofonos [p] y [b] son unidades contrastantes en espa\u00f1ol (vaso / paso), pero no en chino mandarin. Por eso, en espa\u00f1ol se consideran fonemas diferentes, pero en chino mandarin, que usa oposiciones de aspiracion mas que de sonoridad entre las consonantes labiales, solo son dos realizaciones posibles del mismo fonema labial no aspirado.[cita\u00a0requerida]  Un fonema no es un sonido sino un constructo mental. Cada fonema es una clase de equivalencia de sonidos, caracterizada por una especificacion incompleta de rasgos foneticos (acusticos y articulatorios). La pronunciacion concreta de un fonema dependera de la posicion en la palabra o contexto fonetico, que determinara los otros rasgos foneticos relevantes, para poseer una especificacion articulatoria completa. Asi, en espa\u00f1ol tenemos un fonema /b/ que tiene rasgo consonantico, no nasal, labial y sonoro y puede pronunciarse como oclusiva [b] a principio de palabra, o como aproximante [\u03b2] entre vocales, pero del fonema mismo /b/ no podemos decir que sea oclusivo o aproximante. Es, por tanto, un fonema subespecificado respecto a los rasgos. En todas las lenguas, la mayoria de los fonemas estan subespecificados. Algunos de los rasgos foneticos importantes para distinguir fonemas son:  El sistema mas comunmente usado en la transcripcion fonetica es el propuesto por la Asociacion Internacional de Fonetica (AFI) que creo en 1886 un Alfabeto Fonetico Internacional, en el cual estandarizaron simbolos graficos mediante los que poder describir la pronunciacion de cualquier lengua humana, y para el que se han ido proponiendo mejoras y modificaciones sucesivas. Dicho sistema consta de un conjunto basico de unas decenas de signos, complementados mediante signos diacriticos que dan lugar a una gran variedad de combinaciones posibles, capaces de representar gran numero de sutilezas articulatorias.  Otro sistema interesante es el Speech Assessment Methods Phonetic Alphabet (SAMPA) que es un alfabeto fonetico legible por ordenador.  Sin embargo, en la fonologia al ser un nivel de representacion de las lenguas mas abstracto que las lenguas se vienen usando sistemas de transcripcion mas variados. De hecho podriamos representar los fonemas de una lengua por numeros, simbolos abstractos o cualquier sistema finito de grafemas, aunque en el uso practico tienden a tomarse simbolos similares a los usados para la transcripcion fonetica.  En las lenguas de se\u00f1as, el componente fonologico abstracto suele recibir el nombre de querologia. Si bien en esas lenguas no existen rasgos foneticos propiamente dichos, las configuraciones y movimientos de las partes del cuerpo admiten analisis abstractos similares a los usados en la fonologia de las lenguas orales.\u200b Una caracteristica interesante es que en estas lenguas existen fenomenos similares a la asimilacion linguistica. Igualmente se ha comprobado que los ni\u00f1os sordos registran una base de gestualizacion analoga al balbuceo de las lenguas orales.  \u200b \u200b \u200b ","snippet":"La fonologia es la rama de la linguistica que estudia el sistema de los sonidos de la lengua en general, y de cada lengua en particular, incluyendo las silabas, la entonacion, la acentuacion, etc., a ","enlaces_salientes":["Fonolog%C3%ADa","Fonolog%C3%ADa","Fonolog%C3%ADa","Ling%C3%BC%C3%ADstica","Fon%C3%A9tica","Al%C3%B3fono","Fonema","Par_m%C3%ADnimo","Idioma_ruso","%D0%AC","Sistema_fonol%C3%B3gico","Fonema","Fonolog%C3%ADa_del_ingl%C3%A9s#An\u00e1lisis_fonol\u00f3gicos","Generativismo","Oclusiva","Consonante_aproximante","Generativismo","Al%C3%B3fono","Idioma_espa%C3%B1ol","Idioma_chino_mandar%C3%ADn","Fonema","Chino_mandar%C3%ADn","Consonante_labial","Fonema","Fonema","Constructo_(psicolog%C3%ADa)","Clase_de_equivalencia","Rasgo_fon%C3%A9tico","Consonante_aproximante","Sonoridad","Lenguas_romances","Chino_mandar%C3%ADn","Modo_de_articulaci%C3%B3n","Consonante_oclusiva","Consonante_fricativa","Consonante_aproximante","Consonante_africada","Punto_de_articulaci%C3%B3n","Punto_de_articulaci%C3%B3n","Lengua_natural","Consonante_labial","Consonante_coronal","Consonante_palatal","Consonante_velar","Consonante_uvular","Consonante_faringal","Consonante_glotal","Transcripci%C3%B3n_fon%C3%A9tica","Alfabeto_Fon%C3%A9tico_Internacional","Diacr%C3%ADtico","SAMPA","Querolog%C3%ADa","Lenguas_de_se%C3%B1as","Querolog%C3%ADa","Asimilaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Sordera","Alfabeto_Fon%C3%A9tico_Internacional","Fon%C3%A9tica","ISBN","Semantic_Scholar","Digital_object_identifier","Cambridge_University_Press","ISBN","ISBN","JSTOR","Digital_object_identifier","Leonard_Bloomfield","MIT_Press","Noam_Chomsky","Morris_Halle","Semantic_Scholar","Digital_object_identifier","ISBN","ISBN","ISBN","ISBN","J._R._Firth","Digital_object_identifier","Digital_object_identifier","ISBN","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","Roman_Jakobson","Andr%C3%A9_Martinet","Andr%C3%A9_Martinet","Kenneth_Lee_Pike","Edward_Sapir","JSTOR","Digital_object_identifier","Ferdinand_de_Saussure","Morris_Swadesh","JSTOR","Digital_object_identifier","JSTOR","Digital_object_identifier","Nikolai_Trubetzkoy","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Wiley-Blackwell","ISBN","ISBN"]}
{"url":"Lengua_de_se%C3%B1as","titulo":"Lengua de se\u00f1as","contenido":"Una lengua de se\u00f1as o lengua de signos es una lengua natural de expresion y configuracion gesto-espacial y percepcion visual (o incluso tactil por ciertas personas con sordoceguera),\u200b gracias a la cual, las personas sordas pueden establecer un canal de comunicacion con su entorno social, sea este conformado por otras personas sordas o por cualquier persona que conozca la lengua de se\u00f1as empleada. Mientras que la lengua oral se basa en la comunicacion a traves de un canal vocal-auditivo, la lengua de se\u00f1as lo hace por un canal gesto-viso-espacial.\u200b  El 23 de septiembre es Dia Internacional de las lenguas de se\u00f1as a nivel mundial.\u200b  Muchos estudios de neuroimagen, asi como un metanalisis reciente, indican que los lenguajes de se\u00f1as se procesan en las mismas areas del cerebro que se usan para el lenguaje hablado en las personas oyentes.\u200b  Aun cuando hoy en dia las lenguas de se\u00f1as se utilizan casi exclusivamente entre personas sordas, el uso de las se\u00f1as en la comunicacion es tan antiguo como el de las lenguas orales, o incluso tan antiguo como la historia de la Humanidad.\u200b Las lenguas de se\u00f1as han sido y siguen siendo empleadas por comunidades de oyentes. De hecho, los amerindios de la region de las Grandes Llanuras de America del Norte usaban una lengua de se\u00f1as para hacerse entender entre etnias que hablaban lenguas muy diferentes con fonologias extremadamente diversas.\u200b El sistema estuvo en uso hasta mucho despues de la conquista europea.  En otra ocasion, una tribu unica en la que gran parte de sus integrantes eran sordos debido a la herencia y desarrollo de un gen dominante, y se comunicaban con una lengua gestual. Un caso similar, se desarrollo en la isla de Martha's Vineyard, al sur del estado de Massachusetts, donde, debido al gran numero de sordos, se empleo una lengua de se\u00f1as que llego a ser de uso general, tambien entre oyentes hasta principios del siglo\u00a0XX.\u200b Pese a esto, no existen referencias documentales sobre estas lenguas antes del siglo\u00a0XVII. Los datos que se poseen tratan, sobre todo, de sistemas y metodos educativos para personas sordas.\u200b  En el siglo\u00a0XVI Jeronimo Cardano, medico de Padua, en la Italia norte\u00f1a, proclamo que las personas sordas podrian hacerse entender por combinaciones escritas de simbolos asociandolos con las cosas a que ellos se referian. En 1620 Juan de Pablo Bonet publico su Reduccion de las letras y Arte para ense\u00f1ar a hablar los Mudos,\u200b considerado como el primer tratado moderno de Fonetica y Logopedia. En dicha publicacion se proponia un metodo de ense\u00f1anza oral para los sordos mediante el uso de se\u00f1as alfabeticas configuradas unimanualmente, consiguiendo asi divulgar, en toda Europa, y despues, en todo el mundo, el alfabeto manual (util para mejorar la comunicacion de los sordos y mudos). En 1817, Gallaudet fundo la primera escuela norteamericana para personas sordas, en Hartford, Connecticut, y Clerc se convirtio en el primer maestro sordo de lengua de se\u00f1as de los Estados Unidos.\u200b En poco tiempo, las escuelas para personas sordas empezaron a aparecer en varios estados. Entre ellos, la Escuela de Nueva York, que abrio sus puertas en 1818. En 1820, otra escuela se abrio en Pensilvania, y un total de veintidos escuelas se habian establecido a lo largo de los Estados Unidos por el a\u00f1o 1865. En esta obra aparece un abecedario ilustrado mediante grabados calcograficos de los signos de las manos que representan las letras del alfabeto latino.\u200b Del tratado sobre Reduccion de las letras y Arte para ense\u00f1ar a hablar los Mudos se hicieron traducciones a las principales lenguas.\u200b Sobre la base del alfabeto divulgado por Bonet, Charles-Michel de l'Epee publico en el siglo\u00a0XVIII su alfabeto, que basicamente es el que ha llegado hasta la actualidad, siendo conocido internacionalmente como alfabeto manual espa\u00f1ol.    A.  B, C, D.  E, F, G.  H, I, L.  M, N.  O, P, Q.  R, S, T.  V, X, Y, Z.  Las lenguas de se\u00f1as modernas, al igual que las lenguas orales, estan sujetas al proceso universal de cambio linguistico, que hace que evolucionen con el tiempo y eventualmente, una misma lengua puede evolucionar en lugares diferentes hacia variedades diferentes. De hecho, muchas de las lenguas modernas de se\u00f1as pueden ser clasificadas en familias:  El escaso conocimiento de este tipo de lenguas ha conducido a que comunmente se asuman ciertas ideas preconcebidas sobre ellas, que se han demostrado como erroneas:  En las lenguas de se\u00f1as se utiliza el alfabeto manual o dactilologico, generalmente para los nombres propios o tecnicos, si bien es solo una mas de las numerosas herramientas que poseen. Antiguamente, el uso de la dactilologia en las lenguas de se\u00f1as era una evidencia presupuesta de que solo eran una pobre o simplificada version de las lenguas orales, lo que tambien es falso.  En general, las lenguas de se\u00f1as son independientes de las lenguas orales y siguen su propia linea de desarrollo. Por ultimo, un area que tiene mas de una lengua oral puede tener una misma lengua de se\u00f1as, pese a que haya diferentes lenguas orales.\u200b Este es el caso de Canada, los EE. UU. y Mexico, donde la lengua de se\u00f1as americana (ASL) convive con las lenguas orales inglesa, espa\u00f1ola y francesa. Inversamente de igual modo, en una zona donde existe lengua oral que puede servir de lengua franca, pueden convivir varias lenguas de se\u00f1as, como es el caso de Espa\u00f1a, donde conviven la Lengua de signos espa\u00f1ola (LSE), la Lengua de signos catalana (LSC).  Al no ser \"se\u00f1as\" y \"signos\" terminos estrictamente sinonimos, algunos expertos opinan que la denominacion \"lengua de signos\", mayoritaria en Espa\u00f1a, es terminologicamente incorrecta, argumentando que, segun Saussure, todas las lenguas son en rigor \"sistemas de signos\". No obstante, al margen de la terminologia estrictamente empleada en el campo de la linguistica, ambas palabras son utilizadas en el uso comun, dependiendo del pais. Por ejemplo, en Espa\u00f1a es comun denominarla \"lengua de signos\", sobre todo en la legislacion relacionada con esta, y se emplean en menor medida otras denominaciones como \"lengua de se\u00f1as\", \"lengua gestual\" o \"mimica\". Por otro lado, en los paises americanos de habla hispana es tradicional llamarlas \"lenguas de se\u00f1as\".  En la pagina en espa\u00f1ol de la ONU sobre la Convencion Universal de los Derechos de las Personas con Discapacidad, se la cita hasta siete veces con la mencion de \"lengua de se\u00f1as\".\u200b  El estudio cientifico de las lenguas de se\u00f1as, ha revelado que poseen todas las propiedades y complejidades propias de cualquier lengua natural oral. A pesar de la generalizada y erronea concepcion de que son \"lenguas artificiales\". En concreto, se han encontrado los siguientes hechos relativos a las lenguas de se\u00f1as que proporcionan los linguistas necesarios para clasificarlas como lenguas naturales:  Historicamente, el primero en analizar las lenguas de se\u00f1as en terminos linguisticos fue el jesuita espa\u00f1ol, padre de la Linguistica Comparada, Abate Lorenzo Hervas y Panduro (1735-1809). En su obra, editada en Madrid en 1795, Escuela Espa\u00f1ola de Sordomudos o Arte para ense\u00f1arles a escribir y hablar el idioma espa\u00f1ol, es decir, dos siglos antes de que William C. Stokoe hiciera lo propio con la Lengua de Se\u00f1as Estadounidense (ASL). Algunos paises reconocen en su legislacion la lengua de se\u00f1as como lengua nacional (Mexico.  Ley General para la Inclusion de las Persona con Discapacidad. Art. 14, Colombia Ley 324 del 11 de octubre de 1996. Uruguay. Ley N.\u00ba 17.378 , 2001.\u200b)  Las lenguas de se\u00f1as no son simple mimica, ni tampoco una reproduccion visual de alguna version simplificada de ninguna lengua oral. Tienen gramatica compleja, creativa y productiva como la de cualquier otra lengua natural.  Una prueba mas de la diferencia entre las lenguas orales y las lenguas de se\u00f1as es el hecho de que estas ultimas explotan unicamente los disparos del medio visual. La lengua oral es auditiva y, consecuentemente, lineal. Solo se puede emitir o recibir un sonido a la vez, mientras que la lengua de se\u00f1as es visual y, por lo tanto, se puede referir un espacio entero al mismo tiempo. En consecuencia, la informacion puede fluir mediante varios \"canales\" y expresarse simultaneamente.  Otra caracteristica que ha significado una diferenciacion entre la lengua de se\u00f1as y las lenguas orales es la dificultad de ser escrita; pues se trata de una lengua tradicionalmente agrafa, ya que, normalmente, las lenguas de se\u00f1as no se han escrito. Entre otros motivos ha contribuido, a que la mayoria de las personas sordas lean y escriban en la lengua oral de su pais. Pese a esto, ha habido propuestas para desarrollar sistemas de transcripcion de las lenguas de se\u00f1as, provenientes sobre todo del mundo academico, pero la mayoria de ellas, tiene deficiencias para captar todas las caracteristicas comunicativas que se utilizan en las lenguas de se\u00f1as (especialmente los elementos no-manuales y posicionales). Sin embargo, existen varios sistemas de representacion de las se\u00f1as mediante signos textuales (glosas, signo-escritura alfabetica.) O bien, iconicos (HamNoSys, Sign Writing). Este ultimo sistema -creado por Valerie Sutton alrededor de 1974- permite la escritura de todas las lenguas de se\u00f1as del mundo de una forma bastante sencilla de aprender, ademas de ser, quizas, el mas completo y flexible, pues ya se utiliza en varios paises e idiomas con buenos resultados. Por tal motivo permite describir de forma bastante precisa -aunque no perfecta-, los elementos no manuales y posicionales, dotando a las personas sordas de la posibilidad de acceder a diccionarios, libros, diarios o revistas con sus contenidos expresados en la correspondiente lengua de se\u00f1as, con lo cual estas reciben la posibilidad de ser lenguas escritas.  De igual manera a como sucede con el lenguaje oral, no hay necesariamente una lengua de se\u00f1as para cada pais, y aun menos es una lengua universal, sino que hay variadas lenguas de se\u00f1as diferentes en el mundo, ubicadas regionalmente. Existen al menos unas cincuenta lenguas, practicamente ininteligibles entre si, y numerosos dialectos, algunos de los cuales coexisten dentro de una misma ciudad.  Ademas, existe un Sistema de Se\u00f1as Internacional (SSI), que se puede considerar como un sistema de comunicacion formado por se\u00f1as propias, consensuadas, procedentes de las diferentes lenguas. Actualmente, esta en discusion si se trata de una lengua o un piyin (pidgin), termino con el que se le ha vinculado en los ultimos a\u00f1os. En rigor, esto no es asi, sino que, coincidiendo con un cambio en la direccion de la Federacion Mundial de Sordos (WFD-FMS), los nuevos dirigentes pretendieron sustituir el anterior Gestuno. Ambos sistemas son equivalentes al esperanto en la lengua oral, discutidos a la hora de referirnos tanto al Sistema de Se\u00f1as Internacional, como al  Gestuno, son lenguas que, como el Esperanto, son de creacion artificial o convencional, de uso minoritario y desconocido por la mayoria de las personas sordas. El SSI es utilizado por personas que no comparten una lengua de se\u00f1as comun y que necesitan comunicarse sin la intermediacion de un interprete (aunque en conferencias internacionales si es comun el uso de estos interpretes).\u200b  El conjunto de unidades simbolicas minimas o \"fonemas\" de la mayoria de lenguas de se\u00f1as puede analizarse en terminos de siete parametros formativos basicos:  Esto es paralelo con los 5 o 6 parametros generalmente necesarios para analizar la fonologia de las lenguas orales, entre los cuales encontramos:  En el contexto de las lenguas de se\u00f1as se ha acu\u00f1ado el termino queirologia para referirse a la fonologia gestual de estas lenguas.\u200b  Muchas lenguas de se\u00f1as tienden a ser lenguas analiticas con poca morfologia. Esto, sin embargo, puede ser mas una consecuencia del origen historico de las mismas que una caracteristica necesaria o preferente de las lenguas de se\u00f1as. En la mayoria de lenguas de se\u00f1as, por ejemplo, los procesos morfologicos son mas usados en los procesos de formacion de palabras: derivacion y composicion y son evidentes en la estructura de buena parte del lexico.  Las personas sordas instruidas (que sepan leer y escribir) de casi todo el mundo usan un grupo de se\u00f1as para representar las letras del alfabeto con el que se escribe la lengua oral del pais. Es esto lo que se denomina alfabeto manual o alfabeto dactilologico. En el caso de los paises de habla hispana, donde se usa el alfabeto latino, las personas sordas usan alfabetos con algunas similitudes pero que difieren segun la fonetica de la lengua oral con la que coexiste, como tambien del pais (algunos paises comparten la dactilologia, como EE. UU. y Colombia; pero en Argentina la diferencia es muy grande, usandose para algunas letras una mano, en otras ambas manos e incluso en algunas interviene el rostro y el cuerpo). En Inglaterra se usa un alfabeto bimanual. En los paises que usan alfabetos distintos al latino (alfabetos hebreo, arabe, amharico, etc.) existen otras formas de representacion entre las personas sordas. Lo mismo se aplica a los paises donde se usan sistemas de escritura no alfabeticos (como es el caso de Japon, China, etc.).  En la actualidad, se establecen intercambios cientifico-tecnicos y culturales entre distintas comunidades linguisticas, crece cada vez mas la necesidad de aprender una segunda lengua; y en particular se redimensiona su valor al tratarse de un idioma viso gestual: La LSC, que utilizan las personas con discapacidad auditiva, constituye su primera lengua y se considera su lengua natural, la que aprenden en su entorno linguistico sin restricciones. Es necesario que todas las personas involucradas en su educacion la dominen para poder interactuar con ellas, y de este modo, contribuir a la formacion de su personalidad.  La ense\u00f1anza de las segundas lenguas, en su recorrido por el siglo\u00a0XX, ha ido incrementando su interes por el aprendizaje de la comunicacion oral hasta ocupar un lugar preponderante en la actualidad. Sin embargo, ha surgido con gran fuerza en los ultimos 30 a\u00f1os el estudio de otras lenguas de caracter minoritario, donde se emplea el canal de comunicacion viso gestual, que exige de una didactica particular. En ambas su valor formativo esta dado por sus potencialidades educativas, instructivas y desarrolladoras. ","snippet":"Una lengua de se\u00f1as o lengua de signos es una lengua natural de expresion y configuracion gesto-espacial y percepcion visual (o incluso tactil por ciertas personas con sordoceguera),\u200b gracias a la cua","enlaces_salientes":["Lengua_de_se%C3%B1as","Lengua_de_se%C3%B1as","Lengua_de_se%C3%B1as","Lengua_natural","Lengua_de_se%C3%B1as_mexicana","Lengua_de_se%C3%B1as_estadounidense","Lengua_natural","Sordoceguera","23_de_septiembre","Juan_Pablo_Bonet","Amerindio","Fonolog%C3%ADa","Martha%27s_Vineyard","Massachusetts","Juan_de_Pablo_Bonet","Fon%C3%A9tica","Logopedia","Alfabeto_manual","Sordo","Mudo","Charles-Michel_de_l%27%C3%89p%C3%A9e","Familia_de_lenguas#Lenguas_naturales_(gestuales)","Cambio_ling%C3%BC%C3%ADstico","Lengua_de_Se%C3%B1as_Americana","Charles_Michel_de_l%27%C3%89p%C3%A9e","Lengua_de_se%C3%B1as_americana","Lengua_de_se%C3%B1as_mexicana","Lengua_de_se%C3%B1as_italiana","Lengua_de_se%C3%B1as_espa%C3%B1ola","Lengua_de_se%C3%B1as_catalana","Auslan","Lengua_de_se%C3%B1as_alemana","Lengua_natural","Lengua_materna","Analog%C3%ADa","Elipsis_(ling%C3%BC%C3%ADstica)","Cambio_fon%C3%A9tico","Asimilaci%C3%B3n_(ling%C3%BC%C3%ADstica)","N%C3%BAcleo_sint%C3%A1ctico","Alfabeto_manual","Alfabeto_dactilol%C3%B3gico","Canad%C3%A1","Estados_Unidos","M%C3%A9xico","Idioma_ingl%C3%A9s","Idioma_espa%C3%B1ol","Idioma_franc%C3%A9s","Lengua_de_se%C3%B1as_espa%C3%B1ola","Lengua_de_signos_catalana","Ferdinand_de_Saussure","Signo_ling%C3%BC%C3%ADstico","Lengua_natural","Fonolog%C3%ADa","Querolog%C3%ADa","Fonemas","Habla","Asimilaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Cambio_ling%C3%BC%C3%ADstico","Sintaxis","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Cambio_ling%C3%BC%C3%ADstico","Lexema","Lorenzo_Herv%C3%A1s_y_Panduro","William_C._Stokoe","ASL","M%C3%ADmica","Gram%C3%A1tica","%C3%81grafa","Idioma","Pa%C3%ADs","Dialecto","Ciudad","Pidgin","Gestuno","Esperanto","Interpretaci%C3%B3n_de_lenguas","Lengua_anal%C3%ADtica","Derivaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Composici%C3%B3n_(ling%C3%BC%C3%ADstica)","L%C3%A9xico","Alfabeto_manual","Dactilolog%C3%ADa","Inglaterra","Idioma_hebreo","Idioma_%C3%A1rabe","Amh%C3%A1rico","Jap%C3%B3n","China","Palabra_complementada","Cultura_Sorda","Carambuco_cuentos","Lengua_de_se%C3%B1as_argentina","Lengua_de_signos_catalana","Lengua_de_se%C3%B1as_colombiana","Lengua_de_se%C3%B1as_costarricense","Lengua_de_se%C3%B1as_chilena","Lengua_de_se%C3%B1as_ecuatoriana","Lengua_de_signos_espa%C3%B1ola","Lengua_de_se%C3%B1as_mexicana","Idioma_de_se%C3%B1as_de_Nicaragua","Lengua_de_se%C3%B1as_peruana","Lengua_de_se%C3%B1as_uruguaya","Lengua_de_signos_valenciana","Lengua_de_se%C3%B1as_venezolana","Lengua_de_se%C3%B1as_en_los_beb%C3%A9s_y_ni%C3%B1os_peque%C3%B1os","D%C3%ADa_Internacional_de_las_Lenguas_de_Se%C3%B1as","ISSN","Biblioteca_Virtual_Miguel_de_Cervantes","Wayback_Machine","Ethnologue","SIL_International","Harvard_University_Press","MIT_Press","Cambridge_University_Press","Oxford_University_Press","Alfred_L._Kroeber","Wayback_Machine","Oliver_Sacks","Wayback_Machine","William_C._Stokoe","William_C._Stokoe","Wayback_Machine","Cervantes_Virtual","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","National_Archives_and_Records_Administration","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings"]}
{"url":"Charles_F._Hockett","titulo":"Charles F. Hockett","contenido":"Charles Francis Hockett ( * 17 de enero de 1916 - 3 de noviembre de 2000) fue un linguista estadounidense que desarrollo muchas ideas influyentes en el estructuralismo americano.  Represento la fase postbloomfieldiana del estructuralismo, a menudo tomaba como referente el distribucionalismo o el estructuralismo taxonomico.  En su \"Apunte sobre la Estructura\" argumenta que la linguistica puede ser vista como un juego y como una ciencia. Un linguista como el jugador (actor) tiene libertad para la experimentacion sobre todas las expresiones de una lengua, pero ningun criterio para comparar su analisis con otros linguistas. Tarde en su carrera, lo conocian por su ataque a la linguistica chomskiana que el llamo \"una teoria desovada por una generacion de viboras\".  A la edad de dieciseis a\u00f1os, Hockett se matricula en la Universidad de Estado de Ohio en Columbus, Ohio, donde recibio su Licenciatura en Letras y la Maestria de Artes en Historia Antigua.  Al matricularse en Ohio, Hockett se interesa en el trabajo de Leonard Bloomfield, padre del distribucionalismo conductista. Hockett siguio su formacion academica en la Universidad de Yale, donde estudio antropologia y linguistica y recibio su Ph.D. en Antropologia en 1939.  Estudiando en Yale, Hockett coincide con varios otros linguistas influyentes como Edward Sapir, George P. Murdock, y Benjamin Whorf. La disertacion de Hockett estaba basada en su trabajo en el terreno en Potawatomi; su trabajo sobre la sintaxis Potawatomi fue publicado en 1939 en la revista Language.  La recepcion se realiza a traves del canal auditivo. La emision se realiza a traves del canal oral.  La se\u00f1al de la emision circula en todas las direcciones posibles y quien recibe el mensaje es capaz de saber de donde viene.  Habla de las emisiones, estas son transitorias. Desaparecen rapidamente.  Los participantes de una lengua pueden intercambiarse sus papeles. Asi tenemos que el emisor se puede convertir en receptor y viceversa.  Tiene que ver con la consciencia del hecho de ser hablantes, somos conscientes de nuestras emisiones y de los efectos que producen en el receptor.  Los sonidos del lenguaje humano estan especializados para la comunicacion. Cuando los perros jadean es para refrescarse. Cuando los humanos hablan, es para transmitir informacion.  En un sistema de lengua sus unidades tienen un significado fijo, cada expresion tiene que ir asociada a un significado. Cualquier sistema de comunicacion que establezca una relacion entre se\u00f1al y una informacion del mundo real es semantico.  Es sinonimo de \u201cconvencionalidad\u201d. Los sistemas de lengua son arbitrarios. La convencionalidad es fruto de un acuerdo entre los hablantes. No tiene por que existir una relacion entre el signo y el significado.  Tienen que existir unidades discretas, es decir, bien diferenciadas.  Nos indica que mediante un conjunto limitado de elementos podemos comprender un conjunto ilimitado de elementos.  Los lenguajes humanos siempre han de estar doblemente articulados, esta caracteristica tiene que ver con la cuestion estructuralista de Saussure:  Indica que los lenguajes humanos se transmiten culturalmente de generacion en generacion.  Es el criterio que nos indica que todas las lenguas son susceptibles de ser aprendidas.  Es la posibilidad de transmitir informacion falsa, es decir, mensajes emitidos con conciencia, sabiendo que son falsas.  Posibilidad de ofrecer los codigos linguisticos en un tiempo pasado, presente o futuro. ","snippet":"Charles Francis Hockett ( * 17 de enero de 1916 - 3 de noviembre de 2000) fue un linguista estadounidense que desarrollo muchas ideas influyentes en el estructuralismo americano.  Represento la fase p","enlaces_salientes":["Charles_F._Hockett","Charles_F._Hockett","Charles_F._Hockett","Columbus_(Ohio)","Ohio","Estados_Unidos","Ithaca_(Nueva_York)","Nueva_York_(estado)","Universidad_Estatal_de_Ohio","Universidad_Yale","Antrop%C3%B3logo","Ling%C3%BCista","Ling%C3%BC%C3%ADstica","Universidad_Cornell","Universidad_Rice","Emma_Gregores","Jorge_A._Su%C3%A1rez","Academia_Nacional_de_Ciencias_(Estados_Unidos)","Academia_Estadounidense_de_las_Artes_y_las_Ciencias","17_de_enero","1916","3_de_noviembre","2000","Ling%C3%BCista","Estadounidense","Leonard_Bloomfield","Universidad_de_Yale","Ph.D.","Edward_Sapir","George_P._Murdock","Benjamin_Whorf","American_Scientist","Scientific_American","Internet_Archive","Rice_University","The_New_York_Times","13_de_noviembre","2000","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","CiNii","Syst%C3%A8me_universitaire_de_documentation","BIBSYS"]}
{"url":"Boca_humana","titulo":"Boca humana","contenido":"La boca, tambien denominada como una cavidad bucal o cavidad oral, siendo en realidad divisiones en si de la boca del aparato digestivo;\u200b es la abertura corporal por la que se ingieren alimentos.\u200b Esta ubicada en la cara y constituye en su mayor parte el aparato estomatognatico, asi como la primera parte del aparato digestivo. La boca se abre a un espacio previo a la faringe llamado cavidad oral, o cavidad bucal.  La boca humana esta cubierta por los labios superior e inferior y desempe\u00f1a funciones importantes en diversas actividades como el lenguaje y en expresiones faciales, como la sonrisa.  La boca es un gran indicador de la salud del individuo. La mucosa, por ejemplo, puede verse mas clara, palida o con manchas blancas, indicador de proliferaciones epiteliales.  En la boca se pueden distinguir tres tipos de mucosas:  Boca procede del latin bucca, voz de origen celta; confer galo boc[c]a.\u200b  La boca puede considerarse una estancia con cinco paredes:\u200b  Los anexos de la boca son los dientes, las encias y las amigdalas.  La boca humana sana es una de las partes mas colonizadas de nuestros cuerpos, contiene cientos de diferentes especies de bacterias, virus y hongos. El equilibrio ecologico en la cavidad oral se mantiene mediante las interacciones entre especies.\u200b La mayoria de las especies son comensales, pero pueden volverse patogenicas en respuesta a cambios en el medio ambiente de la cavidad bucal.\u200b  Por razon de las terminaciones nerviosas sensitivas de la mucosa oral, casi todas las enfermedades que afectan a la cavidad bucal no relacionada con los dientes se presentan con dolor. Las alteraciones que afectan a la mucosa presentan ulceracion, vesiculas y cambios de color.  En la boca se distinguen dos tipos de fenomenos fundamentales para la digestion: ","snippet":"La boca, tambien denominada como una cavidad bucal o cavidad oral, siendo en realidad divisiones en si de la boca del aparato digestivo;\u200b es la abertura corporal por la que se ingieren alimentos.\u200b Est","enlaces_salientes":["Boca_humana","Boca_humana","Boca_humana","Lat%C3%ADn","Terminologia_Anatomica","Terminologia_Anatomica","Anatom%C3%ADa","Sistema_org%C3%A1nico","Aparato_digestivo","Alimento","Cara","Aparato_estomatogn%C3%A1tico","Aparato_digestivo","Faringe","Humano","Labio","Lenguaje","Sonrisa","Salud","Submucosa","Tejido_%C3%B3seo","Lengua_(anatom%C3%ADa)","Labio","Mejilla","Lengua_(anatom%C3%ADa)","Paladar","Istmo_de_las_fauces","Faringe","Diente","Enc%C3%ADa","Am%C3%ADgdala_far%C3%ADngea","Comensal","%C3%9Alcera","Ves%C3%ADcula_(piel)","Estomatitis","Candidiasis","Micosis","Candida_albicans","Afta","Conjuntivitis","S%C3%ADndrome_de_Behcet","Actinomicosis","Actinomyces_bovis","Angina_de_Vincent","S%C3%ADfilis","Sialadenitis","Tumor","Benigno","Mucocele","R%C3%A1nula","%C3%89pulis","Neoplasia","Estomatitis_gangrenosa","C%C3%A1ncer_de_boca","Fen%C3%B3meno_f%C3%ADsico","Masticaci%C3%B3n","Fen%C3%B3menos_qu%C3%ADmicos","Saliva_(l%C3%ADquido)","Afta","Aparato_digestivo","Est%C3%B3mago","Esofagogastroduodenoscopia","ISBN","ISBN","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","CIE-11","Terminolog%C3%ADa_Anat%C3%B3mica"]}
{"url":"O%C3%ADdo","titulo":"Oido","contenido":"El oido es un organo sensorial que permite percibir los sonidos, formando el sentido de la audicion,\u200b y en mamiferos tambien se encarga del equilibrio. El oido se puede dividir para su estudio en tres secciones: oido externo, oido medio y oido interno.\u200b  La percepcion del sonido es un fenomeno complejo que se desarrolla en varias etapas. En primer lugar se realiza la captacion de las ondas sonoras gracias a la membrana del timpano. En segundo lugar la se\u00f1al mecanica recogida por el timpano debe transformarse en impulsos nerviosos, proceso que ocurre en el oido interno. En tercer lugar los impulsos nerviosos a traves del nervio auditivo son enviados al cerebro para ser procesados en la corteza cerebral.\u200b  El espectro auditivo, es decir la gama de frecuencias que el oido puede percibir, es variable dependiendo de la especie animal. El ser humano puede detectar sonidos de entre 0 y 140 decibelios con un rango de frecuencias comprendido entre 40 y 20\u00a0000 hercios. Las ballenas pueden percibir infrasonidos con una frecuencia inferior a 40 hercios. Algunos animales carnivoros como el perro son capaces de detectar ultrasonidos con una frecuencia superior a 20\u00a0000 hercios que un humano es incapaz de oir.\u200b  El oido externo esta formado por dos partes: El pabellon auricular y el conducto auditivo externo.\u200b  El oido medio es una cavidad llena de aire que esta separada por el timpano del conducto auditivo externo y entra en comunicacion con el oido interno a traves de dos peque\u00f1os orificios: la ventana oval y la ventana redonda. En el interior del oido medio se encuentra una cadena de huesecillos unidos entre si por articulaciones de tipo sinovial, son los huesos mas peque\u00f1os del cuerpo y reciben el nombre de martillo, yunque y estribo. El oido medio esta conectado con la nasofaringe por un conducto de reducidas dimensiones que se llama trompa faringotimpanica o trompa de Eustaquio.\u200b  El oido interno o laberinto esta ubicado en el seno del hueso temporal del craneo. Existe un laberinto oseo y un laberinto membranoso. El laberinto oseo no es mas que la capsula osea que rodea al laberinto membranoso, y este ultimo consiste en un sistema de conductos huecos que contiene en su interior un liquido que se llama endolinfa. En el espacio que queda entre el laberinto oseo y el laberinto membranoso se encuentra la perilinfa.  El oido interno se divide en dos porciones diferenciadas. La primera esta destinada al mantenimiento del equilibrio y se encuentra formada por el vestibulo y los conductos semicirculares. La segunda tiene como funcion la audicion y esta constituida por la coclea o caracol.\u200b El vestibulo se divide en dos sectores que se llaman utriculo y saculo, mientras que la coclea o caracol contiene el organo de Corti responsable de transformar la energia mecanica de las ondas sonoras en impulsos electricos que posteriormente se transmiten al cerebro a traves del nervio auditivo o nervio vestibulococlear.\u200b  Estas porciones estan separadas unas de otras por dos membranas. La membrana vestibular o de Reissner sirve de separacion entre el conducto coclear y la rampa vestibular, mientras que la membrana basilar sirve de separacion entre el conducto coclear y la rampa timpanica. A lo largo de la membrana basilar se encuentra el organo de Corti que contiene alrededor de 16\u00a0000 celulas con cilios que constituyen los receptores de la audicion.  El conducto coclear esta lleno de un liquido que se llama endolinfa rico en K (161\u00a0mmol/l) y pobre en Na (1\u00a0mmol/l) y en calcio (0.02\u00a0mmol/l). La rampa timpanica y vestibular contiene otro liquido diferente que se llama perilinfa cuyas concentraciones ionicas son las inversas, es rico en Na y pobre en K.  La membrana vestibular es tan delgada, que no dificulta el paso de las vibraciones sonoras desde la rampa vestibular a la rampa media. Por lo tanto en cuanto a transmision del sonido, la rampa vestibular y media se consideran como una unica camara. La importancia de la membrana vestibular depende de que conserve la endolinfa en la rampa media necesaria para el normal funcionamiento de las celulas ciliadas.\u200b  Forma parte del oido interno y esta ubicado en la coclea o caracol, a veces se designa con el nombre de organo espiral y tiene un papel fundamental en el proceso de audicion.\u200b Esta formado por un epitelio engrosado de caracteristicas complejas. Dispone de dos tipos de celulas: Celulas ciliadas y celulas de sosten.  Para que se produzca la audicion las ondas sonoras deben penetrar por el conducto auditivo externo hasta alcanzar el timpano. La vibracion de la membrana timpanica se transmite a traves de los huesecillos del oido medio, pasando del martillo al yunque y de este al estribo. El estribo transmite las vibraciones a la perilinfa del oido interno a traves de la ventana oval. En la coclea la energia mecanica de las se\u00f1ales acusticas se transforma en impulsos electricos que a traves de nervio acustico son transportados a la region temporal de la corteza cerebral donde son procesados. Por tanto podria decirse que el organo con el que en realidad escuchamos es el cerebro.\u200b Se conoce con el nombre de sordera central o agnosia auditiva a la dificultad que presentan algunas personas para reconocer sonidos debido a una lesion cerebral que afecta a las areas relacionadas con la audicion. Estas personas tienen sin embargo todas las partes del oido y el nervio auditivo en buena situacion funcional por lo que la deficiencia en la capacidad para discriminar sonidos se debe unicamente a la lesion del cerebro.\u200b  Existen diferentes problemas de salud relacionados con el oido, uno de los mas frecuentes es la hipoacusia o perdida de audicion que en muchos casos es inducida por una exposicion cronica a un ruido de una intensidad superior a 85 decibelios.\u200b Otras patologias son: patologias del conducto auditivo externo, rotura del timpano, otitis, ototoxicidad, otoesclerosis, colesteatoma, enfermedad de Meniere, vertigo, tinnitus y trauma acustico.  En diferentes culturas las orejas se han adornado con joyas perforando el lobulo de esta. Tambien se han colocado adornos para estirar y agrandar los lobulos como adorno.\u200b  La lesion en las orejas ha estado presente desde la epoca romana como metodo de reprimenda o castigo..\u200b  El pabellon auricular tiene un efecto sobre la apariencia facial. En las sociedades occidentales, las orejas protuberantes (presentes en aproximadamente el 5\u00a0% de los europeos etnicos) se han considerado poco atractivas, sobre todo si son asimetricas.\u200b La primera cirugia para reducir la proyeccion de orejas prominentes fue publicada en la literatura medica por Ernst Dieffenbach en 1845, y el primer informe de caso en 1881.\u200b    Las orejas puntiagudas son una caracteristica de algunas criaturas del folclore como el bogeyman, el curupira brasile\u00f1o\u200b o la ara\u00f1a de tierra japonesa.\u200b Ha sido una caracteristica de personajes del arte antiguo como el de la Antigua Grecia\u200b y la Europa medieval.\u200b Las orejas puntiagudas son una caracteristica comun de muchas criaturas en el genero fantastico,\u200b incluyendo elfos,\u200b\u200b\u200b hadas,\u200b\u200b duendes,\u200b hobbits,\u200b u orcos.\u200b Tambien son una caracteristica de las criaturas del genero de terror, como los vampiros.\u200b\u200b Las orejas puntiagudas se encuentran del mismo modo en el genero de ciencia ficcion; por ejemplo, entre las razas Vulcano y Romulano del universo Star Trek.\u200b y en la saga Star Wars estan los rodianos, una especie alienigena con esa caracteristica.  El pabellon auricular ayuda a dirigir el sonido a traves del canal auditivo hacia el timpano. La compleja geometria de las crestas en la superficie interna de algunos oidos de mamiferos ayuda a enfocar con precision los sonidos producidos por las presas, utilizando se\u00f1ales de ecolocalizacion. Estas crestas pueden considerarse como el equivalente acustico de una lente de Fresnel y pueden verse en una amplia gama de animales, incluidos el murcielago, el aye-aye, los galagos, el zorro orejudo, el lemur raton y otros.\u200b\u200b\u200b  Algunos grandes primates como los gorilas y los orangutanes (y tambien los humanos) tienen musculos de la oreja sin desarrollar que son estructuras vestigiales no funcionales, pero que aun son lo suficientemente grandes como para ser facilmente identificables.\u200b Un musculo capaz de mover la oreja, por cualquier motivo, ha perdido esa funcion biologica. Esto sirve como evidencia de homologia entre especies relacionadas. En los seres humanos, existe una variabilidad en estos musculos, de modo que algunas personas pueden mover sus orejas en varias direcciones, y se ha dicho que es posible que otras obtengan ese movimiento mediante ensayos repetidos.\u200b En tales primates, la incapacidad de mover la oreja se compensa principalmente por la capacidad de girar facilmente la cabeza en un plano horizontal, una habilidad que no es comun a la mayoria de los monos.\u200b  Solo los animales vertebrados tienen oidos, aunque muchos invertebrados detectan el sonido utilizando otros tipos de organos de los sentidos. En los insectos, los organos timpanicos se utilizan para escuchar sonidos distantes. Se encuentran en la cabeza o en otro lugar, segun la familia de insectos.\u200b ","snippet":"El oido es un organo sensorial que permite percibir los sonidos, formando el sentido de la audicion,\u200b y en mamiferos tambien se encarga del equilibrio. El oido se puede dividir para su estudio en tres","enlaces_salientes":["O%C3%ADdo","O%C3%ADdo","O%C3%ADdo","Lat%C3%ADn","Terminologia_Anatomica","Terminologia_Anatomica","Anatom%C3%ADa","Sistema_org%C3%A1nico","Sistema_auditivo","Audici%C3%B3n","Mam%C3%ADfero","Equilibriocepci%C3%B3n","O%C3%ADdo_externo","O%C3%ADdo_medio","O%C3%ADdo_interno","T%C3%ADmpano","O%C3%ADdo_interno","Nervio_auditivo","Ser_humano","Decibelio","Hercio","Ballena","Ultrasonido","O%C3%ADdo_externo","Pabell%C3%B3n_auricular","Conducto_auditivo_externo","Hueso_temporal","Cerumen","O%C3%ADdo_medio","3D","O%C3%ADdo_medio","Ventana_oval","Ventana_redonda","Nasofaringe","Trompa_de_Eustaquio","T%C3%ADmpano","Tejido_(biolog%C3%ADa)","Col%C3%A1geno","Epitelio","Hueso_temporal","Epitelio","Epitelio","C%C3%A9lula","Mastoides","Trompa_de_Eustaquio","Nasofaringe","Vena_yugular","Huesecillos_del_o%C3%ADdo","Martillo_(hueso)","Yunque_(hueso)","Estribo_(hueso)","Ventana_oval","Trompa_de_Eustaquio","Epitelio","O%C3%ADdo_interno","Hueso_temporal","Endolinfa","Conductos_semicirculares","Coclea","Utr%C3%ADculo_(o%C3%ADdo)","S%C3%A1culo","Nervio_auditivo","Conductos_semicirculares","Endolinfa","Perilinfa","Endolinfa","Perilinfa","Sonido","%C3%93rgano_de_Corti","Audici%C3%B3n","Ventana_oval","Corteza_cerebral","Agnosia_auditiva","Arteria_car%C3%B3tida_interna","Arteria_maxilar_interna","Car%C3%B3tida_interna","Arteria_men%C3%ADngea_media","Arteria_far%C3%ADngea_ascendente","Arteria_occipital","Arteria_laber%C3%ADntica","Arteria_cerebelosa_media","Arteria_basilar","Hipoacusia","Decibelio","Patolog%C3%ADas_del_conducto_auditivo_externo","Rotura_del_t%C3%ADmpano","Otitis","Ototoxicidad","Otoesclerosis","Colesteatoma","Enfermedad_de_M%C3%A9ni%C3%A8re","V%C3%A9rtigo","Tinnitus","Trauma_ac%C3%BAstico","L%C3%B3bulo_(anatom%C3%ADa)","Ernst_Dieffenbach","Folclore","Bogeyman","Curupira","Antigua_Grecia","Europa_medieval","G%C3%A9nero_fant%C3%A1stico","Elfo","Hada","Duende","Hobbit","Orco","Terror","Vampiro","Ciencia_ficci%C3%B3n","Vulcano_(Star_Trek)","Romulanos","Star_Trek","Star_Wars","Rodiano","Pabell%C3%B3n_auricular","Canal_auditivo","T%C3%ADmpano","Ecolocalizaci%C3%B3n","Lente_de_Fresnel","Murci%C3%A9lago","Daubentonia_madagascariensis","Galago","Otocyon_megalotis","Microcebus","Hominidae","Gorila","Orangutan","Humano","Vestigial","Homolog%C3%ADa_(biolog%C3%ADa)","Mono","Loxodonta_africana","Vulpes_zerda","Vulpes_lagopus","Primate","Macaca_fascicularis","Tub%C3%A9rculo_de_Darwin","Vertebrado","Invertebrado","Insecto","%C3%93rgano_timp%C3%A1nico","Desarrollo_del_o%C3%ADdo","Sistema_auditivo","Otorrinolaringolog%C3%ADa","Audiometr%C3%ADa","Efectos_del_ruido_en_la_salud","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","JSTOR","Digital_object_identifier","Bibcode","PubMed_Identifier","Digital_object_identifier","Charles_Darwin","The_Descent_of_Man,_and_Selection_in_Relation_to_Sex","Digital_object_identifier","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","CIE-11","Medical_Subject_Headings","Descriptores_en_Ciencias_de_la_Salud","Terminolog%C3%ADa_Anat%C3%B3mica","Foundational_Model_of_Anatomy"]}
{"url":"Idioma_croata","titulo":"Idioma croata","contenido":"Indoeuropeo Eslavo Eslavo meridional Eslavo suroccidental Serbocroata  El idioma croata o dialecto croata es una variante estandar del idioma serbocroata. La division es en parte similar a la existente entre el espa\u00f1ol de Espa\u00f1a y el de Latinoamerica,\u200b\u200b\u200b\u200b si bien las diferencias dentro del ambito linguistico del espa\u00f1ol son mayores que las del croata y el serbio.\u200b\u200b El croata y las otras asi llamadas variedades del serbocroata se diferencian en peque\u00f1as cosas (uso de palabras, gramatica); sin embargo, son equivalentes y mutuamente inteligibles.\u200b\u200b El croata es hablado principalmente en Croacia, en donde es oficial, asi como en las zonas de Bosnia y Herzegovina, Eslovenia, Serbia, Macedonia del Norte, Montenegro y Kosovo habitadas por croatas.\u200b  Es, asimismo, la lengua nativa hablada por la diaspora croata, que se encuentra diseminada mayormente en paises como Alemania, Rumania, Canada, Eslovaquia, Australia, Estados Unidos y en America del Sur (principalmente en Argentina y Chile), donde hay amplias concentraciones de croatas nativos o descendientes de croatas que aun mantienen sus costumbres, como el idioma.  Los comienzos de la lengua escrita se pueden remontar al siglo\u00a0IX, cuando el antiguo eslavo eclesiastico fue adoptado como idioma liturgico. Mas tarde comenzo a ser usado para finalidades seglares y llego a ser conocido como version croata del antiguo eslavo. Las dos variantes; liturgico y seglar, continuaron en uso hasta a mediados del siglo\u00a0IX; escritos en el alfabeto conocido como glagolitico. Hasta finales del siglo\u00a0XI, los textos medievales croatas eran escritos de tres maneras: latina, glagolitica, y cirilica croata (arvatica, poljicica, bosancica), y tambien en tres idiomas: croata eslavo, latino y antiguo eslavo. El ultimo, desarrollado en lo que se refiere como la variante croata de la iglesia eslava entre los siglos XII y XVI. El documento antiguo mas importante de instruccion croata es la Tabla de Baska, de finales del siglo\u00a0XI. Es una gran tabla de piedra encontrada en la peque\u00f1a iglesia de Santa Lucia en la isla croata de Krk, conteniendo el texto escrito en chakavski (hoy un dialecto del croata) y en escritura croata glagolitica. Hoy en dia, existe gran cantidad de monumentos en piedra o escritos en glagolitico, y tambien son considerados importantes en la historia de la nacion; ya que mencionan a Zvonimir, en ese entonces rey de Croacia.  Sin embargo, los textos representativos lujosos y adornados de la iglesia croata eslava pertenecen a los siglos XIII y XIV, cuando coexistieron con la literatura vernacula croata. Son el Misal del Principe Novak; de Istria (1368), el Evangelio de Reims (1395), que recibio su nombre de la ciudad donde llego finalmente), el Misal del Duque Hrvoje de Bosnia y la Fractura en Dalmatia (1404), el primer libro impreso en la lengua croata (1483).  Tambien, durante el siglo\u00a0XIII comenzaron a aparecer textos politicos y diplomaticos. Los mas importantes son: Delimitacion de Istria (Istarski Razvod), de 1275 y El Codigo de Vinodol de 1288, ambos en el dialecto chakavski. La literatura del dialecto de Shtokavski, basada en los textos originales chakavski de procedencia religiosa (misales, breviarios, libros de rezo) aparecieron casi un siglo mas adelante. El texto vernaculo mas importante en shtokavski es el libro croata del rezo de Vaticano (c. 1400).  Tanto la lengua usada en textos legales como la usada en la literatura glagolitica cayeron gradualmente bajo influencia del vernaculo, que afecto considerablemente sus sistemas fonologico, morfologico y lexico. De las canciones seculares y religiosas de los siglos XIV y XV, en los festivales de la iglesia fueron compuestos en el vernaculo. Los escritores de la poesia religiosa croata temprana (zacinjavci), los traductores y los redactores introdujeron gradualmente el vernaculo en sus trabajos. Este el zacinjavci era los precursores de la produccion literaria rica de los siglos XV y XVI. La lengua de poemas, de traducciones, del milagro y de los juegos religiosos de la moralidad contribuyo al caracter popular de la literatura croata medieval.  Aunque los primeros textos puramente vernaculos en un croata diferente de la iglesia eslava datan del siglo\u00a0XIII, es en los siglos XIV y XV cuando emergio la lengua croata moderna (registrado en textos como libro croata del rezo del Vaticano a partir de 1400) en la forma (morfologia, fonologia y sintaxis) que se diferencia solamente levemente de lengua de estandar croata contemporanea. En la traduccion de la Biblia del manuscrito de Bartolomeo Kasic, la estandarizacion de la lengua croata se puede remontar de nuevo al primer diccionario illirio (Fausto Verancio: Linguarum-Latinae de Europae del nobilissimarum del quinque de Dictionarium, Italicae, Germanicae, Dalmatiae et Ungaricae, Venecia 1595) y la primera gramatica croata (Bartolomeo Kasic: Duo del libri de los illyricae de las lenguas de Institutionum, Roma 1604). La lengua de la traduccion de Kasic del Jesuit de la biblia (Antiguo y Nuevo testamento, 1622-1636; inedito hasta 2000) en el dialecto shtokavo-ijekavo (el estilo adornado de la literatura del renacimiento de la Republica de Ragusa) esta tan cerca de la lengua estandar contemporanea (ortografia aparte), ya que los linguistas del siglo\u00a0XIX tomaron a la gran Republica como modelo para estandarizar dicho idioma.  Este periodo, a veces llamado \u201cEslavismo barroco\u201d fue crucial en la formacion del idioma literario que le dio la fuerza para convertirse en el florecimiento y testigo de un nacionalismo croata adormecido por siglos, asi como en el referente estandar croata de la lengua, y reconocido en mas de tres estudios como uno de los precursores que ayudaron a formar al idioma croata moderno. Uno de los trabajos linguisticos de mas transcendencia fue el de los filologos jesuitas Bartolomeo Kasic y Giacomo Micaglia; la otra actividad literaria energica fue la del fraile franciscano de origen bosnio Mateo Divkovic, que hizo la traduccion de las escrituras de la Reforma de Contador (cuentos populares de la Biblia, los sermones y las polemicas), y que en sus adaptaciones contenian extensos pasajes en croata, en bosnio, y a su vez contando con gran adaptacion en los anteriores estados, aparte de Herzegovina y Croacia; y, pasado pero no lo menos, en la poesia esteticamente refinada de Ivan Gundulic (de Republica de Ragusa).  Este \u00abtriple logro\u00bb del eslavismo barroco por la primera mitad del siglo\u00a0XVII dio la piedra de fundacion sobre la cual se erigio de manera definitiva el resurgimiento de un movimiento ilirico, que luego termino en el trabajo de la estandarizacion de la lengua.  En ultimas epocas medievales hasta el siglo\u00a0XVII, la parte principal de Croacia semi-autonoma fue gobernada por dos dinastias domesticas de los principes (bani), Zrinski y Frankopan, que fueron ligados por la inter-union. Hacia el siglo\u00a0XVII los dos procuraron unificar a Croacia tambien en el nivel cultural y lingual, y con la gran prevision seleccionaron como su lengua oficial el dialecto transitorio de Ikavski-Kaikavski, este era un intermedio malo aceptable entre todos los dialectos croatas principales (Chakavski, Kaikavski e Ikavski-Shtokavski); se utiliza hasta ahora en el norte de Istra, y en los valles de los rios de Kupa, de Mreznica y de Sutla, y esporadico a otras partes en Croacia central tambien. Esta forma estandarizada entonces se convirtio en la lengua cultivada de la elite de la administracion y de intelectuales de la peninsula de Istra a lo largo de la costa croata, a traves del Croacia central para arriba en los valles norte\u00f1os del Drava y del Mura.  El apogeo cultural de este estandar unificado en el siglo\u00a0XVII es representado por las ediciones \u201cdel sirena del mora de Adrianskog\u201d (Syren del Mar Adriatico) y del \u201ctovarus de Putni\u201d (acompa\u00f1amiento que viaja), estos que estan en el plano cultural mas alto de Europa contemporanea. Sin embargo, este primer renacimiento linguistico en Croacia fue detenido por la ejecucion politica de ambas dinastias por el emperador romano santo en Viena en 1671. Entonces, la elite croata en el siglo\u00a0XVIII abandono gradualmente este estandar croata combinado, y despues de una iniciativa austriaca (Viena, 1850), substituida les por el uniforme neo-estokaviano.  Pero, debido a la situacion linguistica del croata unico, el formar formal de la lengua de estandar croata era un proceso que tomo casi cuatro siglos para terminar: El croata es una lengueta de tres dialectos (una manera algo simplista de distinguir entre los dialectos es referir al pronombre que, que es ca, kaj, sto adentro, respectivamente, cakavian, kajkavian y los dialectos stokavian) y escritura cirilica y latina glagolitica de la lengua de tres escrituras (croata/occidental/bosnio, con la escritura latina como el ultimo ganador). El obstaculo final a la lengua literaria croata unificada (basada en Troubadour croata vernaculo celebrado, renacimiento y Barroco\u2014literatura de las siglas TRB) (desde c. 1490 a c.\u00a01670) de Dalmacia, Republica de Ragusa y Boka Kotorska fueron superados por la estandarizacion de Ljudevit Gaj nacional del despertar croata de la norma escrita latina entre los a\u00f1os 1830 y 1850. Gaj y su movimiento ilirico (centrados en Zagreb, capital de Croacia, de discurso kajkavian) eran, sin embargo, mas politico que linguistico. \u201cEligieron\u201d dialecto stokavian porque no tenian ninguna otra opcion-stokavian realista, o, mas exacto, neostokavian (una version de stokavian que emergio en los siglos XV y XVI) estaba la lengua literaria croata principal del siglo\u00a0XVII.  La preocupacion principal de los linguistas del siglo\u00a0XIX era alcanzar una norma y una ortografia estandar y unificadas; un esfuerzo siguio por las caracteristicas linguisticas croatas peculiares que se pueden describir como \u201cpasion para los neologismos\u201d o la invencion vigorosa de la palabra, originando de la naturaleza uristat de la lengua literaria croata. Una de las particularidades de la \u201ctrayectoria de desarrollo\u201d de la lengua croata es que no hay figura elevada entre los linguistas/los filologos croatas, porque la lengua vernacula infiltrada osmoticamente en la \u201calta cultura\u201d via trabajos literarios tan alli no era ninguna necesidad de las reformas linguisticas revolucionarias son suficientes.  El desarrollo de la lengua en el siglo\u00a0XIX se superpuso a las agitaciones que acontecieron en la lengua serbia. Fue el reformador Vuk Karadzic, que creo una lengua serbia energica e inventiva y que el estilanizacion y ortografica del idioma popular linguistico serbio hizo una rotura radical con el pasado; hasta su actividad por la primera mitad del siglo\u00a0XIX, los serbios habian estado utilizando la variante serbia de la iglesia eslava y de una lengua Ruso-Eslava hibrida. Su \u201cdiccionario serbio\u201d, publicado en Viena 1818 (junto con la gramatica a\u00f1adida), era el solo trabajo mas significativo de la cultura literaria serbia que formo el perfil de la lengua serbia (y, el primer diccionario y gramatica serbios hasta el momento). Despues del incentivo de la burocracia austriaca que prefirio una cierta clase de idiomas croatas y serbias unificadas por razones administrativas practicas, en 1850, el franco esloveno Miklosic del filologo iniciaron una reunion de dos filologos y escritores serbios, Vuk Karadzic y \u0110uro Danicic junto con cinco \u201chombres croatas de letras\u201d: Ivan Mazuranic, Demetrio Demetar, Stjepan Pejakovic, Ivan Kukuljevic y Vinko Pacel. El acuerdo de Viena en las caracteristicas basicas de un \u201ccroata o un serbio unificado\u201d o lengua \u201cserbocroata\u201d fue firmado por los ocho participantes (Miklosic incluyendo).  La influencia de Karadzic en idioma estandar croata fue significativa, filologos y linguistas de Dubrovnik como Pero Budmani, Josip Cobenzl, Milan Resetar, tomaron las reformas vukonianas y las traspasaron a las aulas de las escuelas, sobre todo en algunos aspectos de la gramatica y de la ortografia; muchos otros cambios de Karadzic fueron adquiridos por el croata, hasta el dia de hoy.  Ambas idiomas compartieron la base comun del dialecto neo-shtokavo de los eslavos del sur, pero el acuerdo de Viena no tenia ningun efecto en realidad hasta que un estandar unificado aparecio en el final del siglo\u00a0XIX en que los simpatizantes croatas de Vuk Karadzic, conocidos como el croata Vukovitas, escribio las primeras (de la posicion ventajosa de la escuela linguistica dominante de la neo-gramatica) gramaticas, ortografias y diccionarios modernos de la lengua que llamaron serbo-croata (el profesor Pero Budmani de Dubrovnik fue el primero en denominarla serbo-croata). La gramatica monumental sida autor por el linguista croata preeminente Tomislav Maretic de fin de siecle (gramatica y estilistica de la lengua croata o serbia) y el diccionario por Broz e Ivekovic (diccionario croata) fijo temporalmente (gramatical, sintactica y lexicamente) el estandar elastico de esta lengua hibrida.  El establecimiento del estado yugoslavo fue un acontecimiento importante en la historia del croata. El Reino de los Serbios, Croatas y Eslovenos (1918-1929) duro hasta el enero de 1929, cuando paso a llamarse Reino de Yugoslavia (1929-1941), que intento utilizar una lengua comun en el conjunto de la ideologia yugoslava supranacional. Esto significo que el croata y el serbio no fueron desarrollados individualmente, sino que habia una tentativa de forjar una lengua a partir de los dos.  Los serbios eran el grupo etnico en gran medida mas grande del reino y la forja resultante era una lengua basada en el serbio, lo que significo la serbianiacion de la lengua \"mixta\". En los a\u00f1os 20 y los a\u00f1os 30, las caracteristicas lexicas, sintacticas, ortograficas y morfologicas del serbio fueron prescritas oficialmente para los libros de textos croatas y la comunicacion general. Este proceso de la \u201cunificacion\u201d en una lengua serbocroata fue preferido por los linguistas croatas del neo-grammarian, el ejemplo mas notable que era el influyente filologo y traductor Tomislav Maretic. Sin embargo, esta escuela estaba virtualmente extinta a finales de los a\u00f1os 1920 y los linguistas croatas mas influyentes desde entonces (tales como Petar Skok, Stjepan Ivsic y Petar Guberina) eran unanimes en la reafirmacion del croata como lengua separada. Durante la creacion de la Banovina de Croacia dentro de Yugoslavia en 1939, las cosas comenzaron a cambiar. La situacion se facilitada durante la Segunda Guerra Mundial, con la capitulacion de Yugoslavia y la creacion del Estado Independiente de Croacia (1941-1945), cuando el caudillo fascista Ante Pavelic intento reimponer una ortografia morfologica mas antigua, que precedia las prescripciones ortograficas de Ivan Broz a partir de 1892.  Una orden oficial firmada por Pavelic y cofirmada por Mile Budak y Milovan Zanic desaprobo todas las palabras importadas y prohibio en agosto de 1941 el uso de cualquier palabra extranjera que se pudiera substituir por neologismos croatas. No asombrosamente, no se publicaron ni diccionarios croatas ni gramaticas croatas en este periodo. En el periodo comunista (1945 a 1990), era el subproducto del centralismo y del \u201cinternacionalismo comunistas\u201d. Lo que las intenciones, el resultado era el mismo: la supresion de las caracteristicas basicas que distinguen croata del serbio, en terminos de ortografia y vocabulario. Ningun diccionario croata (aparte del \u201ccroata o el serbio historico\u201d, concebido en el siglo\u00a0XIX) aparecio hasta 1985, cuando el centralismo estaba en decadencia.  En RFS Yugoslavia, la lengua serbia y la terminologia eran las del \u201cfuncionario\u201d en algunas areas: los militares, la diplomacia, las instituciones yugoslavas federales (varios institutos y centros de investigacion), los medios del estado, y la jurisprudencia en el nivel federal. Tambien, la lengua en Bosnia y Herzegovina fue gradualmente \"serbizada\" en todos los niveles del sistema educativo y de la administracion de la republica. La unica institucion que dio importancia a la lengua croata, fue virtualmente el Instituto Lexicografico de Zagreb, dirigida por el escritor croata Miroslav Krleza. Esta politica linguistica unitaria fue animada por el estado.  A pesar de la declaracion de intencion del AVNOJ (el Consejo de Antifascistas para la Liberacion Nacional de Yugoslavia) en 1944, que proclamo la igualdad de todas los idiomas de Yugoslavia (esloveno, croata, serbio y macedonio), en la practica todo se habia inducido hacia la supremacia de la lengua serbia. Esto fue hecho bajo pretexto del \u201cenriquecimiento mutuo\u201d y de la \u201cunidad\u201d, esperando que la fase transitoria de la vida relativamente pacifica entre la gente en Yugoslavia llevaria eventual a una de fusion en la nacion yugoslava supranacional y, proporcionaria indiscutiblemente a una firme Serbianizacion.  Sin embargo, esta \u201cingenieria supranacional\u201d fue condenada discutible desde el principio. Las naciones que formaron el estado yugoslavo fueron formadas mucho antes su existencia y toda la unificacion ejerce presion sobre solamente las relaciones inter-etnicas/nacionales envenenadas y exacerbadas, haciendo el estado llegar a ser simplemente efimero.  El solo esfuerzo mas importante gobernando las elites comunistas yugoslavas para borrar las \u201cdiferencias\u201d entre el croata y el serbio - e imponer en la practica la lengua serbia de Ekavian, escrita en la escritura latina, como la lengua \u201coficial\u201d de Yugoslavia - era el \u201cacuerdo supuesto de Novi Sad\u201d. En 1954, 25 de los mas influyentes filologos serbios, croatas, y montenegrinos firmaron el acuerdo de Novi Sad. Una ortografia comun del serbocroata o del \u201ccroataserbio\u201d fue compilada en una atmosfera de la represion y del miedo del estado. Habia 18 serbios y 7 croatas en Novi Sad.  El \u201cacuerdo\u201d fue considerado por los croatas como derrota para el patrimonio cultural croata. Segun el linguista croata eminente Ljudevit Jonke, fue impuesto ante los croatas. Las conclusiones fueron formuladas segun las metas que habian sido fijadas de antemano, y la discusion no tenia ningun papel importante. En mas que una decada que siguio, los principios del acuerdo de Novi Sad fueron puestos en practica. Una reaccion croata colectiva contra tal imposicion serbia de hecho entro en erupcion el 15 de marzo de 1967.  En ese dia, diecinueve instituciones de estudiante croatas y las organizaciones culturales que se ocupaban de lengua y la literatura (las universidades croatas y las academias), incluyendo los primeros escritores y linguistas croatas (Miroslav Krleza, Radoslav Katicic, Dalibor Brozovic y Tomislav Ladan entre ellos) publicaron el \u201cdeclaracion referente al nombre y el estado de la lengua literaria croata\u201d. En el declaracion, pidieron la enmienda a la constitucion que expresaba dos demandas:  La declaracion acusa a las autoridades federales de Belgrado de imponer el serbio como la lengua oficial del estado y de hacer retroceder al croata a nivel de un dialecto local. A pesar de que la \u201cdeclaracion\u201d fue condenada por autoridades comunistas yugoslavas como un arrebato del \u201cnacionalismo croata\u201d, la unificacion forzada serbocroata fue detenida esencialmente, y un nuevo statu quo permanecio hasta el final del comunismo.  En la decada entre la muerte del mariscal Tito (los 1980) y tras la finalizacion del comunismo, asi como dentro del marco de la disolucion del estado yugoslavo (1990/1991), los trabajos del hasta entonces jefe unico y comandante no pudieron suprimir las culturas y costumbres linguisticas de todas las variantes del serbo-croata que se creia habian desaparecido. Los estudios de los linguistas croatas Brozovic, Katicic y Babic; que habian estado circulando entre especialistas de forma subrepticia, o que eran impresos a la luz de la ilegalidad, dichas publicaciones filologicas constituian la base de la actual fonetica y textologia para la escision del croata actual.  Entre muchas de las monografias y estudios cientificos seriamente realizados, se pueden se\u00f1alar los trabajos llevados a cabo por la academia croata de las ciencias y de los artes, en pos del area encargada de la linguistica y particularmente de la sintaxis, encomendada a los profesores Katicic y Babic. Estas fueron realizadas entre los a\u00f1os sesenta y setenta, y posterior a su conocimiento fueron prohibidos antes de su aparicion, y por ende suprimidos de todas formas concebibles por las autoridades yugoslavas, dentro del supuesto clima de autoritarismo.  Estos trabajos, basados en los estudios y trabajos de campo, mas las diversas teorias modernas conocidas de forma subrepticia (tanto en linguistica como en fonologia de las estructuracion, la linguistica, grafologia y la lexicologia comparativa e historica, gramatica transformacional y linguistica regional) revisaron o desecharon las mas viejas \"historias de la lengua\", y restauraron la independencia de la lengua croata definitivamente, reintegrando y reafirmando las caracteristicas que se reivindicaron como especificamente croatas (en sus aspectos fonetico, morfologico, sintactico, lexico, entre otros), que habia sido suprimidos constantemente en el estado yugoslavo, y que finalmente dieron la descripcion y la prescripcion linguistica modernas a la lengua croata.  Despues de que el comunismo desapareciera y tras la independencia croata (1991), la situacion con respecto a la lengua croata se estabilizo. La publicacion de dichos estudios hacia un \"divorcio formal\" de la variante croata del serbo-croata, e inclusive terminaba el discurrir linguistico comun entre dichas lenguas, desviandose del invariable curso comun propugnado por Tito, y anunciaba la muerte finalmente del sistema serbocroata en uso hasta entonces. Dichos estudios tuvieron finalmente la posibilidad de ser publicados para ser estudiados posteriormente dentro de la nacion croata actual.  No mas debajo de las presiones politicas negativas y de imposiciones de descroatizacion, los linguistas croatas ampliaron el trabajo sobre varios programas ambiciosos e intensificaron sus estudios en areas dominantes actuales de la linguistica: linguistica matematica y de la recopilacion, sicolinguistica, adquisicion de la lengua y lexicografia historica.  A partir de 1991 encendido, los trabajos linguisticos croatas representativos numerosos fueron publicados, entre ellos cuatro diccionarios monolingues voluminosos de croata contemporaneo, los varios diccionarios especializados y los manuales normativos (la mayoria del representante que es la aplicacion el instituto para la lengua croata y la linguistica).  Para una persona presente curiosa, la caracteristica de lengua mas sensible de la sociedad croata era probablemente la recroatizacion del croata en todas las areas, de la fonetica a la semantica y (lo mas evidentemente posible) en vocabulario diario. Las ambiciones politicas desempe\u00f1aron un papel dominante en la creacion de la lengua serbocroata. Asimismo, las politicas eran otra vez un agente crucial en disolver los intentos por una lengua unificada.  Hasta la desintegracion de Yugoslavia en 1991 se considero que el croata formaba, junto con el serbio y el bosnio, una de las variedades del idioma serbocroata.  Tras la desintegracion de Yugoslavia y el cese de la aplicacion de los acuerdos linguisticos entre Croacia y Serbia se viene insistiendo mucho, sobre todo del lado croata, en la separacion de los tres idiomas. El mayor punto de acuerdo que se puede alcanzar en este sentido es el de admitir que el serbio y croata (junto con el bosnio) forman parte del diasistema eslavo centro-meridional.  El termino serbocroata se utilizo durante la mayor parte del siglo\u00a0XX para referirse al idioma comun de croatas y serbios. Dicha denominacion se uso desde 1921 hasta la Guerra de la ex Yugoslavia a principios de los a\u00f1os noventa, de modo generico para los dialectos hablados por serbios, croatas, bosnios y montenegrinos.  Con la separacion de Yugoslavia y la aparicion de los nuevos estados, el termino \u201cserbocroata\u201d cayo en desuso, excepto en el ambito de la linguistica. Hoy en dia, la denominacion de dicho idioma es una cuestion polemica, en la que tienen mucho que ver la historia y la politica.  El idioma croata se subdivide a su vez en tres dialectos: Cakavski, Stokavski y Kajkavski. El cakavski es hablado en Istria, el golfo de Kvarner (Quarnero), el litoral de Dalmacia y en algunas regiones del centro de Croacia. El stokavski se habla principalmente en Dalmacia y Eslavonia, y por ultimo, el kajkavski es hablado en el norte y noroeste de Croacia; siendo el primero el considerado mas prestigioso y mas hablado. La lengua croata tambien es hablada en Bosnia-Herzegovina, donde constituye constitucionalmente una de sus comunidades nacionales.  Otra clasificacion divide el idioma croata en cuatro variantes principales: la ikavski, ekavski, ijekavski y la jekavski. No se trata propiamente de dialectos, sino de variantes en relacion con la evolucion de la vocal protoeslava jat.  Ejemplos:  Ikavski: divojka, zvizda, misto, razumit, rika, dilIjekavski: djevojka, zvijezda, mjesto, razumjeti, dijel/dijeo  La mayoria de los fonemas del croata tienen correspondencia en espa\u00f1ol. Sin embargo existen algunos fonemas que no estan presentes en castellano (si bien en su mayoria son conocidos a traves de otros idiomas). Estos sonidos estan representados por las letras: c, z, s, z, \u0111 y dz.  En este idioma, tambien es gramaticamente correcto de afirmar que el uso de la letra R puede estar considerada como una vocal algunas veces.  El idioma croata consta de 25 consonantes:  En el croata existen siete casos gramaticales: nominativo, genitivo, dativo, acusativo, vocativo, locativo e instrumental. Como en el resto de idiomas eslavos con sistema de casos, los adjetivos se declinan de forma ligeramente distinta a los sustantivos.  Se distinguen tres generos gramaticales: masculino, femenino y neutro. Dentro del genero masculino, se establece una distincion entre animado y no animado.  Hay dos numeros gramaticales: singular y plural. ","snippet":"Indoeuropeo Eslavo Eslavo meridional Eslavo suroccidental Serbocroata  El idioma croata o dialecto croata es una variante estandar del idioma serbocroata. La division es en parte similar a la existent","enlaces_salientes":["Idioma_croata","Idioma_croata","Idioma_croata","Croacia","Bosnia_y_Herzegovina","Serbia","Vojvodina","Eslovenia","Montenegro","Austria","Burgenland","Europa_central","Familia_de_lenguas","Indoeuropeo","Lenguas_eslavas","Lenguas_eslavas_del_sur","Idioma_serbocroata","Sistema_de_escritura","Alfabeto_de_Gaj","Alfabeto_glagol%C3%ADtico","Croacia","Bosnia_y_Herzegovina","Voivodina","Serbia","Burgenland","Uni%C3%B3n_Europea","ISO_639-1","ISO_639-2","ISO_639-3","Lengua_est%C3%A1ndar","Idioma_serbocroata","Espa%C3%B1ol_de_Espa%C3%B1a","Espa%C3%B1ol_de_Am%C3%A9rica","Idioma_espa%C3%B1ol","Gram%C3%A1tica","Inteligibilidad_mutua","Croacia","Bosnia_y_Herzegovina","Eslovenia","Serbia","Macedonia_del_Norte","Montenegro","Kosovo","Di%C3%A1spora_croata","Alemania","Rumania","Canad%C3%A1","Eslovaquia","Australia","Estados_Unidos","Am%C3%A9rica_del_Sur","Argentina","Chile","Antiguo_eslavo_eclesi%C3%A1stico","Liturgia","Alfabeto","Glagol%C3%ADtico","Santa_Luc%C3%ADa","Krk","Dmitar_Zvonimir","Bosnia","Fausto_Verancio","Rep%C3%BAblica_de_Ragusa","Giacomo_Micaglia","Ivan_Gunduli%C4%87","Rep%C3%BAblica_de_Ragusa","Dalmacia","Rep%C3%BAblica_de_Ragusa","Boka_Kotorska","Ljudevit_Gaj","Zagreb","Croacia","Lengua_serbia","Vuk_Karad%C5%BEi%C4%87","Dubrovnik","Yugoslavia","A%C3%B1os_1920","Banovina_de_Croacia","Estado_Independiente_de_Croacia","Ante_Paveli%C4%87","RFS_Yugoslavia","Miroslav_Krle%C5%BEa","AVNOJ","Idioma_serbocroata","Belgrado","A%C3%B1os_1980","Ca%C3%ADda_del_comunismo","Guerras_yugoslavas","Sintaxis","A%C3%B1os_1960","A%C3%B1os_1970","Idioma_serbo-croata","Croacia","Diccionarios","Ling%C3%BC%C3%ADstica","Guerras_yugoslavas","Yugoslavia","Idioma_serbio","Idioma_bosnio","Idioma_serbocroata","Yugoslavia","Croacia","Serbia","Diasistema","Lenguas_eslavas_meridionales","Croacia","Serbia","Guerras_de_Yugoslavia","Protoeslavo","Idioma_espa%C3%B1ol","%C4%8C","%C4%86","%C5%A0","%C5%BD","Caso_nominativo","Caso_genitivo","Caso_dativo","Caso_acusativo","Caso_vocativo","Caso_locativo","Caso_instrumental","Adjetivos","Sustantivos","Masculino","Femenino","Neutro","Singular","Plural","Idioma_serbocroata","Idioma_bosnio","Idioma_montenegrino","Idioma_serbio","Idioma_esloveno","Literatura_en_croata","Snje%C5%BEana_Kordi%C4%87","ISBN","Open_Library","ISBN","OCLC","Open_Library","ISBN","OCLC","OCLC","ISSN","OCLC","OCLC","Etnolog%C3%ADa","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus"]}
{"url":"Fonema","titulo":"Fonema","contenido":"Un fonema (del griego antiguo \u03c6\u03c9\u03bd\u03b7\u03bc\u03b1 fonema 'voz humana, sonido de la voz') es una unidad sonora que puede distinguir una palabra de otra en un lenguaje dado. Es decir, es la articulacion minima de un sonido vocalico o consonantico.\u200b Por otra parte, los fonemas son unidades teoricas basicas postuladas para estudiar el nivel fonico-fonologico de una lengua humana. Es decir, un fonema es cada una de las unidades segmentales postuladas para un sistema fonologico que de cuenta de los sonidos de una lengua.  En los sonidos consonanticos de acuerdo con el punto de articulacion podemos encontrar: labiales, labiodentales, coronales, interdentales, dentales, alveolares, postalveolares, retroflejas, palatales, velares, uvulares, faringeas y glotales. Sin embargo, es dificil encontrar lenguas que usen simultaneamente todos estos puntos de articulacion. Respecto al modo de articulacion se tienen oclusivas, fricativas, africadas y aproximantes.  Entre los criterios para decidir que constituye o no un fonema se requiere que exista una funcion distintiva: son sonidos del habla que permiten distinguir palabras en una lengua.\u200b Asi, los sonidos [p] y [b] son fonemas del espa\u00f1ol porque existen palabras como /pata/ y /bata/ que tienen significado distinto y su pronunciacion solo difiere en relacion con esos dos sonidos (sin embargo, en mandarin los sonidos [p] y [b] son percibidos como variantes posicionales del mismo fonema).  Desde un punto de vista estructural, el fonema pertenece a la lengua, mientras que el sonido pertenece al habla. La palabra <casa>, por ejemplo, consta de cuatro fonemas (/k/, /a/, /s/, /a/). A esta misma palabra tambien corresponden en el habla, acto concreto, cuatro sonidos, a los que la fonologia denominara alofonos, y estos ultimos pueden variar segun el sujeto que lo pronuncie. La distincion fundamental de los conceptos fonema y alofono, esta en que el primero es una huella psiquica de la neutralizacion (un modelo) del segundo que se efectua en el habla.  Un fonema puede dividirse conceptualmente en varios rasgos distintivos que se realizan simultaneamente. Estos rasgos son, segun algunos marcos teoricos, las unidades minimas en fonologia.  Los fonemas no son sonidos con entidad fisica, sino abstracciones mentales o abstracciones formales de los sonidos del habla. En este sentido, un fonema puede ser representado por una familia o clase de equivalencia de sonidos (tecnicamente denominados fonos), que los hablantes asocian a un sonido especifico durante la produccion o la percepcion del habla. Asi por ejemplo en espa\u00f1ol el fonema /d/ [+ obstruyente, + alveolar, + sonoro] puede ser articulado como oclusiva [d] a principio de palabra o tras nasal o pausa larga, pero es pronunciado como aproximante [\u00f0] entre vocales o entre vocal y liquida, asi /dedo/ se pronuncia [de\u00f0o] donde el primer y tercer sonido difieren en el grado de obstruccion aunque son similares en una serie de rasgos (los propios del fonema).  Un sonido o fono se caracteriza por una serie de rasgos foneticos y articulatorios. El numero de dichos rasgos y su identificacion es tarea de la fonetica. Un fono es cualquiera de las posibles realizaciones acusticas de un fonema.  La fonologia en cambio no necesariamente trata entes claramente definibles en terminos acusticos. Como realidad mental o abstracta un fonema no tiene por que tener todos los rasgos foneticos especificados. Por ejemplo, en diversas lenguas la aspiracion es relevante para distinguir pares minimos pero un fonema del espa\u00f1ol puede pronunciarse mas o menos aspirado segun el contexto y la variante linguistica del hablante pero en general para un fonema del espa\u00f1ol no esta especificado el grado de aspiracion. En cambio, en lenguas como el chino mandarin o el coreano un fonema tiene predefinido el rasgo de aspiracion.  El numero de fonemas de una lengua es finito y limitado en cada lengua y el numero de alofonos potencialmente definibles, especialmente si especificamos rasgos foneticos muy sutiles, es potencialmente ilimitado y varia segun el contexto fonetico y la articulacion linguistica individual de los hablantes, a su estudio se dedicara la llamada fonetica experimental. En cuanto al numero de fonemas, este no tiene por que ser fijo, y puede cambiar con el cambio linguistico, de hecho en un instante dado, puede ser que puedan construirse dos sistemas fonologicos con diferente numero de fonemas si se introducen reglas de pronunciacion mas complejas. Sin embargo, la mayoria de analisis del espa\u00f1ol esta en torno a 24 unidades (5 vocales y 19 consonantes), aunque no todas las variedades de espa\u00f1ol tienen el mismo numero de fonemas.  Podemos decir que fonema es una unidad fonologica diferenciadora, indivisible linealmente y abstracta.  Dada la distincion entre fonema y fono, existe otra forma de concebir un fonema como una especificacion incompleta de rasgos foneticos. Esta relacion es de hecho equivalente a la del fonema como conjunto de fonos: el fonema seria el conjunto de rasgos foneticos comunes a todos los fonos que forman la clase de equivalencia del fonema.  Mas formalmente si / f / es un fonema que puede ser articulado como todo un conjunto de fonos { \u03d5 1 , \u03d5 2 , . . . , \u03d5 n } ,\\phi _{2},...,\\phi _{n}\\}\\;} entonces podemos definir una relacion de pertenencia de cada uno de esos alofonos al fonema si definimos la funcion rasg ( \u22c5 ) }(\\cdot )\\,} que asigna a cada fono o fonema el conjunto de rasgos relevantes. Un alofono es una realizacion posible de un fonema si pertenece a la clase de equivalencia de sonidos asociada al fonema, que en terminos de rasgos equivale a que:   Por el contrario a partir del conjunto de fonos del mismo fonema { \u03d5 1 f , \u03d5 2 f , . . . , \u03d5 n f } ^{f},\\phi _{2}^{f},...,\\phi _{n}^{f}\\}\\;} se puede definir el conjunto de rasgos relevantes para definir el fonema:   Podemos aplicar las ideas anteriores a analizar los fonemas obstruyentes /b, d, g/ del espa\u00f1ol. Como es sabido entre estas podemos distinguir una realizacion oclusiva y otra aproximante, por lo que podemos escribir:   Y si introducimos un conjunto de rasgos foneticos relevantes como [+obstruyente], [+oclusivo], [+ aproximante], [+ labial], [+alveolar], [+velar], [-fricativo], [+sonoro], ... se tiene que:  Fijado un conjunto de rasgos foneticos se pueden definir los sonidos de la lengua, en principio no hay limite para lo fina que pueda ser la distincion que establecen estos rasgos; potencialmente la lista de sonidos puede hacerse tan grande como se quiera si se incluyen mas y mas rasgos. Sin embargo el numero de fonemas es un asunto diferente, puesto que muchos de los anteriores sonidos seran equivalentes desde el punto de vista linguistico. Un sistema fonologico es un par F = ( F , R ) }=(F,})} donde F es un inventario de fonemas abstractos definidos por unos pocos rasgos del conjunto total (las lenguas naturales por lo general oscilan entre 10 y 30 fonemas, aunque se han descrito lenguas con cerca de 100 fonemas), y R }} es el conjunto de reglas que en funcion del contexto relativo de aparicion de los fonemas definen totalmente los rasgos foneticos, asi el conjunto de reglas puede pensarse como una aplicacion del conjunto de secuencias admisibles de fonemas en el conjunto de secuencias admisibles de sonidos:   R : \u03a3 0 ( F ) \u2192 \u03a3 0 ( S ) }:\\Sigma _{0}(F)\\to \\Sigma _{0}(S)}  Donde \u03a3 0 ( F ) , \u03a3 0 ( S ) (F),\\Sigma _{0}(S)\\,} representan el conjunto de secuencias finitas de fonemas y el conjunto de secuencias finitas de sonidos o alofonos.  De acuerdo con la caracterizacion clasica de estructuralismo fonemas son entidades abstractas de un estudio sistematizado del lenguaje.  Noam Chomsky y Morris Halle establecieron una interpretacion psicologica de los fonemas como unidades mentales. En el proceso de adquisicion del lenguaje, el ni\u00f1o aprende que caracteristicas foneticas de un sonido son esenciales para el significado de una palabra son esenciales y cuales no lo son. Tomando como base el curso de este proceso, las categorias son vistas como correspondencias mentales (representaciones) del fonema, definido originalmente de manera puramente linguistica. De acuerdo con este punto de vista, los fonemas tienen una existencia independiente en el sistema de procesamiento de lenguaje mental del hablante: el sistema involucra, de hecho, en el procesamiento del lenguaje de estas unidades hacia atras. (Una hipotesis contraria seria la afirmacion de que la impresion solo se crea por la interaccion de las palabras aprendidas y las percepciones individuales de los hablantes. Las categorias de fonemas se encuentran en el sistema a trabajar.)  La influencia de estas categorias de fonemas en la percepcion puede ser especialmente observada cuando se trata de una lengua extranjera. Las distinciones foneticas que no juegan ningun papel en su propia lengua, no son percibidas por el oido no entrenado en otros idiomas o son asignadas incorrectamente al mismo fonema.  Todas las variedades de espa\u00f1ol tienen estos fonemas, para los que se especifican los rasgos foneticos o rasgos distintivos minimos:  Se pueden hacer las siguientes generalizaciones sobre la pronunciacion:  Algunas variedades constan ademas de los fonemas:  Ademas de estas variaciones en el inventario fonemico, el numero de alofonos que presentan los fonemas del espa\u00f1ol presentan peculiaridades en algunas variedades. Por ejemplo en la modalidad linguistica andaluza las secuencias /s+b/, /s+d/ y /s+g/ dan lugar a las fricativas sordas [\u0278], [\u03b8] y [x] (estando el primer alofono ausente de otras variedades de espa\u00f1ol).  En cuanto a la grafia cabe tener en cuenta que:  Frecuencias de aparicion (en porcentaje):\u200b  Todos los lenguajes conocidos utilizan solo un peque\u00f1o subconjunto de los muchos sonidos posibles que pueden producir los organos del habla humanos y, debido a la alofonia, el numero de fonemas distintos generalmente sera menor que el numero de sonidos identificables diferentes. Los diversos idiomas varian considerablemente en el numero de fonemas que tienen en sus sistemas (aunque la variacion aparente a veces puede resultar de los diferentes enfoques adoptados por los linguistas que realizan el analisis). El inventario fonemico total en idiomas varia desde tan solo 11 en el idioma rotokas y piraha hasta 141 en kung.\u200b  El numero de vocales fonemicamente distintas puede ser tan bajo como dos, como en el idioma ubije y el arrente. En el otro extremo, la lengua bantu ngwe tiene 14 vocales, 12 de las cuales pueden ser largas o cortas, formando 26 vocales orales, mas seis vocales nasalizadas, largas y cortas, lo que hace un total de 38 vocales; el idioma \u01c3xoo logra 31 vocales puras, sin contar su variacion adicional por longitud de vocal, al variar la fonacion. En cuanto a los fonemas consonantes, el puinave y el idioma papu tauade tienen cada uno solo siete, y el rotokas presenta seis. El !xoo, por otro lado, tiene alrededor de 77 y el ubykh 81. El idioma ingles usa un conjunto bastante grande de 13 a 21 fonemas vocales, incluidos diptongos, aunque sus 22 a 26 consonantes estan cerca del promedio.  Algunos idiomas, como el frances, no tienen tono ni acentuacion fonemica, mientras que el cantones y varias de las lenguas kam-sui presentan nueve tonos, y se ha afirmado que una de las lenguas kru, el wobe, tiene 14,\u200b aunque esto es disputado.\u200b  El sistema de vocales mas comun consta de cinco vocales /i/, /e/, /a/, /o/, /u/. Las consonantes mas comunes son /p/, /t/, /k/, /m/, /n/.\u200b Relativamente pocos idiomas carecen de estas consonantes, aunque sucede: por ejemplo, el arabe carece de /p/, el hawaiano estandar carece de /t/, el mohawk y el tlingit no presentan /p/ y /m/, el hupa carece de /p/ y un /k/ simple, idioma samoano coloquial no cuenta con /t/ y /n/, mientras que el rotokas y el quileute no usa la /m/ y /n/.  Los fonemas del lenguaje de se\u00f1as son conjuntos de caracteristicas de articulacion. Stokoe fue el primer estudioso en describir el sistema fonemico de la lengua de signos americana. Identifico localizadores, la forma de la mano, y el movimiento. Algunos investigadores tambien disciernen la orientacion, la expresion facial o articulacion de la boca. Al igual que con los idiomas hablados, cuando se combinan funciones, crean fonemas. Del mismo modo que las lenguas habladas, las lenguas de se\u00f1as tienen pares minimos que difieren en un solo fonema. Por ejemplo, los signos de la lengua americana para el padre y la madre difieren minimamente con respecto a la ubicacion, mientras que la forma y el movimiento de las manos son identicos; la ubicacion es, por tanto, contrastiva.  Los investigadores ya no utilizan el sistema de notacion y terminologia de Stokoe para describir los fonemas de los lenguajes de signos. Se ha descubierto que la investigacion de William Stokoe, aunque todavia se considera fundamental, no caracteriza suficientemente el lenguaje de se\u00f1as estadounidense u otros lenguajes de se\u00f1as.\u200b Por ejemplo, las funciones no manuales no se incluyen en la clasificacion de Stokoe. Desde entonces, Brentari,\u200b Sandler,\u200b y van der Kooij han propuesto modelos mas sofisticados de fonologia del lenguaje de signos.\u200b  En el lenguaje estadounidense, el termino cherema (del griego antiguo: \u03c7\u03b5\u03c1 \"mano\") es sinonimo de fonema, utilizado anteriormente en el estudio de lenguajes de signos. Un chereme, como unidad basica de la comunicacion por se\u00f1as, es funcional y psicologicamente equivalente a los fonemas de las lenguas orales, y ha sido reemplazado por ese termino en la literatura academica. La cherologia, como estudio de las unidades minimas en el lenguaje, equivale a la fonologia. Los terminos ya no estan en uso. En cambio, los terminos fonologia y fonema (o rasgo distintivo) se utilizan para enfatizar las similitudes linguisticas entre las lenguas habladas y de se\u00f1as.\u200b  Los terminos fueron acu\u00f1ados en 1960 por William Stokoe\u200b en la Universidad Gallaudet para describir los lenguajes de signos como lenguajes verdaderos y completos. Aunque entonces fue una idea controvertida, el concepto ahora es universalmente aceptado en linguistica. Sin embargo, la terminologia de Stokoe se ha abandonado en gran medida.\u200b ","snippet":"Un fonema (del griego antiguo \u03c6\u03c9\u03bd\u03b7\u03bc\u03b1 fonema 'voz humana, sonido de la voz') es una unidad sonora que puede distinguir una palabra de otra en un lenguaje dado. Es decir, es la articulacion minima de un","enlaces_salientes":["Fonema","Fonema","Fonema","Griego_antiguo","Vocal","Consonante","Fonolog%C3%ADa","Lengua_natural","Punto_de_articulaci%C3%B3n","Consonante_labial","Consonante_labiodental","Consonante_coronal","Consonante_interdental","Consonante_dental","Consonante_alveolar","Consonante_postalveolar","Consonante_retrofleja","Consonante_palatal","Consonante_velar","Consonante_uvular","Consonante_far%C3%ADngea","Consonante_glotal","Modo_de_articulaci%C3%B3n","Oclusiva","Fricativa","Africada","Aproximante","Palabra","Habla","Habla","Al%C3%B3fono","Rasgo_fon%C3%A9tico_distintivo","Abstracci%C3%B3n_(psicolog%C3%ADa)","Clase_de_equivalencia","Fono","Articulaci%C3%B3n_fon%C3%A9tica","Obstruyente","Consonante_alveolar","Oclusiva","Consonante_l%C3%ADquida","Fon%C3%A9tica","Par_m%C3%ADnimo","Variante_ling%C3%BC%C3%ADstica","Idioma_coreano","Lengua_natural","Articulaci%C3%B3n_ling%C3%BC%C3%ADstica","Cambio_ling%C3%BC%C3%ADstico","Idioma_espa%C3%B1ol","S%C3%ADlaba","Sonido","Lengua_natural","Noam_Chomsky","Morris_Halle","Ling%C3%BC%C3%ADstica","Transcripci%C3%B3n_fon%C3%A9tica_del_espa%C3%B1ol_con_el_AFI","Rasgo_fon%C3%A9tico","Al%C3%B3fono","Modalidad_ling%C3%BC%C3%ADstica_andaluza","Andaluc%C3%ADa_Oriental#Hablas_de_Andaluc\u00eda_Oriental","Oposici%C3%B3n_fonol%C3%B3gica","Espa%C3%B1ol_medieval","Extranjerismo","Fono","Fon%C3%A9tica_articulatoria","Al%C3%B3fono","Idioma_rotokas","Idioma_pirah%C3%A3","Idioma_kung","Vocal","Idioma_ubij%C3%A9","Idioma_arrernte","Lenguas_bant%C3%BAes","Idioma_%C7%83x%C3%B3%C3%B5","Fonaci%C3%B3n","Consonante","Idioma_puinave","Idioma_ingl%C3%A9s","Diptongo","Idioma_franc%C3%A9s","Tono_(ling%C3%BC%C3%ADstica)","Acento_pros%C3%B3dico","Canton%C3%A9s","Lenguas_kam-sui","Lenguas_kru","Idioma_%C3%A1rabe","Idioma_hawaiano","Idioma_mohawk","Idioma_tlingit","Idioma_samoano","Idioma_quileute","Lenguaje_de_se%C3%B1as","Lengua_de_signos_americana","Universidad_Gallaudet","Fonolog%C3%ADa","Fon%C3%A9tica","Lengua_natural","Fonolog%C3%ADa_del_espa%C3%B1ol","Rima","Oxford_University_Press","ISBN","ISBN","OCLC","Wayback_Machine","ISBN","OCLC","ISBN","ISBN","ISBN","ISBN","OCLC","OCLC","OCLC","JSTOR","OCLC","ISBN","OCLC","JSTOR","Digital_object_identifier","OCLC","ISBN","Wikcionario","Diccionario_de_la_lengua_espa%C3%B1ola","Control_de_autoridades","Gemeinsame_Normdatei","Biblioteca_Nacional_de_la_Dieta","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica"]}
{"url":"De%C3%ADxis","titulo":"Deixis","contenido":"El termino deixis (del griego antiguo \u03b4\u03b5\u03be\u03c2 deixis, 'demostracion', 'referencia'\u200b) indica el uso de un punto de referencia en el habla que solo se puede identificar por el contexto; el uso del termino se remonta al filosofo griego estoico Crisipo de Solos. Los deicticos,\u200b por tanto, son los elementos gramaticales cuyo significado completo e interpretacion precisa cambian por completo segun la perspectiva personal, espacial o temporal del hablante en un momento determinado: los pronombres personales (yo, tu, nosotros... ) o los adverbios de tiempo (hoy, ayer, entonces... ) y de espacio (aqui, alla, detras... ) son ejemplos de representacion deictica.\u200b  En pragmatica, las expresiones deicticas dependen, para su interpretacion, del contexto del hablante, sobre todo del contexto fisico de los elementos extralinguisticos. Los deicticos son las palabras que se interpretan segun la situacion de comunicacion, y necesitan que se muestre de algun modo a que se refieren.  En la oralidad y en las lenguas de se\u00f1as, puede se\u00f1alarse o mirarse el referente en cuestion. En la escritura, en cambio, dicho referente ya fue mencionado con anterioridad. En cualquiera de sus formas de expresion, el receptor puede completar su significado si conoce todo el contexto. Si alguien dice: \"Se lo daras a ella, no a el\", el destinatario de la orden debera conocer a que personas concretas se refieren los pronombres el y ella en esa situacion.  Segun se refiera a personas, objetos, lugares o espacios temporales, la deixis se clasifica como sigue:  Cuando un pronombre no se refiere a un elemento de la situacion de comunicacion sino a otra palabra mencionada antes en el texto se denomina anafora. Por ejemplo: Alicia acaricio a su gato y este salio corriendo por la ventana. Es, pues, la facultad que poseen las palabras denominadas deicticas o deicticos: los pronombres, algunos determinantes y algunos adverbios, de hacer referencia a una palabra que ha aparecido antes (deixis anaforica) o que aparecera despues (deixis cataforica) o de se\u00f1alar circunstancias espaciales, personales y temporales.  La llamada deixis exoforica o deixis ad oculos es aquella en la que el referente al que alude el pronombre es extralinguistico, es decir, se situa en la situacion comunicativa real. La deixis de la fantasia o deixis ad fantasma es el se\u00f1alamiento a objetos no presentes en la situacion de discurso. Se realiza en el plano de la memoria o la imaginacion: En aquellos a\u00f1os eso era corriente. Algunos ejemplos ilustrativos adicionales son:  La deixis tambien se utiliza en las oraciones como un tipo de mecanismo de sustitucion. O tambien un deixis se emplean para se\u00f1alar personas, espacios o tiempos que no tienen un referente directo. Algunos adverbios de tiempo y espacio de los pronombres personales pueden tener esta funcion: yo, tu, el, ahi, aqui, alla, ahora, despues, entonces. ","snippet":"El termino deixis (del griego antiguo \u03b4\u03b5\u03be\u03c2 deixis, 'demostracion', 'referencia'\u200b) indica el uso de un punto de referencia en el habla que solo se puede identificar por el contexto; el uso del termino ","enlaces_salientes":["Deixis","Deixis","Deixis","Historia_del_idioma_griego","Punto_de_referencia","Habla","Estoicismo","Crisipo_de_Solos","Pragm%C3%A1tica","Contexto_ling%C3%BC%C3%ADstico","Pronombre","Determinante_(ling%C3%BC%C3%ADstica)","Pronombre","Comunicaci%C3%B3n","An%C3%A1fora_(gram%C3%A1tica)","Pronombre","Determinante_(ling%C3%BC%C3%ADstica)","Adverbio","Referente","Adposici%C3%B3n","Adverbio","An%C3%A1fora_(gram%C3%A1tica)","Determinante_(ling%C3%BC%C3%ADstica)","Postposici%C3%B3n","Preposici%C3%B3n","Pronombre","Sintagma_preposicional","Control_de_autoridades","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa"]}
{"url":"Doble_articulaci%C3%B3n","titulo":"Doble articulacion","contenido":"En linguistica, la doble articulacion es una de las caracteristicas distintivas del lenguaje humano, frente a otros sistemas de comunicacion. El concepto fue introducido por Andre Martinet. Hace referencia al modo en el que se organiza el lenguaje, distinguiendo entre dos niveles:  Asi, tenemos la secuencia ser del primer nivel y los elementos /s/ /e/, /r/ del segundo nivel, los cuales, combinados de diferente forma, dan lugar a otro signo diferente: res.  Los fonemas no tienen significado en si mismos, pero permiten distinguir significados.\u200b Si se realiza la conmutacion de un fonema por otro en un determinado contexto, el significado varia, como ocurre con pocos/poros/polos/posos.\u200b  La doble articulacion del lenguaje posibilita que, con un numero peque\u00f1o de unidades (los fonemas), se construyan infinitos mensajes, incluso aquellos nunca emitidos ni oidos anteriormente.\u200b  Ademas de los fonemas, tambien el acento lexico y la entonacion poseen capacidad para diferenciar los significados, como por ejemplo ocurre en /bebe/ y /bebe/.\u200b  Aunque esta teoria sea de corte funcionalista (ya que Martinet fue discipulo de Nikolai Trubetskoi) cabe destacar que Charles F. Hockett utilizo esto para introducir la idea de la creatividad del lenguaje, pensamiento caracteristico de la escuela generativista, que afirma que con un numero finito de elementos se puede crear un numero infinito de constituyentes.  En todos los sistemas de comunicacion se diferencian unidades primarias (con significado), pero estas no se componen necesariamente de elementos.\u200b Al parecer, la mayoria de los sistemas de comunicacion animal no presentan la propiedad de la doble articulacion, y los que si la tienen no combinan entre si sus unidades como se unen los morfemas para formar infinitos enunciados.\u200b Asi, no es posible considerar que la danza de las abejas este formada por elementos mas sencillos: la danza constituye un todo, cuyo significado lo da la forma completa.\u200b ","snippet":"En linguistica, la doble articulacion es una de las caracteristicas distintivas del lenguaje humano, frente a otros sistemas de comunicacion. El concepto fue introducido por Andre Martinet. Hace refer","enlaces_salientes":["Doble_articulaci%C3%B3n","Doble_articulaci%C3%B3n","Doble_articulaci%C3%B3n","Ling%C3%BC%C3%ADstica","Andr%C3%A9_Martinet","Morfema","Significado","Conmutaci%C3%B3n","Acento_l%C3%A9xico","Entonaci%C3%B3n","Nikol%C3%A1i_Trubetsk%C3%B3i","Charles_F._Hockett","Gram%C3%A1tica_generativa","Finito","Infinito","Significado","Comunicaci%C3%B3n_animal","Enunciado","Danza_de_las_abejas","Oxford_University_Press","ISBN","Control_de_autoridades"]}
{"url":"Morfema","titulo":"Morfema","contenido":"En morfologia linguistica, un morfema es un fragmento minimo capaz de expresar un significado, y que o bien coincide con un lexema, o bien unido a uno modifica su sentido. En ciertas terminologias, se distingue entre un lexema, que puede usarse aislado, y un morfema, que solo puede usarse conectado a un lexema, y ambos tipos son llamados conjuntamente monemas; sin embargo hoy en dia se prefiere llamar morfema a cualquier monema, y entonces se distingue entre morfemas libres que no necesitan unirse a otros morfemas (por ejemplo pronto), y morfemas ligados que siempre van unidos a otros morfemas, de los cuales al menos uno es un lexema (por ejemplo -idad en vitalidad); dicho de otro modo, para algunos autores el termino monema designa tanto a los lexemas como a los morfemas gramaticales, mientras que para otros el termino morfema designa cualquier tipo de monema, sin importar si se refiere a un monema dependiente o no dependiente.  En muchas lenguas los morfemas generalmente estan constituidos por una secuencia de fonemas, aunque en otras lenguas algunos elementos foneticos  suprasegmentales como el tono, el  acento o la nasalidad pueden constituir una diferencia fonetica que realiza un fonema, en esos casos los morfemas no son un fragmento separable de la palabra.  Tradicionalmente, se ha se\u00f1alado que el \u00abmorfema es la unidad mas peque\u00f1a con significado de la lengua\u00bb aunque dicha definicion no es demasiado util porque no aclara que debe entenderse por significado, ni establece que es una unidad relevante. Informalmente los morfemas se clasifican en varios tipos: morfemas lexicos o lexemas, y morfemas gramaticales que a su vez se clasifican en derivativos y flexivos.  En las lenguas flexivas los morfemas constituyen la parte variable de la palabra. El morfema gramatical, que tiene menos carga semantica, aparece siempre asociado al lexema, con mas carga semantica. Ambos pueden descomponerse en unidades menores: los fonemas, que no tienen significado gramatical ni semantico, y que son las unidades minimas de la fonologia.  De acuerdo con el grado de anexion a la palabra, los morfemas pueden dividirse en:  En la mayoria de las lenguas, incluyendo el espa\u00f1ol, los morfemas derivativos y flexivos pueden clasificarse ademas en:  Los interfijos por otra parte son alargamientos que en si mismos no pueden considerarse morfemas con significado gramatical ya que puede argumentarse que todo el significado recae en los afijos a los que alarga.  En espa\u00f1ol podemos encontrar dos tipos de interfijos:  No debe confundirse un interfijo con un infijo. Muchos interfijos (los antihiaticos, por ejemplo) no aportan ningun cambio de significado gramatical o referencial, mientras que los infijos siempre lo hacen (al igual que los prefijos y sufijos).  Panaderia\u00a0:  Libros\u00a0:  Avioneta\u00a0:  Cantabamos\u00a0:  Agrietado  No siempre hay una unica manera de dividir una palabra en morfemas, asi por ejemplo en la palabra libro en algunos marcos teoricos se incluiria un morfema vacio al final como marca de singular, que contrasta con el morfema -s de plural.  Es el morfema libre que puede aparecer como una palabra independiente [como los ejemplos en (1a)]. Otros morfemas son ligados y necesitan estar ligados obligatoriamente a otros morfemas [como los morfemas marcados en (1b)]:  Entre estos dos tipos estan los cliticos que son morfemas que si bien dependen sintacticamente y fonologicamente de otros morfemas admiten la interposicion entre ellos. Entre estos morfemas estan por ejemplo los articulos y las preposiciones: ","snippet":"En morfologia linguistica, un morfema es un fragmento minimo capaz de expresar un significado, y que o bien coincide con un lexema, o bien unido a uno modifica su sentido. En ciertas terminologias, se","enlaces_salientes":["Morfema","Morfema","Morfema","Monema","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Lexema","Monema","Caracter%C3%ADstica_suprasegmental","Tono_(ling%C3%BC%C3%ADstica)","Acento_pros%C3%B3dico","Lexema","Derivaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","Fonema","Fonolog%C3%ADa","Cl%C3%ADtico","Idioma_espa%C3%B1ol","Determinante_(ling%C3%BC%C3%ADstica)","Preposici%C3%B3n","Conjunci%C3%B3n_(gram%C3%A1tica)","Derivaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Campo_sem%C3%A1ntico","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","G%C3%A9nero_gramatical","N%C3%BAmero_gramatical","Verbo","Tiempo_gramatical","Prefijo","Idioma_griego","Lat%C3%ADn","Sufijo","Interfijo","Interfijo","Cl%C3%ADtico","MIT_Press","Wayback_Machine","Cambridge_University_Press","ISBN","Wikcionario","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Hjelmslev","titulo":"Louis Hjelmslev","contenido":"Louis Trolle Hjelmslev (Copenhague, 3 de octubre de 1899 - ibidem, 30 de mayo de 1965) fue un linguista danes, maestro indiscutible del Circulo Linguistico de Copenhague. En 1931 fue uno de los creadores del Circulo Linguistico de Copenhague y colaboro con Hans J\u00f8rgen Uldall en el desarrollo de la glosematica, dedicada al estudio de los glosarios con un enfoque cientifico similar al del calculo matematico. Tambien destaco como un brillante filosofo dentro del circulo linguistico de Copenhague.  Hjelmslev nacio en una familia de academicos y estudio linguistica comparativa en Copenhague, Praga y Paris.  El Circulo Linguistico de Copenhague fue fundado por Hjelmslev y otros en 1931. Se inspiro en la Escuela de Praga, y su objetivo fue crear un foro de estudio que desarrollara un nuevo tipo de investigacion linguistica. Al principio, su trabajo se centro en la fonologia, pero mas tarde derivo hacia el estructuralismo. El numero de miembros del grupo aumento rapidamente, dando lugar a un gran numero de publicaciones, incluida una serie de obras notables publicadas de forma irregular bajo el nombre Trabajos del Circulo Linguistico de Copenhague. Se creo un \"Boletin\", seguido de una revista internacional de investigacion estructuralista, los Acta Linguistica (mas tarde llamados Acta Linguistica Hafniensia). Excepto durante un breve parentesis 1934-37, periodo en el que trabajo con Uldall en la glosematica, Hjelmslev fue presidente del Circulo, abandonando el cargo poco antes de su muerte en 1965.  Siguiendo a Saussure, Hjelmslev considera el lenguaje como un sistema de signos: la esencia del lenguaje es definir un sistema de correspondencias entre sonido y significado. El analisis del lenguaje envuelve, entonces, describir cada uno de estos dos planos y sus interconexiones. La dicotomia saussureana de significante/significado es llamada por Hjemslev expresion/contenido. Cada uno de estos planos, en una determinada lengua, tiene su propia estructura. En el plano de la expresion la estructura es una secuencia de segmentos, mientras que en el plano del contenido es una combinacion de unidades componenciales mas peque\u00f1as.  La glosematica critica la linguistica anterior y contemporanea por ser trascendente, o sea, por fundamentarse en datos exteriores a la propia lengua (historicos, sociales, etc.). La linguistica debe ser inmanente. Esto significa que debe analizar los dos planos en terminos de su propia estructura.  Para hacer explicita la separacion entre el sistema y su manifestacion, Hjelmslev propuso una terminologia que no siempre ha sido bien comprendida. En primer lugar, el distingue entre forma y sustancia. La forma es el orden de lo puramente abstracto, categorias relacionales que constituyen los sistemas de expresion y de contenido de una determinada lengua, mientras que la sustancia se refiere a las manifestaciones especificas de estos elementos formales. Hjelmslev sostiene que \u201clas sustancia presupone la forma, pero no viceversa\u201d. La sustancia de una lengua particular es considerada como la manifestacion de una forma linguistica dada en un sentido (purport) particular. Este ultimo concepto es una especie de \u201cmaterial en bruto\u201d susceptible de ser usado para propositos linguisticos, pero que no posee un caracter linguistico en si mismo. El plano de cada plano envuelve la busqueda de un conjunto de los elementos constitutivos de los signos y los principios que gobiernan su organizacion.  Para tal efecto, se utiliza el \u201ctest de la conmutacion\u201d. Una innovacion de la glosematica fue aplicar este procedimiento al plano del contenido. La meta de la linguistica, para la glosematica, es desarrollar un \u201calgebra\u201d (o sistema nocional) con la cual todos los posibles sistemas linguisticos puedan ser expresados. Cada una de las gramaticas especificada por esta teoria es simplemente una red de elementos formales definidos relacionalmente. En ingles, el fonema /t/ no es una consonante oclusiva dental sorda, sino una forma del plano de la expresion que es distinta de /p/, /d/, /n/, etc., y que ocurre al inicio y al final de una silaba, despues de /s/, etc.  Para Hjelmslev, el analisis  del sistema de expresion de una determinada lengua comienza con un conjunto de elementos conmutables (o contrastables) entre si. Estos son los candidatos para el estatus de constituyentes elementales del sistema de expresion; sin embargo, el inventario podria reducirse si hay razones para representar algunos items como combinaciones o variantes de otros.  En cada uno de los planos, los constituyentes elementales de la forma linguistica se denominan taxemas. Estos son unidades minimas que pueden ser obtenidas en un analisis particular: en el plano de la expresion vienen a ser algo asi la \u201ctalla\u201d de un segmento.  Las taxemas, desde luego, se pueden manifestar foneticamente. En este caso, las unidades de la sustancia fonetica que los manifiesta son llamados fonematemas, unidad similar al fonema estructuralista. Los taxemas pueden, ademas, disolverse en combinaciones de factores primordiales llamados glosemas. En alcance, estas unidades son comparables (en el plano de la expresion) a rasgos distintivos, pero su analisis es puramente formal y universal y no depende, de ninguna forma, del contenido fonetico de los segmentos que se manifiestan en los taxemas. Los glosemas en el plano de la expresion son llamados cenemas, mientras que, en el plano del contenido, se les denomina pleremas. Hjemslev muy a menudo se refiere a los elementos como cenematicos o plerematicos.  Los taxemas de la forma de la expresion se definen a si mismos como una red de relaciones. En 1935, Hjelmslev dividio las reglas que los caracterizan en tres tipos: (a) reglas de agrupamiento, que especifican las propiedades distribucionales de los elementos; (b) reglas de alternancia, que especifican el reemplazo de un elemento por otro, y (c) reglas de implicacion, que especifican la reubicacion que se lleva a cabo bajo condiciones fonematicas. Estas tres reglas, incidentalmente, gobiernan la relacion entre los fonematemas.  Esto conlleva el hecho de que dos segmentos que alternan no puedan ser sistematicamente  relacionados por reglas de agrupamiento. En aleman, las obstruyentes sordas y sonoras que alternan a final de silaba no hacen co-ocurrencia en un grupo. Ademas, como las distinciones entre los taxemas son puramente formales y relacionales, usualmente corresponden a superficies foneticas diferentes. En frances, la shwa se mantiene fonologicamente aparte de [\u0153], no porque difieran de forma fonetica, sino porque el shwa es facultativo bajo condiciones especificas. Las situaciones anteriores hacen que Hjemslev considere el rol de (1) la neutralizacion, o \u201csuspension de la conmutacion\u201d, y (2) reducciones de dos elementos en el  inventario de taxemas a una combinacion o variantes de otros.  La distancia entre la representacion cenematica y la fonematica hace posible hacer un esfuerzo por reducir el inventario de taxemas tratando a algunos elementos como variantes o combinaciones de otros. Para este fin, el utiliza aspectos de representacion que otros considerarian arbitrarios. Asi, un solo segmento puede representarse como la manifestacion de un grupo. En danes, [\u014b] puede representarse como la manifestacion de \u2018n\u2019 antes de \u2018k\u2019 o \u2018g\u2019. De igual forma las consonantes aspiradas [p], [t] y [k] se interpretan como agrupamientos de \u2018b\u2019, \u2018d\u2019 y \u2018g\u2019 con \u2018h\u2019. Tal analisis es susceptible de ser criticado desde muchos puntos de vista.  Finalmente, es importante mencionar que la teoria de Hjelmslev se diferencia de sus contemporaneos por su interes en la estructura fonologica y las propiedades que no pueden ser localizadas dentro del alcance de un segmento.  Hjelmslev considera que un texto esta organizado jerarquicamente en parrafos, que se dividen en oraciones, que se divide en clausulas, que se dividen frases. La frase se divide en silabas y las silabas en segmentos. Podria darse una definicion fonetica de silaba, pero esto seria irrelevante para el analisis linguistico. Lo que le conviene al analisis linguistico es una definicion funcional de la silaba. Hjemslev propone varias, una de ellas es la siguiente: \u201cunidad jerarquica de organizacion que soporta un unico acento\u201d.  Para entender la definicion anterior, debemos preguntarnos por como se define \u201cacento\u201d. Para Hjelmslev, es un prosodema. Estos son elementos que caracterizan el encadenamiento sin constituirlos. Hay dos tipos de prosodemas: las modulaciones y los acentos. Un aspecto interesante de la teoria de la silaba de Hjemslev es que diferencia vocal de consonante. Una vocal es un segmento que puede constituir una silaba, las consonantes son segmentos que aparecen en posiciones dependientes de las vocales. De esta definicion se deduce que liquidas y nasales son vocales, pues pueden constituir nucleos silabicos.  Su libro mas importante, Prolegomena, fue publicado en 1943. Supone una critica de la metodologia utilizada hasta el momento por la linguistica, que resultaba descriptiva de forma no sistematica. Hjelmslev propuso una teoria linguistica cuyo fin eran una linguistica mas general y contribuir a la epistemologia general. Al igual que Saussure (1857-1913), considero la linguistica como parte de la semiotica (ciencia de los signos). Segun su analisis, el signo es una forma, es decir: es posible describirlo empiricamente, pero su sustancia es ontologicamente especulativa (puede interpretarse de forma diferente a como quiso el emisor). Un signo tambien tiene una funcion, a la que estan asociados dos elementos, el contenido y la expresion. Tambien introdujo la connotacion como elemento no linguistico de su \"calculo\" del lenguaje, rechazando la prioridad dada tradicionalmente al estudio de los sonidos (fonetica): cuando el sujeto oye algo, se pone en marcha un proceso cognitivo que traduce las ondas en datos con significado. De la misma forma, lo percibido por la vista es interpretado por el cerebro de forma inmediata, sin necesidad de ser traducido a una \"sustancia\" fonetica o en un objeto perceptual concreto. Hjelmslev afirmaba que para interpretar un signo era necesario contextualizarlo. Su concepcion de que expresion y contenido son los mecanismos connotativos generales anticipo la idea de la escuela de Greimas de que todo significado es esencialmente del mismo tipo. Por tanto, las imagenes artisticas y la literatura no se construyen unicamente de acuerdo con los mismos principios, sino que, mas en general, lo visual y lo auditivo son identicos en un nivel profundo. ","snippet":"Louis Trolle Hjelmslev (Copenhague, 3 de octubre de 1899 - ibidem, 30 de mayo de 1965) fue un linguista danes, maestro indiscutible del Circulo Linguistico de Copenhague. En 1931 fue uno de los creado","enlaces_salientes":["Louis_Hjelmslev","Louis_Hjelmslev","Louis_Hjelmslev","Copenhague","Dinamarca","Johannes_Hjelmslev","Universidad_de_Copenhague","Holger_Pedersen","Antoine_Meillet","Joseph_Vendryes","Ling%C3%BCista","Profesor_de_educaci%C3%B3n_superior","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Estructuralismo_(filosof%C3%ADa)","Catedr%C3%A1tico_de_universidad","Universidad_de_Aarhus","Copenhague","Ibidem","Ling%C3%BC%C3%ADstica","Dinamarca","C%C3%ADrculo_Ling%C3%BC%C3%ADstico_de_Copenhague","C%C3%ADrculo_Ling%C3%BC%C3%ADstico_de_Copenhague","Glosem%C3%A1tica","Escuela_de_Praga","Fonolog%C3%ADa","Estructuralismo_(ling%C3%BC%C3%ADstica)","Glosem%C3%A1tica","Epistemolog%C3%ADa","Ferdinand_de_Saussure","Semi%C3%B3tica","Empirismo","Connotaci%C3%B3n","Fon%C3%A9tica","Cognitivo","Algirdas_Julius_Greimas","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Biblioteca_de_Catalu%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Australia","Biblioteca_Nacional_de_Israel","CiNii","Syst%C3%A8me_universitaire_de_documentation","BIBSYS","Mathematics_Genealogy_Project","Istituto_Centrale_per_il_Catalogo_Unico","Deutsche_Biographie","Open_Library","Enciclopedia_Brit%C3%A1nica","Enciclopedia_Treccani"]}
{"url":"Gram%C3%A1tica","titulo":"Gramatica","contenido":"La gramatica es el estudio de las reglas y principios que gobiernan el uso de las lenguas y la organizacion de las palabras dentro de unas oraciones y otro tipo de constituyentes sintacticos. Tambien se denomina asi al conjunto de reglas y principios que gobiernan el uso de una lengua concreta; asi, cada lengua tiene su propia gramatica.\u200b\u200b  La gramatica es parte del estudio general del lenguaje denominado linguistica. Clasicamente, el estudio de la lengua se divide en cuatro niveles:  No obstante, se pueden a\u00f1adir otros niveles, tales como:  A veces se restringe el uso del termino gramatica a las reglas y principios que definen la morfologia y la sintaxis. Sin embargo, la separacion de los niveles no es totalmente nitida por diversas razones, como que ciertas reglas gramaticales se realizan en el nivel fonetico-fonologico, o que existen parametros o criterios semanticos que sirven para decidir cuando una determinada construccion se considera gramatical. Algunas tendencias de la linguistica moderna representan un regreso a los temas de la gramatica tradicional desde nuevos puntos de vista.\u200b  Las partes centrales de la gramatica han sido tradicionalmente la ense\u00f1anza de las partes del discurso y las categorias gramaticales, asi como la ense\u00f1anza de las reglas generales para combinar palabras en unidades mas largas (combinaciones de palabras, oraciones) y la estructura de estas unidades del discurso, la sintaxis.\u200b  El termino \u00abgramatica\u00bb tambien puede describir el comportamiento linguistico de grupos de hablantes y escritores, en lugar de individuos. Las diferencias de escala son importantes para este sentido de la palabra: por ejemplo, el termino \u00abgramatica inglesa\u00bb podria referirse a toda la gramatica inglesa (es decir, a las gramaticas de todos los hablantes de la lengua), en cuyo caso el termino abarca una gran cantidad de variacion.\u200b A menor escala, puede referirse solo a lo que comparten las gramaticas de todos o de la mayoria de los hablantes de ingles (como el orden de las palabras Sujeto verbo objeto en la oraciones declarativas simples). En la escala mas peque\u00f1a, este sentido de \u00abgramatica\u00bb puede describir las convenciones de una sola forma de ingles relativamente bien definida.  Una descripcion, un estudio o un analisis de estas reglas tambien puede denominarse gramatica\u200b. Un libro de referencia que describe la gramatica de una lengua se denomina \u00abgramatica de referencia\u00bb o simplemente \u00abgramatica\u00bb. Una gramatica totalmente explicita que describe exhaustivamente las construcciones gramaticas de una determinada variedad de habla se denomina gramatica descriptiva. Este tipo de descripcion linguistica contrasta con la prescripcion linguistica, un intento de desalentar o suprimir activamente algunas construcciones gramaticales, mientras que codifica y promueve otras, ya sea en un sentido absoluto o sobre una variedad estandar. Por ejemplo, algunos prescriptivistas sostienen que las oraciones en ingles no deben terminar con preposiciones, prohibicion que se remonta a John Dryden (13 de abril de 1668 - enero de 1688), cuya inexplicable objecion a esta practica quiza llevo a otros angloparlantes a evitar la construccion y a desaconsejar su uso.\u200b\u200b Sin embargo, la encadenacion de preposiciones tiene una larga historia en idiomas germanicos como el ingles, donde esta tan extendida como para ser un uso estandar.  Fuera de la linguistica, el termino gramatica se utiliza a menudo en un sentido bastante diferente. Puede utilizarse de forma mas amplia para incluir las convenciones de ortografia y puntuacion, que los linguistas no suelen considerar como parte de la gramatica, sino como parte de la ortografia, la convenciones utilizada para escribir una lengua. Tambien puede usarse de forma mas restringida para referirse a un conjunto de normas prescriptivas unicamente, excluyendo aquellos aspectos de la gramatica de una lengua que no estan sujetos a variacion o al debate sobre su aceptabilidad normativa. Para los no linguistas, \u00abLa gramatica es a menudo una forma generica de referirse a cualquier aspecto del ingles al que la gente se opone\u00bb.\u200b  El termino gramatica deriva del latin grammatica,\u200b y este del vocablo griego \u03b3\u03c1\u03b1\u03bc\u03bc\u03b1\u03c4\u03ba\u03b7 [\u03c4\u03b5\u03c7\u03bd\u03b7] (grammatike tekhne), donde tekhne significaba \u00abarte\u00bb o \u00abtecnica\u00bb y grammatike, derivado de \u03b3\u03c1\u03b1\u03bc\u03bc\u03b1 (gramma, \u00abletra\u00bb), significaba \u00abde las letras\u00bb.\u200b Para los griegos antiguos, este \u00abarte de las letras\u00bb abarcaba todos los aspectos del discurso: ortografia, sintaxis, interpretacion de los textos e incluso la critica literaria; es decir, englobaba buena parte de lo que hoy diferenciamos como filologia, como gramatica y como retorica.\u200b  Fue Dionisio de Tracia, en su Tekhne Grammatike (siglo\u00a0I\u00a0a.\u00a0C.), el que establecio una terminologia que heredarian las gramaticas occidentales posteriores, a partir de las latinas.\u200b Los romanos antiguos, con Elio Donato a la cabeza, crearon el termino litteratura (de littera, \u00abletra\u00bb) que reservaron para la parte historica e interpretativa, mientras que conservaron el helenismo grammatica para el conjunto de normas y reglas.\u200b  La gramatica formal es una codificacion del uso desarrollada basandose en la observacion. Al establecerse y desarrollarse las reglas, pudo aparecer el concepto prescriptivo, que a menudo creo una brecha entre el uso contemporaneo y lo aceptado como correcto. Los linguistas consideran normalmente que la gramatica prescriptiva no tiene justificacion alguna mas alla del gusto estetico de sus autores. De cualquier forma, las prescripciones permiten a la sociolinguistica explicar las razones por las que un determinado grupo social utiliza construcciones diferenciales.  El estudio formal de la gramatica es una parte importante de la educacion desde la edad temprana hasta el aprendizaje avanzado, aunque las reglas que se ense\u00f1an en las escuelas no constituyen una gramatica en el sentido en que los linguistas utilizan el termino, ya que son prescriptivas antes que descriptivas.  La teoria gramatical ha evolucionado a traves del uso y la division de las poblaciones humanas. Las reglas sobre el uso del lenguaje fueron estudiadas sobre todo con el advenimiento de la escritura. Las primeras gramaticas sistematicas surgieron en la Edad del Hierro en el subcontinente indio, con Iaska ( siglo\u00a0VI\u00a0a.\u00a0C.), Panini ( siglo\u00a0IV\u00a0a.\u00a0C.) y sus comentaristas Pingala (c. 200  a.\u00a0C)., Katyayana y Patanjali (siglo\u00a0II\u00a0a.\u00a0C.). La gramatica mas antigua que se conoce es el Astadhyayi, un estudio sobre el sanscrito, escrito por Panini, hacia el a\u00f1o 480\u00a0a.\u00a0C.  En Occidente, la gramatica surgio como una disciplina durante el periodo helenistico, del siglo\u00a0III\u00a0a.\u00a0C. en adelante, con autores como Riano y Aristarco de Samotracia. Aunque Socrates, Aristoteles y otros sabios de la Antiguedad disertaron sobre la gramatica, el primer tratado completo de gramatica griega fue el que compuso Crates de Malos (siglo\u00a0II\u00a0a.\u00a0C.). En Grecia, la gramatica era labor del filosofo educador: este usaba la gramatica para educar a los jovenes y para contar con un medio expresivo. Como indica el filologo Manuel Quiros: \u00abContrario a los sofistas, Aristoteles y Platon tienen una consideracion estilistica sobre la gramatica [\u2026]; para ambos no es un asunto filosofico, sino meramente expresivo\u00bb.\u200b  En Roma, el interes por la gramatica se relacionaba con lo juridico. Se considera que la Tekhne Grammatike (\u03a4\u03b5\u03c7\u03bd\u03b7 \u0393\u03c1\u03b1\u03bc\u03bc\u03b1\u03c4\u03ba\u03b7), atribuida a Dionisio de Tracia (c. 100\u00a0a.\u00a0C.), es la primera gramatica, en terminos modernos, escrita sobre una lengua europea.\u200b La gramatica latina se desarrollo siguiendo modelos griegos desde el siglo\u00a0I\u00a0a.\u00a0C., gracias a la obra de autores como Orbili Pupil, Palemno, Marco Valerio Probe, Verri Flaco y Aemilius Asper. Elio Estilon Preconio fue el iniciador en Roma, con los signos criticos [aclaracion requerida] utilizados por los alejandrinos, ademas de haber sido maestro de Varron, quien trata la etimologia, flexion declinativa, conjugacion, sintaxis y analogia en su obra De lingua latina. Como se\u00f1ala Quiros,\u200b el primer manual de gramatica fue escrito por Remio Palemon. Por otra parte, el Ars Grammatica de Elio Donato (siglo\u00a0IV) fue dominante en los estudios gramaticales durante la Edad Media.  Tolkappiyam es la primera gramatica del tamil, pero su datacion es aun objeto de controversia. Las fechas oscilan entre el 8000\u00a0a.\u00a0C. y el siglo\u00a0X\u00a0a.\u00a0C..\u200b\u200b  En el siglo\u00a0VII surgio una gramatica del irlandes, el Auraicept na n-Eces.  La gramatica arabe surgio en el siglo\u00a0VI con Abu al-Aswad al-Du'aliy, que a su vez recibio las ense\u00f1anzas de Ali Ibn Abi Talib, cuarto califa historico del Islam y primer iman para los musulmanes chiitas.  Los primeros tratados de gramatica hebrea aparecieron a la Alta Edad Media, en el contexto del Mishna (exegesis de la Biblia hebrea ). La tradicion caraita se origino en el Bagdad abasida. El Diqduq (siglo\u00a0X) es uno de los primeros comentarios gramaticales sobre la Biblia hebrea.\u200b Ibn Barun el siglo\u00a0XII compara la lengua hebrea con el arabe en la tradicion gramatical islamica .\u200b  Como parte del Trivium de las siete artes liberales, la gramatica se ense\u00f1o como una disciplina central en toda la Edad Media, a raiz de la influencia de los autores de la Antiguedad tardia, como Prisciano. El tratamiento de las lenguas vernaculas comenzo gradualmente durante la Alta Edad Media, con obras aisladas, como el Primer tratado gramatical del islandes antiguo (Fyrsta malfr\u00e6\u00f0iritger\u00f0in), pero se hizo influyente solo en los periodos del Renacimiento y del Barroco. En 1486, Antonio de Nebrija publico Introducciones latinas: contrapuesto el romance al latin,\u200b y la primera gramatica castellana, Gramatica Castellana, en 1492.\u200b La Gramatica fue redactada en la localidad extreme\u00f1a de Zalamea de la Serena\u200b En el siglo  XVI, durante el Renacimiento italiano, el Questione della lingua fue el debate sobre el estado y la forma ideal del italiano, iniciado por la obra de Dante de vulgari eloquentia (Pietro Bembo, Prose della volgar lingua Venecia 1525). La primera gramatica del esloveno fue escrita en 1584 por Adam Bohoric.  Las gramaticas de lenguas no europeas comenzaron a ser recopiladas con fines de evangelizacion y traducciones de la Biblia a partir del siglo  XVI, como por ejemplo Grammatica o Arte de la Lengua General de los Indios de los Reynos del Peru (1560), y una gramatica quechua por Domingo de Santo Tomas.  En 1643 aparecio la Grammatica sclavonica de Ivan Ujevitx y, en 1762 se publico tambien la Short Introduction to English Grammar de Robert Lowther. La Grammatisch-Kritisches Worterbuch der Hochdeutsch Mundart, una gramatica del alto aleman en cinco volumenes, escrita por Johann Christoph Adelung, aparecio en 1774.  Desde la ultima parte del siglo\u00a0XVIII, la gramatica llego a ser entendida como un subcampo de la disciplina emergente de la linguistica moderna. La gramatica serbia de Vuk Stefanovic Karadzic llego en 1814, mientras que la Deutsche Grammatik de los Hermanos Grimm fue publicada por primera vez en 1818. La Gramatica Comparada de Franz Bopp, que se publico en 1833, es el punto de partida de la moderna linguistica comparativa.  Los lenguajes construidos son muy comunes en la actualidad. Muchos \u2014como el esperanto\u2014 fueron dise\u00f1ados para ayudar en la comunicacion humana, o el lojban, altamente compatible con lenguajes artificiales. Tambien se han creado lenguajes como parte de un mundo de ficcion (como el klingon y el quenya), y cada uno de ellos tiene su propia gramatica.  El sistema de nociones y categorias de la gramatica moderna, hasta la terminologia (nombres de partes de la oracion, casos, etc.) se remonta a la tradicion linguistica antigua (griegos - Aristoteles, estoicos, escuela alejandrina; romanos - Varron (116-27\u00a0a.\u00a0C.)].  Los metodos modernos de gramatica tienen su origen en la tradicion linguistica india (en los escritos de Artes liberales de mediados del primer milenio a.\u00a0C.). En la Edad Media era una de las Siete Artes Libres. Siendo a la vez descriptiva y normativa, implica el estudio de los textos clasicos y una determinada concepcion del lenguaje; la lengua, identificada con el latin, aparece como una forma potencialmente eterna, directamente relacionada con los mecanismos del pensamiento. Hasta finales del siglo\u00a0XII, se utilizaron en la ense\u00f1anza los libros de texto latinos tardios de Donatus y Prisciano, y solo entonces aparecieron las primeras gramaticas originales como el Doctrinale las de Alexandre de Villedieu y el Grecismus de Eberhard de Bethune).  La semantica, la lexicologia y la fonetica no suelen estar incluidas en la gramatica y se le oponen. Sin embargo, en algunas concepciones de la gramatica, su alcance se entiende de forma amplia y se incluyen la  semantica gramatical, la morfonologia (que incluye la morfonologia segmentaria, la acentologia y la entonologia, es decir, la ciencia de la tonacion) y la derivatologia (la ciencia de la formacion de las palabras), situadas en el limite de la gramatica y, respectivamente, de la semantica, la fonetica y la lexicologia.  Entre los principales tipos de gramatica o enfoques en el estudio de la gramatica se encuentran los siguientes:\u200b  Los linguistas consideran normalmente que la gramatica prescriptiva no tiene ninguna justificacion mas alla del gusto estetico de sus autores. De todos modos, las prescripciones permiten a la sociolinguistica explicar las razones por las cuales uno determinado grupo social utiliza construcciones diferenciales.  El estudio formal de la gramatica es una parte importante de la educacion, desde ni\u00f1os hasta el aprendizaje avanzado, a pesar de que las reglas que se ense\u00f1an en las escuelas no constituyen una gramatica en el sentido en que los linguistas utilizan el termino, puesto que son prescriptivas, mas que descriptivas.  La gramatica del idioma espa\u00f1ol posee numerosas similitudes con la de las otras lenguas romances. El idioma espa\u00f1ol es una lengua flexiva de tipo fusionante, por lo que en las oraciones se usa con gran frecuencia la flexion para indicar las relaciones entre sus elementos. De todas formas, al igual que muchas lenguas fusionantes, tambien utiliza preposiciones que sirven de nexo y son invariables. Por la forma en que se marcan los argumentos de los verbos transitivos e intransitivos, se agrupa dentro de las lenguas nominativo-acusativas con algunos rasgos de ergatividad escindida. Sintacticamente el espa\u00f1ol es una lengua de nucleo inicial altamente consistente.  La Real Academia Espa\u00f1ola, en su manual titulado Nueva Gramatica de la Lengua Espa\u00f1ola, publicado en el a\u00f1o 2010, reconoce seis unidades fundamentales del analisis gramatical del idioma espa\u00f1ol.\u200b Son:  En linguistica, el caso gramatical es un estado de flexion de la palabra; determinadas palabras (como nombres, adjetivos, o pronombres) adoptan diferentes formas segun la funcion que cumplen en la frase, generalmente con la adiccion de un sufijo. Las lenguas que utilizan el sistema de casos son llamadas lenguas flexivas. Muchas lenguas indoeuropeas son o habian sido lenguas flexivas. El ejemplo mas conocido es el latin. Practicamente la totalidad de las lenguas eslavas mantienen el sistema de casos, asi como el vasco, el griego y el turco, entre otros. Tanto las lenguas romanicas como las lenguas germanicas presentan una perdida evolutiva de los casos gramaticales, el catalan, por ejemplo, solo presenta una flexion de caso residual en los pronombres personales (jo, em, mi, ...), el ingles tambien ha perdido el sistema de casos, y hoy en dia solo conserva el llamado genitivo sajon, que algunos linguistas modernos han dejado de reconocer como caso gramatical.\u200b  Los sustantivos se suelen agrupar segun la declinacion a la que pertenecen, en el caso del latin, por ejemplo, existen cinco declinaciones que se subdividen en seis casos por declinacion.  No todos los casos se presentan de la misma manera a todas las lenguas flexivas. Suele variar la cantidad de casos que se emplean como los seis ya mencionados del latin, los dieciocho del hungaro, pasando por los quince del fines, los seis del ruso, los cinco del griego antiguo o los cuatro del moderno, los cuatro del aleman y los tres del arabe, por ejemplo. Tambien varia el tipo de casos que se utilizan, aunque los mas habituales son el nominativo, el genitivo y el acusativo. ","snippet":"La gramatica es el estudio de las reglas y principios que gobiernan el uso de las lenguas y la organizacion de las palabras dentro de unas oraciones y otro tipo de constituyentes sintacticos. Tambien ","enlaces_salientes":["Gram%C3%A1tica","Gram%C3%A1tica","Gram%C3%A1tica","Antonio_de_Nebrija","Mecenazgo","Juan_de_Z%C3%BA%C3%B1iga_y_Pimentel","Lengua_natural","Palabra","Oraci%C3%B3n_(gram%C3%A1tica)","Constituyente_sint%C3%A1ctico","Ling%C3%BC%C3%ADstica","Fon%C3%A9tica","Fonolog%C3%ADa","Morfolog%C3%ADa_(ling%C3%BC%C3%ADstica)","Sintaxis","L%C3%A9xico","Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Pragm%C3%A1tica","An%C3%A1lisis_del_discurso","Partes_de_la_oraci%C3%B3n","Categor%C3%ADas_gramaticales","Sintaxis","Variaci%C3%B3n_ling%C3%BC%C3%ADstica","Sujeto_verbo_objeto","Oraci%C3%B3n_simple","Obra_de_referencia","Prescripci%C3%B3n_ling%C3%BC%C3%ADstica","John_Dryden","Idiomas_germ%C3%A1nicos","Ortograf%C3%ADa","Convenci%C3%B3n_(norma)","Prescriptivismo_ling%C3%BC%C3%ADstico","Variaci%C3%B3n_ling%C3%BC%C3%ADstica","Lat%C3%ADn","Idioma_griego","Antigua_Grecia","Ortograf%C3%ADa","Sintaxis","Cr%C3%ADtica_literaria","Filolog%C3%ADa","Ret%C3%B3rica","Dionisio_de_Tracia","T%C3%A9khne_Grammatik%C3%A9","Antigua_Roma","Antigua_Roma","Elio_Donato","Hist%C3%B3rica","Helenismo","Gram%C3%A1tica_castellana","Antonio_de_Nebrija","Educaci%C3%B3n","Escuela","Teor%C3%ADa","Edad_del_Hierro","Subcontinente_indio","Iaska","P%C4%81%E1%B9%87ini","Pingala","Patanjali","S%C3%A1nscrito","Per%C3%ADodo_helen%C3%ADstico","Riano_(poeta)","Aristarco_de_Samotracia","S%C3%B3crates","Arist%C3%B3teles","Crates_de_Malos","Dionisio_de_Tracia","Elio_Donato","Edad_Media","Idioma_tamil","Ali_Ibn_Abi_Talib","Califa","Islam","Alta_Edad_Media","Mishn%C3%A1","Cara%C3%ADsmo","Califato_abas%C3%AD","Biblia_hebrea","Trivium","Prisciano","Renacimiento","Barroco","Antonio_de_Nebrija","Gram%C3%A1tica_castellana","Zalamea_de_la_Serena","Renacimiento_italiano","Idioma_esloveno","Franz_Bopp","Lengua_construida","Esperanto","Lojban","Klingon","Quenya","Arist%C3%B3teles","Estoicos","Escuela_neoplat%C3%B3nica_de_Alejandr%C3%ADa","Marco_Terencio_Varr%C3%B3n","Artes_liberales","Edad_Media","Artes_liberales","Lat%C3%ADn","Aelius_Donatus","Prisciano","Alexandre_de_Villedieu","Renacimiento","Siglo_de_las_Luces","Descriptivismo","Sem%C3%A1ntica","Lexicolog%C3%ADa","Fon%C3%A9tica","Sem%C3%A1ntica","Acentolog%C3%ADa","Gram%C3%A1tica_prescriptiva","Pedagog%C3%ADa","Gram%C3%A1tica_descriptiva","Gram%C3%A1tica_tradicional","Gram%C3%A1tica_funcional","Lenguaje_natural","Simon_Dik","Adecuaci%C3%B3n_tipol%C3%B3gica","Gram%C3%A1tica_generativa","Noam_Chomsky","Gram%C3%A1tica_generativa_transformacional","Gram%C3%A1tica_sist%C3%A9mica_funcional","Principios_y_Par%C3%A1metros","Gram%C3%A1tica_l%C3%A9xico-funcional","Gram%C3%A1tica_sintagm%C3%A1tica_nuclear","Gram%C3%A1tica_formal","Ling%C3%BC%C3%ADstica_computacional","Lenguaje_formal","Jerarqu%C3%ADa_de_Chomsky","Educaci%C3%B3n","Gram%C3%A1tica_del_espa%C3%B1ol","Alfonso_X_el_Sabio","Lengua_romance","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","Lengua_fusionante","Preposicion","Real_Academia_Espa%C3%B1ola","Ling%C3%BC%C3%ADstica","Caso_gramatical","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","Palabra","Sustantivo","Adjetivo","Pronombre","Funci%C3%B3n_sint%C3%A1ctica","Oraci%C3%B3n_(gram%C3%A1tica)","Sufijo","Lenguas_indoeuropeas","Lat%C3%ADn","Lenguas_eslavas","Vasco","Idioma_griego","Idioma_turco","Lenguas_rom%C3%A1nicas","Lenguas_germ%C3%A1nicas","Idioma_catal%C3%A1n","Pronombre","Idioma_ingl%C3%A9s","Genitivo_saj%C3%B3n","Ling%C3%BC%C3%ADstica","Declinaci%C3%B3n_(gram%C3%A1tica)","Gram%C3%A1tica_latina#El_sustantivo","Idioma_h%C3%BAngaro","Fin%C3%A9s","Idioma_ruso","Griego_antiguo","Griego_moderno","Idioma_alem%C3%A1n","Idioma_%C3%A1rabe","Adjetivo","Adjunto_sint%C3%A1ctico","Adverbio","Art%C3%ADculo_(gram%C3%A1tica)","Aspecto_gramatical","Caso_gramatical","Categor%C3%ADa_gramatical","Cl%C3%ADtico","Composici%C3%B3n_(ling%C3%BC%C3%ADstica)","Complemento_sint%C3%A1ctico","Complemento_circunstancial","Complemento_de_r%C3%A9gimen","Complemento_directo","Complemento_indirecto","Conjugaci%C3%B3n","Conjunci%C3%B3n_(gram%C3%A1tica)","Concordancia_gramatical","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","G%C3%A9nero_gramatical","Gerundio","Modo_imperativo","Infinitivo","Interjecci%C3%B3n","Negaci%C3%B3n_(gram%C3%A1tica)","Nombre_colectivo","N%C3%BAmero_gramatical","Oraci%C3%B3n_(gram%C3%A1tica)","Plural","Postposici%C3%B3n","Predicado_(gram%C3%A1tica)","Predicativo","Preposici%C3%B3n","Pronombre","Pronombre_personal","Singular","Sintagma","Sintaxis","Sujeto_(gram%C3%A1tica)","Superlativo","Sustantivo","Tiempo_gramatical","Verbo","Verbo_auxiliar","Verbo_ditransitivo","Verbo_transitivo","Ling%C3%BC%C3%ADstica","Gram%C3%A1tica_del_alem%C3%A1n","Gram%C3%A1tica_del_catal%C3%A1n","Gram%C3%A1tica_del_chino_mandar%C3%ADn","Gram%C3%A1tica_del_espa%C3%B1ol","Gram%C3%A1tica_del_esperanto","Gram%C3%A1tica_del_franc%C3%A9s","Gram%C3%A1tica_del_griego_antiguo","Gram%C3%A1tica_del_ido","Gram%C3%A1tica_del_ingl%C3%A9s","Gram%C3%A1tica_del_italiano","Gram%C3%A1tica_del_japon%C3%A9s","Gram%C3%A1tica_del_lat%C3%ADn","Gram%C3%A1tica_del_n%C3%A1huatl","Gram%C3%A1tica_pipil","Gram%C3%A1tica_del_quechua_sure%C3%B1o","Gram%C3%A1tica_del_ruso","Jerarqu%C3%ADa_de_Chomsky","Tipolog%C3%ADa_ling%C3%BC%C3%ADstica","Gram%C3%A1tica_transformacional","Wikcionario","Real_Academia_Espa%C3%B1ola","Gran_Enciclopedia_Catalana","ISBN","ISBN","ISBN","Wayback_Machine","Academia.edu","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Competencia_ling%C3%BC%C3%ADstica","titulo":"Competencia linguistica","contenido":"En linguistica, las teorias que se agrupan dentro de la gramatica formal denominan competencia linguistica al conjunto de conocimientos que permite  comprender y producir una cantidad, potencialmente infinita, de oraciones gramaticalmente correctas, con una cantidad finita de elementos. Ademas, ciertos enfoques que se ubican en la gramatica funcional entienden que el termino tambien debe incluir cierto conocimiento acerca de la adecuacion de un enunciado al contexto de situacion en que se produce.  Para Howard Gardner la competencia linguistica es la inteligencia que parece compartida de manera mas universal y comun en toda la especie humana. Considera que las medulas de tal tipo de inteligencia son la fonologia y la sintaxis, mientras que la semantica y la pragmatica se relacionan mas con la inteligencia logica-matematica y la inteligencia interpersonal. Define pues la competencia linguistica como aquella que permite procesar informacion de un sistema de simbolos para reconocer la validez fonologica, sintactica o semantica en un acto de significacion de esa lengua.\u200b  Para Chomsky, la competencia linguistica es la capacidad que tiene todo ser humano de manera innata de poder hablar y crear mensajes que nunca antes habia oido. Esta competencia se centra en las operaciones gramaticales que tiene interiorizadas el individuo y se activan segun se desarrolle su capacidad coloquial. Es decir, el lenguaje nace desde dentro del individuo y no desde lo social como sostenia Saussure. El maestro lo que tiene que hacer es desarrollar esta competencia linguistica en el alumno haciendole que hable y ense\u00f1andole vocabulario y no solamente gramatica. La competencia linguistica se hace realidad a traves de reglas generativas que se relacionan con la gramatica que es saber organizarse y estructurarse.  El Real Decreto 126/2014, de 28 de febrero, por el que se establece el curriculo basico de la Educacion Primaria (BOE, 1 de marzo),\u200b se\u00f1ala como primera competencia basica del curriculo de la ense\u00f1anza Primaria la \"comunicacion linguistica\u201d. El desarrollo de esta competencia se justifica y concreta en las siguientes actividades fundamentales para las relaciones humanas ( BOE 2006): \u200b   1)\tComprension de la realidad, comunicacion oral y escrita, organizacion del pensamiento.  2)\tExpresion de ideas, emociones, vivencias, opiniones, expresion oral y escrita, dialogo y relacion social.  3)\tLa conversacion como medio de aprendizaje, de desarrollo personal y afectivo.  4)\tLa construccion de relaciones iguales; el lenguaje como motor para la resolucion de conflictos en la comunidad escolar.  5)\tLa interaccion verbal y no verbal adaptada a cualquier contexto.  6)\tLa lectura y la escritura.  7)\tEl conocimiento reflexivo de la lengua para explorar todas las estrategias expresivas que permitan una mejor interaccion social.  8)\tEl dominio y la formalizacion de la lengua permiten el desarrollo de la capacidad critica y la capacidad empatica para escuchar,    entender y valorar las opiniones diversas transmitidas en la conversacion oral y en los textos escritos.   Ambitos de la competencia linguistica:  -\tCompetencia lectora.  -\tCompetencia para hablar y escuchar.  -\tCompetencia en composicion de textos   Competencia lectora: el fomento de la lectura en el aula debe ser algo primordial, a traves de la lectura el individuo comprende y se relaciona en la sociedad. La mayor parte de las cosas que sabemos, las aprendemos a traves de los libros.  Competencia para hablar y escuchar: son dos conceptos imprescindibles en nuestra sociedad, debemos escuchar y comprender, el ser humano necesita hablar para comunicarse, para relacionarse y transmitir mensajes a traves de su lengua. Los alumnos deben aprender a comprender lo que escuchan y a expresarse correctamente para poder llegar a establecer una buena comunicacion.  Competencia en composicion de textos: habilidad para componer distintos textos de caracter escrito, transmitiendo un conocimiento o satisfaciendo las necesidades personales y participando en la vida social.  Competencia plurilingue y pluricultural: en la ultima decada ha habido un aumento considerable de la diversidad  linguistica, hoy en dia en una misma aula pueden existir varias culturas, esto no debe ser un obstaculo para la ense\u00f1anza-aprendizaje, sino una oportunidad para enriquecerse y conocer otras culturas y otras lenguas.  Cabe destacar que se dividen en tres textos poeticos,narrativos y dramaticos.  La distincion que la Gramatica generativa hace entre competencia y actuacion\u200b a veces se confunde con que la dicotomia que Ferdinand de Saussure formulo entre lengua y habla. Es muy importante reconocer que estas dos parejas de nociones no tienen ninguna relacion entre si, aunque muchos adversarios de Chomsky usan el cliche de que son equivalentes. Eso es un grave error.  Para comenzar, la competencia es por completo individual, mientras la lengua es enteramente social, como se\u00f1alo Saussure en su famoso Curso de Linguistica General.\u200b Pero hay algo que es incluso mas importante. La suma completa de los enunciados de todos los hablantes (todos ellos, lo que Saussure llamaba la \u201cmasa\u201d) contiene la lengua; en cambio, la coleccion exhaustiva de todos y cada uno de los enunciados de un individuo (toda su actuacion) instancia solo una fraccion de su competencia. De hecho, Chomsky tiene una nocion propia de lengua: un conjunto infinito de oraciones (y la competencia es precisamente la capacidad para generarlo), que tampoco coincide con la lengua saussuriana.  Por otra parte, la actuacion es un proceso mental e innato, igual que la competencia, y se considera que es mucho mas uniforme que la competencia (los procesos de actuacion son esencialmente los mismos en todos los individuos); de hecho, en el Programa minimalista,\u200b el problema central de la sintaxis es como hacer para que las arbitrarias asociaciones de rasgos en el lexico se combinen entre si de tal manera que el resultado final pueda ser interpretado adecuadamente por los sistemas mentales de actuacion, que son el sistema articulatorio-perceptual y el sistema conceptual-intencional; es decir, la tarea de la sintaxis es neutralizar la diferencia entre los lexicos (gracias a la sintaxis, los sistemas de actuacion de todos los individuos reciben la misma informacion). Claramente, esto subraya el hecho de que la actuacion no tiene nada que ver con el habla saussuriana tampoco (es decir la actuacion no es la conducta verbal sino su capacidad).  En otras palabras, competencia y actuacion son dos modulos diferentes de la mente, dos componentes separados, uno puede existir sin el otro (se puede afectar la actuacion sin afectar la competencia). Lengua y habla, en cambio, no son independientes: no hay habla sin lengua.  Frente a la idea de competencia linguistica aparece la nocion de competencia comunicativa de Dell Hymes referida al uso del lenguaje en actos de comunicacion particulares, concretos y social e historicamente situados. De este modo, Hymes introduce una vision mas pragmatica del lenguaje, en la que los aspectos socio-culturales resultan determinantes en los actos comunicativos.  Umberto Eco concibe dos enfoques pragmaticos, una pragmatica de la significacion y otra de la comunicacion, pues fenomenos como la coreferencia textual, el topic, la coherencia textual, la referencia a un conjunto de conocimientos, la implicacion conversacional y muchos otros, ata\u00f1en a un proceso de comunicacion efectivo y ningun sistema de significacion puede preverlos.\u200b  Va tomando forma asi la competencia enciclopedica, referida a la capacidad de poner en juego, en los actos de significacion y comunicacion, los saberes con los que cuentan los sujetos y que son construidos en el ambito de la cultura escolar o socio-cultural en general, y en el micro-entorno local y familiar.  Otra diferencia importante entre las competencias linguistica y comunicativa corresponde al caracter dinamico de la segunda frente al caracter estatico de la primera. La competencia linguistica es innata, tiene base biologica, es estatica, tiene un caracter absoluto y no implica comparacion. La competencia comunicativa es un concepto dinamico que depende de la negociacion del significado entre dos o mas personas que comparten hasta cierto punto el mismo sistema simbolico. Como Savignon (1983) propone, tiene un caracter interpersonal y no intrapersonal. Ademas, la competencia comunicativa tiene un caracter relativo y no absoluto y los diferentes usuarios de la lengua pueden presentar distintos grados de competencia comunicativa. La competencia comunicativa, por lo tanto, tiene base social y es especifica del contexto en el que tiene lugar la comunicacion.  Desde la comunicacion se perfilan tres grandes competencias, la argumentativa, la interpretativa y la propositiva. En la argumentacion se valoran las acciones que directamente legimtiman y dan cuenta de lo planteado en el acto comunicativo, para ampliar la confrontacion de significados y la capacidad de decision en situaciones, se relaciona con el habla, con la retorica y con la etica. En la interpretacion se domina un sistema de reglas para inferir expresiones posibles, se relaciona con la lectura, la hermeneutica y la semiotica. En la proposicion se formula o produce un nuevo sentido que se da en las acciones de confrontacion, refutacion o en las alternativas de solucion plantadas frente a un texto o discurso; se relaciona con la escritura, la pragmatica y la critica. La habilidad de escuchar es importante en las tres competencias comunicativas.  Debido al aumento de la inmigracion en el mundo, muchas personas cuyo idioma es diferente al local utilizan servicios publicos. En principio, todas las personas deberian tener acceso a estos servicios, dado que en muchos casos el acceso igualitario es requerido por la ley. Asimismo, una buena comunicacion es importante para que estos puedan proveer una ayuda eficaz a quienes los utilizan. En este sentido, problemas de comunicacion pueden llevar a tomar decisiones equivocadas y a resultados deficientes, por lo que se deberian ofrecer comunicaciones que se adapten a las personas con habilidades limitadas en el idioma del pais en el que residen.  Una revision sistematica de cuatro estudios comparativos examino la eficacia de las ayudas comunicacionales entre los servicios publicos y los inmigrantes. Estas ayudas se dividieron en tres categorias:  Los resultados sugieren que no hay indicios claros sobre si un enfoque particular de interpretacion funciona mejor que otro. Por otro lado, un estudio sugiere que un curso de ingles como segunda lengua que integra el conocimiento de los padres y su comportamiento, fue mas eficaz que un curso estandar. Dada la poca cantidad de estudios, estos hallazgos pudieran no ser fiables.\u200b ","snippet":"En linguistica, las teorias que se agrupan dentro de la gramatica formal denominan competencia linguistica al conjunto de conocimientos que permite  comprender y producir una cantidad, potencialmente ","enlaces_salientes":["Competencia_ling%C3%BC%C3%ADstica","Competencia_ling%C3%BC%C3%ADstica","Competencia_ling%C3%BC%C3%ADstica","Competencia_(ling%C3%BC%C3%ADstica_generativa)","Ling%C3%BC%C3%ADstica","Competencia","Ling%C3%BC%C3%ADstica","Teor%C3%ADa","Gram%C3%A1tica_formal","Oraci%C3%B3n_(gram%C3%A1tica)","Gram%C3%A1tica_funcional","Enunciado","Contexto","Howard_Gardner","Inteligencia_l%C3%B3gica-matem%C3%A1tica","Inteligencia_interpersonal","Gram%C3%A1tica_generativa","Actuaci%C3%B3n","Ferdinand_de_Saussure","Idioma","Habla","Noam_Chomsky","Idioma","Curso_de_Ling%C3%BC%C3%ADstica_General","Idioma","Actuaci%C3%B3n","Idioma","Idioma","Actuaci%C3%B3n","Actuaci%C3%B3n","Programa_minimalista","Sintaxis","Rasgos","L%C3%A9xico","Actuaci%C3%B3n","Sintaxis","Sintaxis","Habla","Actuaci%C3%B3n","Idioma","Habla","Habla","Idioma","Competencia_comunicativa","Dell_Hymes","Pragm%C3%A1tica","Umberto_Eco","Argumentaci%C3%B3n","Ret%C3%B3rica","Interpretaci%C3%B3n","Hermen%C3%A9utica","Semi%C3%B3tica","Pragm%C3%A1tica","Control_de_autoridades"]}
{"url":"Gram%C3%A1tica_generativa","titulo":"Gramatica generativa","contenido":"En linguistica, el termino gramatica generativa se refiere a un conjunto de marcos teoricos para el estudio de la sintaxis de las lenguas. Una gramatica generativa proporciona un conjunto de reglas o principios que predicen correctamente las combinaciones que aparecen en oraciones gramaticalmente correctas para una determinada lengua.  Las ideas basicas de los modelos incluidos en esta corriente tienen su origen en la teoria estandar formulada por Noam Chomsky. El nucleo comun de todos los modelos generativos seria el intentar dise\u00f1ar un dispositivo formal que permita describir, analizar y especificar las oraciones de una lengua natural en forma simple, exhaustiva y general.  Una gramatica generativa para una lengua concreta pretende describir la estructura gramatical de una lengua mediante una construccion en terminos de constituyentes sintacticos jerarquicamente ordenados. Dicha gramatica pretende hacer predicciones sobre por que ciertas combinaciones sintacticas son posibles en una lengua determinada, mientras que otras combinaciones resultan ser oraciones incorrectas o agramaticales (aun cuando en otra lengua si pudieran ser correctas). La gramatica generativa postula que los mecanismos basicos son comunes a todas las lenguas del mundo, y estas se diferencian solo por su fonologia y su lexicon asi como detalles concretos o \"parametros\" en la sintaxis. Una gramatica generativa no pretende ser una gramatica prescriptiva, como lo suelen ser las gramaticas tradicionales. Igualmente una gramatica generativa se basa en reglas formales y principios muy abstractos, por lo que difiere de otros enfoques que tambien usan constituyentes jerarquicos como la gramatica funcional, que trata de buscar reglas informales y principios basados en intuiciones asociadas a la funcion y la optimizacion de la comunicacion.  Una gramatica generativa pretende por tanto ser capaz de generar una infinita cantidad de construcciones sintacticas a partir de un numero limitado de reglas y unidades abstractas. Esta propiedad es conocida como recursividad. En la actualidad, se postula que el lenguaje humano es el unico sistema de comunicacion natural que tiene la propiedad de ser recursivo. Evidentemente, la capacidad del cerebro humano es finita, pero no asi las oraciones que puede generar e interpretar.  En \"Linguists for Non-Linguists\", Frank Parker y Kathryn Riley sostienen que la gramatica generativa es un tipo de \"conocimiento inconsciente\" que permite a una persona, sin importar el idioma que hable, formar oraciones correctas.\u200b  La gramatica generativa asume como otros modelos teoricos, que una secuencia de discurso puede descomponerse en constituyentes sintacticos. Un constituyente sintactico es una combinacion de palabras que posee un nucleo sintactico del que el constituyente hereda sus propiedades combinatorias. No cualquier conjunto de palabras es un constituyente, por ejemplo una preposicion requiere estar unida a un sintagma nominal o un sintagma determinante para formar un constituyente. Los constituyentes sintacticos forman un conjunto parcialmente ordenado, a traves de la relacion X \u227a Y usualmente representada como [ X \u2026 ] Y } y que se interpreta como \"el constituyente X es parte del constituyente Y\".  La peculiaridad de la gramatica generativa mas reciente es que las secuencias del habla tal como aparecen pueden presentar constituyentes sintacticos desplazados, es decir, la forma aparente de una oracion es el resultado tanto de ensamblaje de constituyentes, como de alteracion del orden de estos, segun los principios del movimiento sintactico (en realidad no es un intercambio de orden lineal sino el cambio de posicion de uno de los dos constituyentes hacia una posicion vacia que puede anteceder la posicion lineal del otro constituyente). Ademas la gramatica generativa impone restricciones sobre los rasgos gramaticales de ciertos elementos sintacticos, dando lugar a relaciones de concordancia gramatical o reccion gramatical.  La gramatica generativa moderna se concibe como parte de las ciencias cognitivas y se considera una ciencia natural, ya que la conciencia del hablante o el conocimiento metalinguistico de los hablantes no tiene efecto sobre la estructura de la lengua o sus principios mas abstractos.\u200b Al considerar que la gramatica generativa es algo que describe el funcionamiento necesario de las habilidades cognitivo-linguisticas del cerebro humano, se considera que la gramatica generativa debe explicar la adquisicion de lenguaje y se propone explicar en que consiste el conocimiento inconsciente y tacito del hablante y en como se adquiere o se desarrolla. Se supone que muchas de las capacidades que permiten entender la estructura de las lenguas naturales, son una capacidad innata de los seres humanos de inteligencia normal, y por tanto de alguna manera estan codificadas en los genes.\u200b Eso explicaria por que los seres humanos aprenden de manera natural y sin esfuerzo, mientras que otras especies de primates, si bien tienen capacidades cognitivas y de comprension semantica importantes, tienen una capacidad linguistica muy limitada. En esa perspectiva, la gramatica generativa solo se interesa por algunos aspectos del lenguaje humano, los mas relacionados con la habilidad cognitiva para el lenguaje, razon por lo que la gramatica generativa podria considerarse una rama altamente especializada de la psicologia cognitiva. Dentro de dicho enfoque, las tres preguntas de alcance general a las que la teoria generativa trata de responder son:  Como se aprecia estas tres cuestiones fundamentales suponen un desplazamiento importante del objeto en el enfoque de los problemas linguisticos, respecto a otras teorias linguisticas.  Otros hechos interesantes o curiosos de los lenguajes humanos, como los factores sociolinguisticos o la evolucion de las lenguas (linguistica historica) no son tratados por la teoria generativa, ya que en ellos aparecen factores sociales y extralinguisticos que no dependen exclusivamente de la estructura interna de las lenguas. Es decir, la teoria generativa esta interesada solo en las formas y los significados que estan determinados por la facultad linguistica,\u200b que se concibe como un componente particular de la mente humana. La naturaleza de esta facultad es el objeto de una teoria general de la estructura linguistica que pretende descubrir el sistema de principios y elementos comunes a todas las lenguas conocidas; se denomina a dicha teoria Gramatica Universal (GU). La GU se puede considerar como una caracterizacion de la facultad linguistica geneticamente determinada, y a dicha facultad, como un instrumento de adquisicion del lenguaje, un componente innato de la mente humana que permite acceder a una lengua particular, hablada por los padres o criadores del ni\u00f1o, mediante la interaccion con la experiencia presente, un instrumento que convierte la experiencia en un sistema de conocimiento realizado, es decir, el conocimiento de una u otra lengua.  Algunos linguistas consideran que al margen de los hechos basicos estudiados por la gramatica generativa, existen otros hechos asociados ya a la conducta linguistica y al producto de esa conducta que merecen ser estudiados (tal es el objeto de la sociolinguistica, la linguistica antropologica, la dialectologia o la linguistica historica). Por esa razon no son infrecuentes las afirmaciones de que la teoria generativa es excesivamente reduccionista, aun cuando muchos de sus defensores nunca han sugerido que los unicos hechos interesantes relacionados con las lenguas sean los estudiados por la altamente especializada gramatica generativa, cuyo enfoque se dirige a la realidad mental que subyace a la conducta linguistica. La teoria generativa es, de hecho, una teoria mentalistica que se preocupa por determinar el conocimiento del lenguaje: su naturaleza, origen y uso.\u200b  Revolucion linguistica  Chomsky revoluciono la linguistica demostrando que no se puede separar la investigacion del linguista de la del psicologo, (su obra ha sido fundamental para el desarrollo de la\u00a0 psicologia cognitiva), por lo cual propuso una gramatica estructural anterior. El principio de la gramatica generativa se fundamenta en la idea de que, junto con las reglas especificas de construccion de oraciones propias a cada lengua, existen unas reglas mas basicas,-de caracter innato y comunes a todas las lenguas-, que explican la facilidad para el aprendizaje del lenguaje por parte del ni\u00f1o/a, para ello son fundamentales los conceptos de estructura profunda y superficial.  Por ejemplo en las frases:  La lluvia era muy fuerte. Derribo el tejado de la casa.  La fuerte lluvia derribo el tejado de la casa.  La lluvia, fortisima, derribo el tejado de la casa.  Las tres secuencias dicen exactamente lo mismo, tienen, por tanto, una misma estructura profunda pero su estructura superficial es distinta (se ordenan de diferentes maneras, y no poseen similares sus pausas internas). \u200b  Comunmente, \u00abgramatica generativa\u00bb suele utilizarse para se\u00f1alar exclusivamente la vertiente teorica conducida por Noam Chomsky, es decir, la gramatica transformacional. Sin embargo, en sentido amplio, el termino refiere a un grupo mayor de teorias y modelos:  La gramatica generativa ha recibido muchas criticas desde sus inicios y a lo largo de los a\u00f1os. Una de las mas significativas es sin duda la falta de correlatos neurocientificos de las estructuras abstractas que se postulan.\u200b En otras palabras, la gramatica generativa propone que el procesamiento del lenguaje se basa en una serie de modulos del lenguaje que realizan funciones especificas, si bien no esta claro si dichos modulos deben entenderse como estructuras anatomicas existentes, o solo como una manera de representar la operacion real de los cerebros cuando procesa el lenguaje.  Otro de los grandes problemas que se le achacan es la complejidad de mecanismos y reglas que utiliza para intentar hallar y explicar esa Estructura Profunda, lo que llevo a Chomsky a intentar simplificar la teoria de Principios y Parametros en la teoria minimista (sin mucho exito). Ademas, si bien es cierto que muchas de estas teorias que propone Chomsky no pueden ser refutadas todavia, tampoco tienen un respaldo cientifico evidente.\u200b Debe notarse de todas maneras, que esta critica solo aplicaria a un modelo especifico de Gramatica Generativa, ya que por el ejemplo el programa minimista que representa la propuesta mas moderna prescinde por completo de la llamada estructura profunda. ","snippet":"En linguistica, el termino gramatica generativa se refiere a un conjunto de marcos teoricos para el estudio de la sintaxis de las lenguas. Una gramatica generativa proporciona un conjunto de reglas o ","enlaces_salientes":["Gram%C3%A1tica_generativa","Gram%C3%A1tica_generativa","Gram%C3%A1tica_generativa","Noam_Chomsky","Ling%C3%BC%C3%ADstica","Ling%C3%BC%C3%ADstica","Sintaxis","Lengua_natural","Oraci%C3%B3n_(gram%C3%A1tica)","Teor%C3%ADa_est%C3%A1ndar","Noam_Chomsky","Constituyente_sint%C3%A1ctico","Verbo_de_ascenso","Movimiento_sint%C3%A1ctico","Complementador","Sujeto_(gram%C3%A1tica)","Constituyente_sint%C3%A1ctico","Lenguas_del_mundo","Fonolog%C3%ADa","Lexic%C3%B3n","Gram%C3%A1tica_prescriptiva","Gram%C3%A1tica_tradicional","Gram%C3%A1tica_funcional","Recursividad","Constituyente_sint%C3%A1ctico","N%C3%BAcleo_sint%C3%A1ctico","Sintagma_nominal","Sintagma_determinante","Conjunto_parcialmente_ordenado","Movimiento_sint%C3%A1ctico","Rasgo_gramatical","Concordancia_gramatical","Recci%C3%B3n_gramatical","Ciencias_cognitivas","Desarrollo_del_lenguaje","Socioling%C3%BC%C3%ADstica","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Gram%C3%A1tica_Universal","Socioling%C3%BC%C3%ADstica","Ling%C3%BC%C3%ADstica_antropol%C3%B3gica","Dialectolog%C3%ADa","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Modelo_mental","Gram%C3%A1tica_transformacional","Teor%C3%ADa_est%C3%A1ndar","Principios_y_par%C3%A1metros","Recci%C3%B3n_y_ligamiento","Programa_minimalista","Gram%C3%A1tica_relacional","Gram%C3%A1tica_l%C3%A9xico-funcional","Joan_Bresnan","Ivan_Sag","Gram%C3%A1tica_sintagm%C3%A1tica_nuclear","Principios_y_Par%C3%A1metros","Programa_minimista","Sintagma_nominal","Sintagma_determinante","Sintagma_verbal","Adjetivo","Pronombre","Verbo","Preposici%C3%B3n","Complemento_sint%C3%A1ctico","Sintagma_preposicional","Determinante_(ling%C3%BC%C3%ADstica)","Cambridge_University_Press","MIT_Press","Oxford_University_Press","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Chomsky","titulo":"Noam Chomsky","contenido":"Avram Noam Chomsky (Filadelfia, 7 de diciembre de 1928) es un linguista, filosofo, politologo y activista estadounidense de origen judio. Es profesor emerito de linguistica en el Instituto Tecnologico de Massachusetts (MIT) y una de las figuras mas destacadas de la linguistica del siglo\u00a0XX, gracias a sus trabajos en teoria linguistica y ciencia cognitiva. Tambien es reconocido por su activismo politico, caracterizado por una fuerte critica del capitalismo contemporaneo y de la politica exterior de los Estados Unidos. Se le considera de pensamiento socialista libertario.\u200b El New York Times lo ha se\u00f1alado como \u00abel mas importante de los pensadores contemporaneos\u00bb.\u200b  Propuso la gramatica generativa, disciplina que situo la sintaxis en el centro de la investigacion linguistica. Con este paradigma, cambiaron la perspectiva, los programas y metodos de investigacion en el estudio del lenguaje. Su linguistica es una teoria de la adquisicion individual del lenguaje e intenta explicar las estructuras y principios mas profundos del mismo. Postulo un aspecto bien definido de innatismo en la adquisicion del lenguaje y la autonomia de la gramatica (sobre los otros sistemas cognitivos), asi como la existencia de un \u00aborgano del lenguaje\u00bb y de una gramatica universal. Se opuso con dureza al empirismo filosofico y cientifico y al funcionalismo, en favor del racionalismo cartesiano. Todas estas ideas chocaban frontalmente con las tradicionales de las ciencias humanas, lo que concito multiples adhesiones, criticas y polemicas que le han acabado convirtiendo en uno de los autores mas citados.\u200b Sus 3.874 citas en el \"Arts and Humanities Citation Index\" entre 1980 y 1992 le convierten en la persona viva mas citada en ese periodo y la octava mas citada de toda la historia, justo por detras de Sigmund Freud y por delante del filosofo Georg Hegel.\u200b  Destaca su contribucion al establecimiento de las ciencias cognitivas a partir de su critica del conductismo de Skinner y de las gramaticas de estados finitos, poniendo en tela de juicio el metodo basado en el comportamiento del estudio de la mente y el lenguaje que dominaba en los a\u00f1os cincuenta. Su enfoque naturalista en el estudio del lenguaje ha influido en la filosofia del lenguaje y de la mente (ver a Harman y a Fodor). Es el descubridor de la jerarquia de Chomsky, una clasificacion de lenguajes formales de gran importancia en teoria de la computacion.  Tambien es conocido por su activismo politico y por sus criticas a la politica exterior de Estados Unidos y de otros paises, como Israel. Chomsky, que desvincula completamente su actividad cientifica de su activismo politico, se describe a si mismo como simpatizante del anarcosindicalismo (es miembro del sindicato IWW). Chomsky es considerado una figura influyente en su pais de origen y en el mundo.  Noam Chomsky nacio el 7 de diciembre de 1928 en Filadelfia (Pensilvania),\u200b hijo del doctor William (Zev) Chomsky (estudioso de la lengua hebrea y uno de sus mas distinguidos gramaticos) y de Elsie Simonofsky, maestra de hebreo. Ambos eran inmigrantes judeo-ucranianos. Desde 1945, estudio filosofia, linguistica y matematica en la Universidad de Pensilvania. Alli estuvo bajo la tutela del profesor Zellig Harris (tambien inmigrante judeo-ucraniano, fundador del primer departamento especializado en linguistica en Norteamerica). Harris y Elsie influyeron mas que Zev en la formacion de su ideologia politica. Tambien por influencia de Zellig Harris, Chomsky comenzo a tomar clases de matematicas y filosofia. Uno de sus maestros fue el filosofo Nelson Goodman, quien mas tarde los presentaria en la Society of Fellows de Harvard. Recibio su doctorado en 1955, despues de llevar a cabo la mayor parte de sus investigaciones en la Universidad de Harvard durante los cuatro a\u00f1os anteriores. En 1998 recibio el Doctorado honoris causa (linguistica) de la Universidad Rovira i Virgili.\u200b Recibio esta misma distincion por parte de la Universidad Nacional de Colombia\u200b en 2002, de la Universidad de Chile\u200b y de la Universidad de la Frontera\u200b en 2006 y de la Universidad Nacional Autonoma de Mexico\u200b en 2010.  En su tesis doctoral comenzo a desarrollar algunas de sus ideas en linguistica, elaborandolas luego en su libro Estructuras sintacticas,\u200b posiblemente su trabajo mas conocido en este campo. Sus planteamientos linguisticos han revolucionado muchos puntos clave del estudio del lenguaje humano, que se han plasmado en la teoria de la Gramatica generativa transformacional.  Es profesor del Massachusetts Institute of Technology (MIT) desde 1961, donde ocupo la catedra Ferrari P. Ward de Lenguaje Moderno y Linguistica de 1966 a 1976.  En abril de 2019 es reconocido con el  Premio Fronteras del Conocimiento en la categoria de Humanidades y Ciencias Sociales. El jurado recogio en el acta que Chomsky ha situado la investigacion de la mente humana y sus productos \u201cen una nueva y fructifera via que abarca la linguistica teorica, la psicolinguistica, las ciencias cognitivas, las filosofias del lenguaje y de la mente y la psicologia cognitiva\u201d.\u200b  Su conyuge fue Carol Schatz, quien murio el 20 de diciembre de 2008.\u200b Tiene dos hijas y un hijo.  En 1957, con solo veintinueve a\u00f1os, Chomsky revoluciono el campo de la linguistica teorica con la publicacion de la obra Estructuras sintacticas, basada en su tesis doctoral \u2015Estructura logica de la teoria linguistica\u2015, que no se publicaria hasta 1975. Su efecto sobre las teorias linguisticas y psicologicas entonces en boga fue demoledor, ya que atacaba los presupuestos centrales tanto del estructuralismo como de la psicologia conductista. Hasta entonces, se creia que la adquisicion del lenguaje, como cualquier otra destreza humana, se producia por medio del aprendizaje y de la asociacion. Sin embargo, Chomsky postulaba la existencia de un dispositivo cerebral innato (el \u00aborgano del lenguaje\u00bb), que permite aprender y utilizar el lenguaje de forma casi instintiva. Comprobo ademas que los principios generales abstractos de la gramatica son universales en la especie humana y postulo la existencia de una gramatica universal.  La Gramatica Universal de Chomsky asegura que el fundamento comun de la lenguas humanas es su recursividad, un proceso, habitualmente asociado a la subordinacion, que posibilita a un hablante a introducir oraciones en otras oraciones sin limite. Este principio seria el que permitiria a los seres humanos establecer una comunicacion rica y compleja para distanciarse, por ejemplo, de los animales. Sin embargo, la teoria de la recursividad de Chomsky se puso en entredicho en el momento en el que el profesor Daniel Everett, despues de convivir con la tribu indigena de los piraha, descubrio presuntamente un idioma nuevo que contradice dicha teoria: el idioma piraha. Este nuevo idioma, que careceria de numeracion, tiempos verbales y colores, se caracterizaria por su simplicidad aunque, a pesar de que tendria una percepcion simple y reducida del mundo, cumpliria con las necesidades comunicativas de la tribu. Este descubrimiento es muy controvertido, ya que el propio Everett es la unica persona fuera de la tribu capaz de entenderlo.  Chomsky denomino gramatica generativa al conjunto de reglas innatas que permite traducir combinaciones de ideas a combinaciones de un codigo. Fundamento la hipotesis, ya existente, de que la gramatica es un sistema combinatorio discreto que permite construir infinitas frases a partir de un numero finito de elementos mediante reglas diversas que pueden formalizarse. La nueva teoria consideraba que las expresiones (secuencias de palabras) tienen una sintaxis que puede caracterizarse (globalmente) por una gramatica formal; en particular, una gramatica extendida por normas de transformacion. A los ni\u00f1os se les supone un conocimiento innato de la gramatica elemental comun a todas las lenguas humanas (lo que supone que toda lengua existente es una clase de restriccion). Se sostiene que la modelizacion del conocimiento de la lengua a traves de una gramatica formal explica la \u00abproductividad\u00bb de la lengua: con un juego reducido de reglas gramaticales y un conjunto finito de terminos, los humanos pueden producir un numero infinito de frases, incluidas frases que nadie haya dicho anteriormente.  The Principles and Parameters approach (P&P) (Aproximacion por principios y parametros), desarrollada en las Conferencias de Pisa (1979) y publicada mas tarde bajo el titulo Lectures on Government and Binding (LGB), retoma mucho de la gramatica universal: los principios gramaticales en los que se basan las lenguas son innatos y fijos; las diferencias entre las distintas lenguas en el mundo se pueden caracterizar en terminos de parametros programados en el cerebro (como el parametro de elision, pro drop param, que indica cuando un tema explicito es siempre requerido, como en ingles, o si este puede elidirse, como en espa\u00f1ol) a menudo comparados a interruptores (de ahi el termino de principios y parametros utilizado para calificar este enfoque). Segun esta teoria, un ni\u00f1o que aprende una lengua solo necesita adquirir los elementos lexicos basicos (palabras, morfemas gramaticales y refranes) y fijar los valores convenientes en los parametros, lo que puede efectuarse sobre algunos ejemplos clave.  Los partidarios de esta concepcion ponen como ejemplo que la velocidad con la cual los ni\u00f1os aprenden lenguas es inexplicablemente rapida, algo no posible a menos que tengan una capacidad innata para aprenderlas. La similitud de las etapas que siguen todos los ni\u00f1os alrededor del mundo cuando aprenden una lengua, y el hecho de que cometan errores caracteristicos cuando adquieren su primera lengua, mientras que otros tipos de error al parecer logicos no se producen nunca (y, segun Chomsky, estos deberian darse si el mecanismo de aprendizaje utilizado fuese general mas que especifico de una lengua), se postulan tambien como un argumento a favor de dicho innatismo.  Mas recientemente, en su Programa minimalista (1995), conservando al mismo tiempo el concepto central de \u00abprincipios y parametros\u00bb, Chomsky intenta una revision importante de las maquinas linguisticas implicadas en el modelo de LGB, despojandolos de todo excepto de los elementos estrictamente necesarios. Al mismo tiempo, preconiza un enfoque general de la arquitectura de la facultad de la lengua humana, destaca los principios de la economia y la concepcion optima y retorna al enfoque derivacional de la generacion, en oposicion con la mayor parte del enfoque representativo clasico del P&P.  Chomsky caracterizo la tarea del linguista mucho mejor que ninguno de sus predecesores y fijo con todo rigor el campo para el estudio cientifico del lenguaje. Su objetivo nunca fue establecer una teoria especulativa mas sobre el lenguaje, sino una explicacion rigurosa de su complejidad. La intencion era por tanto pasar de una preciencia meramente descriptiva a una ciencia con poder explicativo y predictivo falsable y con construcciones abstractas que permitiesen un riguroso sistema axiomatico. Nada ha sido igual desde entonces en el campo del estudio del lenguaje y, por extension, de la mente humana. La gramatica generativa de Chomsky fue la primera evidencia solida de que la inteligencia humana esta basada en dispositivos cerebrales especializados e innatos y eso ha permitido agrupar las ciencias cognitivas. Tambien provoco una enorme escision epistemologica, que todavia se mantiene, frente a quienes rechazan la concepcion modular e innata de la mente y siguen siendo partidarios de un modelo de cerebro como tabla rasa, como por ejemplo los psicologos que trabajan con procesos de emergencia o las teorias conexionistas, que consideran la lengua como un caso particular de los procesos generales del cerebro.  Chomsky se ocupa de las lenguas naturales partiendo de una gramatica universal propia de todos los seres humanos, de raiz biologica, de la cual derivan las distintas lenguas de las diversas culturas que han existido en la historia y que existen aun.  La diferencia entre la gramatica universal (GU) y las distintas gramaticas particulares (GGPP) radica en que la primera se relaciona con la disposicion de un conjunto de principios \u2015como el \u00abprincipio de proyeccion\u00bb, el \u00abprincipio de dependencia de la estructura\u00bb, el \u00abprincipio de ligamiento\u00bb, la \u00abteoria del caso\u00bb, el \u00abcriterio tematico\u00bb y algunos otros\u2015, mientras que las GGPP se vinculan a las multiples variaciones que pueden hacer las lenguas de los parametros de esos principios. Un ejemplo de esta variacion se da en el \u00abparametro de los sujetos nulos\u00bb, que en espa\u00f1ol se puede presentar mientras que en ingles no, como muestra el siguiente ejemplo:  Asi, las GGPP no son mas que combinaciones de elementos finitos que pueden dar lugar a multiples lenguas e idiomas que en esta teoria son llamadas lengua-I.  El sistema encargado de articular estos principios y variar los parametros es el cerebro humano con su capacidad de sintaxis, que en su sentido amplio adquiere la forma de un sistema computacional que opera en modulos. Los modulos responden a una estructura matriz compuesta por tres componentes, dentro de los cuales actuan los principios y parametros definidos como una serie de teorias de lenguaje, conectadas con cuatro modulos centrales: la estructura-P, la estructura-S, la forma fonologica (FF) y la forma logica (FL). La estructura-P conecta las oraciones con principios, mientras que la estructura-S apela a la transformacion o variabilidad que pueden presentar dichas conexiones; ademas, la FF se vincula con la entonacion y sonido de las expresiones linguisticas o fonologia y la FL se encarga de la semantica de estas expresiones en relacion con su interpretacion de sentido y significado.  En la estructura-P se encuentran las primeras relaciones entre lexico y sintaxis, como las relaciones sintagmaticas que establecen que es sintagma verbal, sintagma nominal, sintagma adjetival o sintagma preposicional, entre otras relaciones categoriales.  La estructura-S se\u00f1ala acciones transformacionales o de parametro, no solamente de principio como en la estructura-P. Un ejemplo es la operacion muevase \u03b1, en la que un elemento se mueve en la oracion a otra posicion. La estructura-S tambien sirve como conector entre dos modulos que no se relacionan directamente. El primero es la forma fonologica (FF), que se encarga de articular sonidos con formas lexicas a partir de fonemas definidos, como tambien de establecer las entonaciones de una pregunta o una afirmacion, una suposicion entre otras acciones ligadas a lo mismo.  Por ultimo, la forma logica, quizas la mas compleja de todas, conecta con el ejercicio semantico de interpretacion y significado en el sentido de un oracion en la cual se encuentran a nivel lexico las redes tematicas y las selecciones S, como modos de organizar la oracion segun papeles tematicos (tales como agente, tema, experimentante o benefactivo) y categorias gramaticales (tales como animado o humano) respectivamente, para luego dibujar la estructura morfologica de la oracion a nivel sintactico.  Estos cuatro modulos entregan una salida (output) que sirve como entrada (input) del siguiente modulo hasta entregar una realizacion linguistica u oracion en un acto comunicativo.\u200b  Noam Chomsky se intereso por la politica a muy temprana edad, estimulado por las lecturas en las librerias de los anarquistas espa\u00f1oles exiliados en Nueva York. A los once a\u00f1os publico su primer articulo sobre la caida de Barcelona y la expansion del fascismo en Europa.\u200b  Su activismo politico arranca de la movilizacion popular contra la guerra del Vietnam. La participacion de Chomsky en esta movilizacion fue particularmente sorprendente considerando que su propia universidad, MIT, estaba investigando helicopteros, bombas inteligentes y tecnicas de contrainsurgencia para la guerra en Vietnam. Y, como dice Chomsky, \"se desarrollo una buena cantidad de tecnologia de orientacion de misiles [nucleares] en el campus del MIT\".\u200b Como Chomsky tambien dice, \"aproximadamente el 90\u00a0% [del MIT] estaba financiado por el Pentagono en ese momento. Y yo personalmente estaba justo en el medio de eso. Estaba en un laboratorio militar.\u201d\u200b La oposicion de Chomsky a la guerra de Vietnam lo llevo a analizar el papel del mundo academico en la implicacion de Estados Unidos en esta guerra. Fruto de este esfuerzo fueron varios articulos compilados en el libro American Power and the New Mandarins (El poder estadounidense y los nuevos mandarines) 1969, de entre los cuales destaca La responsabilidad de los intelectuales (publicado inicialmente en febrero de 1967 en The New York Review of Books). Desde entonces, ha sido muy conocido por sus ideas politicas de izquierda, que se centran en la lucha por superar el deficit democratico existente de Estados Unidos \u2014es decir, la gran distancia entre las decisiones politicas y la opinion publica\u2014, y en denunciar las ambiciones imperiales del gobierno de este pais en el mundo. En general, se le considera un critico del capitalismo y tambien ha hablado en contra del darwinismo social de Herbert Spencer.  Se define a si mismo como partidario de la tradicion anarquista, especialmente de la corriente de orientacion laboral del anarquismo, el anarcosindicalismo, y es miembro del celebre sindicato revolucionario estadounidense IWW, al que tambien pertenecio su padre. Pese a ello, no se opone totalmente a la politica electoral, al menos en el ambito de la estrategia: su postura en las elecciones de Estados Unidos es que los ciudadanos deberian votar por los democratas locales si con ello se consigue sacar del poder a los republicanos, mientras que en las situaciones donde las victorias republicana o democrata estan claras ha pedido el voto para candidaturas mas a la izquierda, como las del Partido Verde. Es uno de los mas importantes colaboradores del grupo mediatico independiente Z Communications. Esta actuacion se inscribe claramente dentro de la tradicional tactica anarcosindicalista de impulsar movilizaciones populares que coaccionen la accion de los poderes publicos y facticos hasta conseguir cambios concretos y reales (vease el prefacio de Chomsky al libro de Rudolf Rocker, Anarcho-Syndicalism: Theory and Practice, 1989).  Desde un punto de vista mas personal y filosofico, tambien se considera un conservador de la variante liberal clasica (Chomsky's Politics, pp. 188) y se ha definido como un sionista; aunque observa que la mayoria considera como antisionista su definicion de sionismo. Percibe un cambio en el significado del sionismo (Chomsky Reader) desde la decada de 1940. En la misma linea y rescatando su contenido libertario, Chomsky ha declarado su admiracion y adhesion al kibutz como forma social alternativa.  Con el tiempo, se ha convertido en una de las principales figuras de la politica radical estadounidense. Junto a Jose Saramago o Leonardo Boff, entre otros, es uno de los principales intelectuales de la izquierda en el mundo, pese a lo cual, a diferencia de su actividad cientifica, su aportacion teorica en el ambito politico no es demasiado relevante. Nunca se ha considerado un teorico en politica, sino simplemente un ciudadano informado que mantiene una actitud muy critica hacia la ideologia dominante. Chomsky cree que, mientras la actividad cientifica no esta al alcance de cualquiera (ya que exige una formacion y una abstraccion conceptual muy elevada), para la actividad de critica politica basta una cierta apertura de espiritu. Ha reiterado a menudo que la politica deberia ser cosa de todos y no dejarse en manos de la intelligentsia, ni mucho menos aceptar que solo los profesionales de la politica (sean periodistas, intelectuales o politicos) sean los unicos capacitados para opinar sobre politica.  Uno de sus principales aportes intelectuales ha sido el analisis de los medios de comunicacion. En sus estudios sobre el tema se ha ocupado de los enfoques sesgados, o incluso enga\u00f1osos, que hay detras de la supuesta neutralidad de los medios mas prestigiosos. Se trata de un trabajo de \u00abcontrainformacion\u00bb que ha obtenido gran difusion y que muchos otros han continuado. Fruto de este esfuerzo es el libro Los guardianes de la libertad, escrito junto con Edward S. Herman, profesor de la Universidad de Pensilvania.  Su denuncia de la politica exterior de Estados Unidos, de las deficiencias democraticas de su maquinaria politica, y de los enga\u00f1os de los grandes medios de comunicacion en este pais, supone poner en duda tres de los pilares del nacionalismo estadounidense. Por otro lado, su vision sobre la politica del estado israeli en Oriente Medio es parte de su critica a la politica exterior de Estados Unidos. Chomsky se\u00f1ala que desde hace a\u00f1os la maquinaria militar israeli depende mayormente del apoyo material y diplomatico de Estados Unidos, y que ambos estados realizan sistematicamente acciones violentas al margen de las leyes internacionales. Esta ultima circunstancia ha motivado que Chomsky declare que segun los criterios internacionales actuales, ambos estados ejercen el terrorismo. En concreto en su libro 11/09/2001, afirma que los Estados Unidos es \u00abuno de los principales estados terroristas\u00bb (\u00aba leading terrorist state\u00bb). Noam Chomsky lo publico en diciembre del 2001, tres meses despues de lo sucedido en Nueva York. Es un ensayo sobre los hechos y las consecuencias de los atentados del 11 de septiembre. Se basa en una estructura de siete largas entrevistas de periodistas extranjeros durante el primer mes y medio posterior a los ataques al World Trade Center y al Pentagono. No analiza unicamente las causas, las consecuencias de los atentados y la reaccion del pueblo estadounidense, sino que cuestiona las razones de la guerra y los bombardeos. En este libro Chomsky refleja de nuevo su vision critica con el poder y la industria militar.  A raiz de estas denuncias, varios detractores de Chomsky lo han tildado de antiestadounidense. Algunos incluso han comprendido sus criticas como una supuesta obsesion antiestadounidense y antisionista. Para algunos nacionalistas, es especialmente controvertida su critica a la politica del gobierno de Israel, por su origen judio. Tambien ha sido polemico su apoyo a la libertad de expresion en los que se conoce como el escandalo Faurisson. En la decada de 1970, Robert Faurisson realizaria un estudio y escribiria un libro en el cual concluye que muchos de los acontecimientos del holocausto ( como las camaras de gas) no existieron realmente. Chomsky firmaria una peticion para garantizar a las autoridades la libertad de expresion, aclarando que el mismo no compartia el punto de vista negacionista, pero que no reconocia expresiones antisemitas en el trabajo de Faurisson. Chomsky califica al holocausto como la peor muestra de locura colectiva en la historia de la humanidad, pero considera fundamental garantizar la defensa de la libertad de expresion, incluso para aquellas ideas popularmente mal vistas. Por ultimo, destaca la critica que hace de la izquierda posmoderna y de su entusiasmo por el relativismo cultural que, al deconstruir la nocion de verdad, ha invalidado tambien la posibilidad de la critica.[cita\u00a0requerida]  Chomsky ha pedido a EE.\u00a0UU. y a Canada levantar sanciones economicas impuestas a Venezuela.\u200b  En cuanto a Espa\u00f1a, en 2009 firmo un manifiesto de apoyo a la candidatura a las elecciones europeas de la formacion politica Izquierda Anticapitalista,\u200b y en 2014 en apoyo de la formacion politica Podemos.\u200b En 2018, Chomsky, junto con mas de 100 academicos de diecinueve paises, pidio en una carta la \"puesta en libertad inmediata\" de los politicos catalanes encarcelados en Espa\u00f1a por participar en la declaracion de independencia de Catalu\u00f1a.  Desde 2009 es miembro honorario de AIPTI.\u200b  Chomsky es uno de los detractores de la globalizacion, y esto se debe a su forma de entender la hegemonia del capitalismo moderno. Para Chomsky, Estados Unidos no cree en el libre comercio, sino que lo utiliza como un metodo mediante el cual los paises mas fuertes imponen a los paises pobres la obligacion de cumplir unas normas coercitivas y rigidas (la ley del embudo).  El objetivo basico de la globalizacion economica es globalizar toda la economia mundial, y Estados Unidos controlaria la economia mundial con el apoyo de los organismos satelites (Fondo Monetario Internacional, Banco Mundial, Organizacion Mundial del Comercio). El argumento habitual a favor del libre comercio liberalizado es que conducira a un aumento generalizado de los niveles de vida. La experiencia ha demostrado que con la apertura de los mercados comerciales y financieros los inversores y empresarios han ganado mucho mas dinero, pero gran parte de los paises mas pobres han sido las victimas de un descenso pronunciado de sus niveles de vida.  Segun precisa Noam Chomsky:  Sus afirmaciones politicas le han concitado un gran numero de simpatizantes, en amplios sectores de la izquierda, especialmente europea y latinoamericana, y tambien algunos detractores. Su libro 11 de septiembre (9/11) tuvo una gran difusion, pese a haber sido publicado por una peque\u00f1a editorial. Solo la edicion de este libro en ingles vendio centenares de miles ejemplares, y ha sido traducido a varias lenguas. Posteriormente, su libro Hegemonia o supervivencia: la busqueda estadounidense del dominio global fue recomendado por el presidente de Venezuela Hugo Chavez en su discurso frente a la asamblea general de la ONU el dia 20 de septiembre de 2006, lo que ocasiono que dicho libro, en aproximadamente dos dias, pasase del puesto 160.772, al numero 2 de los libros mas vendidos en Amazon..  En diversas ocasiones se le ha preguntado a Chomsky si tiene una postura religiosa o es ateo, a lo cual el respondio en una ocasion:  En una discusion con Lawrence Krauss y Sean M. Carroll en 2006, Chomsky dio una respuesta similar:  Noam Chomsky ha reconocido los limites de la razon humana,\u200b y claramente ha rechazado el cientificismo (la idea de que la ciencia lo puede explicar todo):  Por otra parte, Chomsky ha dejado claro que su postura no es antirreligiosa, pues como analista social, al igual que muchos otros autores, ha reconocido que hay una diferenciacion radical entre el cristianismo de los evangelios en contraste con el de la mayor parte de los gobiernos y organizaciones religiosas:  Ademas, ha hablado favorablemente de la teologia de la liberacion\u200b y ha reconocido la labor de movimientos que han tratado de restaurar y rescatar los principios del cristianismo primitivo: ","snippet":"Avram Noam Chomsky (Filadelfia, 7 de diciembre de 1928) es un linguista, filosofo, politologo y activista estadounidense de origen judio. Es profesor emerito de linguistica en el Instituto Tecnologico","enlaces_salientes":["Noam_Chomsky","Noam_Chomsky","Noam_Chomsky","Filadelfia","Pensilvania","Estados_Unidos","Estados_Unidos","Ate%C3%ADsmo","William_Chomsky","Carol_Chomsky","Instituto_de_Tecnolog%C3%ADa_de_Massachusetts","Universidad_de_Pensilvania","Bachelor_of_Arts","Master_of_Arts","Universidad_de_Harvard","Ling%C3%BC%C3%ADstica","Zellig_Harris","Nelson_Goodman","Roman_Jakobson","Fil%C3%B3sofo","Ling%C3%BCista","Profesor_de_educaci%C3%B3n_superior","Psic%C3%B3logo","Antrop%C3%B3logo","Defensor_de_los_derechos_humanos","Educador","Escritor","Publicista_(escritor)","Inform%C3%A1tico_te%C3%B3rico","Historiador","Filosof%C3%ADa_del_lenguaje","Psicolog%C3%ADa","Gram%C3%A1tica_generativa","Teor%C3%ADa_de_la_comunicaci%C3%B3n","Ciencia_cognitiva","Filosof%C3%ADa_de_la_mente","%C3%89tica","Pol%C3%ADtica","Gram%C3%A1tica_generativa","Gram%C3%A1tica_universal","Gram%C3%A1tica_transformacional","Recci%C3%B3n_y_ligamiento","Teor%C3%ADa_de_la_X%27","Jerarqu%C3%ADa_de_Chomsky","Gram%C3%A1tica_libre_de_contexto","Principios_y_par%C3%A1metros","Programa_minimalista","Pobreza_del_est%C3%ADmulo","Forma_normal_de_Chomsky","Modelo_de_Propaganda_de_los_medios_de_comunicaci%C3%B3n","Catedr%C3%A1tico_de_universidad","Barbara_H._Partee","Tanya_Reinhart","John_R._Ross","Ray_Jackendoff","Mark_Baker_(ling%C3%BCista)","Joan_Bresnan","James_McCawley","Ate%C3%ADsmo","Anarcosindicalismo","Nueva_Izquierda_(concepto)","Movimiento_contra_la_guerra","Academia_Estadounidense_de_las_Artes_y_las_Ciencias","Asociaci%C3%B3n_Estadounidense_para_el_Avance_de_la_Ciencia","Academia_Nacional_de_Ciencias_(Estados_Unidos)","Academia_Alemana_de_las_Ciencias_Naturales_Leopoldina","Academia_Europ%C3%A6a","Academia_de_las_Artes_y_de_las_Ciencias_de_Serbia","American_Philosophical_Society","Filadelfia","7_de_diciembre","1928","Ling%C3%BC%C3%ADstica","Filosof%C3%ADa","Ciencia_pol%C3%ADtica","Instituto_Tecnol%C3%B3gico_de_Massachusetts","Ciencia_cognitiva","Capitalismo","Pol%C3%ADtica_exterior","Socialista_libertario","New_York_Times","Gram%C3%A1tica_generativa","Sintaxis","Innatismo_del_lenguaje","Gram%C3%A1tica_universal","Empirismo","Racionalismo","Cartesianismo","Conductismo","Burrhus_Frederic_Skinner","Jerry_Fodor","Jerarqu%C3%ADa_de_Chomsky","Lenguaje_formal","Teor%C3%ADa_de_la_computaci%C3%B3n","Activismo","Cr%C3%ADtica_social","Israel","Anarcosindicalismo","Industrial_Workers_of_the_World","Filadelfia","William_Chomsky","Idioma_hebreo","Gram%C3%A1tica","Juda%C3%ADsmo","Ucrania","Filosof%C3%ADa","Ling%C3%BC%C3%ADstica","Matem%C3%A1tica","Universidad_de_Pensilvania","Zellig_Harris","Norteam%C3%A9rica","Universidad_de_Harvard","Doctorado_honoris_causa","Universidad_Rovira_i_Virgili","Universidad_Nacional_de_Colombia","Universidad_de_Chile","Universidad_de_la_Frontera","Universidad_Nacional_Aut%C3%B3noma_de_M%C3%A9xico","Tesis","Gram%C3%A1tica_generativa_transformacional","Massachusetts_Institute_of_Technology","Premios_Fundaci%C3%B3n_BBVA_Fronteras_del_Conocimiento","Carol_Chomsky","Estructuralismo_(ling%C3%BC%C3%ADstica)","Psicolog%C3%ADa_conductista","Gram%C3%A1tica_universal","Gram%C3%A1tica_Universal","Recursi%C3%B3n","Daniel_Everett","Pirah%C3%A3","Idioma_pirah%C3%A3","Gram%C3%A1tica_generativa","Gram%C3%A1tica_formal","Principios_y_par%C3%A1metros","Morfema","Proverbio","Emergencia_(filosof%C3%ADa)","Conexionismo","Principios_y_par%C3%A1metros","Recci%C3%B3n_y_ligamiento","Lengua_natural","Gram%C3%A1tica_universal","Teor%C3%ADa-%CE%B8#Principio_de_proyecci\u00f3n","Recci%C3%B3n_y_ligamiento","Caso_(gram%C3%A1tica)#Teor\u00eda_del_caso_abstracto","Idioma_espa%C3%B1ol","Idioma_ingl%C3%A9s","Lengua-I","Cerebro_humano","Sintaxis","Sistema_computacional","M%C3%B3dulos","Principios_y_par%C3%A1metros","Estructura-P","Estructura-S","Fonolog%C3%ADa","Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Estructura-P","L%C3%A9xico","Sintaxis","Sintagma","Sintagma_verbal","Sintagma_nominal","Sintagma_adjetival","Sintagma_preposicional","Estructura-S","Interpretaci%C3%B3n","Significado","Sentido_ling%C3%BC%C3%ADstico","L%C3%A9xico","Categor%C3%ADas_gramaticales","Ling%C3%BC%C3%ADstica","Anarquismo_en_Espa%C3%B1a","Fascismo","Foro_Social_Mundial","Guerra_del_Vietnam","El_Pent%C3%A1gono","La_responsabilidad_de_los_intelectuales","The_New_York_Review_of_Books","Izquierda_pol%C3%ADtica","Capitalismo","Darwinismo_social","Herbert_Spencer","Anarquismo","Anarcosindicalismo","Sindicalismo_revolucionario","Industrial_Workers_of_the_World","Partido_Dem%C3%B3crata_de_los_Estados_Unidos","Partido_Republicano_de_los_Estados_Unidos","Partido_Verde_(Estados_Unidos)","Z_Communications","Rudolf_Rocker","Liberalismo_cl%C3%A1sico","Sionismo","Antisionista","Kibutz","Jos%C3%A9_Saramago","Leonardo_Boff","Cr%C3%ADtica_social","Intelligentsia","Edward_S._Herman","Universidad_de_Pensilvania","Israel","Atentados_del_11_de_septiembre","World_Trade_Center_(1973-2001)","Pent%C3%A1gono","Esc%C3%A1ndalo_Faurisson","Robert_Faurisson","Negaci%C3%B3n_del_Holocausto","Libertad_de_expresi%C3%B3n","Posmoderna","Relativismo_cultural","Canad%C3%A1","Venezuela","Izquierda_Anticapitalista","Podemos_(partido_pol%C3%ADtico)","Independentismo_catal%C3%A1n","AIPTI","Globalizaci%C3%B3n","Capitalismo","Libre_comercio","Ley_del_embudo","Fondo_Monetario_Internacional","Banco_Mundial","Organizaci%C3%B3n_Mundial_del_Comercio","Izquierda_pol%C3%ADtica","Latinoamerica","Hugo_Ch%C3%A1vez","ONU","Amazon.com","Religi%C3%B3n","Ateo","Lawrence_Krauss","Agn%C3%B3stico","Raz%C3%B3n","Cientificismo","L%C3%A1ser","Antirreligi%C3%B3n","Evangelios","Historia_del_cristianismo","Cristianismo","Pacifista","Radicalismo","Religi%C3%B3n","Pobreza","Jes%C3%BAs","Pobreza","Imperio_romano","Iglesia_(organizaci%C3%B3n)","Evangelios","Pobreza","Paz","Constantino_I","Cruz","Imperio_romano","Teolog%C3%ADa_de_la_liberaci%C3%B3n","Cristianismo_primitivo","Fondo_de_Cultura_Econ%C3%B3mica","El_Gobierno_en_el_Futuro","Los_guardianes_de_la_libertad","Ignacio_Ramonet","Heinz_Dieterich","Michel_Foucault","Ilan_Papp%C3%A9","Ilusionistas","Attac","Jerarqu%C3%ADa_de_Chomsky","Gram%C3%A1tica_transformacional","Problema_de_Orwell","Esc%C3%A1ndalo_Faurisson","Modelo_de_Propaganda_de_los_medios_de_comunicaci%C3%B3n","Consenso_manufacturado","Anarquismo_en_Estados_Unidos","Colorless_green_ideas_sleep_furiously","JSTOR","ISBN","Universidad_Nacional_de_Colombia","ISBN","Jorge_Majfud","William_H._Calvin","ISBN","ISBN","ISBN","Neil_Smith","Cambridge_University_Press","ISBN","ISBN","ISBN","The_Guardian","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Argentina","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Biblioteca_Nacional_de_Chile","Biblioteca_de_Catalu%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Australia","Biblioteca_Nacional_de_Israel","CiNii","Syst%C3%A8me_universitaire_de_documentation","Union_List_of_Artist_Names","ORCID","Scopus","BIBSYS","Mathematics_Genealogy_Project","Istituto_Centrale_per_il_Catalogo_Unico","Deutsche_Biographie","Open_Library","Google_Acad%C3%A9mico","Enciclopedia_Brit%C3%A1nica","Enciclopedia_Treccani","Pers%C3%A9e_(portal)","Dialnet","Europeana","Internet_Movie_Database"]}
{"url":"Cambio_ling%C3%BC%C3%ADstico","titulo":"Cambio linguistico","contenido":"Se denomina cambio linguistico al proceso de modificacion y transformacion que, en su evolucion historica, experimentan todas las lenguas en general, y las unidades linguisticas de cada uno de sus niveles en particular.  El cambio linguistico se diferencia de la variacion linguistica en que en el primero las modificaciones son diacronicas y, por tanto, las estudia la linguistica historica, mientras que las variaciones son sincronicas y la analiza, entre otras disciplinas, la sociolinguistica. El cambio linguistico es un proceso interno de la lengua que no tiene nada que ver con el cambio de lengua o sustitucion linguistica que es un proceso condicionado por factores externos.  Dos factores que han intervenido desde siempre en el cambio linguistico han sido los prestamos y la analogia, el primero es un ejemplo de causa externa y el segundo de causa interna. Los cambios linguisticos se agrupan por conveniencia en tres niveles: el cambio fonetico, el cambio morfosintactico y el cambio lexico-semantico.  En la linguistica del siglo XIX, el lenguaje se consideraba como un ser biologico con su nacimiento, desarrollo o evolucion, y muerte. Cada fase del desarrollo esta marcada por una serie de cambios linguisticos.  En los ultimos a\u00f1os del siglo XX, sin embargo, la sociolinguistica ha introducido nuevas teorias, gracias a los trabajos de Labov, sus discipulos y seguidores, que han aportado modificaciones radicales a los postulados clasicos del cambio linguistico propugnados por los neogramaticos. Para Labov es axiomatico que el habla de todos los individuos es variable, esto es, manifiesta mas de una forma. Esta variabilidad o variacionismo es observable tambien en las comunidades del habla a las que pertenecen los individuos. Con este variacionismo se esta poniendo de relieve que existe una motivacion social en los cambios linguisticos, y la regularidad, mas que como esencia de los cambios, es vista como consecuencia de los mismos. Ultimamente se ha demostrado que la conjuncion de algunas variables sociales, como el sexo y el nivel sociocultural, es un factor explicativo de la fuerza que impulsa el cambio linguistico. Igualmente varios estudios han establecido, que aunque aparentemente el cambio linguistico es progresivo, la variacion intergeneracional suele ser mas importante que la variabilidad individual, es decir, el habla de las generaciones jovenes no corresponde exactamente a la de los adultos,\u200b y ese efecto acumulado produce un cambio tras varias generaciones.  Asi las cosas, siguiendo a Labov, el cambio linguistico se origina casi siempre en un grupo intermedio de la clase social (la clase obrera alta o la clase media baja), y, dentro de estos grupos, los innovadores son personas importantes socialmente, con un alto indice de interaccion dentro y fuera de la comunidad de habla, destacando el papel de las mujeres en esta funcion. Por tanto, la funcion de los grupos etnicos nuevos en el cambio linguistico es inapreciable porque, al no estar integrados, no tienen los derechos y privilegios de los demas.  En el cambio linguistico llamamos causas externas a las que estan motivadas por factores sociolinguisticos relacionados con la historia de los hablantes de la lengua, como sus contactos con otras personas de otras lenguas, los factores demograficos y sus influencias culturales.  Asi la existencia masiva de bilinguismo en un grupo humano, o la presencia masiva de prestamos de una lengua a otra por motivos de influencia tecnologica, religiosa o cultural se ha supuesto que podria provocar cambio linguistico. Por ejemplo, durante algun tiempo fue popular la teoria del sustrato, hoy desechada, para la cual causa principal de la diferenciacion del latin fue que sus hablantes antes de la romanizacion hablaban lenguas diversas y al transferir parte de esos rasgos al latin que hablaron provocaron la fragmentacion. En el mismo tipo de ideas se fundamentan las influencias del superestrato (lenguas con hablantes nativos en un territorio que no llegan a ser la lengua mayoritaria de los hablantes del territorio) sobre y del adstrato (conjunto de lenguas de territorios adyacentes).  Las causas internas son aquellas relacionadas con la estructura de la propia lengua y el equilibrio que toda lengua debe mantener entre facilidad de produccion y facilidad de comprension. Las causas internas se manifiestan en la existencia de cambios linguisticos que se presentan juntos. Asi por ejemplo la perdida de ciertas consonantes finales en latin erosiono la flexion nominal de los nombres y eso a su vez hizo que para seguir expresando sin ambiguedad las relaciones sintacticas el orden de palabras fuera mas fijo (Sujeto-Verbo-Objeto).  La analogia, reconocida como uno de los motores del cambio linguistico a nivel morfosintactico, es una de las causas internas mejor conocidas. Para algunos linguistas ciertas innovaciones linguisticas analogicas se deben al proceso psicologico de la abduccion en la que un hablante aplica a un hecho linguistico concreto una supuesta ley general.  Witold Manczak propuso una serie de leyes cualitativas sobre la probabilidad de que una determinada estructura de una lengua cambio en relacion a otra. El resultado de su trabajo son las llamadas leyes de Manczak que dan pautas para ese cambio. Recientemente otros autores independientemente han encontrado una solida evidencia de que el ritmo de regularizacion por analogia morfologica de formas irregulares sigue una ley cuantitativa bien definida. Asi para diversos estados del ingles Martin Nowak y sus colaboradores encontraron que la probabilidad de cambio se relaciona con la frecuencia de uso mediante:\u200b   d p d t = C 1 f p} t}}=}}}}  donde:  En el nivel fonetico-fonologico es un cambio influido basicamente por factores internos, relacionados con las propiedades articulatorias o facilidad de articulacion como la asimilacion fonetica, la disimilacion y otros fenomenos como la epentesis o elision de sonidos.  Tambien se ha mencionado que las lenguas pueden cambiar por factores externos como la influencia del substrato linguistico, que se da cuando hablantes de otra lengua adquieren la nueva lengua como lengua habitual de la comunicacion llevando rasgos foneticos de su antigua lengua. Aunque tecnicamente eso seria la creacion de una nueva variedad en linguistica historica ese tipo de cambios se considera como uno de los posibles factores de diversificacion, y por tanto \"cambio\" de una lengua. Una causa externa similar a la anterior seria la influencia del adstrato linguistico. A veces la ocurrencia geografica no ya de lenguas diferentes sino de dialectos de la misma lengua puede llevar a la presencia de una variabilidad fonetica, que puede desencadenar cambios foneticos y fonologicos considerables.\u200b  En el cambio morfosintactico y morfologico juega un papel muy importante la ambiguedad estructural y la gramaticalizacion. La ambiguedad permite la aparicion de reanalisis morfemico.  Otro papel importante relacionado con minimizacion de la informacion superflua es la regularizacion analogica por la cual los patrones morfologicos residuales o marginales son substituidos por otros patrones flexivos mas extendidos o generalizados, eliminandose asi formas arcaicas, irregulares o singulares, en favor de modelos de flexion mas ampliamente usados. En este ultimo fenomeno la frecuencia de uso desempe\u00f1a un papel importante.  El cambio semantico se refiere a la especializacion o reduccion del significado de una palabra (por ejemplo en ingles deer originalmente designaba a cualquier animal salvaje como sus cognado latino fera 'fiera') o la generalizacion o ampliacion del significado de una palabra. Estos procesos de especializacion y generalizacion tienen que ver con la metonimia y la metafora.  Por el contrario el cambio lexico tiene que ver con la substitucion de una forma lexica por otra para denominar a una misma realidad. Y tambien con el proceso de prestamo linguistico que normalmente consiste en la incorporacion de formas lexicas para designar conceptos nuevos, o para nombrar casos especializados de conceptos existentes (gran parte de los anglicismos recientes en espa\u00f1ol son de este tipo). ","snippet":"Se denomina cambio linguistico al proceso de modificacion y transformacion que, en su evolucion historica, experimentan todas las lenguas en general, y las unidades linguisticas de cada uno de sus niv","enlaces_salientes":["Cambio_ling%C3%BC%C3%ADstico","Cambio_ling%C3%BC%C3%ADstico","Cambio_ling%C3%BC%C3%ADstico","Sustituci%C3%B3n_ling%C3%BC%C3%ADstica","Lengua_natural","Variaci%C3%B3n_ling%C3%BC%C3%ADstica","Diacron%C3%ADa","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Sincron%C3%ADa_y_diacron%C3%ADa","Socioling%C3%BC%C3%ADstica","Sustituci%C3%B3n_ling%C3%BC%C3%ADstica","Pr%C3%A9stamo_ling%C3%BC%C3%ADstico","Analog%C3%ADa","Cambio_fon%C3%A9tico","Cambio_l%C3%A9xico-sem%C3%A1ntico","Ling%C3%BC%C3%ADstica","Siglo_XIX","Lenguaje","Siglo_XX","Socioling%C3%BC%C3%ADstica","Teor%C3%ADa","Labov","Neogram%C3%A1ticos","Habla","Biling%C3%BCismo","Pr%C3%A9stamo_ling%C3%BC%C3%ADstico","Sustrato_(ling%C3%BC%C3%ADstica)","Lat%C3%ADn","Romanizaci%C3%B3n_(aculturaci%C3%B3n)","Superestrato","Adstrato","Lat%C3%ADn","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","Analog%C3%ADa_(morfolog%C3%ADa)","Morfosintaxis","Razonamiento_abductivo","Hablante","Ley","Witold_Ma%C5%84czak","Leyes_de_Ma%C5%84czak","Analog%C3%ADa_(morfolog%C3%ADa)","Cambio_fon%C3%A9tico","Asimilaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Disimilaci%C3%B3n","Ep%C3%A9ntesis","Sustrato_ling%C3%BC%C3%ADstico","Variedad_ling%C3%BC%C3%ADstica","Adstrato","Morfosintaxis","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Ambig%C3%BCedad#Ambig\u00fcedad_estructural","Gramaticalizaci%C3%B3n","Rean%C3%A1lisis_morf%C3%A9mico","Analog%C3%ADa_(morfolog%C3%ADa)","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","Cognado","Metonimia","Met%C3%A1fora","Pr%C3%A9stamo_ling%C3%BC%C3%ADstico","Anglicismo","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Cambridge_University_Press","El_Colegio_de_M%C3%A9xico","Larry_Trask","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Gram%C3%A1tica_hist%C3%B3rica","titulo":"Linguistica historica","contenido":"La linguistica historica o linguistica diacronica es la disciplina linguistica que estudia el cambio de las lenguas con el tiempo y el proceso de cambio linguistico. Por tanto, ocupa un lugar destacado en el estudio del parentesco genetico de las lenguas.  Los resultados de la linguistica historica pueden ser frecuentemente comparados con los de otras disciplinas, como la historia, la arqueologia o la genetica. En los estudios interdisciplinares de este tipo lo que se pretende es reconstruir la cronologia relativa de contactos entre pueblos, rutas de expansion e influencias culturales mutuas.  Dentro de la linguistica historica son especialmente importantes las tecnicas de la linguistica comparada, entre las que destaca el metodo comparativo.  Las similitudes entre diferentes lenguas obedecen a una de tres causas posibles: a) casualidad; b) prestamo linguistico; c) herencia o parentesco.  Cuando las similitudes entre palabras de distintas lenguas se deben a un origen comun, estas palabras se llaman cognados. Dichos cognados pueden usarse para determinar la sucesion de cambios foneticos dentro de una lengua o grupo de ellas (lo cual permite reconstruir parcialmente la historia de una familia de lenguas) o el grado de cercania de dos lenguas dentro de una familia.  Cuando se examina una lista de cognados se aprecian correspondencias foneticas regulares, por ejemplo, muchas palabras basicas en lenguas germanicas como fish 'pez', father 'padre', for 'para', empiezan por f-, mientras que en las lenguas romanicas sus equivalentes son similares pero empiezan por p-. Similarmente las palabras interrogativas muestran una correspondencia wh- / qu-: who 'quien', what 'que', where 'donde' (latin quo), when 'cuando' (latin quando). A partir de las correspondencias foneticas regulares puede tratar de reconstruirse el fonema detras de cada correspondencia. Por ejemplo, la correspondencia entre el ingles wh- y el latin qu- se debe a que ambos sonidos derivan de la labiovelar *kw del protoindoeuropeo, que evoluciono el protogermanico *hw (y en ingles medio se transcribio como wh) y el latin arcaico se mantuvo como *kw (aunque se escribia como qu-).  Si todas las lenguas de un grupo emparentado en forma filogenetica comparten un rasgo, suponemos que este se encontraba presente en la lengua madre. Asi, por ejemplo, todas las lenguas indoeuropeas antiguas son lenguas flexivas con marcas de caso explicitas, por lo que dicho rasgo debio estar presente en el idioma protoindoeuropeo. El protoindoeuropeo ha sido reconstruido principalmente mediante el metodo comparativo, reconstruyendo los elementos detras de cada correspondencia regular observada entre las lenguas indoeuropeas.  Este metodo intenta reconstruir sistemas linguisticos antiguos partiendo de los datos de una sola lengua. Se basa en que las irregularidades del presente remiten a procesos que en el pasado fueron regulares. Este metodo se utiliza basicamente con aquellas lenguas aisladas de las que se desconocen parientes o en combinacion con la reconstruccion externa. Los resultados de la reconstruccion externa mejoran cuando se practica previamente una reconstruccion interna dentro de cada lengua.  Pueden darse varios ejemplos de reconstruccion en espa\u00f1ol, donde sus paradigmas verbales presentan diptongacion en presencia del acento puedo, puedes, puede, podemos, podeis, pueden (notese que en las formas con ue el acento tonico recae en el dipotongo, mientras que las formas con o esta es atona) lo que llevaria a reconstruir las formas antiguas *podo, *podes, *pode, *podemos,... (donde /o/ representa la vocal abierta []). Igualmente el latin resuelve algunos participios que producirian tres consonantes seguidas , simplifancado a s en lugar de t (ama-re 'amar' > ama-tus 'amado') o bien eliminando alguna consonante:  Este metodo parte de ciertos supuestos de la retencion de items de vocabulario basico. El metodo compara el porcentaje de cognados (palabras geneticamente relacionadas) comun a las lenguas comparadas. Para muchos linguistas los supuestos basicos son poco realistas, y no tienen en cuenta los factores sociopoliticos y culturales que pueden influir de manera puntualmente importante en la evolucion de una lengua. Sin embargo, a pesar de esas objeciones el metodo sigue siendo frecuentemente comentado en los manuales de linguistica historica y siguen escribiendose articulos sobre su alcance. Asimismo existe un conjunto de estimaciones glotocronologicas que dan resultados razonablemente concordantes con datos historicos y arqueologicos. Ademas, cuando no existen fuentes escritas mediante las cuales se pueda investigar el pasado de dicha lengua, es frecuentemente una de las pocas alternativas existentes.  La paleontologia linguistica es el estudio del vocabulario lexico reconstruido referente a plantas, animales, tecnologia e instituciones. El conocimiento de dicho vocabulario lexico y su comparacion con datos arqueologicos, paleobotanicos y paleozoologicos proporciona pistas sobre la prehistoria pasada de un grupo de lenguas, permitiendo conjeturar hipotesis mas alla de los registros historicos conocidos.  El desarrollo de la gramatica comparada se dio sobre todo por parte de germanistas. en la misma direccion que Franz Bopp o Jacob Grimm trabajaron August Friedrich Pott (1802-1887), creador de la etimologia comparada; Georg Curtius (1820-1885), conocido sobre todo por sus Principios de etimologia griega (1879); Friedrich Max Muller (1823-1900), cuyas Lecciones sobre la ciencia del lenguaje (1861) contribuyeron a divulgar las doctrinas de los comparatistas, y finalmente August Schleicher (1821-1868), que intento codificar y sintetizar el conjunto de las lenguas indoeuropeas, entonces llamadas indogermanicas. su Compendio de gramatica comparada de las lenguas indogermanicas (1861) representa la sistematizacion de todos los esfuerzos realizados por los comparatistas desde Bopp y Grimm.\u200b  La historia de esta disciplina linguistica tiene su origen a mediados del siglo\u00a0XIX con los llamados Neogramaticos, interesados en encontrar la raiz de todas las lenguas europeas (el indoeuropeo) y leyes foneticas inmutables y sin excepciones.  Dos ideas son las que fundamentaron en aquel momento el desarrollo de la nueva forma de estudio linguistico:  De esta segunda idea se concluia que, para que el cambio poseyera regularidad, parecia necesario que respetase la organizacion gramatical de la lengua y solo alterase la palabra a traves de su organizacion interna. Por lo demas, se sugeria entonces que esa regularidad podia darse tambien en los componentes foneticos; de aqui que en el siglo\u00a0XIX se consolidase el estudio de las leyes foneticas, uno de los terrenos donde la linguistica historica obtuvo sus mayores exitos.  Se suele se\u00f1alar a 1816 como la fecha de nacimiento de la linguistica historica con la aparicion de la obra Sistema de conjugacion de la lengua sanscrita, comparado con el de las lenguas griega, latina, persa y germanica del linguista aleman Franz Bopp. El titulo describe perfectamente la metodologia empleada: el llamado comparatismo o gramatica comparada, tecnica empleada por varios linguistas de la epoca entre los que se incluyen a von Schlegel, Jacob Grimm, August Schleicher y Rasmus Kristian Rask. Las caracteristicas iniciales del comparatismo eran las siguientes:  Posteriormente el metodo comparativo se aplico a otras familias, muy tempranamente a las lenguas bantues y a las Lenguas malayo-polinesias y durante el siglo\u00a0XX virtualmente a casi todas las familias reconocidas. Igualmente ha habido un enfasis en la reconstruccion linguistica de las protolenguas que dieron lugar a las familias y grupos, los cuales lo denominan.  Las variedades dentro de una lengua historica pueden ser de tres tipos, a cada uno de los cuales le corresponde un sistema linguistico concreto:\u200b ","snippet":"La linguistica historica o linguistica diacronica es la disciplina linguistica que estudia el cambio de las lenguas con el tiempo y el proceso de cambio linguistico. Por tanto, ocupa un lugar destacad","enlaces_salientes":["Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Ling%C3%BC%C3%ADstica","Idioma","Cambio_ling%C3%BC%C3%ADstico","Historia","Arqueolog%C3%ADa","Gen%C3%A9tica","Ling%C3%BC%C3%ADstica_comparativa","M%C3%A9todo_comparativo_(ling%C3%BC%C3%ADstica)","Pr%C3%A9stamo_ling%C3%BC%C3%ADstico","Familias_de_lenguas","Palabra","Cognado","Correspondencias_fon%C3%A9ticas","Consonante_labiovelar","Idioma_proto-indoeuropeo","Protogerm%C3%A1nico","Filogen%C3%A9tica","Idioma_protoindoeuropeo","M%C3%A9todo_comparativo_(ling%C3%BC%C3%ADstica)","Lengua_aislada","Participio","Glotocronolog%C3%ADa","Cognado","Glotocronolog%C3%ADa#Supuestos_b\u00e1sicos","Paleontolog%C3%ADa_ling%C3%BC%C3%ADstica","Compa%C3%B1%C3%ADa_de_Jes%C3%BAs","Espa%C3%B1a","Lorenzo_Herv%C3%A1s","Cat%C3%A1logo_de_las_lenguas_de_las_naciones_conocidas","Gram%C3%A1tica_comparada","Franz_Bopp","Jacob_Grimm","August_Friedrich_Pott","Georg_Curtius","Friedrich_Max_M%C3%BCller","August_Schleicher","Lenguas_indoeuropeas","Siglo_XIX","Neogram%C3%A1ticos","Lenguas_indoeuropeas","Cambio_ling%C3%BC%C3%ADstico","Estructuralismo_(ling%C3%BC%C3%ADstica)","Ley_fon%C3%A9tica","Franz_Bopp","Jacob_Grimm","August_Schleicher","Lenguas_indoeuropeas","S%C3%A1nscrito","M%C3%A9todo_comparativo_(ling%C3%BC%C3%ADstica)","Lenguas_bant%C3%BA","Lenguas_malayo-polinesias","Reconstrucci%C3%B3n_ling%C3%BC%C3%ADstica","Protolengua","Variedades_diat%C3%B3picas","Lenguaje","Dialecto","Variedades_diastr%C3%A1ticas","Comunidad_ling%C3%BC%C3%ADstica","Sociolecto","Variedades_diaf%C3%A1sicas","Hablante","Situaci%C3%B3n_comunicativa","Comparat%C3%ADstica","Glotocronolog%C3%ADa","M%C3%A9todo_comparativo_(ling%C3%BC%C3%ADstica)","Familia_de_lenguas","Lista_Swadesh","Paleoling%C3%BC%C3%ADstica","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Filolog%C3%ADa_comparada","Ling%C3%BC%C3%ADstica_comparativa","Oxford_University_Press","ISBN","Cambridge_University_Press","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Comunicaci%C3%B3n_animal","titulo":"Zoosemiotica","contenido":"La zoosemiotica es la rama de la  biosemiotica que estudia los metodos que usan los animales para comunicarse entre si.\u200b\u200b  Se denomina zoosemiotica a la comunicacion celular, biologica y animal; al intercambio de se\u00f1ales que se da entre los animales de cualquier especie.\u200b  Los animales tienen diferentes sistemas de emitir mensajes. Utilizan su sensibilidad y sus sentidos de olfato, vista, tacto, oido y gusto para emitir y recibir mensajes. Usan cuatro campos o sistemas de comunicacion: el campo quimico, el optico, el tactil y el acustico. El uso de estos, les permite abarcar olores, intensidad de la luz, movimientos y el escuchar con claridad y precision si alguien se acerca o se aleja, etc. Por ejemplo; un perro guardian percibe claramente la presencia de extra\u00f1os, sabe como avisar o atacar si es necesario defender a su compa\u00f1ero humano. Percibe claramente el olor de las personas conocidas y desconoce sin temor a equivocaciones cuando la persona que esta cerca no es grata. La comunicacion entre los humanos y animales de otras especies tambien es muy frecuente cuando se establece una relacion entre ambos, como ocurre entre el perro y su compa\u00f1ero humano. El animal no humano aprende que comportamientos son \"buenos\" y cuales no, y despues a mantener un intercambio de afecto y lealtad indiscutible con algunas especies.  La comunicacion generalmente es entre animales de una misma especie, pero tambien puede ocurrir entre dos animales de especies diferentes. Los animales se comunican mediante se\u00f1ales, que pueden ser visuales, auditivas, quimicas \u2014con la participacion de feromonas\u2014 o tactiles. (fp)  La hipotesis principal de la zoosemiotica, asegura que todos los animales son sociales y que cada especie tiene sus propios medios de comunicacion y manifiestan a traves de ella su humor, epoca de celo, alegria, dolor, tristeza, etc. Esta ciencia se divide en: zoosemiotica pura que dise\u00f1a los modelos que permiten estudiar los mensajes y se\u00f1ales que se emiten entre los animales de manera cientifica, la zoosemiotica descriptiva que estudia la comunicacion entre las especies animales, como las se\u00f1ales que utilizan para elegir pareja, para llamar a sus crias o para alertar de la intromision de seres extra\u00f1os o de peligro.[cita\u00a0requerida]  Una de las funciones importantes es reunir los sexos para la reproduccion. El cortejo suele incluir rituales complejos, en los cuales uno o ambos participantes adoptan posturas con el objeto de \"llamarse\". En virtud de estos rituales, los participantes aprenden a reconocerse y a evaluar la conveniencia de aparearse con el otro.  Otra funcion es con motivo de distanciarse de otros animales, como una forma de establecer limites territoriales y posiciones dentro de una jerarquia. Las jerarquias son determinadas mediante la agresion y la sumision. En una manada de lobos indican su sometimiento agachando el lomo, poniendo las orejas hacia atras y colocando el rabo entre las patas.  En la defensa contra el ataque de rivales o predadores, muchas veces intervienen se\u00f1ales intensas o repentinas. Los mamiferos suelen emitir rugidos o gritos fuertes o graves cuando se sienten amenazados. Los conejos y los ciervos hacen se\u00f1ales con el rabo con el objeto de advertir a los demas de algun peligro inminente. Un individuo de un grupo que ha encontrado una fuente de alimento suele transmitir esa informacion al resto de sus compa\u00f1eros.  Las se\u00f1ales de comunicacion adoptan distintas formas. Esto depende de lo que se quiera transmitir, la distancia que esta tiene que recorrer y el habitat de los animales en cuestion. Las se\u00f1ales pueden ser:  Dependen del sentido del olfato y en algunas ocasiones del gusto. Estas se\u00f1ales pueden recorrer grandes distancias cuando son transportadas por las corrientes del aire, aunque solo son percibidas a favor del viento. Las sustancias quimicas especificas que producen efectos concretos se llaman feromonas. En las colonias de abejas, por ejemplo, la reina produce una feromona \"real\" que impide el desarrollo de los ovarios de las obreras. Las feromonas tienen una gran importancia en lo relativo a la atraccion sexual. Tambien se da esto en los perros ya que la hembra, en epoca de celo, suelta un olor que atrae al macho.  Pueden variar de altura e intensidad con rapidez. Sirven para transmitir una amplia gama de informacion. Estas se\u00f1ales viajan en todas direcciones y el receptor las localiza con facilidad. Por ejemplo, los monos aulladores y algunas aves, ranas y sapos poseen grandes sacos vocales que aumentan considerablemente los sonidos que emiten. En los caso de los sapos, emiten un sonido para atraer a la hembra y otro para \"avisar\" a otros que el tambien es macho.  Muchos animales diferentes usan estas se\u00f1ales, que se pueden encender y apagar en un instante, aunque por lo general son utiles en determinadas horas del dia. Suelen ser llamativas o consistir en movimientos bruscos. Una de las garras del cangrejo violinista macho es mayor que la otra, tiene colores fuertes y la sacude para atraer a las hembras. Los colores y dise\u00f1os de las alas de las mariposas y de los machos de muchas aves atraen a sus compa\u00f1eras en distancias cortas.  Actuan solo en distancias muy cortas. Para indicar su presencia a las hembras, los machos de las ara\u00f1as de estuche hacen vibrar sus membranas de un modo caracteristico. Los machos de los heteropteros producen ondas en la superficie del agua para que sean detectadas por los machos rivales y las hembras potenciales. Los ratones topo golpean su cabeza contra el techo de sus tuneles subterraneos para comunicarse con sus rivales o con sus parejas. Durante la epoca de reproduccion, las hembras de los mosquitos mueven sus alas emitiendo una vibracion.  Algunos peces que viven en los rios lodosos de America del Sur y Africa usan se\u00f1ales electricas capaces de atravesar cuerpos solidos. Son utilizadas para la agresion, para el cortejo y para orientarse.  La danza de la abeja se produce cuando una obrera recolectora o picoteadora encuentra una buena fuente de alimento cerca de la colmena, regresa y ejecuta encima del panal, una danza en forma de ocho aplastado.  El interes de estos sistemas de comunicacion radica en sus similitudes y diferencias con el lenguaje humano:\u200b  Los grupos animales actuan con un cerebro colectivo ","snippet":"La zoosemiotica es la rama de la  biosemiotica que estudia los metodos que usan los animales para comunicarse entre si.\u200b\u200b  Se denomina zoosemiotica a la comunicacion celular, biologica y animal; al in","enlaces_salientes":["Zoosemi%C3%B3tica","Zoosemi%C3%B3tica","Zoosemi%C3%B3tica","Comunicaci%C3%B3n_celular","Sociedad","Estro","Animal","Lobo","Mam%C3%ADfero","Conejo","Ciervo","H%C3%A1bitat","Olfato","Gusto","Feromonas","Mono_aullador","Rana","Sapo","Cangrejo","Mariposa","Ara%C3%B1a","Heter%C3%B3ptero","Mosquito","R%C3%ADo","Am%C3%A9rica_del_Sur","%C3%81frica","Danza_de_la_abeja","Colmena","Lenguaje","Doble_articulaci%C3%B3n","Morfema","Palabra","Fonema","Instinto","Dominancia_(etolog%C3%ADa)","Prox%C3%A9mica","Semi%C3%B3tica","Zoomusicolog%C3%ADa","Kalevi_Kull","Sign_Systems_Studies","Kalevi_Kull","Sign_Systems_Studies","Control_de_autoridades"]}
{"url":"Constituyente_sint%C3%A1ctico","titulo":"Constituyente sintactico","contenido":"Un constituyente sintactico es una palabra, o secuencia de palabras, que funciona en conjunto como una unidad dentro de la estructura jerarquica de una oracion. Un constituyente puede descomponerse frecuentemente en dos subsecuencias o mas, cada una de las cuales es, a su vez, otro constituyente. El conjunto de todos los constituyentes de una oracion es un conjunto ordenado, donde el orden se basa en la descomponibilidad de los constituyentes en subsconstituyentes.  Aunque todo constituyente esta formado por una secuencia de palabras (que en el limite podria ser una palabra), no cualquier secuencia de palabras es un constituyente. Se dira que una secuencia es un constituyente si cumple alguna de las pruebas de constituencia.  En la gramatica tradicional es comun aplicar el nombre \"sintagma\" a cualquier constituyente sintactico de mas de dos elementos. Sin embargo, en la moderna teoria generativa se distingue entre sintagmas y constituyentes sintacticos generales.\u200b De hecho los sintagmas son precisamente el constituyente sintactico maximal cuyas propiedades estan determinadas por el nucleo sintactico, hecho que se parafrasea diciendo que los \"sintagmas son precisamente las proyecciones sintacticas maximas de un nucleo sintactico\", siendo el resto de constituyentes sintacticos que contienen al nucleo de un sintagma, simplemente constituyentes sintacticos no sintagmaticos.  Algunos de los precedentes del moderno concepto de constituyente sintactico se encuentran en Bloomfield (1933).\u200b Y existen algunos precedentes menos sistematicas en autores europeos anteriores. La moderna teoria de la X' (1981) postula un sintagma de tipo SX tiene la estructura basica:  Siendo en ese esquema las dos X' (X'1 y X'2) que intervienen constituyentes sintacticos que no son sintagmas, sino simplemente constituyentes. Y donde ademas el papel de adjunto y complemento solo pueden ser realizados por constituyentes que tambien sean sintagmas. La anterior estructura arborea puede escribirse en la notacion de claudator, que es equivalente como:   [ S X S Z [ X \u00af 1 [ X \u00af 2 X 0 S Y ] S W ] ] \\ SZ\\ [_{}_{1}}\\ [_{}_{2}}\\ X^{0}\\ SY\\ ]\\ SW\\ ]\\ ]}  Donde:  Un ejemplo de la anterior estructura seria el siguiente:   [ S A [ S A d v mucho menos ] [ A \u00af [ A \u00af propenso [ S P a las enfermedades ] ] [ S P por falta de defensas ] ] ] \\ [_{SAdv}\\ }]\\ [_}\\ [_}\\ }\\ [_{SP}\\ }]]\\ [_{SP}\\ }]]]}  Existen varias pruebas o propiedades que nos permiten decidir en muchos casos, si una secuencia de palabras dada es o no un constituyente sintactico.  Debe advertirse, que contrariamente a lo que parece desprenderse de una buena parte de los manuales introductorios a la sintaxis, no existe un procedimiento mecanico algoritmico para establecer la estructura de constituyentes de cualquier oracion posible.\u200b Por tanto, las pruebas de constituencia aunque utiles no constituyen diagnosticos inequivocos que de la estructura oracional. ","snippet":"Un constituyente sintactico es una palabra, o secuencia de palabras, que funciona en conjunto como una unidad dentro de la estructura jerarquica de una oracion. Un constituyente puede descomponerse fr","enlaces_salientes":["Constituyente_sint%C3%A1ctico","Constituyente_sint%C3%A1ctico","Constituyente_sint%C3%A1ctico","%C3%81rbol_sint%C3%A1ctico","Oraci%C3%B3n_(gram%C3%A1tica)","%C3%81rbol_(teor%C3%ADa_de_grafos)","Palabra","Oraci%C3%B3n_(gram%C3%A1tica)","Conjunto_ordenado","Palabra","Gram%C3%A1tica_tradicional","Sintagma","Elemento_maximal","N%C3%BAcleo_sint%C3%A1ctico","Leonard_Bloomfield","Teor%C3%ADa_de_la_X%27","Adjunto_sint%C3%A1ctico","Complemento_sint%C3%A1ctico","Especificador_(sintaxis)","Complemento_sint%C3%A1ctico","Adjunto_sint%C3%A1ctico","Pronombre","Proforma","Control_de_autoridades"]}
{"url":"Homo_sapiens","titulo":"Homo sapiens","contenido":"Homo sapiens (en latin \u2018el hombre sabio\u2019),\u200b comunmente llamado ser humano, persona\u200b u hombre\u200b \u2014este ultimo en el sentido de ser racional, que no distingue entre ambos sexos\u2014,\u200b es una especie del orden de los primates perteneciente a la familia de los hominidos. El conjunto de personas o el genero humano\u200b tambien se conoce con la denominacion generica de humanos\u200b y humanidad.\u200b Los seres humanos poseen capacidades mentales que les permiten inventar, aprender, utilizar estructuras linguisticas complejas, y adquirir y mejorar sus habilidades logicas, matematicas, de escritura, musicales, entre otras. Los seres humanos son animales sociales, capaces de concebir, transmitir y aprender conceptos totalmente abstractos.  Se considera Homo sapiens de manera indiscutible a los que poseen las caracteristicas anatomicas de las poblaciones humanas actuales. Los restos mas antiguos atribuidos a Homo sapiens, datados en 315\u00a0000 a\u00f1os, se encontraron en Marruecos.\u200b Las evidencias mas antiguas de comportamiento moderno son las de Pinnacle Point (Sudafrica), con 165\u00a0000 a\u00f1os de antiguedad.  Pertenece al genero Homo, que fue mas diversificado y durante el ultimo millon y medio de a\u00f1os incluia otras especies ya extintas. Desde la extincion de Homo neanderthalensis, hace 28\u00a0000 a\u00f1os, es la unica especie conocida del genero Homo que aun perdura.  Hasta hace poco, la biologia utilizaba un nombre trinomial \u2014Homo sapiens sapiens\u2014 para esta especie, pero mas recientemente se ha descartado el nexo filogenetico entre el neandertal y la actual humanidad,\u200b por lo que se usa exclusivamente el nombre binomial. Homo sapiens pertenece a una estirpe de primates, los hominoideos. Aunque el descubrimiento de Homo sapiens idaltu en 2003 haria necesario volver al sistema trinomial, la posicion taxonomica de este ultimo es aun incierta.\u200b Evolutivamente se diferencio en Africa y de ese ancestro surgio la familia de la que forman parte los hominidos.  Filosoficamente, el ser humano se ha definido y redefinido a si mismo de numerosas maneras a traves de la historia, otorgandose de esta manera un proposito positivo o negativo respecto de su propia existencia. Existen diversos sistemas religiosos e ideales filosoficos que, de acuerdo con una diversa gama de culturas e ideales individuales, tienen como proposito y funcion responder a algunas de esas interrogantes existenciales. Los seres humanos tienen la capacidad de ser conscientes de si mismos, asi como de su pasado; saben que tienen el poder de planear, transformar y realizar proyectos de diversos tipos. En funcion de esta capacidad, han creado diversos codigos morales y dogmas orientados directamente al manejo de estas capacidades. Ademas, pueden ser conscientes de responsabilidades y peligros provenientes de la naturaleza, asi como de otros seres humanos.  En la actualidad, aproximadamente 8000 millones de seres humanos habitan la Tierra.  El nombre cientifico asignado por el naturalista sueco Carlos Linneo (1707-1778) en 1758\u200b alude al rasgo biologico mas caracteristico (sapiens significa \u00absabio\u00bb o \u00abcapaz de conocer\u00bb) y se refiere a la consideracion del ser humano como \u00abanimal racional\u00bb, al contrario que todas las otras especies, siendo la descripcion que aporto para Homo sapiens fue simplemente: Nosce te ipsum (\u00abConocete a ti mismo\u00bb). Es precisamente la capacidad del ser humano de realizar operaciones conceptuales y simbolicas muy complejas \u2014que incluyen, por ejemplo, el uso de sistemas linguisticos muy sofisticados, el razonamiento abstracto y las capacidades de introspeccion y especulacion\u2014 uno de sus rasgos mas destacados. Posiblemente esta complejidad, fundada neurologicamente en un aumento del tama\u00f1o del cerebro y, sobre todo, en el desarrollo del lobulo frontal, es tambien una de las causas, a la vez que producto, de las muy complejas estructuras sociales que el ser humano ha desarrollado, y que forman una de las bases de la cultura, entendida biologicamente como la capacidad para transmitir informacion y habitos por imitacion e instruccion, en vez de por herencia genetica. Esta propiedad no es exclusiva de esta especie y es importante tambien en otros primates.  Linneo clasifico al hombre y a los monos en un grupo que llamo antropomorfos, como subconjunto del grupo cuadrupedos, pues entonces no reconocia signos organicos que le permitieran ubicar al ser humano en un lugar privilegiado de la escala de los seres vivientes. A\u00f1os mas tarde, en el prefacio de Fauna suecica, manifesto que habia clasificado al hombre como cuadrupedo porque no era planta ni piedra, sino un animal, tanto por su genero de vida como por su locomocion y porque ademas, no habia podido encontrar un solo caracter distintivo por el cual el hombre se diferenciara del mono; en otro contexto afirmo sin embargo que considera al hombre como el fin ultimo de la creacion. A partir de la decima edicion de Systema naturae reemplazo a los cuadrupedos por los mamiferos y como primer orden de estos, puso a los primates, entre los cuales coloco al hombre. Linneo tuvo el merito de dar origen a un nuevo e inmenso campo epistemologico, el de la antropologia, si bien se limito a enunciarlo y no lo cultivo. A el tendran que remitirse todos los cientificos posteriores, tanto para retomar sus definiciones como para criticarlas. En 1758 se definio al Homo sapiens linneano como una especie diurna que cambiaba por la educacion y el clima.  Linneo no designo un holotipo para Homo sapiens, pero en 1959 William Stearn propuso al propio Linneo, padre de la moderna taxonomia, como lectotipo para la especie. Con posterioridad se difundio la idea de que habia sido sustituido por Edward Cope, pero esta propuesta no llego a formalizarse, asi que siguen siendo los restos de Linneo enterrados en Uppsala el tipo nomenclatural -que debe considerarse simbolico- para la especie Homo sapiens.\u200b  En la actualidad existen defensores de incluir al ser humano, chimpance (Pan troglodytes) y bonobo (Pan paniscus) en el mismo genero, dada la cercania filogenetica, que es mas estrecha que la que se encuentra entre otras especies animales que si estan agrupadas genericamente.\u200b Sin embargo, la inmensa mayoria de los especialistas no consideran correcto incluirlos dentro del mismo genero, debido a que los linajes evolutivos que condujeron al ser humano y al chimpance divergieron hace entre 6 y 10 millones de a\u00f1os y se diversificaron posteriormente, como argumenta Sandy Harcourt,\u200b y debido a las significativas diferencias entre los planes corporales de ambas lineas, especialmente en la de los Hominina, que permiten justificar varios generos (Ardipithecus, Paranthropus, Australopithecus u Homo).\u200b  El ser humano es un ser vivo, y como tal esta compuesto por sustancias quimicas llamadas biomoleculas, por celulas y realiza las tres funciones vitales: nutricion, relacion y reproduccion.\u200b  Ademas, el cuerpo es un organismo pluricelular; es decir, esta formado por muchas celulas, entre las cuales existen diferencias de estructura y de funcion.\u200b  Por otra parte, el ser humano es un animal, pues tiene celulas eucariotas, es decir, presenta organulos celulares especializados en una funcion determinada y su material genetico se encuentra protegido por una envoltura; y presenta nutricion heterotrofa; es decir, que para obtener su propia materia organica se alimenta de otros seres vivos.\u200b  En cuanto a su locomocion y movimiento, es uno de los mas plasticos del reino animal, pues existe una amplia gama de movimientos posibles, lo que le capacita para actividades como el arte escenico y la danza, el deporte y un sinnumero de actividades cotidianas. Asimismo destaca la habilidad de manipulacion, gracias a los pulgares oponibles, que le facilitan la fabricacion y uso de instrumentos.  La especie humana posee un notorio dimorfismo sexual en el nivel anatomico, siendo los hombres adultos mas altos y mas pesados que las mujeres en promedio, aunque se ha notado una \u00abtendencia secular\u00bb al aumento de las tallas en ambos sexos (especialmente durante el siglo\u00a0XX).  El ser humano adulto contemporaneo promedio mide entre: 1,55 m a 1,65 m (mujeres), y entre 1,65 m a 1,85 m (hombres). El peso depende de la contextura del individuo y del sexo, generalmente rondando los 45 kg a 70 kg (mujeres), y 65 kg a 100 kg (hombres). Los cuerpos humanos difieren entre si segun la estatura, peso, musculatura, nivel de grasa, entre otros.  La mente se refiere colectivamente a aspectos del entendimiento y conciencia que son combinaciones de capacidades como el raciocinio, la percepcion, la emocion, la memoria, la imaginacion y la voluntad. La mente, segun la neurociencia, es un resultado de la actividad del cerebro.  El termino pensamiento define todos los productos que la mente puede generar incluyendo las actividades racionales del intelecto y las abstracciones de la imaginacion; todo aquello que sea de naturaleza mental es considerado pensamiento, bien sean estos abstractos, racionales, creativos, artisticos, etc. Junto con los cetaceos superiores (delfines y ballenas), los homininos de los generos Gorilla y Pan, y los elefantes, alcanzan el mayor desarrollo y aun muchas de sus interacciones nos son desconocidas.  Los seres humanos, a diferencia del resto del reino animal, son los unicos con capacidad de razonar. Ademas poseen capacidades mentales que les permiten inventar, aprender y utilizar estructuras linguisticas complejas, logicas, matematicas, escritura, musica, ciencia y tecnologia. Los seres humanos son animales sociales, capaces de concebir, transmitir y aprender conceptos totalmente abstractos.  El ser humano es un animal omnivoro.\u200b\u200b En las primeras especies del genero Homo, el paso de una alimentacion eminentemente vegetariana a la inclusion de carne y grasas animales en la dieta no se debio a cuestiones culturales, sino a los desajustes metabolicos provocados por un mayor desarrollo cerebral.\u200b Sin embargo, en el humano, una dieta demasiado rica en proteinas necesita el complemento de carbohidratos y grasas; de lo contrario pueden aparecer carencias nutricionales importantes que pueden incluso provocar la muerte.\u200b Por ello, la alimentacion del ser humano se basa en la combinacion de carne con materia vegetal.\u200b  La especie humana es entre los seres vivos pluricelulares actuales una de las mas longevas; se tienen documentados casos de longevidad que sobrepasan los cien a\u00f1os. Tal longevidad es un caracter genotipico que, sin embargo, debe ser coadyuvado por condiciones vivenciales favorables. En el Imperio romano, hacia el a\u00f1o 1\u00a0d.\u00a0C., la esperanza de vida rondaba solo los 25 a\u00f1os, debido en gran parte a la elevada mortalidad infantil.[cita\u00a0requerida] A principios del siglo\u00a0XXI, la esperanza de vida global era de unos 70 a\u00f1os aproximadamente, siendo mas elevada en paises desarrollados y mas baja en paises subdesarrollados.  Se supone que el ser humano, en optimas condiciones, pueda vivir cien a\u00f1os o un poco mas. Sin embargo a pesar del avance en la salud y calidad de vida en el ultimo siglo, las costumbres humanas como el consumo de drogas, alcohol, azucar, comida basura, sedentarismo, estres, enfermedades de todo tipo, exposicion a elementos toxicos, entre otros, disminuye los a\u00f1os de vida de los seres humanos. Se cree tambien que pueda ser genetico.\u200b  La 'infancia' humana es una de las mas prolongadas en comparacion con otras especies cercanas, siendo la edad de la pubertad es aproximadamente a los once a\u00f1os en las ni\u00f1as y a los trece a\u00f1os en los ni\u00f1os, aunque las edades varian segun la persona.  Como todos los mamiferos, el ser humano tiene comportamientos reproductivos y sexuales. Pero a diferencia de la mayoria de ellos no tiene una epoca reproductiva estacional determinada, manteniendo actividad sexual y fertilidad en las hembras a lo largo de todo el a\u00f1o. Las mujeres tienen un ciclo de ovulacion aproximadamente mensual, durante el cual producen ovulos y pueden ser fecundadas; en caso contrario tienen la menstruacion, que es la eliminacion a traves de la vagina de los tejidos y sustancias relacionados con la produccion de celulas sexuales.  Pero el comportamiento sexual humano no esta unicamente supeditado a las funciones reproductivas, sino que, de modo similar a otros simios antropoides, tiene fines recreativos y sociales. En el contacto sexual se busca tanto el placer como la comunicacion afectiva. Es una parte importante de las relaciones de pareja y tambien se considera importante en las necesidades psicologicas del individuo aunque no tenga una relacion de pareja.  Cabe destacar la importancia del lenguaje simbolico en Homo sapiens, que hace que los significantes sean los soportes del pensar o los pensamientos. En nuestra especie, el pensar humano, a partir de los tres a\u00f1os y medio de edad se hace prevalentemente simbolico.  Asociado con lo anterior, debe notarse que la especie humana es practicamente la unica que se mantiene en celo sexual continuo: es realmente destacable que en la especie humana no exista un estro propiamente dicho. En las mujeres existe un ciclo de actividad ovarica en virtud del cual existen cambios fisiologicos en todo su sistema reproductivo y del cual derivan ciertos cambios de conducta. Sin embargo, como en las mujeres la aceptacion sexual no se circunscribe a una parte del ciclo reproductivo, no se deberia usar los vocablos \u00abestro\u00bb y \u00abcelo\u00bb en el ser humano, dado que la aceptacion sexual es independiente de su ciclo reproductivo. Ya entre chimpances y, sobre todo, bonobos, se nota una conducta proxima.  Ahora bien, dada la dificultad de vivir \u00absolamente\u00bb practicando relaciones sexuales, un \u00abmecanismo\u00bb evolutivo compensatorio habria sido el de la sublimacion \u2013la cual se considera asociada a la existencia de un lenguaje y un pensar simbolicos\u2013. Si se da una sublimacion, esto parece significar que tambien se da una \u00abrepresion\u00bb (en el sentido freudiano) que origina a lo inconsciente. Homo sapiens es, en este sentido, un \u00ab\u00abanimal pulsional\u00bb. Segun la ley del reflejo condicional de Pavlov Homo sapiens \u00abno\u00bb se restringe a un \u00abprimer sistema de se\u00f1ales\u00bb (el de estimulo/respuesta y respuesta a un estimulo substitutivo), sino que el ser humano se encuentra en un nivel de \u00absegundo sistema de se\u00f1ales\u00bb. Este segundo sistema es, principalmente, el del lenguaje simbolico que permite una heuristica, que es la capacidad para realizar de forma inmediata innovaciones positivas para sus fines.  Por otra parte, la especie humana es de las pocas, junto con el bonobo (Pan paniscus), en el reino animal que copula cara a cara, lo cual tiene implicaciones emocionales de gran relevancia para la especie.  Cabe anotar que con el surgimiento de la teoria de la inteligencia emocional, desde la psicologia sistemica, el ser humano no debe reducirse a sus pulsiones, las cuales sublima o reprime, sino que se entiende como un ser sexuado, que vive esta dimension en relacion con la formacion recibida en la familia y la sociedad. La sexualidad se forma entonces desde los primeros a\u00f1os y se va entendiendo como una vivencia procesual acorde a su ciclo vital y su contexto sociocultural.  A diferencia de lo que ocurre en la mayor parte de las otras especies sexuadas, la mujer sigue viviendo mucho tiempo tras la menopausia. En las otras especies la hembra suele fenecer al poco tiempo de su llegada.  Por la indicada prematuracion, la madurez sexo-genital es \u2013con relacion a otras especies\u2013 muy tardia entre los individuos de la especie humana. Actualmente en muchas zonas la menarquia esta ocurriendo a los once a\u00f1os; esto significa que, aunque la madurez sexo-genital es siempre lenta en la especie humana, existe un adelantamiento de la misma respecto a epocas pasadas (del mismo modo suele darse una menopausia cada vez mas tardia). Pero si la madurez sexo-genital es tardia en la especie humana, aun mas suele serlo la madurez intelectual y, en especial, la madurez emotiva.  A lo largo de la historia se han ido desarrollando distintas concepciones miticas, religiosas, filosoficas y cientificas respecto del ser humano, cada una con su propia explicacion sobre el origen del hombre, trascendencia y mision en la vida.  Evolutivamente, en cuanto perteneciente al infraorden Catarrhini, Homo sapiens parece tener su ancestro, junto con todos los primates catarrinos, en un periodo que va de los 50 a 33 millones de a\u00f1os antes del presente (AP). Uno de los primeros catarrinos, quizas el primero, es Propliopithecus, incluyendo a Aegyptopithecus. En este sentido, el ser humano actual, al igual que primates del \"Viejo Mundo\" con caracteristicas mas primitivas, probablemente descienda de esa antigua especie.  En cuanto a la bipedestacion, esta se observa en ciertos primates a partir del Mioceno. Ya se encuentran ejemplos de bipedacion en Oreopithecus bambolii y la bipedestacion parece haber sido comun en Orrorin y Ardipithecus. Las mutaciones que llevaron a la bipedacion fueron exitosas porque dejaban libres las manos para agarrar objetos y, particularmente, porque en la marcha un hominido ahorra mucha mas energia andando sobre dos piernas que sobre cuatro patas, puede acarrear objetos durante la marcha y otear mas lejos. Sin embargo, de remontarse la bipedestacion a quizas a unos seis millones de a\u00f1os AP, la andadura o forma de marcha tipica del humano se consolida aproximadamente hace al menos unos cuatro millones de a\u00f1os con Australopithecus. Previamente los primates antropoides apoyaban toda la planta del pie haciendo una flexion y descargando el peso en el calcaneo; en cambio, Australopithecus logra una marcha bipeda eficiente, pues se notan claramente los cambios anatomicos a nivel del pie, en especial del dedo gordo; tambien ajustando el angulo del femur con el cuerpo para el equilibrio, la cadera o pelvis cambia a mas robusta, corta y concava (forma de cuenco); la columna paso de ser un arco en forma de C a una forma de S y el agujero de la base del craneo que conecta con la columna se desplazo hacia adelante\u200b como dirigiendose al centro de gravedad de la cabeza.  Hace 1.5 millones de a\u00f1os con Homo erectus o con Homo ergaster, la andadura moderna implica la existencia de un peque\u00f1o angulo entre el dedo gordo y el eje del pie, asi como la presencia del arco longitudinal de la planta y una distribucion medial del peso (notese que en las mujeres la andadura distribuye el peso mas hacia las partes internas del pie debido a la mayor anchura de la pelvis).\u200b  Todos los cambios rese\u00f1ados han sucedido en un periodo relativamente breve (aunque se mida en millones de a\u00f1os). Esto explica la susceptibilidad de nuestra especie a afecciones en la columna vertebral y en la circulacion sanguinea y linfatica (por ejemplo, el corazon recibe -relativamente- \"poca\" sangre).  Lo que denominamos propiamente \u00abhumano\u00bb es una referencia a la aparicion de la capacidad de fabricar herramientas de piedra en un hominido bipedo, Homo habilis, considerado por la mayoria como la especie humana mas primitiva, mostrando ademas incremento en la capacidad craneana con respecto a Australopithecus. Es asi como se establece que hace unos dos millones y medio de a\u00f1os, con la aparicion del genero Homo, se toma como punto de inicio para el Paleolitico o Edad de Piedra. Mayor exito evolutivo tendra Homo erectus, quien lograra expandirse por toda Eurasia.  Probablemente cuando los ancestros de Homo sapiens vivian en selvas comiendo frutos, bayas y hojas, abundantes en vitamina C, pudieron perder la capacidad metabolica que tiene la mayoria de los animales de sintetizar en su propio organismo tal vitamina; ya antes parecen haber perdido la capacidad de digerir la celulosa. Tales perdidas durante la evolucion han implicado sutiles pero importantes determinaciones: cuando las selvas originales se redujeron o, por crecimiento demografico, resultaron superpobladas, los primitivos hominidos (y luego los humanos) se vieron forzados a recorrer importantes distancias, migrar, para obtener nuevas fuentes de nutrientes. La perdida de la capacidad de metabolizar ciertos nutrientes como la vitamina C habria sido compensada por una mutacion favorable que permite a Homo sapiens una metabolizacion optima (ausente en primates) del almidon, y asi una rapida y \"barata\" obtencion de energia, particularmente util para el cerebro. Homo sapiens parece ser una criatura bastante indefensa, y como respuesta satisfactoria la unica solucion evolutiva que ha tenido es su complejisimo sistema nervioso central, espoleado principalmente por la busqueda de nuevas fuentes de alimentacion. Se ha sugerido la hipotesis de que la cefalizacion aumento paralelamente al incremento de consumo de carne,[cita\u00a0requerida] aunque dicha hipotesis no concuerda con el grado de cefalizacion desarrollada por los animales carnivoros. La habilidad humana para digerir alimentos con alto contenido de almidon podria explicar el exito del Homo sapiens en el planeta, y sugiere un estudio genetico.\u200b  Se denomina \u00abhumanos arcaicos\u00bb, \u00abHomo sapiens arcaico\u00bb o tambien \u00abpre-sapiens\u00bb, a un cierto numero de especies de Homo que aun no son considerados anatomicamente modernos. Poseen hasta 600\u00a0000 a\u00f1os de antiguedad y tienen un tama\u00f1o cerebral cercano al de los humanos modernos. El antropologo Robin Dunbar opina que es en esta etapa cuando aparece el lenguaje humano. La filiacion de estos individuos dentro de nuestro genero resulta aun controvertida.  Entre los humanos arcaicos estan considerados Homo heidelbergensis, Homo rhodesiensis, Homo neanderthalensis y a veces Homo antecessor. En 2010 se ha a\u00f1adido a estos el denominado \u00abhombre de Denisova\u00bb,\u200b y en 2012 el denominado \u00abhombre del ciervo rojo\u00bb en China.\u200b Ya que no son sapiens, algunos especialistas prefieren llamarlos simplemente arcaicos antes que H. sapiens arcaico.\u200b  Se denomina propiamente Homo sapiens o anatomicamente modernos a individuos con una apariencia similar a la de los humanos modernos. Estos humanos pueden clasificarse como premodernos, pues en ellos no se observa todavia el conjunto de caracteristicas de un craneo moderno, casi esferico, con la boveda alta y la frente vertical.\u200b La similitud se aprecia a nivel del esqueleto del cuerpo y cavidad craneana, pero esta similitud no es total pues el rostro aun mantiene caracteristicas arcaicas como los arcos superciliares (grandes cejas) y prognatismo maxilar (proyeccion bucal), aunque menos desarrollados que en los neandertales.\u200b  Se considera dentro de este grupo a los restos de Florisbad en Sudafrica (260\u00a0000 a\u00f1os),\u200b los de Herto en Etiopia, que corresponde a Homo sapiens idaltu (160\u00a0000 a\u00f1os), los de Jebel Irhoud en Marruecos (315\u00a0000 a\u00f1os) y los de Skhul/Qafzeh al norte de Israel (100\u00a0000 a\u00f1os). Tambien se considera anatomicamente modernos a los hombres de Kibish; sin embargo, estos se enmarcan mejor dentro de los humanos modernos.  Se considera Homo sapiens sapiens de forma indiscutible a los que poseen las caracteristicas principales que definen a los humanos modernos: primero la equiparacion anatomica con las poblaciones humanas actuales y luego lo que se define como \"comportamiento moderno\".  Actualmente, gracias a los analisis cientificos, se sabe que en la genealogia de la evolucion humana habria existido un antepasado comun masculino y uno femenino, a los cuales se les nombro como sus similes religiosos.  Los restos mas antiguos son los de Omo I, llamados Hombres de Kibish, encontrados en Etiopia con 195\u00a0000 a\u00f1os, y restos en cuevas del rio Klasies en Sudafrica con 125\u00a0000 a\u00f1os y con indicios de una conducta mas moderna.\u200b  Esta antiguedad coincide con lo estimado para la Eva mitocondrial, la cual esta considerada la antecesora de todos los seres humanos actuales y de la que se cree que vivio en el Africa Oriental\u200b (probablemente Tanzania) hace unos 200\u00a0000 a\u00f1os.  Por otra parte, la linea patrilineal nos lleva hasta el Adan cromosomico, quien nos confirma un origen para los humanos modernos en el Africa subsahariana y se le calcula unos 140\u00a0000 a\u00f1os de antiguedad.\u200b  Es casi seguro que la Eva mitocondrial y el Adan cromosomico, los primeros Homo sapiens eran melanodermicos, esto es, de tez oscura. Esto se debe a que la piel oscura es una excelente adaptacion a la exposicion solar alta de las zonas intertropicales del planeta Tierra; la tez oscura (por la melanina) protege de las radiaciones UV (ultravioletas) y obtiene de ellas por metabolismo un nutriente llamado folato, indispensable para el desarrollo del embrion y del feto; pero, a medida que las poblaciones humanas migraron a latitudes mas alla de los 45\u00b0 (tanto norte como sur) la melanina paulatinamente fue menos necesaria, mas aun, en las cercanias de las latitudes de los 50\u00b0 la casi total falta de este pigmento en la dermis, cabello y ojos ha sido una adaptacion para captar mas radiaciones U.V. \u2014relativamente escasas en tales latitudes, salvo que se produzcan huecos de ozono\u2014; en tales latitudes la tez muy clara posibilita una mayor metabolizacion de vitamina D a partir de las radiaciones UV.  La aparicion del comportamiento humano moderno significo el mas importante cambio en la evolucion de la mente humana, dando lugar a que el ingenio creativo humano le permitiese dominar su entorno paulatinamente.  Las innovaciones que fueron apareciendo consisten en una gran diversidad de herramientas de piedra, en el uso de hueso, asta y marfil, en entierros con bienes funerarios y rituales, construccion de viviendas, dise\u00f1o de las fogatas, evidencia de pesca, caceria compleja, aparicion del arte figurativo y el uso de adornos personales.\u200b  Las evidencias mas antiguas se encuentran en Africa; herramientas elaboradas hace 165\u00a0000 a\u00f1os se encontraron en la cueva de Pinnacle Point (Sudafrica).\u200b Restos de puntas de flechas y herramientas de hueso para pescar se encontraron en el Congo y tienen 90\u00a0000 a\u00f1os. Igualmente antiguos son unos simbolos sombreados con ocre rojo en costas al sur de Africa.\u200b  Segun la teoria fuera de Africa, hubo una gran migracion de Africa hacia Eurasia hace 70\u00a0000 a\u00f1os que produjo la paulatina dispersion por todos los continentes. Segun los estudios geneticos y los descubrimientos paleontologicos, se estima que hace 60\u00a0000 a\u00f1os hubo una migracion costera por el Sur de Asia, de pocos miles de a\u00f1os, que posibilito la colonizacion posterior de Australia, Extremo Oriente y Europa.  En Occidente hubo un centro de expansion en el Medio Oriente que esta relacionado con el hombre de Croma\u00f1on y la poblacion temprana de Europa, probable causa de la extincion del hombre de Neandertal.  Segun algunos estudios geneticos, en Europa hubo tres migraciones: la primera, proveniente del Asia Central hace 40\u00a0000 a\u00f1os que colonizo la Europa del Este. Una segunda oleada hace 22\u00a0000 a\u00f1os, proveniente del Oriente Medio, que se instalo en la Europa del sur y del oeste. El 80\u00a0% de los europeos actuales son descendientes de estas dos migraciones, que durante el transcurso del maximo glaciar de hace 20\u00a0000 a\u00f1os se refugiaron en la peninsula iberica y en los Balcanes, para volver a expandirse por el resto de Europa cuando llego el clima favorable. La tercera migracion se habria producido hace 9000 a\u00f1os, proveniente del Oriente Medio, durante el transcurso del Neolitico, y solo el 20\u00a0% de los europeos actuales llevan marcadores geneticos correspondientes a esos emigrantes.\u200b  Otros estudios dicen lo contrario, afirmando que en Europa el componente neolitico desde el Cercano Oriente es el mas importante.\u200b Lo cierto por ahora es que el acervo genetico europeo prehistorico proviene mayoritariamente del Cercano Oriente, y una menor parte proviene de Africa, Asia Central y Siberia.  En Oriente la poblacion es igualmente antigua. El pliegue epicantico de los parpados existente en gran parte de las poblaciones del Asia y de America, el pliegue que hace 'bridados' en su aspecto externo a los ojos, ha sido una especializacion de poblaciones que durante las glaciaciones debieron pervivir en lugares con abundancia de nieve; los ojos vulgarmente llamados \u00abrasgados\u00bb entonces fueron el modo de adaptacion para que los ojos no padecieran un excesivo reflejo de la luz solar reflejada por la nieve.[cita\u00a0requerida]  Sin embargo, una publicacion de julio de 2019 en la revista Nature puso en tela de juicio las teorias e ideas previas acerca del momento del poblamiento de Europa por Homo sapiens desde Africa. El hallazgo y datacion de un craneo de Homo sapiens de 210 000 a\u00f1os de antiguedad en Grecia significaria un poblamiento de Europa 60 000 a\u00f1os mas temprano que lo que se suponia.\u200b\u200b  El lenguaje designa todas las comunicaciones basadas en la interpretacion, incluyendo el lenguaje humano, pero la mayoria de las veces el termino se refiere a lo que los humanos utilizan para comunicarse, es decir, a las lenguas naturales. El lenguaje es universal y es usado por naturaleza en las personas y en los animales. Sin embargo, filosofos como Martin Heidegger consideran que el lenguaje propiamente tal es solo privativo del hombre. Es famosa la tesis de Heidegger segun la cual el lenguaje es la casa del ser (Haus des Seins) y la morada de la esencia humana. Este criterio es similar al de Ernst Cassirer, quien ha definido a Homo sapiens como el animal simbolico por excelencia; tan es asi que es casi imposible suponer un pensamiento humano sin la ayuda de los simbolos, particularmente de los significantes que subyacen como fundamentos elementales para todo pensar complejo y que transcienda a lo instintivo.  Actualmente la especie humana muestra esta faceta hablando en torno a 6000 idiomas diferentes, si bien mas del 50\u00a0% de los 8000 millones de personas que actualmente conforman la colectividad humana, sabe hablar al menos uno de los siguientes: chino mandarin, espa\u00f1ol, ingles, frances, arabe, hindi, portugues, aleman, bengali o ruso.  En muchas civilizaciones los seres humanos se han visto a si mismos como diferentes de los demas animales, y en ciertos ambitos culturales (como las religiones del Libro o buena parte de la metafisica del Occidente) la diferencia se asigna a una entidad inmaterial llamada alma, en la que residirian la mente y la personalidad, y que algunos creen que puede existir con independencia del cuerpo.  Posiblemente, la manifestacion mas clara de humanidad es el arte \u2014en el sentido amplio del termino\u2014, que produce la cultura. Por ejemplo, los individuos de una determinada especie de ave fabrican un nido, o emiten un canto, cuyas caracteristicas son especificas, comunes a todos los individuos de esa especie. En cambio, cada hombre puede imprimir a sus acciones los rasgos propios de su individualidad; por eso, cuando se analiza un cuadro, una forma de escribir, una manera de fabricar herramientas, etc., se puede deducir quien es su autor, su artifice, su artista.[cita\u00a0requerida]  En 2011, en la revista Science, se publico un trabajo de Francesco d'Errico, de la Universidad de Burdeos, donde afirma haber encontrado uno de los rastros mas antiguos de un taller de pintura, en la cueva Blombos en Cape Coast, 300\u00a0km al este de Ciudad del Cabo. Este hecho muestra un modo sistematico para obtener pigmentos, pues reunir todos los elementos necesarios para una preparacion de este tipo es indicativo de un elevado nivel de pensamiento, que se puede llamar pensamiento simbolico. \"La capacidad de tener estos pensamientos es considerada un gran paso en la evolucion humana, precisamente lo que nos diferencio del mundo animal\".\u200b  Paralelamente, tambien es la unica especie que dedica su tiempo y energia a algo aparentemente inutil desde el punto de vista puramente practico. El arte es una de las manifestaciones de la creatividad humana, pero una manifestacion vacia y negativa desde el punto de vista de la supervivencia. Si bien esta actividad es en principio da\u00f1ina, en realidad es la herramienta con la cual Homo sapiens desarrolla su cultura, union y fuerza como pueblo.[aclaracion requerida][cita\u00a0requerida]  La ciencia (del latin scientia, 'conocimiento') es un  conjunto de conocimientos sistematicos comprobables que estudian, explican y predicen los fenomenos sociales, artificiales y naturales.\u200b El conocimiento cientifico se obtiene de manera metodologica mediante observacion y experimentacion en campos de estudio especificos. Dicho conocimiento se organiza y se clasifica sobre la base de principios explicativos, ya sean de forma teorica o practica. A partir del razonamiento logico y el analisis objetivo de la evidencia cientifica se formulan preguntas de investigacion e hipotesis, se deducen principios y leyes, y se construyen modelos, teorias y sistemas de conocimientos por medio del metodo cientifico.\u200b  La ciencia considera y tiene como fundamento la observacion experimental. Este tipo de observacion se organiza por medio de metodos, modelos y teorias con el fin de generar nuevo conocimiento. Para ello se establecen previamente unos criterios de verdad y un metodo de investigacion. La aplicacion de esos metodos y conocimientos conduce a la generacion de nuevos conocimientos en forma de predicciones concretas, cuantitativas y comprobables referidas a observaciones pasadas, presentes y futuras. Con frecuencia esas predicciones se pueden formular mediante razonamientos y estructurar como reglas o leyes generales, que dan cuenta del comportamiento de un sistema y predicen como actuara dicho sistema en determinadas circunstancias.  Una sociedad humana es aquella que se considera a si misma, a los habitantes y a su entorno, todo ello interrelacionado con un proyecto comun, que les da una identidad de pertenencia. Asimismo, el termino connota un grupo con lazos economicos, ideologicos y politicos. Tal sociedad supera al concepto de nacion-estado, planteando a la sociedad occidental como una sociedad de naciones, etc.  En relacion con la capacidad para realizar grandes modificaciones ambientales, cabe decir que Homo sapiens es actualmente un poderoso agente geomorfologico; es en este y otros sentidos que el ser humano es actualmente el mayor superpredador y la especie mas poderosa del planeta. Sin embargo, sigue siendo fragil ante posibles eventos cataclismicos que pudieran afectar a su habitat, como las glaciaciones.  Homo sapiens, por ser un animal muy vulnerable en el medio natural, es muy dependiente de la tecnologia (ergo: es dependiente de la ciencia por primitiva que esta sea), asi es que se dice de Homo sapiens que es homo faber.  Quizas, dado que todo sistema retroalimentado de forma natural llega a su fin, el fin de un ecosistema llega cuando la vida ha logrado evolucionar hasta lograr seres con un grado de conciencia capaz de programarse en funcion de la educacion recibida y no segun lo termodinamicamente sostenible.[cita\u00a0requerida] La educacion es, por tanto, la demostracion evidente de si somos parte de un sistema aun mayor o intentamos independizarnos de todo, estableciendo nuestras formas de obtener nuestros recursos, sin tener en cuenta los ya establecidos por la propia naturaleza.  Por ejemplo, la naturaleza le dota de capacidades fisicas para buscar alimentos en el medio que les rodea de una manera termodinamicamente eficaz. Los humanos establecen que lo mejor es racionalizar los medios que la naturaleza les da y replicarlos de forma industrial, aplicando procesos que no se dan de forma natural, aumentando el consumo energetico por redundar algo que ya existe y ampliandolo a algo totalmente termodinamicamente innecesario, como es el hecho de que se le entregue alimento en casa, de intervenir los codigos geneticos de las especies alimentarias para hacerlas resistentes a enfermedades, de influir en que alimentos contendran semillas y cuales no y un largo etcetera, que a dia de hoy nos hace la vida mas comoda, pero que ignoran como les afectan esos cambios en su estructura genetica y, por lo tanto, si su descendencia portara caracteristicas fundamentales para sobrevivir a un medio natural o, por el contrario, naceran y dependeran tan intimamente del medio artificial que cualquier modificacion a ese medio le incapacite de tal manera que provoque su extincion.[cita\u00a0requerida] ","snippet":"Homo sapiens (en latin \u2018el hombre sabio\u2019),\u200b comunmente llamado ser humano, persona\u200b u hombre\u200b \u2014este ultimo en el sentido de ser racional, que no distingue entre ambos sexos\u2014,\u200b es una especie del orden","enlaces_salientes":["Homo_sapiens","Homo_sapiens","Homo_sapiens","Humano_(desambiguaci%C3%B3n)","Humanidad_(desambiguaci%C3%B3n)","Escala_temporal_geol%C3%B3gica","Prec%C3%A1mbrico","C%C3%A1mbrico","Ordov%C3%ADcico","Sil%C3%BArico","Dev%C3%B3nico","Carbon%C3%ADfero","P%C3%A9rmico","Tri%C3%A1sico","Jur%C3%A1sico","Cret%C3%A1cico","Pale%C3%B3geno","Ne%C3%B3geno","Pleistoceno","Chibaniense","Holoceno","Pioneer_11","Voyager","Var%C3%B3n","Mujer","Taxonom%C3%ADa","Dominio_(biolog%C3%ADa)","Eukaryota","Reino_(biolog%C3%ADa)","Animalia","Eumetazoa","Bilateria","Deuterostomia","Filo","Chordata","Vertebrata","Gnathostomata","Tetrapoda","Clase_(biolog%C3%ADa)","Mammalia","Theria","Placentalia","Boreoeutheria","Euarchontoglires","Euarchonta","Primatomorpha","Orden_(biolog%C3%ADa)","Primates","Haplorrhini","Simiiformes","Catarrhini","Hominoidea","Familia_(biolog%C3%ADa)","Hominidae","Homininae","Tribu_(biolog%C3%ADa)","Hominini","Hominina","G%C3%A9nero_(biolog%C3%ADa)","Homo","Especie","%C3%81rea_biogeogr%C3%A1fica","Homo_sapiens_idaltu","Homo_sapiens_sapiens","Grupos_%C3%A9tnicos","Lat%C3%ADn","Persona","Racionalidad","Especie","Orden_(biolog%C3%ADa)","Primates","Familia_(biolog%C3%ADa)","Hominidae","Invento","Aprendizaje","Idioma","L%C3%B3gica","Matem%C3%A1ticas","Escritura","M%C3%BAsica","Animal_social","Abstracci%C3%B3n_(filosof%C3%ADa)","Marruecos","Yacimiento_arqueol%C3%B3gico_de_Pinnacle_Point","G%C3%A9nero_(biolog%C3%ADa)","Homo","Homo_neanderthalensis","Homo_sapiens_sapiens","Filog%C3%A9nesis","Primates","Hominoidea","Homo_sapiens_idaltu","Evoluci%C3%B3n_humana","%C3%81frica","Familia_(biolog%C3%ADa)","Hominidae","Filosof%C3%ADa","Existencia","Religi%C3%B3n","Cultura","Conciencia","Historia","Moral","Dogma","Desastre_natural","Guerra","Poblaci%C3%B3n_humana_mundial","Hombre_de_Vitruvio","Leonardo_da_Vinci","Nomenclatura_binomial","Carlos_Linneo","Con%C3%B3cete_a_ti_mismo","Concepto","S%C3%ADmbolo","Lenguaje","Abstracci%C3%B3n_(filosof%C3%ADa)","Introspecci%C3%B3n","Especulaci%C3%B3n_(filosof%C3%ADa)","Neurolog%C3%ADa","Cerebro_humano","Cultura","Linneo","Mono","Antropomorfos","Cuadr%C3%BApedo","Systema_naturae","Mam%C3%ADferos","Primates","Antropolog%C3%ADa","Tipo_nomenclatural","William_Thomas_Stearn","Tipo_nomenclatural","Edward_Drinker_Cope","Uppsala","Pan_troglodytes","Pan_paniscus","Plan_corporal","Hominina","Ser_vivo","Sustancia_qu%C3%ADmica","Biomol%C3%A9cula","C%C3%A9lula","Funciones_vitales","Nutrici%C3%B3n","Interacci%C3%B3n_biol%C3%B3gica","Reproducci%C3%B3n","Organismo_pluricelular","Animal","C%C3%A9lulas_eucariotas","Org%C3%A1nulo_celular","Material_gen%C3%A9tico","Nutrici%C3%B3n_heter%C3%B3trofa","Materia_org%C3%A1nica","Anatom%C3%ADa_humana","Mujer","Var%C3%B3n","Anatom%C3%ADa_humana","Artes_esc%C3%A9nicas","Danza","Deporte","Dedo_pulgar","Dimorfismo_sexual","Metro","Cuerpo_humano","Fisiolog%C3%ADa_humana","Gen%C3%A9tica_humana","Mente","Neurociencia","Cerebro_humano","Delphinidae","Balaenidae","Gorilla","Pan_(animal)","Elephantidae","Razonar","Invento","Aprendizaje","Idioma","L%C3%B3gica","Matem%C3%A1ticas","Escritura","M%C3%BAsica","Ciencia","Tecnolog%C3%ADa","Animal_social","Abstracci%C3%B3n_(filosof%C3%ADa)","Cerebro_humano","Consciente","Inteligencia","Pensamiento","Psicolog%C3%ADa","Nutrici%C3%B3n","R%C3%A9gimen_alimenticio","Alimentaci%C3%B3n_humana","Omn%C3%ADvoro","Vegetarianismo","Omn%C3%ADvoro","G%C3%A9nero_(biolog%C3%ADa)","Homo_(g%C3%A9nero)","Prote%C3%ADna","Gl%C3%BAcido","Grasa","Comportamiento_humano","Feto","Leonardo_da_Vinci","Pluricelular","Genotipo","Imperio_romano","Esperanza_de_vida","Mortalidad_infantil","Biolog%C3%ADa_del_desarrollo","Longevidad","Crecimiento_humano","Desarrollo_(biolog%C3%ADa)","Sexualidad","Significantes","Pensamiento_(mente)","Estro","Chimpanc%C3%A9","Pan_paniscus","Relaciones_sexuales","Sublimaci%C3%B3n_(psicolog%C3%ADa)","Freud","Inconsciente","Condicionamiento_cl%C3%A1sico","Ivan_Petrovich_Pavlov","Lenguaje","Heur%C3%ADstica","Pan_paniscus","Inteligencia_emocional","Sexuaci%C3%B3n","Familia","Sociedad","Ciclo_de_vida_(biolog%C3%ADa)","Menopausia","Muerte","Dimorfismo_sexual","Genital","Menarquia","Amor","Sexualidad_humana","Sistema_reproductivo","Evoluci%C3%B3n_humana","Origen_del_hombre","Mitos_de_la_creaci%C3%B3n","Mito","Religi%C3%B3n","Filosof%C3%ADa","Ciencia","Origen_del_hombre","Proconsul","Primate","Hominoideo","Catarrinos","Catarrhini","A%C3%B1o","Propliopithecus","Aegyptopithecus","Viejo_Mundo","Hominina","Australopithecus_africanus","Evoluci%C3%B3n_humana#bipedestaci\u00f3n","Mioceno","Bipedaci%C3%B3n","Oreopithecus","Orrorin","Ardipithecus","Mano","Energ%C3%ADa","Australopithecus","Homo_erectus","Homo_ergaster","Homo","Homo_erectus","Homo_habilis","Homo","Paleol%C3%ADtico","Homo_erectus","Eurasia","Prehistoria","Paleol%C3%ADtico_inferior","Selva","Vitamina_C","Metabolismo","Celulosa","Mutaci%C3%B3n","Almid%C3%B3n","Energ%C3%ADa","Sistema_nervioso_central","Humanos_arcaicos","Homo_neanderthalensis","Homo","Robin_Dunbar","Lenguaje_humano","Homo_heidelbergensis","Homo_rhodesiensis","Homo_neanderthalensis","Homo_antecessor","Hom%C3%ADnido_de_Den%C3%ADsova","Hombre_del_ciervo_rojo","Humanos_anat%C3%B3micamente_modernos","Prognatismo","Neandertal","Cr%C3%A1neo_de_Florisbad","Sud%C3%A1frica","Herto_Bouri","Homo_sapiens_idaltu","Jebel_Irhoud","Marruecos","Yacimientos_de_Skhul_y_Qafzeh","Israel","Hombres_de_Kibish","Origen_de_los_humanos_modernos","Ad%C3%A1n_cromos%C3%B3mico","Eva_mitocondrial","Evoluci%C3%B3n_humana","Antepasado_com%C3%BAn","S%C3%ADmil","R%C3%ADo_Omo","Hombres_de_Kibish","Etiop%C3%ADa","Sud%C3%A1frica","Eva_mitocondrial","ACMR","Tanzania","Ad%C3%A1n_cromos%C3%B3mico","%C3%81frica_subsahariana","Eva_mitocondrial","Ad%C3%A1n_cromos%C3%B3mico","Melanina","Ultravioleta","Folato","Embri%C3%B3n","Vitamina_D","Ind%C3%ADgena","Karaj%C3%A1","Comportamiento_humano","Mente","Industria_l%C3%ADtica","Sepultura","Vivienda","Hogar_(fuego)","Pesca","Caza","Arte","Artes_figurativas","Ornamento","Yacimiento_arqueol%C3%B3gico_de_Pinnacle_Point","Sud%C3%A1frica","El_Congo_(regi%C3%B3n)","Ocre","Paleol%C3%ADtico_superior","Expansi%C3%B3n_de_la_humanidad","Teor%C3%ADa_fuera_de_%C3%81frica","Sur_de_Asia","Medio_Oriente","Hombre_de_Cro-Magnon","Homo_neanderthalensis","Pen%C3%ADnsula_ib%C3%A9rica","Pen%C3%ADnsula_balc%C3%A1nica","Nature","Neol%C3%ADtico","Civilizaci%C3%B3n","Historia","Arqueolog%C3%ADa","Cultura","Lengua_natural","Martin_Heidegger","Ernst_Cassirer","S%C3%ADmbolo","Pensamiento_(mente)","Significante","Idioma","Chino_mandar%C3%ADn","Idioma_espa%C3%B1ol","Idioma_ingl%C3%A9s","Idioma_franc%C3%A9s","Idioma_%C3%A1rabe","Hindi","Idioma_portugu%C3%A9s","Idioma_alem%C3%A1n","Idioma_bengal%C3%AD","Idioma_ruso","Lenguaje","Familias_de_lenguas","Idioma","Ling%C3%BC%C3%ADstica","Evoluci%C3%B3n_del_lenguaje","Religi%C3%B3n","Religiones_abrah%C3%A1micas","Metaf%C3%ADsica","Alma","Familias_de_religiones","Arte","Cueva_de_Blombos","Pensamiento_simb%C3%B3lico","Humanidades","M%C3%BAsica","Danza","Historia_del_arte","Filosof%C3%ADa","Ciencia","Sebastiano_Conca","Ciencia","Lat%C3%ADn","Conocimiento","Sistema","Estudian","Explicaci%C3%B3n_cient%C3%ADfica","Predicci%C3%B3n_cient%C3%ADfica","Fen%C3%B3meno_social","Artificial","Fen%C3%B3meno_natural","Conocimiento_cient%C3%ADfico","Metodol%C3%B3gica","Observaci%C3%B3n","Experimentaci%C3%B3n","Campos_de_estudio","Conocimiento","Organizaci%C3%B3n_del_conocimiento","Te%C3%B3rica","Praxis","Razonamiento_l%C3%B3gico","An%C3%A1lisis","Objetividad","Evidencia_cient%C3%ADfica","Pregunta_de_investigaci%C3%B3n","Hip%C3%B3tesis_(m%C3%A9todo_cient%C3%ADfico)","Principios","Ley_cient%C3%ADfica","Modelo_cient%C3%ADfico","Teor%C3%ADa_cient%C3%ADfica","M%C3%A9todo_cient%C3%ADfico","Observador","Verdad","Revoluci%C3%B3n_cient%C3%ADfica","Publicaci%C3%B3n_cient%C3%ADfica","Divulgaci%C3%B3n_cient%C3%ADfica","Tecnolog%C3%ADa","Sociedad","Econ%C3%B3micos","Pol%C3%ADticos","Sistema_social","Comercio","Estado","Gobierno","Guerra","Monterrey","Geograf%C3%ADa_humana","Geomorfolog%C3%ADa","Superpredador","Tecnolog%C3%ADa","Ciencia","Homo_faber","H%C3%A1bitat_humano","Demograf%C3%ADa","Poblaci%C3%B3n","Poblaci%C3%B3n_mundial","Razas_humanas","Etnia","Antropolog%C3%ADa","Antropolog%C3%ADa_filos%C3%B3fica","Antropolog%C3%ADa_teol%C3%B3gica","Autodomesticaci%C3%B3n","Cambios_en_el_esqueleto_humano_debido_al_bipedismo","Condici%C3%B3n_humana","Evoluci%C3%B3n_humana","Evoluci%C3%B3n_de_la_inteligencia_humana","Superpredador","Humanismo_(desambiguaci%C3%B3n)","Homo_homini_lupus","Especismo","ISSN","Digital_object_identifier","Digital_object_identifier","Digital_object_identifier","Carlos_Linneo","Systema_natur%C3%A6","Digital_object_identifier","Oxford_University_Press","ISBN","ISBN","Kenia","Rutgers_University","Science","2009","Dawkins","ISBN","Wayback_Machine","ISBN","Diccionario_de_la_lengua_espa%C3%B1ola_de_la_Real_Academia_Espa%C3%B1ola","ISBN","OCLC","ISBN","Bill_Bryson","RBA_Libros","ISBN","Wikcionario","HTML_din%C3%A1mico","Ensembl","UCSC_Genome_Browser","NCBI","NCBI","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Animal_Diversity_Web","Catalogue_of_Life","Dyntaxa","Enciclopedia_de_la_vida","Global_Biodiversity_Information_Facility","Sistema_Integrado_de_Informaci%C3%B3n_Taxon%C3%B3mica","Mammal_Species_of_the_World","Centro_Nacional_para_la_Informaci%C3%B3n_Biotecnol%C3%B3gica","Paleobiology_Database","Registro_Mundial_de_Especies_Marinas","Zoobank","Unique_Ingredient_Identifier"]}
{"url":"Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","titulo":"Semantica linguistica","contenido":"La semantica linguistica es un subcampo de la semantica general y de la linguistica que estudia la codificacion del significado dentro de las expresiones linguisticas. Etimologicamente, el termino proviene del griego semantikos (\u03c3\u03b7\u03bc\u03b1\u03bd\u03c4\u03ba\u03bf\u03c2, \"significado relevante\"), derivado a su vez de sema (\u03c3\u03b7\u03bc\u03b1, \"signo\").  Una lengua es un sistema convencional para la comunicacion verbal, es decir, un sistema para transmitir mensajes convencionalmente codificados, que transmitan informacion o permitan interaccionar con otros individuos.  La transmision de informacion requiere algun tipo de codificacion del contenido semantico en forma de expresiones linguisticas. La sintaxis codifica explicitamente algunas de las relaciones sintacticas de la situacion o estado de hechos descrito por el mensaje. Asi, los nombres representan las entidades fisicas que intervienen en un estado de hechos, mientras que el verbo describe estados de algunas de estas entidades o los procesos que realizan unas entidades sobre las otras. Los diferentes tipos de entidades materiales pueden ser clasificados de acuerdo con el tipo de funcion que desempe\u00f1an en cada estado de hechos en diferentes papeles tematicos. Asi, una descripcion gramatical de una lengua debe contener ciertos principios que describan como se codifican los papeles tematicos de las entidades que intervienen en una oracion. Por ello, la informacion semantica es una parte integral de la gramatica.\u200b  Sin embargo, la semantica linguistica no se agota en el estudio de los papeles tematicos y su codificacion. Por ejemplo, la semantica lexica trata de la codificacion de significados, tanto en la dimension paradigmatica, y tambien de los significados obtenidos mediante derivacion de diversos procedimientos morfologicos.  La semantica lexica, rama de la Linguistica que estudia el significado de las palabras, se puede enfocar desde una perspectiva onomasiologica, en la que se parte del significado para llegar a la forma, o desde una perspectiva semasiologica, que parte de la forma (significante) para llegar al estudio del significado.  Una adecuada descripcion de las lenguas naturales debe contener datos de significado, referencia linguistica y condiciones de verdad. Pero los analisis semanticos tambien se aplican a aquellas expresiones construidas de palabras: las frases y las oraciones. Tradicionalmente las frases y las oraciones han recibido mas atencion que las palabras que las componen.  Sin embargo el concepto de referente conlleva ciertos problemas. Por un lado, no funciona siempre, ya que no todos los verbos denotan accion, ni todos los adjetivos, cualidades... Tampoco funciona cuando el nombre se refiere a una entidad que no existe, algo imaginario. Por ultimo, varias expresiones pueden compartir el mismo referente pero significar cosas muy distintas. Por todo ello, cuando se estudia la palabra tenemos en cuenta lo siguiente:  Por lo tanto es una rama de la gramatica linguistica muy importante en la elaboracion de textos.  De este modo, mientras que \"perro\" y \"chucho\" denotan el mismo significado, sus connotaciones son muy diferentes. La connotacion varia segun a quien se le sugiera. De tal manera, la palabra \"pacifista\" tiene distintas connotaciones en la jerga militar y en un grupo de \"hippies\".  Cabe mencionar que los sinonimos no existen, dado que se pierde la ley de la lengua, \"la que dice que una lengua busca la eficiencia, el menor esfuerzo que hay en una lengua\".  Asi mismo, los semas constituyen una parte fundamental en cuanto a los constituyentes del significado, siendo en este contexto la unidad basica funcional. ","snippet":"La semantica linguistica es un subcampo de la semantica general y de la linguistica que estudia la codificacion del significado dentro de las expresiones linguisticas. Etimologicamente, el termino pro","enlaces_salientes":["Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Sem%C3%A1ntica","Ling%C3%BC%C3%ADstica","Significado","Griego_antiguo","Comunicaci%C3%B3n_verbal","Mensaje","Nombre","Verbo","Teor%C3%ADa-%CE%B8#Lista_de_papeles_tem\u00e1ticos","Gram%C3%A1tica","Significado","Derivaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Cohip%C3%B3nimo","Hiper%C3%B3nimo","Hip%C3%B3nimo","Holonimia","Meronimia","Monosemia","Polisemia","Hom%C3%B3nimo","Homofon%C3%ADa","Homograf%C3%ADa","Paronimia","Sin%C3%B3nimo","Ant%C3%B3nimo","Criptolexema","Sem%C3%A1ntica","Ling%C3%BC%C3%ADstica","Onomasiolog%C3%ADa","Semasiolog%C3%ADa","Significante","Referente","Denotaci%C3%B3n","Connotaci%C3%B3n","An%C3%A1lisis_del_discurso","Sem%C3%A1ntica_generativa","Ferdinand_de_Saussure","Semi%C3%B3tica","Semiolog%C3%ADa","Sentido_literal_y_figurado","MIT_Press","ISBN","OCLC","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings"]}
{"url":"Estructuralismo_(ling%C3%BC%C3%ADstica)","titulo":"Estructuralismo (linguistica)","contenido":"El movimiento del estructuralismo linguistico se situa a comienzos del siglo\u00a0XX y supone ya el arranque de la linguistica moderna. Su iniciador fue Ferdinand de Saussure con su Curso de linguistica general (1916), que fue una obra publicada postumamente por dos de sus discipulos, quienes se basaron en apuntes de clase de estudiantes que habian escuchado a Saussure durante sus tres ultimos a\u00f1os en la Universidad de Ginebra. Plantea que la linguistica debe tener como objeto de estudio la lengua en forma sincronica, es decir, el estudio de la estructura y funcionamiento de una lengua en un momento dado, sin tener en cuenta su evolucion, a lo que se le denomina estructura externa. El estructuralismo surge como una reaccion frente a las investigaciones linguisticas comparativistas de la gramatica comparada, frente a las investigaciones diacronicas de la gramatica historica y frente a las investigaciones positivistas de los neogramaticos.  Este nuevo movimiento propuso, en cambio, una nueva concepcion de los hechos del lenguaje, considerandolos como un sistema en el cual los diversos elementos que lo integran ofrecen entre si una relacion de solidaridad y dependencia. De todos modos la nocion de lengua como \u00absistema\u00bb era admitida antes de la aparicion de Saussure; pero Saussure, ademas de reforzar esa idea, agrego la idea de que la lengua es \u00abforma\u00bb y no \u00absustancia\u00bb, y de que las unidades de la lengua solo pueden definirse mediante sus relaciones.\u200b El estructuralismo fundado por Saussure, que habla de \u00abla estructura de un sistema\u00bb, continuo desarrollandose en Europa por linguistas posteriores, surgiendo mas tarde diversas escuelas estructuralistas, como la Escuela de Ginebra, el Circulo Linguistico de Praga y la Escuela de Copenhague.  El estructuralismo saussureano influyo sobremanera en el desarrollo de la linguistica posterior al punto de que se habla de una linguistica anterior y posterior a Saussure.\u200b Debido a que el hecho linguistico es muy complejo, pues intervienen multiples factores de naturaleza fonica, acustica, fisiologica y de alcance tanto individual como social, la linguistica no se ocupa del lenguaje, ya que es un fenomeno amplio, sino que su objeto es el estudio de las relaciones entre los elementos que forman parte unicamente del sistema linguistico, es decir, define su objeto de estudio, la lengua y el habla en si mismos.\u200b  La teoria iniciada por la labor de Saussure, que sienta las bases del estructuralismo, supone una ruptura con la tradicion historicista de la linguistica conocida hasta entonces, que se centraba en el estudio evolutivo de las lenguas. El estructuralismo afirma que se deben estudiar las lenguas atendiendo a su realidad, y no solo a su evolucion. Por lo tanto, atendiendo al principio de inmanencia linguistica, se separa el estudio del aspecto social concerniente a las lenguas, pero sin obviarlo ya que Saussure es consciente de este hecho al dividir la linguistica en dos grandes campos: la linguistica interna \u2015que se encarga del estudio de la lengua en si y supondria la verdadera linguistica\u2015 y la linguistica externa \u2015que se encarga del aspecto sociolinguistico\u2015. Segun esta nueva orientacion de los estudios linguisticos que representa el estructuralismo, la lengua se concibe como un sistema de signos, y su metodologia de estudio se basa en la consideracion de una serie de dualidades o dicotomias:  Saussure establecio la distincion entre esos dos conceptos. La diacronia atiende a los cambios linguisticos que se suceden a lo largo del tiempo. La sincronia, en cambio, atiende al estado de una lengua en un momento dado, haciendo abstraccion del factor temporal. Un estudio sincronico de la lengua tiene que tener en cuenta la simultaneidad de los signos linguisticos dentro de un espacio temporal. En este sentido, el estudio sincronico se asimilaria a hacer una fotografia de la lengua y estudiarla en su imagen estatica, sin tener en cuenta la variabilidad temporal. Entonces, este tipo de estudio proporciona el conocimiento de una lengua en un momento determinado, a partir del cual pueden llevarse a cabo estudios diacronicos, esto es, estudios que tengan en cuenta su evolucion e historia. En el aula se habla y se escucha, se escribe y se lee; ademas, se evaluan como se dicen \u2014oralmente y por escrito\u2014 las cosas. Es decir, no solo se valoran los contenidos sino tambien los comportamientos comunicativos. Por lo tanto, es fundamental tener en cuenta tanto los usos \u00abreales\u00bb de ense\u00f1antes y aprendices como las expectativas respecto a como hay que utilizar el habla y la escritura (la escucha y la lectura) en el proceso de ense\u00f1anza y aprendizaje.  Con la idea de la sincronia, se abre la puerta a la consideracion de la lengua como conjunto de elementos, cada uno de los cuales mantiene relacion con los restantes. Esta idea de sincronia queda refleja en Saussure en su nocion de sistema o estructura del lenguaje. Sincronia y diacronia se complementan. Saussure, establecio la relacion en el estudio de los signos a partir de dos elementos fundamentales: significado y significante.  Lo que el signo linguistico une, es un concepto (significado) y una imagen acustica (significante). Por lo tanto el signo linguistico es la combinacion de ambos, y es la base de Saussure, segun afirma en su curso, hablando de una ciencia nueva, la semiologia.\u200b El significante es una representacion mental de los sonidos que forma un signo. Lo observamos cuando nos hablamos a nosotros mismos mentalmente. El significado es la representacion mental de la realidad, la interpretacion del concepto.  Los signos no aparecen de forma aislada, sino que se hallan en relacion. Saussure propuso dos tipos:  Para Saussure la conexion entre el significado y el significante es arbitraria, es decir, convencional, socialmente construida. Con esto quiere decir que no hay ninguna relacion intrinseca entre el sonido (significante) y el concepto (significado). La forma mas evidente de comprobarlo es que en distintos idiomas un mismo concepto recibe distintos significantes (ej. arbol/tree). Por lo tanto, la conexion entre significante y significado seria producto de la interaccion humana.  Saussure creia que los conceptos son productos mentales y no entidades independientes de la mente. La idea es que percibimos la realidad a traves de los conceptos ya que no tenemos acceso a esas entidades independientes, por lo que no se puede asegurar que dos personas tengan el mismo significado en mente al usar un mismo significante. Los ejemplos con colores son muy ilustrativos al respecto. Para Saussure no podemos estar seguros de que estemos viendo la misma tonalidad cuando usamos el significante \u00abrojo\u00bb. La adquisicion de la nocion \u00abrojo\u00bb tambien seria producto de la interaccion humana, por la cual, por ejemplo, en un momento determinado de nuestra vida a uno le mostrarian una tonalidad y le dirian que aquello es \u00abrojo\u00bb. En ese momento se produciria la conexion arbitraria entre el significado (la tonalidad) y el significante (\u00abrojo\u00bb). Entonces, para Saussure uno puede estar seguro de usar el mismo significante que otra persona (\"rojo\") pero no de que se este viendo la misma tonalidad, esto es, teniendo el mismo significado en mente. Segun Saussure, la unica manera de probar que se tiene el mismo significado seria acudir a las entidades independientes de la mente, y en la medida en que no podemos aislarnos de ella, nuestra percepcion de la realidad se ve mediatizada por los conceptos que son constructos mentales.  Todo esto prueba para Saussure que el lenguaje es una institucion social. Como en el ultimo ejemplo, los signos adquieren su funcion y su significado a traves de la practica social y el intercambio humano. Cuando un signo esta socialmente establecido adquiere estabilidad, por lo que no cambiaria facilmente. Aun asi, el significado de un signo es mas probable que cambie con el contexto, esto es, su uso social.[nota 1]\u200b  Para Saussure y los estructuralistas los signos estan interconectados formando la estructura de la lengua. En su Curso de linguistica general (1916) Saussure defendio que la lengua es un sistema formal basado en la diferenciacion de los elementos que lo constituyen. Este sistema fue posteriormente llamado \u00abestructura\u00bb, de aqui que la aproximacion general a esta concepcion del lenguaje se llama Estructuralismo..  Por lo tanto, la estructura de la lengua  se basa en su diferenciacion entre los signos. En el caso de los significantes, la diferenciacion consiste en que su sonido o su dibujo (las grafias unidas en cierto orden que forman un significante, ej. calle) son distintos de otros sonidos o dibujos de otros terminos de la estructura.  Respecto al significado, Saussure decia que era abstraido a partir de la relacion entre los conceptos que formaban la estructura de la lengua. Con ello queria decir que el significado no es algo intrinseco a la palabra, sino algo extrinseco respecto a los otros significados dentro de la estructura. Por ejemplo, tomando de nuevo el significado de \u00abrojo\u00bb, para Saussure dicho significado se entenderia a partir de las relaciones negativas que mantendria con los otros significados del lenguaje. La idea seria que uno sabe que es \u00abrojo\u00bb por contraste, diciendo: no es azul, no es lila etc., pero no solo con los demas colores sino con todos los significados, ya que en la estructura o sistema de la lengua cada termino (con su significado y significante) esta relacionado con todos los demas al mismo tiempo.  Esto significa que la estructura de la lengua  no puede ser concebida de manera atomistica, esto es: que sus elementos (los signos) puedan separarse unos de otros. Por eso los estructuralistas defienden la perspectiva holistica, esto es: la idea de que las propiedades de un sistema no pueden ser determinadas o explicadas a partir de sus componentes aislados. De aqui que la estructura de la lengua se basa en la relacion diferencial entre los terminos y que dichos terminos no puedan entenderse sin tener en cuenta su interconexion.  El Curso de linguistica general (1916) de Saussure influyo a muchos linguistas entre la Primera y la Segunda Guerra Mundial.  La Escuela de Praga es la mas destacada inicialmente, con miembros como Roman Jakobson o Nikolai Trubetskoi.\u200b Su mayor legado dentro del estructuralismo hace referencia a la fonetica. En vez de hacer una lista de los sonidos que aparecen en el lenguaje, la Escuela de Praga estudio como estos estaban relacionados. En este sentido, determinaron que el inventario de sonidos de un idioma puede ser analizado en terminos de contraste. Por ejemplo, en ingles los sonidos de /p/ y /b/ representan distintos fonemas porque existen casos donde el contraste entre los dos es la unica diferencia entre palabras distintas (ej. pat y bat).  Analizar los sonidos en terminos de contraste tambien permite hacer estudios comparativos. Por ejemplo, se puede explicar que la dificultad que tienen los japoneses para diferenciar la /r/ y la /l/ en ingles es debido a que dichos sonidos no se contrastan en japones. Aunque este tipo de aproximacion es hoy muy aceptada en linguistica fue revolucionaria en su tiempo. Desde entonces, la Fonologia se convertiria en la base paradigmatica para distintos campos de estudio.  Los trabajos seguirian con una figura capital, Louis Hjelmslev (Ensayos linguisticos, Prolegomenos de una teoria del lenguaje), en Dinamarca, o con Alf Sommerfelt en Noruega.  En Francia, Antoine Meillet y su discipulo Emile Benveniste continuarian con el programa de Saussure. El segundo ha sido capital, dada ademas su magnifica formacion historica, y sus obras son una continuacion renovada de las investigaciones iniciales sobre las lenguas indoeuropeas. Como gran comparatista renovador, fue autor de un importante Vocabulario de las instituciones indoeuropeas.\u200b Pero sus escritos en ese campo se hallan recogidos en Problemas de linguistica general, tomos I y II, colecciones de articulos magistrales, que son aun fuente de inspiracion para los estudiosos de las ciencias humanas en general.  Emile Benveniste, al resaltar que el estructuralismo en realidad habla de la estructura de un sistema, se\u00f1ala que la lengua debe analizarse como unidades que se condicionan mutuamente, y que se distingue de los otros sistemas posibles por el arreglo interno de tales unidades: ese arreglo es lo que constituye su estructura.\u200b  Eugenio Coseriu parte de los estudios de Saussure, pero expresa la necesidad de que la lengua y el habla no estan tan separados. El habla no es tan individual y existe un paso intermedio entre el habla y la lengua: la norma. La norma implica los usos habituales repetidos en un determinado colectivo. Es decir, tomamos rasgos linguisticos caracteristicos de nuestro entorno. La norma se clasifica en tres tipos y se manifiestan en la pronunciacion, el lexico, la morfosintactica delatando en la situacion comun en la que nos encontramos:  Ya en la decada de los 40 el estructuralismo era la corriente dominante en los estudios linguisticos. Dentro de la vertiente europea encontramos el principal referente y punto de partida insoslayable en el propio Saussure, algunos de cuyos discipulos como Martinet y Alarcos serian los representantes de su paradigma y enfoque metodologico, en este caso de la escuela francesa y espa\u00f1ola respectivamente. Los estructuralistas acabaran derivando hacia el funcionalismo linguistico sin perder el principio de inmanencia linguistica pero teniendo en cuenta criterios externos y, desde luego, oponiendose a las corrientes formalistas del generativismo chomskiano. El estructuralismo tuvo una influencia fundamental en la ense\u00f1anza de lenguas durante la segunda mitad del siglo\u00a0XX que continua hoy dia. Muestra de ello son las muchas huellas de su aportacion y, en consecuencia, sigue plenamente vigente, con sus desarrollos ulteriores, en los metodos de ense\u00f1anza moderna.  En Estados Unidos, Leonard Bloomfield desarrollo su propia version del estructuralismo linguistico, conocida como distribucionalismo. ","snippet":"El movimiento del estructuralismo linguistico se situa a comienzos del siglo\u00a0XX y supone ya el arranque de la linguistica moderna. Su iniciador fue Ferdinand de Saussure con su Curso de linguistica ge","enlaces_salientes":["Estructuralismo_(ling%C3%BC%C3%ADstica)","Estructuralismo_(ling%C3%BC%C3%ADstica)","Estructuralismo_(ling%C3%BC%C3%ADstica)","Ferdinand_de_Saussure","Curso_de_ling%C3%BC%C3%ADstica_general","Universidad_de_Ginebra","Positivista","Neogram%C3%A1ticos","Escuela_de_Praga","Escuela_de_Copenhague_o_Glosem%C3%A1tica","Inmanencia","Ling%C3%BC%C3%ADstica","Dicotom%C3%ADas","Diacron%C3%ADa","Sincron%C3%ADa_y_diacron%C3%ADa","Sincron%C3%ADa_y_diacron%C3%ADa","Signo_ling%C3%BC%C3%ADstico","Significado","Significante","Escuela_de_Praga","Roman_Jakobson","Nikol%C3%A1i_Trubetsk%C3%B3i","Louis_Hjelmslev","Antoine_Meillet","%C3%89mile_Benveniste","Eugenio_Coseriu","Dialectolog%C3%ADa","Socioling%C3%BC%C3%ADstica","Pragm%C3%A1tica","Andr%C3%A9_Martinet","Emilio_Alarcos","Funcionalismo_ling%C3%BC%C3%ADstico","Generativismo","Noam_Chomsky","Leonard_Bloomfield","Leonard_Bloomfield","Ferdinand_de_Saussure","Roman_Jakobson","Roman_Jakobson","Nikol%C3%A1i_Trubetsk%C3%B3i","Louis_Hjelmslev","%C3%89mile_Benveniste","Roland_Barthes","Tzvetan_Todorov","Los_Simpson","%C3%89mile_Benveniste","Roland_Barthes","The_Times_Literary_Supplement","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Oraci%C3%B3n_(gram%C3%A1tica)","titulo":"Oracion (gramatica)","contenido":"La definicion mas tradicional, didactica y breve, es que la  oracion es el \u00abconjunto de palabras que expresa un juicio con sentido y autonomia sintactica\u00bb.[cita\u00a0requerida] Su fin es destacar el hecho de que la oracion, practica- o pragmaticamente, es el fragmento mas peque\u00f1o del discurso.[pornhub.com] que comunica una idea completa y posee autonomia e independencia (es decir, podria sacarse del contexto y seguir comunicando).  Una definicion mas exacta es la de que se trata del constituyente sintactico independiente mas peque\u00f1o capaz de informar o expresar por medio de un idioma la realizacion de un enunciado, esto es, revelar con palabras el contenido de una proposicion logica, un mandato, una peticion, una pregunta o acto ilocutivo o de habla que incluya algun tipo de predicado o desarrollo sintactico estructurado de sentido completo, como por ejemplo en Ese profesor ha ense\u00f1ado bien la gramatica a sus alumnos.  La oracion se efectua en un contexto y situacion determinados y, con frecuencia, con el apoyo de otros codigos de signos no linguisticos concurrentes, como los gestos.  Segun la fonologia, las oraciones estan delimitadas prosodicamente por pausas y una entonacion determinada. La pausa inicial suele se\u00f1alarse en la escritura con una mayuscula y, la final, con un punto o, mas raramente, con coma o punto y coma.  Se diferencia de las frases en su completitud descriptiva y en que poseen estructura compleja o analitica, ya que expresiones como \u00a1alto!, buenos dias, si, no y las llamadas proformas poseen un sentido completo, pero no pueden denominarse oraciones a causa de su estructura simplificada o sintetica o de su caracter sustitutorio.  Por otra parte, se usan a veces tambien los terminos clausula, suboracion, proposicion (no en sentido logico, sino gramatical) o nexus para designar un constituyente sintactico semejante a la oracion en su estructura, pero dependiente sintacticamente (las mas de las veces a traves de un nexo) de otra unidad oracional mayor en que se inserta o con la que se une o ayunta, respecto a la cual carece tambien de independencia semantica y fonologica, como en \u201cElla me dijo que ese profesor habia ense\u00f1ado bien la gramatica a sus alumnos\u201d, donde el nexo \u201cque\u201d une y subordina a la clausula posterior (... ese profesor [...] alumnos) la anterior (\u201cElla me dijo...\u201d) formando una unidad superior compuesta de ambas clausulas (o proposiciones, suboraciones, nexus) denominada por esto oracion compuesta. Esta falta de autonomia es la principal diferencia de la clausula, suboracion, proposicion o nexus respecto de la oracion, que es una unidad completa e independiente, ya que la clausula necesita o reclama relacionarse con otras clausulas dentro de la oracion compuesta y principal.  Debe tenerse en cuenta que, tecnicamente, terminos como enunciado, proposicion y oracion no son completamente sinonimos, ya que el primero se refiere mas a aspectos pragmaticos, el segundo mas a logicos y semanticos y solo el ultimo a puramente gramaticales.  El concepto de \u00aboracion\u00bb es paradojicamente uno de los que mas revisiones ha sufrido en los modelos gramaticales desde la aparicion de la linguistica moderna y en particular la moderna teoria de la sintaxis. Tradicionalmente los gramaticos trataron la oracion como una union de \u00absujeto + predicado\u00bb.  pero ese analisis semanticamente simplista ha sido abandonado en sintaxis moderna, entre otras cosas porque no aclara la estructura interna, no permite hacer generalizaciones interesantes y parece ignorar las evidencias que llevaron a la hipotesis de endocentricidad generalizada. Ademas el esquema \u201csujeto + predicado\u201d no puede explicar oraciones interrogativas como:  Porque en ella la estructura claramente es mas complicada, y el sujeto esta rodeado de constituyentes sintacticos que la gramatica tradicional considera parte del predicado. Tampoco la relacion entre una oracion en voz activa y en voz pasiva queda capturada por una atribucion convencional al sujeto y al predicado:  El analisis sujeto predicado simple no puede aclarar porque en (2a) Maria es parte del predicado, pero en la oracion (2b) que tienen el mismo contenido proposicional es el sujeto, sin recurrir a argumentos circulares.  Los primeros analisis sintacticos en terminos de constituyentes inmediatos de Leonard Bloomfield trataron la oracion como una construccion exocentrica en la que ninguno de los dos constituyentes basicos en sintagma nominal sujeto y la frase verbal eran el nucleo principal de la misma, y ambos digamos constituian elementos jerarquicos del mismo nivel. En el modelo de Noam Chomsky de 1986\u200b por el contrario el sujeto se trataba como el especificador de un sintagma de tiempo:  Este sintagma de tiempo seria una categoria funcional cuyo nucleo seria la inflexion de tiempo normalmente asociada a un verbo lexico conjugado a un [verbo auxiliar]. Ademas este analisis respalda la hipotesis de endocentricidad generalizada.  En cambio en el analisis del funcionalismo linguistico no existe una definicion formal de oracion, sino que existen patrones recurrentes fonologicos, sintacticos y semanticos que permiten definir prototipos de oracion, ver mas abajo.  En gramatica tradicional, las categorias gramaticales eran vistas como unidades discretas. Esto implica dos cosas fundamentales: las categorias poseen limites precisos, o sea, un elemento pertenece a una categoria si posee las propiedades o caracteristicas que definen a esta como tal, y, debido a esto mismo, los miembros de una categoria son equivalentes entre si.  Sin embargo, el funcionalismo linguistico entiende la oracion como un continuum dentro del cual una serie de rasgos o propiedades, cuyo fin es identificar no la pertenencia sino la gradacion, confluyen y tienden a coincidir segun una determinada probabilidad. Esto provoca que dentro de una categoria existen miembros que pueden llegar a ser mejores ejemplos que otros a los cuales se les llama prototipos.  De esta manera, para establecer la definicion de la oracion, se propone una caracterizacion de su prototipo y no un conjunto de condiciones necesarias y suficientes para identificarla. Los principales aspectos que se toman en cuenta para definir el ambito de la oracion son los siguientes:  El analisis de la estructura interna de las oraciones que ha hecho la escuela generativista ha ido variando con el tiempo desde las \u201creglas de reescritura sintagmatica\u201d en que la oracion se analizaba como una construccion exocentrica en la que se unen un sintagma nominal, que en esencia se comportaba como un sujeto, con un sintagma verbal, y sobre los que luego mas tarde actuaban desplazamientos sintacticos, pasandose de una estructura profunda a una estructura superficial. A la hipotesis de \u201cendocentricidad generalizada\u201d que trataba en pie de igualdad las categorias funcionales y las lexicas. En este modelo se presupone que las oraciones en esencia se ajustan al esquema estructural:  Donde SN seria en sintagma nominal sujeto, C\u00ba la particula que introduce una oracion que podria no existir,\u200b SX seria un especificador del sintagma complementante (en las oraciones interrogativas paricales estara ocupado por el pronombre interrogativo y su complemento). T\u00ba seria un verbo auxiliar o un verbo en forma finita (que aparece solo en algunas oraciones), SV el sintagma verbal que en la gramatica tradicional se identificaba con el predicado. Cada uno de estos sintagmas constituyentes ademas podia tener su propia estructura interna.  Los terminos oracion, clausula, enunciado y proposicion son usados informalmente como sinonimos, aunque conviene usar cada termino para un conjunto de aspectos diferentes. En principio, el termino proposicion se refiere al contenido logico-semantico de una oracion, aunque el uso del termino es usado de manera ligeramente diferente por diferentes autores. El termino enunciado se refiere a una unidad pragmatica, que frecuentemente coincide con el contenido oracion sintactica, pero no siempre. Los terminos oracion y clausula se usan con un sentido eminentemente gramatical, siendo esencialmente sinonimos. Ocasionalmente clausula es mas usado para referirse a una oracion que forma parte de una oracion compuesta mas grande.  En algunas gramaticas se prefiere el termino oracion transpuesta dentro de una oracion compleja, antes que hablar de oracion principal o de oraciones subordinadas.\u200b Otros incluso prefieren hablar de oraciones subordinadas inyectadas o incrustadas, si bien en estas no incluyen a las oraciones comparativas ni a las que establecen una relacion de causa y consecuencia.\u200b  En gramatica tradicional es comun clasificar las oraciones. Estas se pueden clasificar atendiendo a criterios sintacticos, semanticos y pragmaticos.  La gramatica tradicional trata las oraciones desde un punto de vista de componentes inmediatos y distingue en primer lugar entre oraciones simples y oraciones complejas o compuestas.  Tradicionalmente, estas oraciones se han denominado subordinadas y principal a la oracion de la que forma parte. Las oraciones subordinadas carecen, por si solas de significacion y se ligan a las principales mediante conjunciones subordinantes.  Este enfoque difiere grandemente de los enfoques mas formales, y en cierto modo mas aplicables a la generalidad de lenguas del mundo. En estos enfoques lo mas importante no es la cualidad de los elementos de union en las oraciones compuestas, sino el tipo de estructura jerarquica que se da entre las diversas partes de dicha oracion.  Dentro del enfoque funcionalista las oraciones se clasifican en:  Se llaman a veces tambien predicados directos y no se pueden dividir en sujeto-predicado, sino que tienen su propia categorizacion segun el tipo de informacion que comunican. Las interjecciones, las exclamaciones, los vocativos, las respuestas a preguntas o los imperativos desnudos son oraciones unimembres por ejemplo. En cambio en el analisis generativista este tipo de actos de habla no se considera que tengan estructura sintactica.  Son aquellas que poseen dos miembros (o constituyentes sintacticos) y por lo tanto, pueden ser analizadas estructuralmente segun sus partes. Se reconocen dos grandes grupos:  Segun el tipo de sintagma nominal que hace de sujeto las oraciones se pueden clasificar en:  Segun la forma del sintagma verbal o en particular el numero de verbos flexionados las oraciones se pueden clasificar en simples o compuestas:  Una oracion subordinada (o secundaria) es una oracion que depende de la proposicion principal. Es decir, la oracion subordinada es una oracion que es a su vez un constituyente sintactico de otro sintagma que no es oracion. Y por tanto, la oracion subordinada no tiene una autonomia sintactica (si es considerada sola) y es \u201csubordinada\u201d por otra, siendo locuciones adverbiales o conjunciones. La oracion subordinada puede ser explicita (verbo conjugado en un modo definido) o implicita (el verbo esta conjugado en un modo indefinido). Algunas oraciones tambien pueden tener dos o mas conjunciones, sean disyuntivas, copulativas, etc.  Las oraciones coordinadas tienen relacion de igualdad jerarquica, es decir, estan en el mismo del arbol sintactico. Se puede decir que son dos oraciones que se han unido en condicion de igualdad, manteniendo su estatus la una respecto de la otra. Las oraciones formadas por dos o mas oraciones simples coordinadas se conocen como oraciones compuestas por coordinacion (especificando ademas el tipo de esta coordinacion, que viene marcado por el nexo, pudiendo ser de todos los tipos que se muestra en los ejemplos. El nexo de este tipo de coordinacion se conoce como conjuncion.  Algunos ejemplos de oraciones compuestas formadas por coordinacion:  Las oraciones subordinadas establecen una relacion de dependencia respecto de otra oracion, es decir, jerarquicamente estan dominadas por otra oracion llamada oracion principal. Las oraciones formadas por una oracion principal y una o mas oraciones subordinadas se conocen como oraciones complejas u oraciones compuestas por subordinacion (especificando ademas el tipo de esta, que viene tambien marcado por el nexo), pudiendo ser de todos los tipos que se muestra en los ejemplos:  Segun la fuerza ilocutiva o posibilidad de asignarles un valor de verdad:  Segun lo dicho (Que es lo dicho), o tambien el tipo de verbo (mas concretamente su semantica o bien su morfologia):  Conviene tener presente que: ","snippet":"La definicion mas tradicional, didactica y breve, es que la  oracion es el \u00abconjunto de palabras que expresa un juicio con sentido y autonomia sintactica\u00bb.[cita\u00a0requerida] Su fin es destacar el hecho ","enlaces_salientes":["Oraci%C3%B3n_(gram%C3%A1tica)","Oraci%C3%B3n_(gram%C3%A1tica)","Oraci%C3%B3n_(gram%C3%A1tica)","%C3%81rbol_sint%C3%A1ctico","Oraci%C3%B3n_compuesta","Oraci%C3%B3n_subordinada","Oraci%C3%B3n_de_relativo","Palabra","Discurso","Contexto","Constituyente_sint%C3%A1ctico","Idioma","Enunciado","Palabra","Proposici%C3%B3n","Teor%C3%ADa_de_los_actos_de_habla","Predicado_(gram%C3%A1tica)","Contexto","C%C3%B3digo_(comunicaci%C3%B3n)","Signo_ling%C3%BC%C3%ADstico","Lenguaje_corporal","Fonolog%C3%ADa","Prosodia_(ling%C3%BC%C3%ADstica)","Entonaci%C3%B3n","Punto_(puntuaci%C3%B3n)","Coma_(puntuaci%C3%B3n)","Proforma","Nexo_(gram%C3%A1tica)","Oraci%C3%B3n_compuesta","Oraci%C3%B3n,_enunciado_y_proposici%C3%B3n","Tihany","Ling%C3%BC%C3%ADstica","Sintaxis","Sujeto_(gram%C3%A1tica)","Predicado_(gram%C3%A1tica)","Construcci%C3%B3n_endoc%C3%A9ntrica","Gram%C3%A1tica_tradicional","Proposici%C3%B3n","Leonard_Bloomfield","Construcci%C3%B3n_exoc%C3%A9ntrica","Noam_Chomsky","Especificador_(sintaxis)","Sintagma_de_tiempo","Categor%C3%ADa_funcional","Categor%C3%ADa_l%C3%A9xica","Conjugaci%C3%B3n","Construcci%C3%B3n_endoc%C3%A9ntrica","Funcionalismo_ling%C3%BC%C3%ADstico","Gram%C3%A1tica_tradicional","Categor%C3%ADa_gramatical","Funcionalismo_ling%C3%BC%C3%ADstico","Entonaci%C3%B3n","Sem%C3%A1ntica","Sintaxis","Estructura_interna_de_las_oraciones","Gram%C3%A1tica_generativa","Construcci%C3%B3n_exoc%C3%A9ntrica","Sujeto_(gram%C3%A1tica)","Estructura_profunda","Estructura_superficial","Categor%C3%ADa_funcional","Categor%C3%ADa_l%C3%A9xica","Sintagma_de_tiempo","Complementador","Sintagma_nominal","Especificador_(sintaxis)","Complementador","Oraci%C3%B3n_interrogativa","Verbo_auxiliar","Sintagma_verbal","Oraci%C3%B3n,_enunciado_y_proposici%C3%B3n","Proposici%C3%B3n","Enunciado","Clasificaci%C3%B3n_de_la_oraci%C3%B3n_simple","Gram%C3%A1tica_tradicional","Sintaxis","Sem%C3%A1ntica","Pragm%C3%A1tica","Gram%C3%A1tica_tradicional","Oraci%C3%B3n_compuesta","Oraci%C3%B3n_coordinada","Sustantivo","Adjetivo","Adverbio","Sujeto_(gram%C3%A1tica)","Predicado_(gram%C3%A1tica)","Interjecci%C3%B3n","Exclamaci%C3%B3n","Caso_vocativo","Teor%C3%ADa_de_los_actos_de_habla","Constituyente_sint%C3%A1ctico","Verboide","Gerundio","Participio","Modo_infinitivo","Tiempo_gramatical","Sintagma_nominal","Sujeto_el%C3%ADptico","Referencia","Gram%C3%A1tica_tradicional","Sintagma_de_tiempo","Oraci%C3%B3n_compuesta","Oraci%C3%B3n_subordinada","Coordinaci%C3%B3n_(gram%C3%A1tica)","%C3%81rbol_sint%C3%A1ctico","Oraci%C3%B3n_compuesta","Coordinaci%C3%B3n_(gram%C3%A1tica)#Tipolog\u00eda","Conjunci%C3%B3n_(gram%C3%A1tica)","Hipotaxis","Oraci%C3%B3n_subordinada","Oraci%C3%B3n_principal","Oraci%C3%B3n_principal","Complemento_directo","Oraci%C3%B3n_de_relativo","Pronombre","Sintagma_de_negaci%C3%B3n","No","Fuerza_ilocutiva","Complementador","Oraci%C3%B3n_interrogativa","Lenguas_indoeuropeas","Atributo_(gram%C3%A1tica)","Predicado_verbal","Complemento_directo","Lengua_ergativa","Voz_pasiva","Voz_activa","Verbo_copulativo","Voz_gramatical","Sintagma_nominal","Sintagma_determinante","Sintagma_verbal","Sintagma_de_tiempo","Sintagma_de_negaci%C3%B3n","N%C3%BAcleo_sint%C3%A1ctico","Sustantivo","Adjetivo","Pronombre","Verbo","Preposici%C3%B3n","Complemento_sint%C3%A1ctico","Objeto_directo","Complemento_indirecto","Preposici%C3%B3n","Determinante_(ling%C3%BC%C3%ADstica)","Oraci%C3%B3n_compuesta","Oraci%C3%B3n,_enunciado_y_proposici%C3%B3n","Estructura_interna_de_las_oraciones","Funci%C3%B3n_gramatical","Gram%C3%A1tica_generativa","Emilio_Alarcos","ISBN","ISBN","Ignacio_Bosque","ISBN","ISBN","Control_de_autoridades","Wikcionario","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica","Wikcionario"]}
{"url":"A%C3%B1os_1950","titulo":"A\u00f1os 1950","contenido":"La decada de los a\u00f1os 1950 comenzo el 1 de enero de 1950 y termino el 31 de diciembre de 1959.  Durante esta decada, las dos superpotencias vencedoras de la Segunda Guerra Mundial, Estados Unidos y la Union Sovietica, rompieron su alianza durante la guerra y se enemistaron convirtiendose en lideres de dos bloques: el bloque Occidental (occidental-capitalista) liderado por Estados Unidos, y el bloque del Este (oriental-comunista) liderado por la Union Sovietica y el mundo vio formarse lo que se conocio como Guerra Fria.  Poco despues del fin del conflicto mundial, la guerra civil en China, dio el triunfo de Mao Zedong quien instauro en la parte continental de su nacion un nuevo gobierno de ideologia comunista que revoluciono al pais, reconocido como Republica Popular China.  En la decada de 1950, la disputa entre los dos nuevos ejes mundiales, se intensifico notablemente con la guerra de Corea y la posterior division del pais en dos estados diferentes. Se inicio una carrera armamentistica sin precedentes que se extenderia en las siguientes decadas, asi la URSS y EE.\u00a0UU. se iniciaron a la carrera de un arsenal nuclear capaz de destruir todo el planeta.  El proceso de descolonizacion iniciado despues de la Segunda Guerra Mundial se intensifica y marcara esta decada y las dos siguientes. Imperios como el frances o el britanico se desprenden de numerosas posesiones en Africa, Oriente Medio y Asia.  Estados Unidos vio una revolucion cultural impulsada por el rapido desarrollo industrial y el consecuente fenomeno de consumismo. Alemania y Japon experimentaron una sorprendente recuperacion economica en menos de dos decadas despues del final de la guerra, habia transformado a ambos paises en potencias economicas, si bien no politicas ni militares. Por lo tanto, aunque Francia y Gran Breta\u00f1a tenian un mayor peso politico, Japon y Alemania superaban a los dos paises que obtuvieron la victoria en la segunda guerra e incluso su presencia en el comercio internacional superaba a la de la Union Sovietica.  Un proceso de importancia capital para el futuro de Europa y el mundo se inicio cuando Robert Schuman pronuncio la celebre declaracion homonima y que constituye el embrion de la actual Union Europea.   Harry S. Truman   Dwight D. Eisenhower   Iosif Stalin   Francisco Franco   Nikita Jrushchov   Winston Churchill   Anthony Eden   Harold Macmillan   Vincent Auriol   Rene Coty   Charles de Gaulle   Chiang Kai-shek   Mao Zedong   Konrad Adenauer   Walter Ulbricht   Alcide De Gasperi   Pio XII   Juan XXIII   Miguel Aleman Valdes   Adolfo Ruiz Cortines   Adolfo Lopez Mateos   Juan Domingo Peron   Louis St. Laurent   John Diefenbaker   Robert Menzies   Getulio Vargas   Juscelino Kubitschek   Gamal Abdel Nasser   Jawaharlal Nehru   David Ben-Gurion   Syngman Rhee   Kim Il-sung   Willem Drees   Ibn Saud   Saud bin Abdulaziz Al Saud   Husein I de Jordania   Fidel Castro   Matyas Rakosi   Imre Nagy   Janos Kadar   Boles\u0142aw Bierut   W\u0142adys\u0142aw Gomu\u0142ka   Josip Broz Tito   Marcos Perez Jimenez  En los a\u00f1os 50 se vivio en Hollywood la etapa conocida como la Edad de Oro del cine, caracterizada por un exceso de peliculas, actores y directores considerados esenciales para entender el cine actual. En este sentido, el cine de los a\u00f1os 50 de Hollywood no hace referencia exclusivamente a ciertas convenciones formales ni a un conjunto de peliculas especificas, sino que es un sistema de practica cinematografica: esta consiste en una serie de normas estilisticas ampliamente aceptadas, que constituyen un sistema integral de produccion cinematografica que a su vez las soporta a ellas. Estas normas constituyen una determinada serie de supuestos acerca de como debe comportarse una pelicula, acerca de que historias debe contar y como debe contarlas, del alcance y las funciones de la tecnica cinematografica y acerca de las actividades del espectador. Estas normas formales y las funciones se crearan, tomaran forma y encontraran apoyo dentro de un modo de produccion: un conjunto caracteristico de objetivos economicos, una division especifica del trabajo y modos particulares de concebir y ejecutar el trabajo cinematografico.\u201d Si bien no hay ninguna pelicula totalmente \u201cclasica\u201d, pues todas estas representan un equilibrio inestable de las normas clasicas, es posible identificar el clasicismo de este sistema dado su enfasis en la armonia formal, la destreza tecnica y el control de las respuestas del espectador. Este enfasis se sustentaba en una serie de normas estilisticas basadas en el realismo (entendido como verosimilitud de los acontecimientos, aunque obviamente con amplias excepciones que variaban segun los generos), el montaje de continuidad, la invisibilidad de la narracion, la reduccion de la ambiguedad y la universalidad de las historias.  En Espa\u00f1a, se vive la consagracion de lo que sera el cine espa\u00f1ol clasico durante la decada de los a\u00f1os 1960, 1970 y 1980, apareciendo actores como Jose Luis Lopez Vazquez, Gracita Morales, Alfredo Landa, Paco Martinez Soria etc...  Se produce ademas un intento de estructurar una nueva forma de hacer cine, se intenta avanzar en forma y fondo, pero cuesta porque la mentalidad aun esta muy parada respecto de los avances de mayor vision del cine. En estos a\u00f1os comienza a surgir el cine policiaco, aunque lo que interesa es mostar un cine mas realista, que no muestre tanto los valores patrios y el drama exagerado. de tal forma que abunde la dimension humana. Por ese camino, y a finales de los a\u00f1os 40, surgen las Primeras Conversaciones Cinematograficas de Salamanca, un congreso organizado por antiguos alumnos del Instituto de Cinematografia, entre ellos destacaron: Juan Antonio Bardem, Luis Garcia Berlanga, Carlos Saura, Basilio Martin Patino\u2026 En estas conversaciones, se hizo un repaso general al cine espa\u00f1ol desde todas las opticas y se intento generar una vision positiva del mismo. Por ejemplo, Juan Antonio Bardem definio el cine espa\u00f1ol como \u201cpoliticamente ineficaz, socialmente falso, intelectualmente infimo, esteticamente nulo e industrialmente raquitico\u201c. A partir de estas conversaciones, se intento realizar una serie de peliculas diferentes, como \u201cEsa Pareja Feliz\u201d (1951) dirigida por Bardem y Berlanga, que durante a\u00f1os fueron un tandem importantisimo en el cine espa\u00f1ol. Esta pelicula es el comienzo de las otras posibilidades del cine de nuestro pais y marco las pautas de los nuevos directores. El cine espa\u00f1ol en esta decada viviria ademas una moda pasajera de utilizar ni\u00f1os como protagonistas de peliculas, convirtiendolos en estrellas, siendo el caso de Joselito, Marisol o Pili y Mili.  En esta decada el Cine mexicano se encuentra en su maximo apogeo con grandes estrellas como: Pedro Infante;Jorge Negrete; Arturo de Cordova; Pedro Armendariz; Maria Felix; Dolores del Rio; Cantinflas; German Valdes.  Alfred Hitchcock  Charles Chaplin  Stanley Kubrick  Orson Welles  Ingrid Bergam  James Stewart  Ray Milland  Audrey Hepburn  Grace Kelly  Ava Gardner  Chartlon Heston  Paul Newman  Henry Fonda  Cary Grant  Marilyn Monroe  John Wayne  En esta decada musicalmente predominaban Bing Crosby y Frank Sinatra, al mismo tiempo Dean Martin y Doris Day colocaban exitos en las listas musicales de la epoca.\u200b\u200b En esta decada sobresalieron generos musicales como el Pop y Jazz, no obstante a finales de esta decada se inicia el rock and roll siendo popularizada principalmente por Elvis Presley, Chuck Berry y Bill Haley.  Bing Crosby  Frank Sinatra  Dean Martin  Chuck Berry  Elvis Presley  Doris Day   ","snippet":"La decada de los a\u00f1os 1950 comenzo el 1 de enero de 1950 y termino el 31 de diciembre de 1959.  Durante esta decada, las dos superpotencias vencedoras de la Segunda Guerra Mundial, Estados Unidos y la","enlaces_salientes":["A%C3%B1os_1950","A%C3%B1os_1950","A%C3%B1os_1950","D%C3%A9cada","A%C3%B1os_1920","A%C3%B1os_1930","A%C3%B1os_1940","A%C3%B1os_1960","A%C3%B1os_1970","A%C3%B1os_1980","1950","1951","1952","1953","1954","1955","1956","1957","1958","1959","Siglo","Siglo_XIX","Siglo_XX","Siglo_XXI","Guerra_de_Corea","Poliomielitis","Jonas_Salk","Arma_nuclear","Fidel_Castro","Elvis_Presley","Crisis_de_Suez","Revoluci%C3%B3n_h%C3%BAngara_de_1956","Sputnik_I","Sat%C3%A9lite_artificial","1_de_enero","1950","31_de_diciembre","1959","Segunda_Guerra_Mundial","Estados_Unidos","Uni%C3%B3n_Sovi%C3%A9tica","Bloque_Occidental","Historia_del_capitalismo","Estados_Unidos","Bloque_del_Este","Historia_del_comunismo","Uni%C3%B3n_Sovi%C3%A9tica","Guerra_Fr%C3%ADa","Guerra_Civil_China","Rep%C3%BAblica_Popular_China","Mao_Zedong","Comunismo","Rep%C3%BAblica_Popular_China","1950","Guerra_de_Corea","URSS","Estados_Unidos","Descolonizaci%C3%B3n","Consumismo","Alemania","Jap%C3%B3n","Francia","Gran_Breta%C3%B1a","Jap%C3%B3n","Alemania","Europa","Robert_Schuman","Declaraci%C3%B3n_Schuman","Uni%C3%B3n_Europea","Pena_de_muerte","Uni%C3%B3n_Sovi%C3%A9tica","Guerra_de_Corea","Gustavo_VI_Adolfo_de_Suecia","Libia","Italia","Ciudad_del_Vaticano","P%C3%ADo_XII","Get%C3%BAlio_Vargas","Tratado_de_Par%C3%ADs_(1951)","Comunidad_Europea_del_Carb%C3%B3n_y_del_Acero","Uni%C3%B3n_Europea","Leopoldo_III_de_B%C3%A9lgica","Balduino_de_B%C3%A9lgica","Abd_Allah_ibn_Husayn","Talal_ibn_Abd_Allah","Mohammad_Mosaddeq","Ir%C3%A1n","Jorge_VI","Isabel_II_del_Reino_Unido","Eva_Per%C3%B3n","Argentina","Talal_ibn_Abd_Allah","Hussein_I","Jordania","Juan_Domingo_Per%C3%B3n","Estados_Unidos","Bomba_de_hidr%C3%B3geno","Jonas_Edward_Salk","Vacuna_contra_la_poliomielitis","Miss_Universo","Armi_Kuusela","Marcos_P%C3%A9rez_Jim%C3%A9nez","Venezuela","Derechos_humanos","Revoluci%C3%B3n_boliviana_de_1952","Dwight_D._Eisenhower","Presidente_de_los_Estados_Unidos","I%C3%B3sif_Stalin","Isabel_II_del_Reino_Unido","Reino_Unido","Edmund_Hillary","Tenzing_Norgay","Everest","Jorge_Negrete","Fidel_Castro","Ra%C3%BAl_Castro","Guerra_de_Corea","Corea_del_Norte","Uni%C3%B3n_Sovi%C3%A9tica","Corea_del_Sur","Estados_Unidos","Alfredo_Stroessner","Paraguay","Guerra_de_Independencia_de_Argelia","Joseph_Edward_Murray","Trasplante_de_ri%C3%B1%C3%B3n","Jo%C3%A3o_Caf%C3%A9_Filho","Golpe_de_Estado_en_Guatemala_de_1954","Guatemala","Jacobo_%C3%81rbenz","Robert_Oppenheimer","Estados_Unidos","Bombardeo_de_la_Plaza_de_Mayo","Guerra_de_Vietnam","Disneyland","Anaheim","California","Pacto_de_Varsovia","Albert_Einstein","Argentina","Eduardo_Lonardi","Revoluci%C3%B3n_Libertadora_(Argentina)","Pedro_Eugenio_Aramburu","Nereu_de_Oliveira_Ramos","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Juscelino_Kubitschek","Revoluci%C3%B3n_h%C3%BAngara_de_1956","Uni%C3%B3n_Sovi%C3%A9tica","Guerra_del_Sina%C3%AD","Elvis_Presley","Ghana","Reino_Unido","Joseph_McCarthy","Sputnik_2","Laika","Tratados_de_Roma","Comunidad_Econ%C3%B3mica_Europea","John_Backus","Terremoto_de_M%C3%A9xico_de_1957","Escala_sismol%C3%B3gica_de_Richter","Estado_de_Guerrero","Rep%C3%BAblica_%C3%81rabe_Unida","Marcos_P%C3%A9rez_Jim%C3%A9nez","Venezuela","Pierre_Boulle","Premios_%C3%93scar","Idioma_ingl%C3%A9s","NASA","Proscripci%C3%B3n","Peronismo","Arturo_Frondizi","Uni%C3%B3n_C%C3%ADvica_Radical","Revoluci%C3%B3n_Cubana","Fidel_Castro","Fulgencio_Batista","Alaska","Haw%C3%A1i","Estados_Unidos","Francisco_Franco","Valle_de_los_Ca%C3%ADdos","Dwight_Eisenhower","Guerra_civil_Espa%C3%B1ola","Euskadi_Ta_Askatasuna","Derechos_del_Ni%C3%B1o","Asamblea_General_de_las_Naciones_Unidas","Huelga_ferrocarrilera_mexicana_de_1959","R%C3%B3mulo_Betancourt","Harry_S._Truman","Dwight_D._Eisenhower","I%C3%B3sif_Stalin","Francisco_Franco","Nikita_Jrushchov","Winston_Churchill","Anthony_Eden","Harold_Macmillan","Vincent_Auriol","Ren%C3%A9_Coty","Charles_de_Gaulle","Chiang_Kai-shek","Mao_Zedong","Konrad_Adenauer","Walter_Ulbricht","Alcide_De_Gasperi","P%C3%ADo_XII","Juan_XXIII","Miguel_Alem%C3%A1n_Vald%C3%A9s","Adolfo_Ruiz_Cortines","Adolfo_L%C3%B3pez_Mateos","Juan_Domingo_Per%C3%B3n","Louis_St._Laurent","Robert_Menzies","Getulio_Vargas","Juscelino_Kubitschek","Gamal_Abdel_Nasser","Jawaharlal_Nehru","David_Ben-Gurion","Syngman_Rhee","Kim_Il-sung","Willem_Drees","Ibn_Saud","Sa%C3%BAd_bin_Abdulaziz","Hus%C3%A9in_I_de_Jordania","Fidel_Castro","M%C3%A1ty%C3%A1s_R%C3%A1kosi","Imre_Nagy","J%C3%A1nos_K%C3%A1d%C3%A1r","Boles%C5%82aw_Bierut","W%C5%82adys%C5%82aw_Gomu%C5%82ka","Josip_Broz_Tito","Marcos_P%C3%A9rez_Jim%C3%A9nez","James_Dean","Marilyn_Monroe","Hollywood","Movimiento_art%C3%ADstico","Producci%C3%B3n_cinematogr%C3%A1fica","Espectador","Clasicismo","Realismo","G%C3%A9nero_cinematogr%C3%A1fico","Montaje_cinematogr%C3%A1fico","Jos%C3%A9_Luis_L%C3%B3pez_V%C3%A1zquez","Gracita_Morales","Alfredo_Landa","Paco_Mart%C3%ADnez_Soria","Juan_Antonio_Bardem","Luis_Garc%C3%ADa_Berlanga","Carlos_Saura","Basilio_Mart%C3%ADn_Patino","1951","Juan_Antonio_Bardem","Luis_Garc%C3%ADa_Berlanga","Joselito_(cantante)","Marisol","Pili_y_Mili","Cine_mexicano","Pedro_Infante","Jorge_Negrete","Arturo_de_C%C3%B3rdova","Pedro_Armend%C3%A1riz","Mar%C3%ADa_F%C3%A9lix","Dolores_del_R%C3%ADo","Cantinflas","Germ%C3%A1n_Vald%C3%A9s","Eva_al_desnudo","Rash%C5%8Dmon_(pel%C3%ADcula)","La_Reina_de_%C3%81frica","Bienvenido,_Mister_Marshall","Cantando_bajo_la_lluvia","High_Noon","Roman_Holiday","Ra%C3%ADces_profundas","Los_caballeros_las_prefieren_rubias","Dos_tipos_de_cuidado","La_ley_del_silencio","La_ventana_indiscreta","Sabrina_(pel%C3%ADcula_de_1954)","El_mot%C3%ADn_del_Caine","Veracruz","Rebelde_sin_causa","Escuela_de_vagabundos","La_tentaci%C3%B3n_vive_arriba","La_vuelta_al_mundo_en_ochenta_d%C3%ADas_(pel%C3%ADcula_de_1956)","Senderos_de_gloria","El_bolero_de_Raquel","The_Searchers","Touch_of_Evil","V%C3%A9rtigo","Ben-Hur_(1959)","R%C3%ADo_Bravo_(pel%C3%ADcula_de_1959)","Con_faldas_y_a_lo_loco","Los_cuatrocientos_golpes","Alfred_Hitchcock","Charles_Chaplin","Stanley_Kubrick","Orson_Welles","Ingrid_Bergman","James_Stewart","Ray_Milland","Audrey_Hepburn","Grace_Kelly","Ava_Gardner","Charlton_Heston","Paul_Newman","Henry_Fonda","Cary_Grant","Marilyn_Monroe","John_Wayne","Bing_Crosby","Frank_Sinatra","Dean_Martin","Doris_Day","Rock_and_roll","Elvis_Presley","Chuck_Berry","Bill_Haley","Bing_Crosby","Frank_Sinatra","Dean_Martin","Chuck_Berry","Elvis_Presley","Doris_Day","John_Wayne","Clark_Gable","Humphrey_Bogart","Alfredo_Di_St%C3%A9fano","%C3%81ngel_Labruna","Valeriano_L%C3%B3pez","Paco_Gento","Fidel_Castro","Marcos_P%C3%A9rez_Jim%C3%A9nez","Bing_Crosby","V%C3%ADctor_Paz_Estenssoro","Juan_Domingo_Per%C3%B3n","Eva_Per%C3%B3n","I%C3%B3sif_Stalin","Alfredo_Stroessner","Mao_Zedong","Pedro_Infante","Nikita_Jrushchov","Juan_Alberto_Schiaffino","Audrey_Hepburn","Kim_Il-sung","Chuck_Berry","The_Quarrymen","The_Beatles","Winston_Churchill","Jorge_Negrete","Anthony_Eden","Harold_Macmillan","Konrad_Adenauer","Louis_Armstrong","Lucille_Ball","James_Dean","Arturo_de_C%C3%B3rdova","Yma_Sumac","Ren%C3%A9_Coty","Lauren_Bacall","Get%C3%BAlio_Vargas","Charles_De_Gaulle","Vittorio_De_Sica","Walter_Disney","Elvis_Presley","Gary_Cooper","Isabel_II_del_Reino_Unido","Mar%C3%ADa_F%C3%A9lix","Roy_Lichtenstein","Frank_Sinatra","Cary_Grant","Rocky_Marciano","Cantinflas","Joseph_McCarthy","Marilyn_Monroe","David_Ben-Guri%C3%B3n","Luis_Miguel_Domingu%C3%ADn","Gamal_Abdel_Nasser","Richard_Nixon","Rosa_Parks","Ladislao_Kubala","Ferenc_Pusk%C3%A1s","Andy_Warhol","Burt_Lancaster","Diego_Rivera","Juan_Rulfo","Grace_Kelly","Rufino_Tamayo","Pel%C3%A9","Ferenc_Pusk%C3%A1s","Yul_Brynner","Pedro_Armend%C3%A1riz","Charlton_Heston","Harry_S._Truman","Dwight_D._Eisenhower","Adlai_Stevenson_II","Marlon_Brando","Al_Hibbler","Adam_Faith","Andy_Williams","Big_Joe_Turner","Bill_Haley","Billy_Eckstine","Billy_Fury","Billy_Vaughn","Bobby_Darin","Bobby_Rydell","Bobby_Vee","Brenda_Lee","Buddy_Holly","Cliff_Richard","Connie_Francis","Debbie_Reynolds","Dinah_Shore","Don_Cornell","Doris_Day","Duane_Eddy","Eddie_Cochran","%C3%89dith_Piaf","Ella_Fitzgerald","Fabian","Fats_Domino","Frankie_Avalon","Frankie_Laine","Frankie_Lymon","Freddy_Cannon","Gale_Storm","Gordon_Jenkins","Guy_Lombardo","Guy_Mitchell","Harry_Belafonte","Jerry_Lee_Lewis","Jimmie_Rodgers","Jimmy_Dorsey","Jody_Reynolds","Johnnie_Ray","Johnny_Cash","Johnny_Mathis","Johnny_Rivers","Julie_Andrews","Kitty_Kallen","Lloyd_Price","Lonnie_Donegan","Louis_Armstrong","Mario_Lanza","Marty_Robbins","Marty_Wilde","Neil_Sedaka","Pat_Boone","Patti_Page","Paul_Anka","Perry_Como","Ray_Peterson","Red_Foley","Ricky_Nelson","Roy_Hamilton_(cantante)","Sammy_Davis_Jr.","Skeeter_Davis","Steve_Lawrence","Teresa_Brewer","Tommy_Dorsey","Tommy_Steele","Tony_Bennett","Tony_Martin_(cantante_estadounidense)","ISBN","ISBN","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","KulturNav"]}
{"url":"Zoosemi%C3%B3tica","titulo":"Zoosemiotica","contenido":"La zoosemiotica es la rama de la  biosemiotica que estudia los metodos que usan los animales para comunicarse entre si.\u200b\u200b  Se denomina zoosemiotica a la comunicacion celular, biologica y animal; al intercambio de se\u00f1ales que se da entre los animales de cualquier especie.\u200b  Los animales tienen diferentes sistemas de emitir mensajes. Utilizan su sensibilidad y sus sentidos de olfato, vista, tacto, oido y gusto para emitir y recibir mensajes. Usan cuatro campos o sistemas de comunicacion: el campo quimico, el optico, el tactil y el acustico. El uso de estos, les permite abarcar olores, intensidad de la luz, movimientos y el escuchar con claridad y precision si alguien se acerca o se aleja, etc. Por ejemplo; un perro guardian percibe claramente la presencia de extra\u00f1os, sabe como avisar o atacar si es necesario defender a su compa\u00f1ero humano. Percibe claramente el olor de las personas conocidas y desconoce sin temor a equivocaciones cuando la persona que esta cerca no es grata. La comunicacion entre los humanos y animales de otras especies tambien es muy frecuente cuando se establece una relacion entre ambos, como ocurre entre el perro y su compa\u00f1ero humano. El animal no humano aprende que comportamientos son \"buenos\" y cuales no, y despues a mantener un intercambio de afecto y lealtad indiscutible con algunas especies.  La comunicacion generalmente es entre animales de una misma especie, pero tambien puede ocurrir entre dos animales de especies diferentes. Los animales se comunican mediante se\u00f1ales, que pueden ser visuales, auditivas, quimicas \u2014con la participacion de feromonas\u2014 o tactiles. (fp)  La hipotesis principal de la zoosemiotica, asegura que todos los animales son sociales y que cada especie tiene sus propios medios de comunicacion y manifiestan a traves de ella su humor, epoca de celo, alegria, dolor, tristeza, etc. Esta ciencia se divide en: zoosemiotica pura que dise\u00f1a los modelos que permiten estudiar los mensajes y se\u00f1ales que se emiten entre los animales de manera cientifica, la zoosemiotica descriptiva que estudia la comunicacion entre las especies animales, como las se\u00f1ales que utilizan para elegir pareja, para llamar a sus crias o para alertar de la intromision de seres extra\u00f1os o de peligro.[cita\u00a0requerida]  Una de las funciones importantes es reunir los sexos para la reproduccion. El cortejo suele incluir rituales complejos, en los cuales uno o ambos participantes adoptan posturas con el objeto de \"llamarse\". En virtud de estos rituales, los participantes aprenden a reconocerse y a evaluar la conveniencia de aparearse con el otro.  Otra funcion es con motivo de distanciarse de otros animales, como una forma de establecer limites territoriales y posiciones dentro de una jerarquia. Las jerarquias son determinadas mediante la agresion y la sumision. En una manada de lobos indican su sometimiento agachando el lomo, poniendo las orejas hacia atras y colocando el rabo entre las patas.  En la defensa contra el ataque de rivales o predadores, muchas veces intervienen se\u00f1ales intensas o repentinas. Los mamiferos suelen emitir rugidos o gritos fuertes o graves cuando se sienten amenazados. Los conejos y los ciervos hacen se\u00f1ales con el rabo con el objeto de advertir a los demas de algun peligro inminente. Un individuo de un grupo que ha encontrado una fuente de alimento suele transmitir esa informacion al resto de sus compa\u00f1eros.  Las se\u00f1ales de comunicacion adoptan distintas formas. Esto depende de lo que se quiera transmitir, la distancia que esta tiene que recorrer y el habitat de los animales en cuestion. Las se\u00f1ales pueden ser:  Dependen del sentido del olfato y en algunas ocasiones del gusto. Estas se\u00f1ales pueden recorrer grandes distancias cuando son transportadas por las corrientes del aire, aunque solo son percibidas a favor del viento. Las sustancias quimicas especificas que producen efectos concretos se llaman feromonas. En las colonias de abejas, por ejemplo, la reina produce una feromona \"real\" que impide el desarrollo de los ovarios de las obreras. Las feromonas tienen una gran importancia en lo relativo a la atraccion sexual. Tambien se da esto en los perros ya que la hembra, en epoca de celo, suelta un olor que atrae al macho.  Pueden variar de altura e intensidad con rapidez. Sirven para transmitir una amplia gama de informacion. Estas se\u00f1ales viajan en todas direcciones y el receptor las localiza con facilidad. Por ejemplo, los monos aulladores y algunas aves, ranas y sapos poseen grandes sacos vocales que aumentan considerablemente los sonidos que emiten. En los caso de los sapos, emiten un sonido para atraer a la hembra y otro para \"avisar\" a otros que el tambien es macho.  Muchos animales diferentes usan estas se\u00f1ales, que se pueden encender y apagar en un instante, aunque por lo general son utiles en determinadas horas del dia. Suelen ser llamativas o consistir en movimientos bruscos. Una de las garras del cangrejo violinista macho es mayor que la otra, tiene colores fuertes y la sacude para atraer a las hembras. Los colores y dise\u00f1os de las alas de las mariposas y de los machos de muchas aves atraen a sus compa\u00f1eras en distancias cortas.  Actuan solo en distancias muy cortas. Para indicar su presencia a las hembras, los machos de las ara\u00f1as de estuche hacen vibrar sus membranas de un modo caracteristico. Los machos de los heteropteros producen ondas en la superficie del agua para que sean detectadas por los machos rivales y las hembras potenciales. Los ratones topo golpean su cabeza contra el techo de sus tuneles subterraneos para comunicarse con sus rivales o con sus parejas. Durante la epoca de reproduccion, las hembras de los mosquitos mueven sus alas emitiendo una vibracion.  Algunos peces que viven en los rios lodosos de America del Sur y Africa usan se\u00f1ales electricas capaces de atravesar cuerpos solidos. Son utilizadas para la agresion, para el cortejo y para orientarse.  La danza de la abeja se produce cuando una obrera recolectora o picoteadora encuentra una buena fuente de alimento cerca de la colmena, regresa y ejecuta encima del panal, una danza en forma de ocho aplastado.  El interes de estos sistemas de comunicacion radica en sus similitudes y diferencias con el lenguaje humano:\u200b  Los grupos animales actuan con un cerebro colectivo ","snippet":"La zoosemiotica es la rama de la  biosemiotica que estudia los metodos que usan los animales para comunicarse entre si.\u200b\u200b  Se denomina zoosemiotica a la comunicacion celular, biologica y animal; al in","enlaces_salientes":["Zoosemi%C3%B3tica","Zoosemi%C3%B3tica","Zoosemi%C3%B3tica","Comunicaci%C3%B3n_celular","Sociedad","Estro","Animal","Lobo","Mam%C3%ADfero","Conejo","Ciervo","H%C3%A1bitat","Olfato","Gusto","Feromonas","Mono_aullador","Rana","Sapo","Cangrejo","Mariposa","Ara%C3%B1a","Heter%C3%B3ptero","Mosquito","R%C3%ADo","Am%C3%A9rica_del_Sur","%C3%81frica","Danza_de_la_abeja","Colmena","Lenguaje","Doble_articulaci%C3%B3n","Morfema","Palabra","Fonema","Instinto","Dominancia_(etolog%C3%ADa)","Prox%C3%A9mica","Semi%C3%B3tica","Zoomusicolog%C3%ADa","Kalevi_Kull","Sign_Systems_Studies","Kalevi_Kull","Sign_Systems_Studies","Control_de_autoridades"]}
{"url":"Origen_de_las_lenguas","titulo":"Origen de las lenguas","contenido":"El origen de la lengua es un objeto de estudio de diferentes disciplinas, como la linguistica, la antropologia, la psicologia, la geografia y la genetica humana. El problema del origen del lenguaje se refiere a la adquisicion de la capacidad linguistica en los hominidos que derivo en la evolucion del lenguaje humano; con la estructura y forma actual que presentan las diferentes lenguas naturales.  Un problema diferente es el origen filogenetico de las lenguas humanas, este problema ha sido abordado principalmente dentro de la linguistica historica y las principales hipotesis son la Monogenesis y poligenesis linguistica. De acuerdo a la hipotesis monogenetica, todas las lenguas humanas derivan de una lengua ancestral que debio aparecer antes de la salida de los homo sapiens de Africa. La hipotesis poligenetica sostiene que, si bien los humanos tenian capacidad para el lenguaje, este aparecio en diferentes grupos de humanos mas o menos por la misma epoca.  Otra polemica relacionada con la hipotesis monogenetica es que podemos conocer de la estructura de esta lengua. La postura mas extrema llega a postular que es posible reconstruir parte de su vocabulario, y sus adherentes pretenden reconstruir el idioma protosapiens, aunque la mayor parte de los linguistas consideran que no es posible reconstruirlo.  El origen nace en cada nacion a su naturalidad, ya que se van construyendo su vocabulario y este, con el paso del tiempo, se va extendiendo. Sus modificaciones pueden ser variadas debido a factores internos como errores gramaticales o sonoros y tambien a factores externos como el intercambio cultural que hay debido a la globalizacion que da cabida a extranjerismos o demas errores comunes que transforman la manera de hablar de una sociedad.[cita\u00a0requerida]  El origen de las diferentes lenguas en la especie humana ha sido un tema debatido por varios eruditos a traves de los siglos. De hecho, en el siglo\u00a0XIX, el debate llego a ser tan enconado, persistente y repetitivo que, en 1866, la Sociedad Linguistica de Paris decidio prohibir el tema, aludiendo que todas las teorias al respecto eran tan contradictorias entre si que jamas se podria llegar a un acuerdo. Asi, el problema del origen del lenguaje quedo suspendido por casi un siglo, siendo luego revivido con la esperanza de que los avances en genetica, psicologia evolutiva, linguistica y antropologia fueran capaces de dar una respuesta. Si bien en el siglo\u00a0XIX las discusiones fueron meramente especulativas, por falta de evidencias cientificas solidas, los avances en genetica, linguistica comparativa y otras areas hicieron resurgir el debate en el siglo\u00a0XX sobre bases mas solidas. A pesar de esto, dentro del estudio de la Linguistica historica, no existe un consenso sobre el origen filogenetico de las lenguas y la antiguedad de las familias linguisticas. Los metodos de reconstruccion linguistica a partir del lexico, la estructura y forma actual que presentan las diferentes lenguas, pierde fiabilidad a medida que tratamos de reconstruir estados mas antiguos, y se estima que para profundidades de mas de 5 o 6 milenios, es imposible reconstruir los rasgos esenciales de una protolengua.  Uno de los problemas que dificulta el estudio de esta tematica es la carencia de evidencia directa. Segun linguistas, puede haber unas 4000 o 5000 lenguas en el mundo, algunas bases de datos como Ethnologue agrupan las variedades linguisticas existentes en mas de 6500 lenguas (no siempre existen claros o un criterio definido para decidir si dos variedades son dialectos de la misma lengua o lenguas diferentes). A los linguistas siempre les ha causado intriga el hecho de que haya tantas lenguas, por eso desde los inicios del trabajo cientifico sistematico se esforzaron por probar que las lenguas emparentadas derivaban de lenguas antiguas que se habian diversificado. Asi las mas de 5000 lenguas pueden agruparse en solo unos cuantos centenares de familias, entre las que destacan unas pocas decenas de familias que agrupan a la gran mayoria de las lenguas del mundo. ","snippet":"El origen de la lengua es un objeto de estudio de diferentes disciplinas, como la linguistica, la antropologia, la psicologia, la geografia y la genetica humana. El problema del origen del lenguaje se","enlaces_salientes":["Origen_de_las_lenguas","Origen_de_las_lenguas","Origen_de_las_lenguas","Ling%C3%BC%C3%ADstica","Antropolog%C3%ADa","Psicolog%C3%ADa","Geograf%C3%ADa","Gen%C3%A9tica_humana","Evoluci%C3%B3n_del_lenguaje","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Expansi%C3%B3n_de_la_humanidad","Idioma_protosapiens","Extranjerismos","Gen%C3%A9tica","Psicolog%C3%ADa_evolutiva","Ling%C3%BC%C3%ADstica","Antropolog%C3%ADa","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Reconstrucci%C3%B3n_ling%C3%BC%C3%ADstica","Protolengua","Ethnologue","Lenguas_del_mundo","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Evoluci%C3%B3n_del_lenguaje","Idioma_m%C3%A1s_antiguo","Torre_de_Babel","Filolog%C3%ADa","Antropolog%C3%ADa_ling%C3%BC%C3%ADstica","Control_de_autoridades"]}
{"url":"Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica#Monog\u00e9nesis","titulo":"Monogenesis y poligenesis linguistica","contenido":"La monogenesis y la poligenesis linguisticas son dos hipotesis alternativas sobre el origen filogenetico de las lenguas humanas. De acuerdo con la monogenesis el lenguaje humano surgio una sola vez en una unica comunidad, y todas las lenguas actuales proceden de la primera lengua primigenia. De acuerdo con la segunda las lenguas humanas pudieron nacer en varias comunidades independientemente, y las lenguas actuales procederian de diferentes fuentes.  La monogenesis indica un origen unico de las lenguas del mundo, todas las lenguas actuales se habrian formado mediante el cambio linguistico a partir de una primera que se fue diferenciando en lenguas ininteligibles. El primer cientifico serio en publicarla fue el linguista italiano Alfredo Trombetti, en el libro L'Unita d'origine del linguaggio, publicado en 1905. Mas modernamente Greenberg y Ruhlen, partidarios de la monogenesis, sostienen que en las lenguas modernas existen suficientes evidencias para reconstruir parte de la lengua originaria o protomundo o protosapiens. Sin embargo, esta afirmacion ha sido muy controvertida y las reconstrucciones practicadas por Ruhlen son frecuentemente descalificadas.  La hipotesis monogenetica siempre ha encontrado mucha discusion y realmente existe poca evidencia linguistica solida en su favor. Uno de los principales argumentos para sostenerla procede de la genetica de poblaciones, ya que hay fuertes indicios que sustentan la hipotesis de que la especie humana habria surgido a partir de un reducido grupo humano en Africa, que presumiblemente habria compartido una lengua, denominada por algunos idioma protosapiens. Sin embargo, el surgimiento de la especie humana no esta relacionado por ninguna prueba o teoria solida con el origen de la lengua y, en este caso, tampoco con el surgimiento de una unica lengua original. Se dice que hubo cambios por causa cultural, religiosa, etc.  La poligenesis indica el origen multiple. Segun esta hipotesis, hubo brotes linguisticos independientes en cada lugar donde se iban estableciendo humanos sin tener previamente ningun habla. Indica que de Africa salio el ser humano sin idioma[cita\u00a0requerida] y despues de establecerse en Oriente Medio, Europa, Asia y America, fueron surgiendo alli los distintos grupos linguisticos actuales y extintos. La investigacion moderna sobre lenguas criollas ha mostrado que a partir de un input linguistico adecuado o pidgin, en una generacion los ni\u00f1os desarrollan una lengua con gramatica perfectamente estable y definida. Las lenguas criollas son precisamente las lenguas historicamente surgidas de pidgins. Otro ejemplo notable es idioma de se\u00f1as de Nicaragua que fue creado inconscientemente a partir de se\u00f1as aisladas que no formaban un conjunto de reglas estables, y por tanto no constituian una lengua autentica. ","snippet":"La monogenesis y la poligenesis linguisticas son dos hipotesis alternativas sobre el origen filogenetico de las lenguas humanas. De acuerdo con la monogenesis el lenguaje humano surgio una sola vez en","enlaces_salientes":["Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Filog%C3%A9nesis","Cambio_ling%C3%BC%C3%ADstico","Inteligibilidad_mutua","Alfredo_Trombetti","Joseph_Greenberg","Merritt_Ruhlen","Idioma_protomundo","Idioma_protosapiens","Oriente_Medio","Europa","Asia","Am%C3%A9rica","Lengua_criolla","Pidgin","Idioma_de_se%C3%B1as_de_Nicaragua","Oxford_University_Press","Stanford_University_Press","Control_de_autoridades"]}
{"url":"Protolengua","titulo":"Protolengua","contenido":"Una protolengua o lengua reconstruida es la reconstruccion probable de la lengua original de un grupo de lenguas, sea una rama o una familia, sobre la base de las coincidencias y rasgos comunes a dicha familia de lenguas que no constituyan innovaciones o prestamos.  Dicha reconstruccion se realiza mediante la comparacion de lenguas o metodo comparativo de dicho grupo aplicando los metodos de la linguistica historica. Normalmente el proceso de reconstruccion empieza reconstruyendo el nivel fonetico-fonologico de la lengua madre, lo cual se hace en tres etapas:  Naturalmente, este proceder no puede hacer olvidar la existencia de leyes foneticas que relacionan sonidos o segmentos muy distintos entre si, como los famosos casos (Meillet) existentes entre el armenio y las restantes lenguas indoeuropeas. Es mas, este tipo de correspondencias inexplicables por mera casualidad son las preferidas por los comparatistas para su labor en este apartado, al igual que en morfologia son muy relevantes las irregularidades compartidas.  Es importante entender que habitualmente la reconstruccion se aplica a una lengua que dejo de hablarse hace tiempo, y generalmente es desconocida en su mayoria, es decir, no existen inscripciones o referencias escritas. Dicho proceso de reconstruccion pretende conjeturar cual fue el camino seguido en la evolucion de la lengua, y recorrerlo en sentido inverso.  Historicamente, la primera protolengua reconstruida fue el protoindoeuropeo o indoeuropeo comun, lengua madre que habria dado lugar a las lenguas romances, germanicas, celticas, balticas, griegas, eslavas e indoiranias entre otras. Esto se realizo a finales del siglo\u00a0XIX, y entonces el metodo comparativo adquirio un caracter plenamente cientifico (induccion + deduccion). Desde entonces se han hecho decenas de reconstrucciones de otras protolenguas. Con todo, la reconstruccion interna puede y debe a veces aplicarse al resultado de la comparacion (i.e., a la protolengua de primer grado) o a diferentes etapas de la prehistoria de las lenguas particulares, no solo para descubrir nuevos procesos o formas, sino para establecer cronologias relativas entre estos.  Las palabras reconstruidas sobre la base de evidencia linguistica fiable se escriben precidadas de *.  La siguiente lista contiene enlaces a algunas protolenguas reconstruidas de las que existen articulos en Wikipedia: ","snippet":"Una protolengua o lengua reconstruida es la reconstruccion probable de la lengua original de un grupo de lenguas, sea una rama o una familia, sobre la base de las coincidencias y rasgos comunes a dich","enlaces_salientes":["Protolengua","Protolengua","Protolengua","Idioma","Familia_de_lenguas","Pr%C3%A9stamo_ling%C3%BC%C3%ADstico","M%C3%A9todo_comparativo_(ling%C3%BC%C3%ADstica)","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Cognado","Ley_fon%C3%A9tica","Cambio_ling%C3%BC%C3%ADstico","Idioma_protoindoeuropeo","M%C3%A9todo_comparativo_(ling%C3%BC%C3%ADstica)","Asterisco#ling\u00fc\u00edstica","Idioma_protoc%C3%A9ltico","Idioma_protoaustronesio","Idioma_protomalayo-polinesio","Idioma_proto-oce%C3%A1nico","Idioma_protopac%C3%ADfico_central","Idioma_protopolinesio","Idioma_protoeslavo","Idioma_protogerm%C3%A1nico","Idioma_protoindoeuropeo","Idioma_protoindoiranio","Idioma_protoit%C3%A1lico","Protorromance","Idioma_protojap%C3%B3nico","Idioma_protokartveliano","Idioma_protootom%C3%AD","Idioma_protomixteco","Idioma_protoquechua","Idioma_protosem%C3%ADtico","Idioma_proto-utoazteca","Idioma_protoeuskera","Idioma_protogeorgiano-zan","Idioma_protojap%C3%B3nico","Idioma_proto-armenio","Idioma_protogriego","Idioma_proton%C3%B3rdico","Idioma_protomayense","Idioma_protoindoiranio","Idioma_protoiranio","Idioma_protonahua","Idioma_proto-tup%C3%AD","Idioma_protobereber","Idioma_protobant%C3%BA","Idioma_proto-torresbanks","Origen_del_lenguaje","ISBN","Karl_Brugmann","Ferdinand_de_Saussure","Digital_object_identifier","Julius_Pokorny","Control_de_autoridades","Gemeinsame_Normdatei","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Biblia","titulo":"Biblia","contenido":"La Biblia (del latin tardio biblia, y este del griego \u03b2\u03b2\u03bb\u03b1 [biblia]; literalmente \u2018libros\u2019)\u200b es un conjunto de libros canonicos que en el cristianismo y en otras religiones se consideran producto de inspiracion divina y un reflejo o registro de la relacion entre Dios y la humanidad. La Biblia esta organizada por dos partes principales: el Antiguo Testamento y el Nuevo Testamento, que se enfoca en Cristo y el cristianismo primitivo.  Fue en el Concilio de Roma del a\u00f1o 382, cuando la Iglesia catolica junto al papa Damaso I instituyeron el Canon Biblico con la lista del Nuevo Testamento similar al de Atanasio de Alejandria y los libros del Antiguo Testamento de la Version de los LXX. Esta version fue traducida del griego al latin por Jeronimo (la Vulgata) por encargo de la Iglesia. Posteriormente los Concilios regionales de Hipona del 393, III de Cartago del 397 y IV de Cartago del 419, en los cuales participo Agustin de Hipona, aprobaron definitivamente dicho canon. En el a\u00f1o 405 esta lista fue enviada por el papa Inocencio I al obispo Exuperio de Tolosa (en la Galia, hoy Francia), donde aparece el canon biblico con los 73 libros ya existentes. El concilio de Trento fijo el canon de la Iglesia catolica declarandolo dogma.\u200b La division por capitulos, tal como es al dia de hoy, fue introducida por el cardenal Stephen Langton.\u200b\u200b  Se estima que a lo largo de los siglos se han producido alrededor de cinco mil millones de copias de la Biblia en todas sus variedades (aunque algunos las cifran en muchas mas\u200b), la mayoria en las ultimas decadas (tres mil novecientos millones entre los a\u00f1os 1960 y 2013\u200b), lo que la convierte en el libro mas distribuido y vendido de la historia, siendo frecuentemente reconocido como el libro mas influyente de todos los tiempos.\u200b\u200b\u200b  Se atribuye el gran exito de su distribucion en los ultimos tiempos a la imprenta, habiendo sido el primer libro realizado por medio de la impresion con tipos moviles (la conocida como Biblia de Gutenberg).\u200b En mayo de 2000, se afirmo que \u00abla Biblia ha hecho mas para dar forma a la literatura, la cultura y el entretenimiento, que ningun otro libro que se haya escrito. Su influencia en la historia mundial no tiene equiparable, y no tiene sintomas de estar menguando\u00bb.\u200b Cada a\u00f1o se venden unos cien millones de ejemplares de la Biblia,\u200b\u200b habiendo sido traducida a 438 idiomas en su totalidad (Antiguo Testamento, Nuevo Testamento y textos adicionales), y de forma parcial al menos a 2454 idiomas.\u200b\u200b  La palabra Biblia procede, a traves del latin biblia, de la expresion griega \u03c4\u03b1 \u03b2\u03b2\u03bb\u03b1 \u03c4\u03b1 \u03b1\u03b3\u03b1 (ta biblia ta hagia; \u2018los libros sagrados\u2019), acu\u00f1ada por primera vez en el deuterocanonico 1 Macabeos 12:9,\u200b donde \u03b2\u03b2\u03bb\u03b1 es el plural de \u03b2\u03b2\u03bb\u03bf\u03bd (biblion, \u2018papiro\u2019 o \u2018rollo\u2019 y, por extension, \u2018libro\u2019).\u200b Se cree que este nombre nacio como diminutivo del nombre de la ciudad de Biblos (\u0392\u03c5\u03b2\u03bb\u03bf\u03c2, Byblos), importante mercado de papiros de la antiguedad.\u200b  No obstante, ya que Biblos solamente con dificultad podria ser un prestamo del nombre original de dicha ciudad en fenicio, Gubla, existe la posibilidad de que fuera la ciudad la que recibiera su nombre griego a partir del termino que designaba a la planta de papiro, y no al reves.\u200b  Dicha expresion fue empleada por los hebreos helenizados (aquellos que habitaban en ciudades de habla griega) mucho tiempo antes del nacimiento de Jesus de Nazaret para referirse al Tanaj o Antiguo Testamento.  En la traduccion al griego del Libro de Daniel de la Septuaginta (de aprox. 150 a.\u00a0C.), biblia aparece como traduccion del original hebreo sepharim empleado en Daniel 9:2.\u200b\u200b  Muchos a\u00f1os despues empezo a ser utilizada por los cristianos para referirse al conjunto de libros que forman el Antiguo Testamento, asi como los Evangelios y las cartas apostolicas (es decir, el Nuevo Testamento). Por entonces, ya era comun utilizar unicamente el primer sintagma, \u03c4\u03b1 \u03b2\u03b2\u03bb\u03b1, a manera de titulo.  Ya como titulo, se empezo a utilizar en latin Biblia Sacra (\u2018los libros sagrados\u2019), sin articulo, pues este no existia en latin. Sin embargo, al ser Biblia un cultismo en latin, acabo pasando de considerarse un neutro plural a un femenino singular (\u00abla Sagrada Biblia\u00bb), entendiendo ya Biblia como el nombre propio de todo el conjunto. A traves del latin se derivo a la gran mayoria de las lenguas modernas.  Los libros biblicos fueron escritos inicialmente en distintas lenguas, llamadas lenguas biblicas (hebreo, arameo y griego helenistico). En distintas epocas historicas fueron traducidos de unas de ellas a otras, y posteriormente a las demas.  Biblia hebrea o Biblia hebraica es un termino generico para referirse a los libros de la Biblia escritos originalmente en hebreo y arameo antiguos. Se ajusta muy estrechamente al concepto judio Tanaj y al cristiano Antiguo Testamento (particularmente en la version de algunos grupos cristianos (Evangelicos), que no incluyen las partes deuterocanonicas del Antiguo Testamento y el Anagignoskomena ortodoxo).  El termino Biblia hebrea no implica ningun genero de denominacion, numeracion u ordenacion de libros, que es muy variable. (Vease Canon biblico).  En el estudio erudito de hoy, es comun referirse a las tres ediciones de la obra denominada Biblia hebrea editada por Rudolf Kittel. En este contexto es frecuente la abreviatura BH, o BHK (K por Kittel), o (donde se refieren a las distintas ediciones), BH1, BH2 y BH3.  La Tora o \"ley\" entendida como \"instruccion\" es la base de las reglas y regulaciones religiosas judias y consiste en:  El titulo hebreo proviene de la primera palabra en cada parte excepto Exodo, donde es la quinta palabra. Los libros contienen 613 mitzvot o mandamientos de Dios, que forman la base de la ley religiosa judia (Halakha).  La Tora describe tres etapas en la relacion entre Dios y el hombre. Primero Genesis 1-11 describe la historia general de la creacion de la humanidad, la caida y decadencia del hombre a partir de entonces. Los ultimos 39 capitulos del Genesis, donde Abraham es elegido como el antepasado de un pueblo numeroso a traves del cual sera bendecido. \u00a0Abraham fue llamado por Dios para ir a Canaan, donde la promesa se repitio a sus descendientes, Isaac, Jacob y Jose. En los ultimos cuatro libros cuenta la historia de Moises, que vivio cientos de a\u00f1os despues de los patriarcas de Egipto y cuenta la historia del exodo de los israelitas de Egipto, el exodo del desierto y la renovacion del pacto con Dios en el monte Sinai. La Tora termina con la muerte de Moises.  Los Nevi'im o \"profetas\" incluyen algunas escrituras que se refieren a las escrituras historicas de la Biblia. Los libros describen el reinado del Juicio , el establecimiento de la monarquia israelita, la division en dos reinos y profetas que, en nombre de Dios, advierten y juzgan a los reyes y al pueblo de Israel. Las escrituras terminan con la conquista babilonica del reino sure\u00f1o de Juda. Segun la tradicion judia, Nevi'im se divide en ocho libros. Esa division no se sigue en las Biblias danesas normales:  Ketuvim, o \"los escritos\" en hebreo, son 11 libros escritos por varios autores y contienen la literatura de sabiduria israeli. Segun la tradicion rabinica, muchos de los himnos fueron escritos por David; Se presume que el rey Salomon de joven fue el autor del Cantar de los Cantares, el Libro de Proverbios en la mitad de la vida y el Libro de Eclesiastes en su vejez. El libro de Rut es el unico libro biblico sobre un no judio. Cinco de los libros se llaman \"Los cinco rollos\" (Megilot) y se leen en voz alta durante las fiestas judias: El Cantar de los Cantares en Pascua; Libro de Rut por shavuot; Libro de las Lamentaciones de tisha b'av; El Libro de Eclesiastes de Sucot; y el Libro de Ester de Purim. En general, las \"escrituras\" contienen poesia, reflexiones filosoficas sobre la vida, las vidas de los profetas y otros lideres israelitas durante el cautiverio babilonico. Termina con el decreto persa, que permite a los judios regresar a Jerusalen y reconstruir el templo.  La Biblia griega, comunmente llamada Biblia Septuaginta o Biblia de los Setenta (en griego antiguo: \u03b7 \u039c\u03b5\u03c4\u03b1\u03c6\u03c1\u03b1\u03c3\u03c2 \u03c4\u03c9\u03bd \u0395\u03b2\u03b4\u03bf\u03bc\u03b7\u03ba\u03bf\u03bd\u03c4\u03b1; en griego moderno: \u039c\u03b5\u03c4\u03b1\u03c6\u03c1\u03b1\u03c3\u03b7 \u03c4\u03c9\u03bd \u0395\u03b2\u03b4\u03bf\u03bc\u03b7\u03ba\u03bf\u03bd\u03c4\u03b1; en latin: Septuaginta o Vetus Testamentum Graece iuxta LXX interpretes), y generalmente abreviada simplemente LXX, es una antigua recopilacion en griego koine de los libros hebreos y arameos del Tanaj o Biblia hebrea y otros libros, incluidos algunos escritos originalmente en griego.  Las biblias cristianas estan constituidas por escritos hebreos, arameos y griegos, que han sido retomados de la Biblia griega, llamada Septuaginta, y del Tanaj hebreo-arameo, y luego reagrupados bajo el nombre de Antiguo Testamento. A estos se ha sumado una tercera serie de escritos griegos cristianos agrupados bajo el nombre de Nuevo Testamento. Distintos grupos cristianos han debatido largamente sobre la inclusion o exclusion de algunos de los libros de ambos testamentos, surgiendo los conceptos de apocrifos y deuterocanonicos para hacer referencia a algunos de estos textos.  La comunidad judia actual reserva la expresion \u00abBiblia cristiana\u00bb para identificar solo a los libros que han sido a\u00f1adidos al Tanaj hebreo-arameo por el judaismo tardio helenizante alejandrino, y luego por el cristianismo, y evita referirse a su Tanaj con los terminos \u00abBiblia\u00bb o \u00abAntiguo Testamento\u00bb. Varias denominaciones cristianas incorporan otros libros en el canon de ambos Testamentos.  La biblia protestante version Reina Valera cuenta con 66 libros, divididos entre el Antiguo Testamento que comprenden 39 libros y el Nuevo Testamento 27 libros.  El Antiguo Testamento es la serie de textos sagrados israelitas anteriores a Cristo, y que es aceptada por todos los cristianos como primera parte de las biblias cristianas. En terminos generales, no existe un consenso general entre los diferentes grupos de cristianos sobre si el canon del Antiguo Testamento debe corresponder al de la Biblia griega, con deuterocanonicos, que es lo que plantean las iglesias cristianas ortodoxas y catolica a traves de su historia, o al del Tanaj hebreo, que es lo que plantean los judios actuales, algunos protestantes, y otros grupos cristianos emanados de estos. En total se numeran en el Antiguo Testamento 39 libros en la version protestante, 46 libros en la version de la Iglesia catolica, y 51 libros en la de la Iglesia ortodoxa. Sin embargo, el orden, nombres y particiones de los libros del Antiguo Testamento de las biblias cristianas, a traves de la historia, siguen la usanza griega y no la hebrea. Y, de la misma forma, varia del judaismo en la interpretacion y enfasis (Vease, por ejemplo, el Libro de Isaias, capitulo 7, verso 14).\u200b Aparte de los libros propios del texto griego de la Biblia, el canon de la Iglesia copta admite otros libros, como el Libro de Enoc y el Libro de los Jubileos.  El Nuevo Testamento es una coleccion de 27 libros, representativos de 4 diferentes generos literarios judeocristianos:  La palabra canon significa \u2018regla\u2019 o \u2018medida\u2019, asi que se le llama canon biblico al conjunto de libros que integran la Biblia segun una tradicion religiosa concreta, que los considera asi \u00abdivinamente inspirados\u00bb y los distingue de otros textos que no se consideran revelados. Estas diferencias entre las distintas ramas del cristianismo se dan unicamente para el Antiguo Testamento; por ejemplo, segun la Iglesia catolica son 46 libros, y segun la mayoria de iglesias protestantes son 39. Con relacion al Nuevo Testamento todas tienen el mismo numero de libros.  El primer canon es el Pentateuco, el cual se compone de los libros del Genesis, Exodo, Levitico, Numeros y Deuteronomio y contiene la \u00abLey de Dios\u00bb, que es el conjunto de los 613 preceptos del judaismo (Mitzva).  Dentro del judaismo surge disputa sobre el canon correcto. Un grupo religioso, los saduceos, sostiene que solamente conforma el canon de las Escrituras la Tora (\u2018la Ley\u2019) o Pentateuco (\u2018cinco libros\u2019), mientras que otros grupos tambien incluyen los Nevi'im (Profetas) y los Ketuvim (los Escritos). Despues de la destruccion de Jerusalen en el a\u00f1o 70 d.\u00a0C., el grupo judio predominante fue el de los fariseos, que si considera al canon como conformado por la Ley, los Profetas y los Escritos. Asi, a finales del siglo\u00a0I el judaismo establecio en Yamnia (Yavne) como canon de sus libros sagrados aquellos que cumplieran tres requisitos: que hubiera una copia del libro en cuestion que se supiera que fue escrito antes del a\u00f1o 300 a.\u00a0C. (cuando la helenizacion llego a Judea, con los problemas culturales y religiosos subsecuentes, y que pueden leerse en libros como el Libro de los macabeos o el Libro de Daniel), que dicha copia estuviera escrita en hebreo o cuando menos arameo (no griego, la lengua y cultura invasora) y que tuviera un mensaje considerado como inspirado o dirigido al pueblo de Dios (con lo que tambien algunos libros que cumplian las dos caracteristicas anteriores tuvieron que salir del canon).  En tiempos de Jesus de Nazaret es dominante la segunda opinion, la cual es sostenida y transmitida por muchos cristianos hasta tiempos de la Reforma protestante con la controversia de los libros deuterocanonicos (ver \u00abEstructura\u00bb, ut supra). Esta controversia probablemente se origino precisamente por el hecho de que el judaismo habia establecido su canon a fines del siglo\u00a0I, con lo que para ellos ya no estaban presentes aquellos textos que solo se encontrarian en griego (en la version de la Biblia judia de los Setenta). Estos libros fueron precisamente los que se considerarian, posteriormente, como deuterocanonicos.  La version judia de la Biblia, llamada el Tanaj, consta de 24 libros, con ciertas diferencias respecto a las Biblias cristianas. Algunas de ellas son:  Actualmente, los libros que no son considerados canonicos por catolicos y ortodoxos, reciben el nombre de libros apocrifos; a su vez, esos mismos libros suelen ser denominados pseudoepigrafos por los protestantes, que, habitualmente, respetan tambien el nombre de deuterocanonicos (literalmente, \u2018del segundo canon\u2019) para aquellos que han recibido reconocimiento canonico de catolicos y ortodoxos (en general, son libros escritos originalmente en griego, incluidos en la traduccion al griego de la Biblia judia conocida como Septuaginta o de los LXX). No obstante, algunas corrientes protestantes fundamentalistas insisten en conservar el nombre de apocrifos para los libros deuterocanonicos. Con todo, hay que se\u00f1alar, que los primeros cristianos no usaban la Biblia hebrea, sino que usaban la Septuaginta o de los LXX por cuanto varios de los nuevos cristianos fueron judios de cultura griega, como por ejemplo, Pablo de Tarso, Esteban, y los evangelistas Lucas y Marcos.  Asi pues, las versiones catolicas de la Biblia constan de 73 escritos, en tanto que las mas de las versiones protestantes solo contienen 66. Sin embargo, las Biblias de los anabaptistas, luteranos, anglicanos y episcopalianos, incluyen los deuterocanonicos, si bien bajo el rubro de \u00abapocrifos\u00bb; ya que los consideran \u00ablectura edificante\u00bb, pero no canonica. Las versiones ortodoxas, por su parte, incluyen 76 libros en total. Ademas, la Iglesia copta incluye en su canon del Antiguo Testamento el Libro de Enoc y el Libro de los Jubileos, que no incluye ninguna de las otras corrientes actuales del judeocristianismo, pero que eran libros bastante populares en los tiempos de Cristo; de lo cual han quedado vestigios incluso en los escritos del Nuevo Testamento. La Iglesia siria disponia inicialmente de solo 22 en su Nuevo Testamento, aunque posteriormente acabo aceptando los demas.  La Biblia es una recopilacion de textos que en un principio eran documentos separados (llamados \u00ablibros\u00bb), escritos primero en hebreo, arameo y griego durante un periodo muy dilatado y despues reunidos para formar el Tanaj y la Septuaginta (Antiguo Testamento para los cristianos) y luego el Nuevo Testamento. Ambos testamentos forman la Biblia cristiana. En si, los textos que componen la Biblia fueron escritos a lo largo de aproximadamente 1000 a\u00f1os (entre el 900 a.\u00a0C. y el 100 d.\u00a0C.). Los textos mas antiguos se encuentran en el Libro de los Jueces (\u00abCanto de Debora\u00bb) y en las denominadas fuentes (tradicion elohista) y (tradicion yahvista) de la Tora (llamada Pentateuco por los cristianos), que son datadas en la epoca de los dos reinos (siglos X a siglo\u00a0VIII\u00a0a.\u00a0C.). El libro completo mas antiguo, el de Oseas, es tambien de la misma epoca. El pueblo judio identifica a la Biblia con el Tanaj, para el que carece de sentido y no es aceptada la denominacion como Antiguo Testamento al no aceptar la validez del Nuevo Testamento.  El canon catolico de la Biblia que se conoce hoy fue creado por la Iglesia primitiva que, en las Cartas de Ignacio de Antioquia a la Iglesia de Esmirna se menciona como Catolica (Universal), bajo el pontificado del papa Damaso I, en el Sinodo de Roma del a\u00f1o 382, y esta version es la que Jeronimo de Estridon tradujo al latin. Dicho canon consta de 73 libros: 46 constitutivos del llamado Antiguo Testamento, incluyendo 7 libros llamados actualmente deuterocanonicos (Tobit, Judit, Primer libro de los Macabeos, Segundo libro de los Macabeos, Sabiduria, Eclesiastico (Siracida), y Baruc) y 27 del Nuevo Testamento. Fue confirmado en el Concilio de Hipona en el a\u00f1o 393, y ratificado en el Concilio III de Cartago (en el a\u00f1o 397), y el IV Concilio de Cartago, en el a\u00f1o 419.  A raiz de la reforma protestante, el concilio de Trento (1546 d.\u00a0C.) reafirmo el canon biblico que ya habia sido afirmado en concilios previos, por medio de una declaracion dogmatica en la cuarta sesion del Concilio de Trento, del 8 de abril de 1546. Las definiciones doctrinales del Concilio de Trento no fueron reconocidas ni asumidas por muchos protestantes, surgidos a partir del siglo\u00a0XVI, ni por distintas denominaciones vinculadas al protestantismo surgidas a partir del siglo\u00a0XIX. El canon de las biblias cristianas ortodoxas es aun mas amplio que el canon biblico catolico, e incluye el Salmo 151, la Oracion de Manases, el Tercer libro de Esdras y el Tercer libro de los Macabeos. En adicion a estos, el Cuarto libro de Esdras y el Cuarto libro de los Macabeos figuran, asimismo, como apendices en muchas importantes versiones y ediciones de la Biblia cristiana ortodoxa.  El Antiguo Testamento narra principalmente la historia de los hebreos y el Nuevo Testamento la vida, muerte y resurreccion de Jesus, su mensaje y la historia de los primeros cristianos. El Nuevo Testamento fue escrito en lengua griega koine. En el se cita con frecuencia al Antiguo Testamento de la version de los Setenta, traduccion al griego del Antiguo Testamento realizada en Alejandria (Egipto) en el siglo\u00a0III\u00a0a.\u00a0C.  Para los creyentes, la Biblia es la palabra de Dios, de inspiracion divina, aunque su redaccion se realizo a traves de hombres elegidos que usaron de sus facultades como verdaderos autores. Se trata de una obra eminentemente espiritual que los creyentes interpretan como la forma que tuvo Dios de revelarse a si mismo y manifestar su voluntad de salvacion de la Humanidad, ademas de su caracter y atributos.  Para los creyentes cristianos, la Biblia es la principal fuente de fe y doctrina en Cristo. En el siglo\u00a0XVI los diferentes movimientos de la Reforma protestante comenzaron a experimentar un alto desgaste en discusiones filosoficas y a separarse unos de otros; para menguar este problema se definio el principio llamado \u00absola escritura\u00bb, que significa que solamente la Biblia puede ser considerada fuente de doctrina cristiana. Para la Iglesia catolica, ademas de la Biblia, tambien son fuente doctrinal la Tradicion, las ense\u00f1anzas de los Padres de la Iglesia (discipulos de los apostoles), y las decisiones emanadas de los Concilios. Esta divergencia entre cristianos se intensifico despues de 1870, cuando el papa Pio IX promulgo la constitucion Pastor Aeternus, del Concilio Vaticano I, que reafirma el Primado papal y proclama la infalibilidad del sumo pontifice en asuntos de fe, moral y doctrina cristiana (dogma de la infalibilidad papal) cuando habla ex cathedra (18 de julio de 1870) en cuanto unico \u00absucesor de Pedro\u00bb y, consecuentemente, \u00abcustodio y depositario de las llaves del Reino de los Cielos\u00bb. Mientras que los cristianos protestantes rechazan esta aseveracion y consideran como cabeza unica de la iglesia a Jesucristo. Para ambas partes esta gran diferencia ya no es considerada tan solo en terminos filosoficos o religiosos, sino como designios divinos plasmados y asentados en la Biblia misma.  Para los judios ortodoxos, por supuesto, el Nuevo Testamento no tiene validez. El judaismo rabinico considera como fuente de doctrina el Talmud, mientras los caraitas defienden desde el siglo\u00a0VIII el Tanaj como unica fuente de fe.  El canon del Antiguo Testamento cristiano entro en uso en la Septuaginta griega, traducciones y libros originales, y sus diferentes listas de los textos. Ademas de la Septuaginta, el cristianismo posteriormente a\u00f1adio diversos escritos que se convertirian en el Nuevo Testamento. Poco diferentes listas de las obras aceptadas siguio desarrollando en la antiguedad. En el siglo\u00a0IV, varios sinodos fueron elaborando listas de escritos sagrados que fijaban un canon del Antiguo Testamento de entre 46 y 54 distintos documentos y un canon del Nuevo Testamento de 20 a 27, siendo este ultimo el utilizado hasta el dia de hoy; el cual fue definido finalmente en el Concilio de Hipona en el a\u00f1o 393. Hacia el a\u00f1o 400, Jeronimo habia escrito una edicion definitiva de la Biblia en latin (vease la Vulgata), el Canon de la cual, debido en parte a la insistencia del papa Damaso, fue hecho coincidir con decisiones de varios de los Sinodos reunidos con anterioridad. Con el beneficio de la retrospectiva se puede decir que estos procesos establecieron de manera eficaz el canon del Nuevo Testamento, aunque hay otros ejemplos de listas canonicas en uso despues de este tiempo. Sin embargo, esta lista definitiva de 27 libros no fue cerrada por ningun Concilio ecumenico sino hasta el Concilio de Trento (1545-63).  Durante la Reforma protestante, algunos reformadores canonicos propusieron diferentes listas de las que se encuentran actualmente en uso en la Iglesia de San Pedro en Roma. Aunque no sin debate, la lista de los libros del Nuevo Testamento vendria a seguir siendo la misma, sin embargo, en el Antiguo Testamento algunos textos presentes en la Septuaginta fueron eliminados de la mayoria de los canones protestantes. Por lo tanto, en un contexto catolico, estos textos se denominan libros deuterocanonicos, mientras que en el contexto protestante, en el que se les llama libros apocrifos, la etiqueta se aplica a todos los textos excluidos del canon biblico que estaban en la Septuaginta. Cabe se\u00f1alar tambien, que tanto catolicos como protestantes describen algunos otros libros, como el Libro de los hechos de Pedro, como apocrifos.  Por lo tanto, el Antiguo Testamento protestante de hoy tiene 39 libros \u2014el numero varia del numero de los libros en el Tanaj (aunque no en contenido) a causa de un metodo diferente de la division\u2014. Tambien varia el orden y el nombre de los libros, mientras que la Iglesia catolica reconoce a 46 libros como parte del Antiguo Testamento canonico. El libro de Enoc es aceptado en el canon del Antiguo Testamento solo por la Iglesia ortodoxa de Etiopia. El termino \u00abEscrituras hebreas\u00bb es solo sinonimo del Antiguo Testamento protestante (no catolico) que contiene las Escrituras hebreas y textos adicionales. En cuanto al canon del Nuevo Testamento, son 27 libros en el canon de la Iglesia catolica, aceptado por la mayoria de las Iglesias de la Reforma. La Iglesia siria acepta en la actualidad los 27 libros en su canon. Libros como el Primer libro de Clemente y el Segundo libro de Clemente, el Libro de la Alianza, el Octateuco y otros, han sido motivo de disputas, y se encuentran canonizados por algunas iglesias ortodoxas orientales.  La Biblia describe el desarrollo historico de un pueblo, los israelitas, durante un largo periodo de tiempo. La historia comienza en Mesopotamia, donde Dios llama a Abraham para que se establezca en Canaan (hoy el Estado de Israel y Palestina). Debido al hambre, los descendientes de Abraham, Isaac y Jacob viajaron a Egipto. Despues de una larga estadia en Egipto, la familia emigro a Canaan, despues de 40 a\u00f1os en el desierto bajo el liderazgo de Moises. La gente ahora tiene la ley. Se ha debatido la datacion del evento. El sucesor, Joshua, los condujo a Canaan y dirigio la invasion de la tierra, que estaba habitada por otras tribus. Despues de 400 a\u00f1os de cambiar jueces, la gente queria un rey, el rey Saul, a quien sucedieron el rey David y el rey Salomon. Despues del prospero reinado de Salomon, la tierra se dividio en dos partes. Las diez tribus del norte en el \"Reino del Norte\" (Israel), las dos tribus Juda y Benjamin en el \"Reino del Sur\" (Juda), donde los descendientes de David se sentaron en el trono hasta el 586 a.\u00a0C., donde Juda fue tomada por los babilonios y el pueblo exiliado.  Aproximadamente 70 a\u00f1os despues, a parte de la poblacion se le permitio regresar y construir el templo y la muralla de la ciudad de Jerusalen. Fue dirigido por Esdras y Nehemias. Desde entonces, el pais estuvo en manos de varios gobernantes y unos a\u00f1os bajo un gobierno independiente, hasta que los romanos la incorporaron como provincia de Iudea al Imperio Romano en el a\u00f1o 63 a.\u00a0C.  Entre los a\u00f1os 7 y 4 a.\u00a0C. fue Jesus nacio bajo Herodes I el Grande, que habia ampliado el templo y construido varios palacios y fortalezas grandes en el pais y la metropoli de Cesarea Maritima como un tributo al emperador en Roma. En el a\u00f1o 66 d.\u00a0C. acaecio el levantamiento judio fallido y en 135 a los judios se les prohibio el acceso a Jerusalen, que paso a llamarse Aelia Capitolina.  Todos los escritos del Nuevo Testamento estan marcados por Jesucristo como el punto de partida para la fe y la predicacion y son la figura central del cristianismo. El\u00a0evangelio de Marcos se presenta asi: \"Principio del evangelio de Jesucristo, Hijo de Dios\" (Marcos 1:1). Los evangelios hablan de las ense\u00f1anzas y obras maravillosas de Jesus; sobre como reunio discipulos a su alrededor, entro en conflicto con la sociedad existente, fue acusado de blasfemia; como fue crucificado, muerto y resucitado despues de tres dias. Desde entonces, ha enviado a sus discipulos a predicar el evangelio a todas las naciones. Lo mismo ocurre con las cartas y otros escritos del Nuevo Testamento. Jesucristo juega un papel dominante en los escritos de Pablo. La\u00a0epistola a los Romanos comienza con: \"el evangelio de su Hijo, Jesucristo nuestro Se\u00f1or\" (Rom. 3:1). Los escritores del Nuevo Testamento y la Iglesia consideran que Jesus es el cumplimiento de las profecias mesianicas del Antiguo Testamento. Segun ellos, Jesus \"ascendio al cielo, sentado a la diestra de Dios Padre Todopoderoso, de donde vendra para juzgar a vivos y muertos\".  Las cartas de los apostoles, segun su testimonio de si mismos, son el intento de realizar el mandato de la mision transmitiendo las ense\u00f1anzas de Jesus e interpretando sus ense\u00f1anzas. Segun Jesus, los apostoles hablan con su autoridad y sus palabras deben recibir tanta importancia como las suyas.  La arqueologia biblica es la rama de la arqueologia que se ocupa de los testimonios biblicos. Con el tiempo, los arqueologos han buscado corroborar o socavar la credibilidad de la Biblia a traves de excavaciones arqueologicas en el Medio Oriente: restos de edificios y ciudades, hallazgos de textos e inscripciones. Los manuscritos biblicos se han comparado con otros textos de la comunidad circundante para obtener una mayor conciencia de la Biblia y los textos culturales escritos en ellos. Entre los sitios mas importantes se incluyen: el tunel de Hizkias en Jerusalen, las murallas de Jerico, la rampa de asedio de Senaquerib, el estanque de Siloe, el templo en Jerusalen y los Rollos del Mar Muerto en Qumran . Ademas, hay innumerables excavaciones mas peque\u00f1as y hallazgos individuales relacionados con los relatos biblicos.  La arqueologia biblica muestra que los eventos de la Biblia tienen sus raices en la historia contemporanea, pero lejos de todo es demostrable arqueologicamente. El arqueologo William Matthew Flinders Petrie fue el primero en llevar a cabo una excavacion cientifica en Palestina en 1890, durante la cual excavo Tell el-Hesi durante seis semanas, que se identifico incorrectamente con Laquis. Se le llama el padre de la arqueologia palestina, categorizando y dividiendo los hallazgos en periodos arqueologicos y tratando de datar a partir de fragmentos de ceramica y estratificacion en varias excavaciones.  Un libro de la Biblia es un grupo establecido de escrituras. Por ejemplo, el Libro de los Salmos (en hebreo Tehilim o \u2018canciones de alabanza\u2019) tiene 150 canciones (151 en la version de los Setenta), mientras que la Epistola de Judas es una carta de media pagina.  La Biblia hebrea o Tanaj esta dividida en tres secciones: los cinco libros de Moises (la Tora), los libros escritos por los profetas hebreos (los Profetas o Nevi'im) y unos libros que no entran en las dos categorias anteriores (las Escrituras o Ketuvim); estos son conocidos como hagiografa o simplemente \u00ablas Escrituras\u00bb.  La Biblia judia fue escrita predominantemente en hebreo, pero tiene algunas peque\u00f1as partes que fueron escritas en arameo. En la Biblia cristiana, la Biblia hebrea es llamada Antiguo Testamento, para distinguirla del Nuevo Testamento, que es la parte que narra la vida de Jesus y su predicacion, entre otras cosas. El Nuevo Testamento esta dividido en los cuatro Evangelios, historia (Hechos de los Apostoles), las cartas (epistolas) a iglesias cristianas por Pablo y otros apostoles, y el Apocalipsis.  Las Biblias cristianas contienen la totalidad del Tanaj (o Antiguo Testamento), junto con un grupo de textos posteriores cristianos, conocidos como el Nuevo Testamento. Dentro del cristianismo no hay acuerdo completo sobre el numero exacto de libros que debe tener (con igual reconocimiento) el Antiguo Testamento, es decir, sobre su canon. Hasta el siglo\u00a0XVI se mantuvo en Occidente la traduccion latina de Jeronimo conocida como \u00abla Vulgata\u00bb (proveniente del latin vulgar) que incorporaba tanto el canon judio como aquellos escritos de la Septuaginta griega. Con la Reforma protestante, Martin Lutero cuestiono la necesidad de mantener los libros de la Septuaginta junto a los del canon judio y los agrupo como un apendice considerandolos utiles para la instruccion pero no canonicos al final de su traduccion al aleman de la Biblia. La Iglesia catolica confirmo, sin embargo, el canon de la Biblia de los Setenta y de la Vulgata en el Concilio de Trento (1545-1563), reconociendo mas claramente la canonicidad de algunas escrituras cuestionadas por Lutero, que desde ese mismo siglo comenzaron a ser llamados deuterocanonicos (concepto introducido por Sixto de Siena). Las iglesias orientales tambien reconocen plena canonicidad a los deuterocanonicos, agregando tambien otros libros que se encuentran en codices antiguos, como el Salmo 151, la Oracion de Manases, III y IV Esdras, y III y IV Macabeos. La Iglesia copta acepta asimismo en su canon el Libro de Enoc y el Libro de los Jubileos. El Nuevo Testamento hace referencia tanto a los libros deuterocanonicos como al Libro de Enoc, y narra los sucesos de la pasion de Cristo de acuerdo con el computo asentado en el Libro de los jubileos. En cuanto al resto de los libros, no hay disputa alguna y todos los grupos cristianos tienen los mismos libros en el Nuevo Testamento de la Biblia.  Dentro del texto biblico se mencionan algunos libros y epistolas de los cuales no se cuenta con copias reportadas actualmente o solo se conservan fragmentos. Generalmente se les menciona como referencias primarias, escritos de elaboracion anterior o como complemento de lo escrito dentro del contexto donde se los menciona. En el caso del Libro de Enoc, este ha venido siendo tenido por apocrifo por la mayoria de religiones (siendo caso contrario el canon de la Iglesia ortodoxa de Etiopia) a pesar de haber sido referenciado en la Biblia y encontrarse en un estado integro de contenido.  La siguiente lista parcial muestra algunos de los libros que no estan disponibles hoy en dia en la mayoria de ediciones biblicas. Dichos libros son:  Existen opiniones divididas en cuanto a la afirmacion de que gran parte de la Biblia se ha conservado sin cambios importantes hasta nuestros dias. Actualmente, la creencia comun en casi toda la cristiandad supone la infalibilidad y/o inerrancia del texto biblico, dando por sentado que la Biblia esta exenta de todo error, siendo perfecta como palabra de Dios al hombre. Este concepto es similar a la doctrina de la sola scriptura, donde se considera que la Biblia contiene todo lo necesario para la salvacion del hombre. En el credo de Nicea se confiesa la creencia de que el Espiritu Santo \u00abha hablado por medio de los profetas\u00bb. Este credo ha sido sostenido por los catolicos, ortodoxos, anglicanos, luteranos y la mayoria de denominaciones protestantes. Sin embargo, como nota Alister E. McGrath, \u00ablos reformadores no vieron conectado el asunto de la inspiracion con la absoluta fiabilidad o verdadera inerrancia de los textos biblicos\u00bb. El dice:  Los defensores de la idea de que las escrituras biblicas son fieles y estan completas se basan en la cantidad de copias identicas que, desde tiempos remotos, se ha realizado de las mismas. Los copistas hebreos de las Escrituras, denominados masoretas, que copiaron las Escrituras hebreas entre los siglos VI y X solian contar las letras para evitar errores.  Quienes no estan de acuerdo con estas afirmaciones apelan a circunstancias tales como traducciones de un idioma a otro, copiado de manuscritos, opiniones divergentes en dogmas y/o destruccion deliberada y sostienen por tanto que la Biblia no ha llegado como un volumen completo. Hallazgos tales como los manuscritos del Mar Muerto han mostrado que, en gran parte, esto sucedio antes del siglo\u00a0I de nuestra era, aunque los textos encontrados alli, y los conocidos hasta entonces, parecen presentar cambios menores. En otros casos, libros tales como los Evangelios apocrifos fueron descartados del canon aceptado durante los concilios ecumenicos, como parte de un esfuerzo por mantener la integridad doctrinal. Casos como el del hallazgo del texto completo del Evangelio de Tomas entre los Manuscritos de Nag Hammadi, entre otros textos tomados por hereticos en su momento, evidencian un proceso editorial paulatino en epocas pasadas. Hay otros textos relevantes relacionados con la Biblia \u00aboriginal\u00bb como los escritos apocrifos hallados en Egipto y Cisjordania (Qumran, cerca del mar Muerto), e incluso en paises muy lejanos hacia el Sur y el Oriente. Estos han supuesto una nueva interrogante acerca de si ya estaria completo el canon biblico, o habria que revisarlo de forma detallada.  Las investigaciones arqueologicas en la zona donde se desarrollan los hechos narrados en la Biblia tienen como un resultado a\u00f1adido la comprobacion de los hechos, lugares y personajes que aparecen citados en los diferentes libros que componen la Biblia. Incluso se ha llegado a crear el termino de arqueologia biblica para denominar a una parte de la arqueologia que se encarga de estudiar los lugares indicados en la Biblia.  Hay varios casos en que los descubrimientos arqueologicos han se\u00f1alado congruencias con los hechos o personajes biblicos. Entre esos descubrimientos se encuentran los siguientes:  La arqueologia tambien ha brindado descubrimientos interesantes con relacion a la conformacion de los propios textos biblicos.[cita\u00a0requerida] Los descubrimientos del Evangelio de Tomas y del Evangelio de Felipe, por ejemplo, reforzaron la Hipotesis de Q. Unos pocos eruditos se inclinan a opinar que el Evangelio de Tomas es mas antiguo que los 4 canonicos y que al igual que Mateo y Lucas, tuvo a Q por fuente documental. Conforme a quienes apoyan la hipotesis de la Fuente Q, los evangelios mas antiguos serian colecciones de dichos de Jesus que no narrarian la crucifixion ni la resurreccion, sino que se preocuparian por mantener el registro de las ense\u00f1anzas del Maestro.  La critica biblica es el estudio e investigacion de los escritos biblicos que busca discernir juicios sobre estos escritos.\u200b Viendo los textos biblicos con un origen humano mas que sobrenatural, se pregunta cuando y donde se origina un determinado texto. Como, por que, por quien, para quien y en que circunstancias fue producido, que influencias existen en su produccion, que fuentes se habrian utilizado en su composicion, y que mensaje se pretende transmitir.  La critica biblica varia levemente segun se focalice en el Antiguo Testamento, las cartas del Nuevo Testamento o los Evangelios canonicos y juega tambien un papel importante en la busqueda del Jesus historico.  Tambien alude al texto fisico, incluyendo el significado de cada palabra y el modo en el que se utiliza cada una de ellas, su preservacion, historia e integridad. De hecho, la critica biblica es una disciplina que abarca un amplio rango de materias como la arqueologia, la antropologia, el folclore, la linguistica, las tradiciones orales evangelicas y los estudios religiosos e historicos.  Las traducciones de la Biblia han sido numerosas: a 450 lenguas de forma completa y a mas de 2000 de forma parcial, lo que convierte la Biblia en el libro (o conjunto de libros) mas traducido de la historia.\u200b Algunas de ellas han sido trascendentales para el desarrollo de las lenguas y las culturas en que se dieron.  Las primeras traducciones biblicas comenzaron en el mismo amplio periodo en que sus libros se fueron redactando: el texto masoretico en hebreo, los targum en arameo y la traduccion al griego denominada Biblia de los Setenta (siglo\u00a0III a II a.\u00a0C.), que se realizo de los textos originales que componen la Biblia hebrea del judaismo (Antiguo Testamento para el cristianismo). Los textos del Nuevo Testamento fueron escritos directamente en griego. Esa version sigue siendo utilizada directamente en buena parte de la cristiandad oriental (iglesia ortodoxa), ademas de las traducciones de la Biblia a las lenguas eslavas (desde la traduccion al antiguo eslavo eclesiastico de Cirilo y Metodio, 863) y otras en distintos ambitos linguisticos, algunas de las cuales se cuentan entre las mas antiguas (Diatessaron de Taciano en siriaco, ca. 170, traducciones coptas, etiopes, el Codex Argenteus del godo Ulfilas, siglo\u00a0VI, etc.)  Aunque hay traducciones anteriores (las llamadas Vetus Latina), la traduccion al latin de San Jeronimo (denominada Vulgata, 382) fue la dominante en la cristiandad occidental hasta la reforma protestante (siglo\u00a0XVI), y continuo siendolo en el catolicismo hasta la Edad Contemporanea.\u200b La critica filologica del humanismo buscaba la obtencion de traducciones depuradas (Biblia poliglota complutense impulsada por el cardenal Cisneros, 1514-1522, Textus Receptus iniciado por Erasmo, 1516-1522, continuado por Beza, 1565-1604, Biblia regia o Poliglota de Amberes, de Arias Montano, 1568-1572, etc.)  Coincidiendo con la Edad de Oro del islam (siglos VIII al XIII) hubo traducciones de la Biblia al arabe tanto en el Proximo Oriente como en la Espa\u00f1a musulmana (realizadas por mozarabes).  A finales de la Edad Media ya habian aparecido traducciones totales o parciales de la Biblia a las lenguas vulgares romances y germanicas. Las primeras traducciones de la Biblia al castellano son las llamadas prealfonsinas, que preceden a la denominada Biblia alfonsina (1260-1280) incorporada en la General estoria de Alfonso X el Sabio. Por la misma epoca se produjeron la primera traduccion de la Biblia al portugues (la Biblia de don Dinis, patrocinada por el rey Dionisio I de Portugal) y la primera traduccion de la Biblia al catalan, denominada Biblia de Montjuich (patrocinada por Alfonso III de Aragon en 1287, sobre una preexistente version francesa. La Biblia Valenciana (de Bonifacio Ferrer, comienzos del siglo\u00a0XV) fue uno de los primeros libros impresos en Espa\u00f1a (en 1478). Unos a\u00f1os antes, en 1471, habia aparecido la primera Biblia impresa en italiano (traduccion de Nicolo Malermi). La mas trascendente de las traducciones de la Biblia al aleman fue resultado del trabajo de Martin Lutero entre los a\u00f1os 1521 y 1534 (Biblia de Lutero). Entre las mas importantes traducciones de la Biblia al ingles estan la Biblia de los Obispos (1568), la Tyndale (1525-1536) y la King James (1611). La Reina-Valera (1565-1602) fue la mas usada por los protestantes espa\u00f1oles. ","snippet":"La Biblia (del latin tardio biblia, y este del griego \u03b2\u03b2\u03bb\u03b1 [biblia]; literalmente \u2018libros\u2019)\u200b es un conjunto de libros canonicos que en el cristianismo y en otras religiones se consideran producto de i","enlaces_salientes":["Biblia","Biblia","Biblia","Biblia_(desambiguaci%C3%B3n)","Biblia_de_Gutenberg","Johannes_Gutenberg","Maguncia","Biblioteca_P%C3%BAblica_de_Nueva_York","Libro_sagrado","Oriente_Medio","Hebreo_b%C3%ADblico","Lenguas_arameas","Koin%C3%A9","Dataci%C3%B3n_de_la_Biblia","Idioma_espa%C3%B1ol","Antiguo_Testamento","Pentateuco","Libros_hist%C3%B3ricos","Libros_sapienciales","Libros_prof%C3%A9ticos","Nuevo_Testamento","Evangelios","Hechos_de_los_Ap%C3%B3stoles","Ep%C3%ADstolas","Apocalipsis","Lat%C3%ADn_tard%C3%ADo","Griego_antiguo","Canon_b%C3%ADblico","Cristianismo","Inspiraci%C3%B3n_(teolog%C3%ADa)","Divina_providencia","Antiguo_Testamento","Nuevo_Testamento","Cristo","Cristianismo_primitivo","Iglesia_cat%C3%B3lica","D%C3%A1maso_I","Nuevo_Testamento","Atanasio_de_Alejandr%C3%ADa","Antiguo_Testamento","Septuaginta","Jer%C3%B3nimo_(santo)","Vulgata","Concilio_de_Cartago","Agust%C3%ADn_de_Hipona","A%C3%B1o_405","Inocencio_I","Exuperio_de_Tolosa","Galia","Francia","Concilio_de_Trento","Iglesia_cat%C3%B3lica","Dogma","Cardenal","Stephen_Langton","Imprenta","Impresi%C3%B3n","Tipos_m%C3%B3viles","Biblia_de_Gutenberg","Antiguo_Testamento","Nuevo_Testamento","Lat%C3%ADn","Deuterocan%C3%B3nico","1_Macabeos","Papiro","Rollo_(manuscrito)","Libro","Biblos","Papiro","Idioma_fenicio","Jes%C3%BAs_de_Nazaret","Tanaj","Antiguo_Testamento","Libro_de_Daniel","Septuaginta","Antiguo_Testamento","Evangelio","Nuevo_Testamento","Lat%C3%ADn","Lenguas_orientales_b%C3%ADblicas","Idioma_hebreo","Lenguas_arameas","Koin%C3%A9","Biblia_hebrea","Targum","Alfabeto_hebreo","Biblia_hebrea","Idioma_hebreo","Idioma_arameo","Jud%C3%ADo","Tanaj","Cristiano","Antiguo_Testamento","Evangelicalismo","Deuterocan%C3%B3nicas","Anagignoskomena","Iglesia_Ortodoxa","Canon_b%C3%ADblico","Rudolf_Kittel","1906","1913","Biblia_Hebraica_Stuttgartensia","Tor%C3%A1","G%C3%A9nesis","%C3%89xodo","Lev%C3%ADtico","N%C3%BAmeros","Deuteronomio","%C3%89xodo","Dios","Dios","G%C3%A9nesis","G%C3%A9nesis","Abraham","Abraham","Dios","Cana%C3%A1n","Isaac","Jacob","Mois%C3%A9s","Egipto","Egipto","%C3%89xodo","Monte_Sina%C3%AD","Tor%C3%A1","Mois%C3%A9s","Nevi%27im","Dios","Libro_de_Josu%C3%A9","Idioma_hebreo","Libro_de_Jueces","Idioma_hebreo","Libros_de_Samuel","Libro_de_Reyes","Libro_de_Isa%C3%ADas","Idioma_hebreo","Libro_de_Jerem%C3%ADas","Idioma_hebreo","Libro_de_Ezequiel","Idioma_hebreo","Libro_de_Oseas","Libro_de_Joel","Libro_de_Am%C3%B3s","Libro_de_Abd%C3%ADas","Libro_de_Jon%C3%A1s","Libro_de_Miqueas","Libro_de_Nahum","Libro_de_Habacuc","Libro_de_Sofon%C3%ADas","Libro_de_Hageo","Libro_de_Zacar%C3%ADas","Libro_de_Malaqu%C3%ADas","Ketuvim","David","Cantar_de_los_Cantares","Proverbios","Libro_del_Eclesiast%C3%A9s","Libro_de_Rut","Festividades_jud%C3%ADas","Cantar_de_los_Cantares","Pascua","Libro_de_Rut","Shavuot","Libro_de_las_Lamentaciones","Libro_del_Eclesiast%C3%A9s","Sucot","Libro_de_Ester","Purim","Poes%C3%ADa","Jerusal%C3%A9n","Libro_de_los_salmos","Proverbios","Libro_de_Job","Cantar_de_los_Cantares","Libro_de_Rut","Libro_de_las_Lamentaciones","Libro_del_Eclesiast%C3%A9s","Libro_de_Ester","Libro_de_Daniel","Esdras%E2%80%93Nehem%C3%ADas","Libros_de_Cr%C3%B3nicas","I_Cr%C3%B3nicas","II_Cr%C3%B3nicas","Septuaginta","May%C3%BAscula","Libro_de_Esdras","Septuaginta","Griego_antiguo","Griego_moderno","Lat%C3%ADn","Griego_koin%C3%A9","Idioma_hebreo","Idioma_arameo","Tanaj","Biblia_hebrea","Koin%C3%A9","Pentateuco","Tor%C3%A1","Ptolomeo_II","Libro_de_la_Sabidur%C3%ADa_de_Salom%C3%B3n","Anno_Domini","Libro_de_Ester","Libro_de_Rut","Libro_del_Eclesiast%C3%A9s","Libro_de_las_Lamentaciones","Cantar_de_los_Cantares","Aquila_de_Sinope","Versiones_latinas_de_la_Biblia","Versiones_latinas_de_la_Biblia","Traducciones","Lat%C3%ADn","Septuaginta","Tanaj","Antiguo_Testamento","Nuevo_Testamento","Ap%C3%B3crifo_(religi%C3%B3n)","Deuterocan%C3%B3nicos","Tanaj","Tanaj","Reina-Valera","Antiguo_Testamento","Nuevo_Testamento","Libros_de_la_Biblia","Antiguo_Testamento","Antiguo_Testamento","Cristo","Cristianismo","Antiguo_Testamento","Deuterocan%C3%B3nicos","Protestantismo","Antiguo_Testamento","Iglesia_cat%C3%B3lica","Iglesia_ortodoxa","Antiguo_Testamento","Juda%C3%ADsmo","Libro_de_Isa%C3%ADas","Libro_de_Enoc","Idioma_ingl%C3%A9s","Padre_nuestro","Evangelio_de_Lucas","Nuevo_Testamento","Nuevo_Testamento","Evangelios","Libro_de_los_Hechos","Ep%C3%ADstola","Ep%C3%ADstolas_paulinas","Primera_ep%C3%ADstola_de_Juan","Ep%C3%ADstola_a_los_hebreos","Ensayo","Nuevo_Testamento","Jes%C3%BAs_de_Nazaret","Cristo","Gnosticismo","Nuevo_Testamento","Nuevo_Testamento","Iglesia_cat%C3%B3lica","Protestantismo","Primera_ep%C3%ADstola_de_Clemente","Segunda_ep%C3%ADstola_de_Clemente","Apocalipsis_de_San_Juan","Protestantismo","Nuevo_Testamento","Pentateuco","G%C3%A9nesis","%C3%89xodo","Lev%C3%ADtico","N%C3%BAmeros","Deuteronomio","Dios","Mitzv%C3%A1","Juda%C3%ADsmo","Saduceos","Tor%C3%A1","Nevi%27im","Ketuvim","Jerusal%C3%A9n","Fariseos","Juda%C3%ADsmo","Yavne","Historia_de_Grecia","Judea","Libro_I_de_los_Macabeos","Libro_de_Daniel","Idioma_hebreo","Jes%C3%BAs_de_Nazaret","Reforma_protestante","Septuaginta","Deuterocan%C3%B3nicos","Tanaj","%C3%89xodo","%C3%89xodo","Lev%C3%ADtico","Lev%C3%ADtico","Tor%C3%A1","Pentateuco","Nevi%27im","Libro_de_Josu%C3%A9","Libro_de_los_Jueces","I_Samuel","I_Reyes","Profeta","Libro_de_Isa%C3%ADas","Libro_de_Jerem%C3%ADas","Libro_de_Ezequiel","Profeta_menor","Ketuvim","Libro_de_los_Salmos","Proverbios","Libro_de_Daniel","Ap%C3%B3crifo_(religi%C3%B3n)","Protestantismo","Deuterocan%C3%B3nicos","Tanaj","Septuaginta","Evangelios_ap%C3%B3crifos","Deuterocan%C3%B3nicos","Septuaginta","Pablo_de_Tarso","Esteban_(m%C3%A1rtir)","Lucas_el_Evangelista","Marcos_el_Evangelista","Anabaptismo","Luteranismo","Anglicanismo","Anglicanismo","Evangelios_ap%C3%B3crifos","Iglesia_ortodoxa","Iglesia_ortodoxa_copta","Antiguo_Testamento","Libro_de_Enoc","Libro_de_los_Jubileos","Judeocristianos","Cristo","Nuevo_Testamento","Iglesia_ortodoxa_siria","Nuevo_Testamento","Idioma_hebreo","Lenguas_arameas","Idioma_griego","Tanaj","Septuaginta","Antiguo_Testamento","Cristianismo","Nuevo_Testamento","Libro_de_los_Jueces","D%C3%A9bora","Tradici%C3%B3n_eloh%C3%ADsta","Tradici%C3%B3n_yahvista","Tor%C3%A1","Pentateuco","Libro_de_Oseas","Pueblo_jud%C3%ADo","Tanaj","Antiguo_Testamento","Nuevo_Testamento","Canon_b%C3%ADblico_de_la_Iglesia_cat%C3%B3lica","Ignacio_de_Antioqu%C3%ADa","Iglesia_cat%C3%B3lica","D%C3%A1maso_I","Jer%C3%B3nimo_(santo)","Antiguo_Testamento","Deuterocan%C3%B3nicos","Libro_de_Tobit","Libro_de_Judit","Primer_libro_de_los_Macabeos","Segundo_libro_de_los_Macabeos","Libro_de_la_Sabidur%C3%ADa_de_Salom%C3%B3n","Libro_de_la_Sabidur%C3%ADa_de_Jes%C3%BAs_ben_Sira","Libro_de_Baruc","Nuevo_Testamento","Concilio_de_Cartago","Reforma_protestante","Canon_b%C3%ADblico","Concilio_de_Trento","Concilio_de_Trento","Protestantismo","Canon_b%C3%ADblico_de_la_Iglesia_cat%C3%B3lica","Libro_de_los_salmos","Oraci%C3%B3n_de_Manas%C3%A9s","Tercer_libro_de_Esdras","Tercer_libro_de_los_Macabeos","Cuarto_libro_de_Esdras","Cuarto_libro_de_los_Macabeos","Antiguo_Testamento","Libros_hist%C3%B3ricos","Resurrecci%C3%B3n_de_Jes%C3%BAs","Jes%C3%BAs_de_Nazaret","Nuevo_Testamento","Idioma_griego","Koin%C3%A9","Septuaginta","Antiguo_Testamento","Alejandr%C3%ADa","Dios","Cristianismo","Cristo","Reforma_protestante","Teolog%C3%ADa_cristiana","Iglesia_cat%C3%B3lica","Tradici%C3%B3n_apost%C3%B3lica","Padres_de_la_Iglesia","Ap%C3%B3stol","Cristianismo","P%C3%ADo_IX","Pastor_Aeternus","Concilio_Vaticano_I","Primado_papal","Teolog%C3%ADa_cristiana","Infalibilidad_pontificia","Sim%C3%B3n_Pedro","Cristo","Nuevo_Testamento","Talmud","Cara%C3%ADsmo","Tanaj","Autor%C3%ADa_de_la_Biblia","Dataci%C3%B3n_de_la_Biblia","Antiguo_Testamento","Septuaginta","Septuaginta","Cristianismo","Nuevo_Testamento","Antiguo_Testamento","Nuevo_Testamento","Vulgata","Papa_D%C3%A1maso","Nuevo_Testamento","Concilio_ecum%C3%A9nico","Concilio_de_Trento","Reforma_protestante","Nuevo_Testamento","Antiguo_Testamento","Septuaginta","Protestantismo","Deuterocan%C3%B3nicos","Protestantismo","Ap%C3%B3crifo_(religi%C3%B3n)","Septuaginta","Protestantismo","Hechos_de_Pedro","Ap%C3%B3crifo_(religi%C3%B3n)","Antiguo_Testamento","Protestantismo","Tanaj","Iglesia_cat%C3%B3lica","Antiguo_Testamento","Libro_de_Enoc","Iglesia_ortodoxa_de_Etiop%C3%ADa","Antiguo_Testamento","Protestantismo","Nuevo_Testamento","Iglesia_cat%C3%B3lica","Iglesia_ortodoxa_siria","Iglesias_ortodoxas_orientales","Mesopotamia","Dios","Abraham","Cana%C3%A1n","Israel","Palestina_(regi%C3%B3n)","Abraham","Isaac","Jacob","Egipto","Egipto","Cana%C3%A1n","Mois%C3%A9s","Cana%C3%A1n","David","Salom%C3%B3n","Salom%C3%B3n","Reino_de_Israel","Jerusal%C3%A9n","Esdras","Nehem%C3%ADas","Imperio_romano","Jes%C3%BAs_de_Nazaret","Herodes_I_el_Grande","Jerusal%C3%A9n","Aelia_Capitolina","Jesucristo","Pablo_de_Tarso","Oriente_Medio","Jerusal%C3%A9n","Jeric%C3%B3","Jerusal%C3%A9n","Manuscritos_del_Mar_Muerto","Qumr%C3%A1n","Arqueolog%C3%ADa_b%C3%ADblica","William_Matthew_Flinders_Petrie","Palestina_(regi%C3%B3n)","Libro_de_los_Salmos","Idioma_hebreo","Septuaginta","Ep%C3%ADstola_de_Judas","Biblia_hebrea","Tanaj","Mois%C3%A9s","Tor%C3%A1","Libros_prof%C3%A9ticos","Ketuvim","Idioma_hebreo","Lenguas_arameas","Antiguo_Testamento","Nuevo_Testamento","Jes%C3%BAs_de_Nazaret","Nuevo_Testamento","Evangelio","Hechos_de_los_Ap%C3%B3stoles","Pablo_de_Tarso","Apocalipsis","Tanaj","Antiguo_Testamento","Nuevo_Testamento","Cristianismo","Antiguo_Testamento","Jer%C3%B3nimo_de_Estrid%C3%B3n","Vulgata","Lat%C3%ADn_vulgar","Septuaginta","Reforma_protestante","Mart%C3%ADn_Lutero","Iglesia_cat%C3%B3lica","Septuaginta","Vulgata","Concilio_de_Trento","Mart%C3%ADn_Lutero","Deuterocan%C3%B3nicos","Deuterocan%C3%B3nicos","Libro_de_Esdras","Macabeos","Iglesia_ortodoxa_copta","Libro_de_Enoc","Libro_de_los_Jubileos","Nuevo_Testamento","Deuterocan%C3%B3nicos","Nuevo_Testamento","Iglesia_ortodoxa_de_Etiop%C3%ADa","Nat%C3%A1n_(profeta)","Jeh%C3%BA","Dios","Sola_scriptura","S%C3%ADmbolo_niceno","Esp%C3%ADritu_Santo","Anglicanismo","Luteranismo","Protestantismo","Alister_McGrath","Masoreta","Manuscrito","Manuscritos_del_Mar_Muerto","Evangelio_ap%C3%B3crifo","Concilio_ecum%C3%A9nico","Evangelio_de_Tom%C3%A1s","Manuscritos_de_Nag_Hammadi","Egipto","Cisjordania","Qumr%C3%A1n","Mar_Muerto","Canon_b%C3%ADblico","Arqueolog%C3%ADa_b%C3%ADblica","Arqueolog%C3%ADa_b%C3%ADblica","Arqueolog%C3%ADa","Sarg%C3%B3n_II","Asiria","Samaria","Asdod","Libro_de_Isa%C3%ADas","Joaqu%C3%ADn_de_Jud%C3%A1","Babilonia_(ciudad)","Segundo_libro_de_los_reyes","Primer_libro_de_cr%C3%B3nicas","Eilat_Mazar","Arcilla","Libro_de_Jerem%C3%ADas","N%C3%ADnive","Senaquerib","Laquis","II_Reyes","Anales_de_Senaquerib","Ezequ%C3%ADas","Jerusal%C3%A9n","Libro_de_los_Reyes_(Antiguo_Testamento)","Vers%C3%ADculo","II_Reyes","Vers%C3%ADculo","Cilindro_de_Ciro","Sippar","Bagdad","Irak","Babilonia_(ciudad)","Ciro_II_el_Grande","Babilonia_(reino)","Israelitas","Tishrei","Esdras","Arqueolog%C3%ADa","Evangelio_de_Tom%C3%A1s","Evangelio_de_Felipe","Fuente_Q","Evangelio_de_Tom%C3%A1s","Mateo_el_Evangelista","Lucas_el_Evangelista","Jes%C3%BAs_de_Nazaret","Antiguo_Testamento","Nuevo_Testamento","Evangelios_can%C3%B3nicos","B%C3%BAsqueda_del_Jes%C3%BAs_hist%C3%B3rico","Arqueolog%C3%ADa","Antropolog%C3%ADa","Folclore","Ling%C3%BC%C3%ADstica","Tradiciones_orales_evang%C3%A9licas","Ciencias_de_la_religi%C3%B3n","Traducciones_de_la_Biblia","Traducciones_de_la_Biblia","Libro","Traducci%C3%B3n","Texto_masor%C3%A9tico","Hebreo_b%C3%ADblico","T%C3%A1rgum","Arameo_b%C3%ADblico","Koin%C3%A9","Biblia_de_los_Setenta","Biblia_hebrea","Juda%C3%ADsmo","Antiguo_Testamento","Cristianismo","Nuevo_Testamento","Cristiandad_oriental","Iglesia_ortodoxa","Antiguo_eslavo_eclesi%C3%A1stico","Cirilo_y_Metodio","Diatessaron","Taciano","Sir%C3%ADaco","Codex_Argenteus","Ulfilas","Vetus_Latina","Lat%C3%ADn","Jer%C3%B3nimo_de_Estrid%C3%B3n","Vulgata","Cristiandad_occidental","Reforma_protestante","Catolicismo","Humanismo_renacentista","Biblia_pol%C3%ADglota_complutense","Cardenal_Cisneros","Textus_Receptus","Erasmo","Teodoro_de_Beza","Biblia_regia","Arias_Montano","Edad_de_Oro_del_islam","Pr%C3%B3ximo_Oriente","Espa%C3%B1a_musulmana","Moz%C3%A1rabe","Lenguas_vulgares","Lenguas_romances","Lenguas_germ%C3%A1nicas","Traducciones_de_la_Biblia_al_castellano","Biblia_alfonsina","General_estoria","Alfonso_X_el_Sabio","Dionisio_I_de_Portugal","Traducci%C3%B3n_de_la_Biblia_al_catal%C3%A1n","Alfonso_III_de_Arag%C3%B3n","Biblia_Valenciana","Bonifacio_Ferrer","Nicol%C3%B2_Malermi","Mart%C3%ADn_Lutero","Biblia_de_Lutero","Biblia_de_los_Obispos","King_James","Reina-Valera","Joanes_Leizarraga","Bernardino_de_Sahag%C3%BAn","Nahuatl","Inquisici%C3%B3n_espa%C3%B1ola","Canon_b%C3%ADblico_de_la_Iglesia_cat%C3%B3lica","Canon_b%C3%ADblico_protestante","Libros_de_la_Biblia","Libros_hist%C3%B3ricos","Antiguo_Testamento","Pentateuco","Libro_de_los_salmos","Nuevo_Testamento","Sociedades_B%C3%ADblicas_Unidas","Coma_jo%C3%A1nica","Alta_cr%C3%ADtica","Deuterocan%C3%B3nicos","Evangelios_ap%C3%B3crifos","Fuente_b%C3%ADblica","Fuente_teol%C3%B3gica","Tanaj","Providentissimus_Deus","Textus_Receptus","Verbum_Domini","YouVersion","Enchiridion_symbolorum","ISSN","Digital_object_identifier","BBC","Time_Magazine","ISBN","C%C3%B3nfer","Idioma_hebreo","ISBN","ISBN","Concilio_de_Trento","%C3%8Dndice_de_Libros_Prohibidos","ISBN","ISBN","ISBN","Roberto_Blatt","ISBN","ISBN","ISBN","ISBN","Control_de_autoridades","Wikcionario","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Argentina","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","National_Archives_and_Records_Administration","Syst%C3%A8me_universitaire_de_documentation","BIBSYS","Art_%26_Architecture_Thesaurus","Historical_Dictionary_of_Switzerland","Enciclopedia_Brit%C3%A1nica","Enciclopedia_Treccani","Medical_Subject_Headings","Descriptores_en_Ciencias_de_la_Salud","Wikcionario"]}
{"url":"Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica#Polig\u00e9nesis","titulo":"Monogenesis y poligenesis linguistica","contenido":"La monogenesis y la poligenesis linguisticas son dos hipotesis alternativas sobre el origen filogenetico de las lenguas humanas. De acuerdo con la monogenesis el lenguaje humano surgio una sola vez en una unica comunidad, y todas las lenguas actuales proceden de la primera lengua primigenia. De acuerdo con la segunda las lenguas humanas pudieron nacer en varias comunidades independientemente, y las lenguas actuales procederian de diferentes fuentes.  La monogenesis indica un origen unico de las lenguas del mundo, todas las lenguas actuales se habrian formado mediante el cambio linguistico a partir de una primera que se fue diferenciando en lenguas ininteligibles. El primer cientifico serio en publicarla fue el linguista italiano Alfredo Trombetti, en el libro L'Unita d'origine del linguaggio, publicado en 1905. Mas modernamente Greenberg y Ruhlen, partidarios de la monogenesis, sostienen que en las lenguas modernas existen suficientes evidencias para reconstruir parte de la lengua originaria o protomundo o protosapiens. Sin embargo, esta afirmacion ha sido muy controvertida y las reconstrucciones practicadas por Ruhlen son frecuentemente descalificadas.  La hipotesis monogenetica siempre ha encontrado mucha discusion y realmente existe poca evidencia linguistica solida en su favor. Uno de los principales argumentos para sostenerla procede de la genetica de poblaciones, ya que hay fuertes indicios que sustentan la hipotesis de que la especie humana habria surgido a partir de un reducido grupo humano en Africa, que presumiblemente habria compartido una lengua, denominada por algunos idioma protosapiens. Sin embargo, el surgimiento de la especie humana no esta relacionado por ninguna prueba o teoria solida con el origen de la lengua y, en este caso, tampoco con el surgimiento de una unica lengua original. Se dice que hubo cambios por causa cultural, religiosa, etc.  La poligenesis indica el origen multiple. Segun esta hipotesis, hubo brotes linguisticos independientes en cada lugar donde se iban estableciendo humanos sin tener previamente ningun habla. Indica que de Africa salio el ser humano sin idioma[cita\u00a0requerida] y despues de establecerse en Oriente Medio, Europa, Asia y America, fueron surgiendo alli los distintos grupos linguisticos actuales y extintos. La investigacion moderna sobre lenguas criollas ha mostrado que a partir de un input linguistico adecuado o pidgin, en una generacion los ni\u00f1os desarrollan una lengua con gramatica perfectamente estable y definida. Las lenguas criollas son precisamente las lenguas historicamente surgidas de pidgins. Otro ejemplo notable es idioma de se\u00f1as de Nicaragua que fue creado inconscientemente a partir de se\u00f1as aisladas que no formaban un conjunto de reglas estables, y por tanto no constituian una lengua autentica. ","snippet":"La monogenesis y la poligenesis linguisticas son dos hipotesis alternativas sobre el origen filogenetico de las lenguas humanas. De acuerdo con la monogenesis el lenguaje humano surgio una sola vez en","enlaces_salientes":["Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Monog%C3%A9nesis_y_polig%C3%A9nesis_ling%C3%BC%C3%ADstica","Filog%C3%A9nesis","Cambio_ling%C3%BC%C3%ADstico","Inteligibilidad_mutua","Alfredo_Trombetti","Joseph_Greenberg","Merritt_Ruhlen","Idioma_protomundo","Idioma_protosapiens","Oriente_Medio","Europa","Asia","Am%C3%A9rica","Lengua_criolla","Pidgin","Idioma_de_se%C3%B1as_de_Nicaragua","Oxford_University_Press","Stanford_University_Press","Control_de_autoridades"]}
{"url":"Lenguas_criollas","titulo":"Lengua criolla","contenido":"Una lengua criolla, idioma criollo o, simplemente criollo es una lengua que nace habitualmente en una comunidad compuesta de personas de origenes diversos que no comparten previamente un idioma, que tienen necesidad de comunicarse, y por ello se ven forzados a crear una nueva lengua con elementos de las suyas propias para poderse comunicar.  Un ejemplo tipico es el de los esclavos africanos llevados despues de la conquista de America a las plantaciones del Caribe o de las poblaciones autoctonas de regiones de Sudamerica, Oceania y Africa que se vieron obligadas a utilizar el idioma de la potencia colonial (el ingles, el frances, el espa\u00f1ol, el portugues y el neerlandes) para comunicarse.  Tradicionalmente, la locucion \u00abidioma criollo\u00bb se referia a cualquier lengua mixta, producto de la convivencia prolongada entre hablantes de varios idiomas nativos. Actualmente, el termino lengua mixta hace referencia a un modelo interlinguistico diferente.[cita\u00a0requerida]  Existen discrepancias entre los linguistas sobre la formacion de los idiomas criollos. Para los linguistas Ronald Wardhaugh y Robert A. Hall, Jr., la comunicacion adopta inicialmente la forma de un pidgin, una segunda lengua que toma el lexico, muy deformado y simplificado, de la lengua impuesta y que, sin embargo, mantiene una sintaxis propia de las lenguas indigenas. Los hijos y los descendientes de los hablantes perfeccionaran este lenguaje reducido para transformarlo en una lengua mas eficiente, en un proceso llamado nativizacion.\u200b Cuando el pidgin nativizado se convierte en su idioma materno, una lengua con una sintaxis mas estructurada y un lexico estable y mas amplio, se habla entonces de lengua criolla.\u200b  Para otros linguistas, las lenguas criollas serian el resultado de la evolucion progresiva de un idioma en contacto con otras lenguas, sin la necesidad de pasar por la etapa de transicion del pidgin.  Algunas lenguas criollas clasificadas (no por su gramatica sino por la lengua de la que procede). ","snippet":"Una lengua criolla, idioma criollo o, simplemente criollo es una lengua que nace habitualmente en una comunidad compuesta de personas de origenes diversos que no comparten previamente un idioma, que t","enlaces_salientes":["Lengua_criolla","Lengua_criolla","Lengua_criolla","Criollo_antillano","Agua_de_coco","Idioma","Esclavo","Caribe_(zona)","Lengua_mixta","Pidgin","Segunda_lengua","L%C3%A9xico","Sintaxis","Lenguas_criollas_de_base_inglesa","Criollo_de_Panam%C3%A1","Criollo_limonense","Costa_Rica","Ingl%C3%A9s_criollo_nicarag%C3%BCense","Criollo_sanandresano","Criollo_de_las_Islas_de_la_Bah%C3%ADa","Idioma_misquito","Honduras","Nicaragua","Criollo_belice%C3%B1o","Sranan_tongo","Ndyuka","Barbados","Patois_jamaiquino","Criollo_de_las_Islas_Caim%C3%A1n","Idioma_pichi","Tok_pisin","Bislama","Pitcairn%C3%A9s-norfolkense","Criollos_de_base_francesa","Criollo_haitiano","Criollo_antillano","Guadalupe_(Francia)","Dominica","Grenada","Islas_de_los_Santos","Martinica","Idioma_kweyol","Criollo_franc%C3%A9s_de_Trinidad_y_Tobago","Criollo_franc%C3%A9s_de_Venezuela","Criollo_de_Guayana_Francesa","Franc%C3%A9s_caj%C3%BAn_(idioma)","Criollo_de_Agalega","Criollo_chagosiano","Criollo_de_Rodrigues","Criollo_de_Reuni%C3%B3n","Criollo_mauriciano","Criollo_seychelense","Lenguas_criollas_de_base_portuguesa","Papiamento","Criollo_forro","Criollo_angolar","Criollo_annobonense","Criollo_bissauguineano","Criollo_caboverdiano","Lenguas_criollas_de_base_espa%C3%B1ola","Criollo_chabacano","Criollo_palenquero","Islas_V%C3%ADrgenes_de_los_Estados_Unidos","Estado_de_Nueva_York","Nueva_Jersey","Afrik%C3%A1ans","Sud%C3%A1frica","Indias_Orientales_Neerlandesas","Uganda","Kenia","%C3%81rabe_Yuba","Criollo_de_Yilan","Taiw%C3%A1n","K%C3%BCchendeutsch","Namibia","Unserdeutsch","Pap%C3%BAa_Nueva_Guinea","Lenguas_criollas_de_base_espa%C3%B1ola","Lenguas_criollas_de_base_inglesa","Criollos_de_base_francesa","Pidgin","Lengua_mixta","Lengua_koin%C3%A9","John_M._Lipski","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Pidgin","titulo":"Pidgin","contenido":"Un pidgin (pronunciado en ingles /p\u026ad\u0292\u026an/)  es una lengua simplificada, creada y usada por individuos de comunidades que no tienen una lengua comun ni conocen suficientemente alguna otra lengua para usarla entre ellos. Los pidgins han sido comunes a lo largo de la historia en situaciones como el comercio, donde los dos grupos hablan lenguas diferentes, o situaciones coloniales en que habia mano de obra forzada (frecuentemente entre los esclavos de las colonias se usaban temporalmente pidgins).  En esencia, un pidgin es un codigo simplificado que permite una comunicacion linguistica escueta, con estructuras simples y construidas azarosamente mediante convenciones, entre los grupos que lo usan. Un pidgin no es la lengua materna de ninguna comunidad, sino una segunda lengua aprendida o adquirida. Los pidgins se caracterizan por combinar los rasgos foneticos, morfologicos y lexicos de una lengua con las unidades lexicas de otra, sin tener una gramatica estructurada estable.  El pidgin no es habitualmente la lengua materna de ningun grupo etnico o social; suele ser la lengua que emplea un inmigrante en su nuevo lugar de residencia, o una lingua franca empleada en una zona de contacto intenso de poblaciones linguisticamente diferenciadas, como por ejemplo un puerto muy activo. Los pidgins fueron frecuentes tambien en las colonias, mezclando elementos de la lengua de la nacion dominante con los de los nativos y los esclavos introducidos en ella.  El hablante del pidgin emplea las estructuras formales de su lengua materna, a las que completa con vocablos de la lengua de su interlocutor. Puesto que se emplean para mantener comunicaciones entre individuos con competencias linguisticas diferentes, su gramatica normalmente suele reducirse a lo indispensable. Es comunmente aceptada la idea de que si un pidgin se estabiliza como lengua de un grupo, de modo que llega a tener hablantes nativos, empieza a convertirse en un creole o lengua criolla, la cual se caracteriza por adquirir, sobre la base del pidgin, todas las caracteristicas de una lengua natural completa. Sin embargo, algunos linguistas, como Salikoko Mufwene, consideran que este hecho no esta bien demostrado.  El pidgin mas antiguo del que se tiene noticia es la lingua franca o sabir, un dialecto empleado por los marinos y mercaderes del Mediterraneo desde el siglo\u00a0XIV que continuo en uso hasta finales del siglo\u00a0XIX. Muchos otros pidgins se han originado en la actividad comercial de los europeos; el pidgin de Guangzhou \u2013del que una etimologia popular, pero probablemente falaz, hace derivar el propio termino \u00abpidgin\u00bb\u2013 se origino en los puertos chinos para la negociacion.  Otra rica fuente de pidgins fue la introduccion en las colonias americanas y caribe\u00f1as de esclavos de origen africano. La combinacion de las distintas lenguas que estos hablaban \u2013puesto que los esclavistas capturaban indistintamente a miembros de distintas etnias, muchas veces desconocidas u hostiles entre si\u2013 con las lenguas de los terratenientes coloniales y los nativos amerindios dio lugar a numerosas mezclas, de las cuales la mayoria se estabilizaron al final en lenguas criollas. En Sudamerica, la combinacion del portugues, el espa\u00f1ol y las lenguas tupi-guaranies dio origen a la Lingua geral o \u00f1e'engatu, hablado en la cuenca del Amazonas y en todo el Paraguay (llamado ahi \"jopara\"), empleada para los ritos umbanda hasta el dia de hoy.  El origen del termino no esta claro. Se ha sugerido que la palabra se tomo de la pronunciacion china de la palabra inglesa business (\"negocios\"), pero podria deberse tambien a la expresion pigeon English (\u00abingles de paloma\u00bb), en referencia a la paloma mensajera. La palabra china para pidgin, en chino tradicional, \u6d0b\u6d87\u6ff1; en chino simplificado, \u6d0b\u6cfe\u6ee8; pinyin, yang jing bin, tuvo su origen a partir del nombre del rio Jing, situado a lo largo de la frontera entre las tierras arrendadas a franceses e ingleses en Shanghai.  Pidgin English es el nombre dado por los angloparlantes al pidgin chino-anglo-portugues usado para el comercio en Canton durante los siglos XVIII y XIX; en China esta lengua franca recibio el nombre de ingles de Canton.  La creacion de un pidgin requiere:  Los pidgins se convierten en lenguas criollas cuando una generacion de ni\u00f1os aprende un pidgin como lengua materna.\u200b Este fenomeno parece apoyar la tesis de Noam Chomsky relativa a que existe una estructura cerebral innata que nos permite, siendo ni\u00f1os, aprender algo tan complejo como la gramatica (gramatica universal).\u200b ","snippet":"Un pidgin (pronunciado en ingles /p\u026ad\u0292\u026an/)  es una lengua simplificada, creada y usada por individuos de comunidades que no tienen una lengua comun ni conocen suficientemente alguna otra lengua para u","enlaces_salientes":["Pidgin","Pidgin","Pidgin","Pidgin_(desambiguaci%C3%B3n)","Alfabeto_Fon%C3%A9tico_Internacional","Esclavos","Segunda_lengua","Fon%C3%A9tica","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Etnia","Grupo_social","Inmigrante","Lingua_franca","Puerto_fluvial","Colonia_(administrativa)","Esclavo","Lengua_criolla","Lengua_natural","Sabir","Marino","Mercader","Mar_Mediterr%C3%A1neo","China","Esclavo","Amerindio","Sudam%C3%A9rica","Lenguas_tup%C3%AD-guaran%C3%AD","L%C3%ADngua_geral","R%C3%ADo_Amazonas","Umbanda","Paloma_mensajera","Caracteres_chinos_tradicionales","Caracteres_chinos_simplificados","Pinyin","R%C3%ADo_J%C4%ABng","Shangh%C3%A1i","Idioma_portugu%C3%A9s","Cant%C3%B3n_(China)","Siglo_XVIII","Siglo_XIX","Interlengua","Lenguas_criollas","Noam_Chomsky","Gram%C3%A1tica_universal","Cocoliche","Hiri_motu","Lengua_criolla","Patois","Lengua_mixta","Lengua_koin%C3%A9","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Idioma_de_se%C3%B1as_de_Nicaragua","titulo":"Lengua de se\u00f1as nicaraguense","contenido":"Idioma de Se\u00f1as de Nicaragua (ISN) o Lengua de Se\u00f1as Nicaraguense o Lenguaje de Se\u00f1as Nicaraguense es una lengua de se\u00f1as que se desarrollo en forma aislada de otras lenguas de se\u00f1as en la Nicaragua de los a\u00f1os 1980, cuando el gobierno revolucionario Sandinista creo la primera escuela publica para ni\u00f1os sordos en la historia del pais. El lenguaje no fue impulsado por el Gobierno, sino que evoluciono naturalmente a partir de la comunicacion entre los propios estudiantes con sus profesores.\u200b  Luego de la Revolucion Popular Sandinista de 1979, el gobierno nicaraguense matriculo a cientos de estudiantes sordos en dos escuelas de Managua. Inicialmente se intento la utilizacion de dactilologia con signos elementales para presentar los caracteres de los lenguajes hablados, lo que resulto en un completo fracaso, ya que la mayoria de los alumnos no podian aprender el concepto palabra, al no haber estado nunca expuestos a la lengua oral ni a la escrita. Por consiguiente, los ni\u00f1os y los docentes estaban desconectados linguisticamente.  Inicialmente, los estudiantes solo podian usar signos gestuales algo rudimentarios, utilizados en el seno de sus propias familias, pero una vez que se los reunio, comenzaron a crear entre ellos de forma independiente una lengua propia. Mientras que a los maestros sin experiencia les resultaba dificil entender a sus alumnos, estos se comunicaban entre si sin ningun problema. En unas pocas decadas habia nacido una lengua madura con su propias reglas y gramatica.\u200b  Las autoridades del Ministerio de Educacion de Nicaragua solicitaron el apoyo de academicos internacionales que finalmente decodificaron la creacion de los ni\u00f1os.  Los linguistas encuentran al ISN particularmente interesante porque ha madurado en unas pocas decadas desde un pidgin hasta una lengua criolla (creole) completamente desarrollada, gracias a la llegada de nuevos ni\u00f1os que han aprendido el ISN como su lengua primaria.  Tambien representa la formacion de una lengua nueva sin una comunidad de \"hablantes\" adultos nativos. Los creoles habituales se desarrollan a partir de la mezcla tipo pidgin de dos o mas comunidades bien definidas de hablantes nativos, pero en este caso la evolucion se dio a partir de un grupo de jovenes sin lengua primaria.  Algunos linguistas consideran que lo sucedido en Managua prueba que la adquisicion del lenguaje es un atributo innato de la mente humana. Steven Pinker ha sostenido que:  Mediante la Ley del Lenguaje de Se\u00f1as Nicaraguense, Ley N.\u00ba 675, aprobada el 12 de febrero de 2009 y publicado en \"La Gaceta\" n.\u00ba 75 del 24 de abril de 2009, se reconoce y regula el Lenguaje de Se\u00f1as Nicaraguense, como lengua de las personas con discapacidad auditiva en Nicaragua, que libremente decidan utilizarla.\u200b  En el Articulo 3 de dicha ley, se otorga el Reconocimiento Oficial por el Estado de Nicaragua:  De conformidad al Arto. 8 de dicha ley se manda a crear el Consejo Nacional del Lenguaje de Se\u00f1as Nicaraguense como instancia de definicion, promocion, investigacion y divulgacion del lenguaje de se\u00f1as Nicaraguense.\u200b  En 2020 el canal nicaraguense VosTV lanzo el programa televisivo \"Mi se\u00f1a Tu se\u00f1a\" en alianza con el proyecto Aprendo y Emprendo, la Federacion de Asociaciones de Personas con Discapacidad (Feconori) y la Alianza Nacional de Sordos Nicaragua (Ansnic).\u200b  El programa esta dirigido a personas oyentes que realmente necesitan y quieren aprender este lenguaje, a fin de fomentar la comunicacion entre la persona sorda y la persona oyente.\u200b  Ciertos investigadores \"puristas\" han sugerido restringir el acceso de los usuarios de este a otras lenguas de se\u00f1as \"con el fin de proteger la pureza del lenguaje\"; sugerencia que no ha tenido ninguna acogida en Nicaragua; por cuanto, esto seria una restriccion poco etica a la libertad y derecho humano a expresarse en el idioma o lenguaje que la persona desee.   ","snippet":"Idioma de Se\u00f1as de Nicaragua (ISN) o Lengua de Se\u00f1as Nicaraguense o Lenguaje de Se\u00f1as Nicaraguense es una lengua de se\u00f1as que se desarrollo en forma aislada de otras lenguas de se\u00f1as en la Nicaragua d","enlaces_salientes":["Lengua_de_se%C3%B1as_nicarag%C3%BCense","Lengua_de_se%C3%B1as_nicarag%C3%BCense","Lengua_de_se%C3%B1as_nicarag%C3%BCense","Nicaragua","Familia_de_lenguas","Lengua_aislada","Nicaragua","ISO_639-2","ISO_639-3","Lengua_de_se%C3%B1as","Nicaragua","A%C3%B1os_1980","Frente_Sandinista_de_Liberaci%C3%B3n_Nacional","Sordo","Revoluci%C3%B3n_Sandinista","1979","Dactilolog%C3%ADa","Expresi%C3%B3n_oral","Lengua_escrita","Ministerio_de_Educaci%C3%B3n_de_Nicaragua","Ling%C3%BC%C3%ADstica","Pidgin","Lengua_criolla","Creole","Managua","Steven_Pinker","12_de_febrero","2009","24_de_abril","QuickTime","RealPlayer","Control_de_autoridades"]}
{"url":"Lenguas","titulo":"Lengua","contenido":"Lengua puede hacer referencia a:  Ademas, puede referirse al nombre vulgar de cualquiera de las siguientes plantas: ","snippet":"Lengua puede hacer referencia a:  Ademas, puede referirse al nombre vulgar de cualquiera de las siguientes plantas: ","enlaces_salientes":["Lengua","Lengua","Lengua","Lengua_(anatom%C3%ADa)","Lengua_(ling%C3%BC%C3%ADstica)","Lengua_(Orden_de_Malta)","%C3%89vert_Lengua","Pueblos_lengua","Anchusa_arvensis","Anchusa_azurea","Echium_plantagineum","Wikcionario","Diccionario_de_la_lengua_espa%C3%B1ola"]}
{"url":"Procesamiento_de_lenguajes_naturales","titulo":"Tratamiento de lenguajes naturales","contenido":"El tratamiento de lenguajes naturales (TLN) es un campo de las ciencias de la computacion, de la inteligencia artificial y de la linguistica que estudia las interacciones entre las computadoras y el lenguaje humano, asi como los detalles computacionales de las lenguas naturales. Se ocupa de la formulacion e investigacion de mecanismos eficaces computacionalmente para la comunicacion entre personas y maquinas por medio del lenguaje natural, es decir, de las lenguas del mundo. No trata de la comunicacion por medio de lenguas naturales de una forma abstracta, sino de dise\u00f1ar mecanismos para comunicarse que sean eficaces computacionalmente \u2014que se puedan realizar por medio de programas que ejecuten o simulen la comunicacion\u2014. Los modelos aplicados se enfocan no solo a la comprension del lenguaje de por si, sino a aspectos generales cognitivos humanos y a la organizacion de la memoria. El lenguaje natural sirve solo de medio para estudiar estos fenomenos. Hasta la decada de 1980, la mayoria de los sistemas de TLN se basaban en un complejo conjunto de reglas dise\u00f1adas a mano. A partir de finales de 1980, sin embargo, hubo una revolucion en TLN con la introduccion de algoritmos de aprendizaje automatico para el procesamiento del lenguaje.\u200b\u200b  La historia del TLN empieza desde 1950, aunque se han encontrado trabajos anteriores. En 1950, Alan Turing publico Computing machinery and intelligence, donde proponia lo que hoy se llama el test de Turing como criterio cualitativo de inteligencia superior. En 1954, el experimento de Georgetown involucro traduccion automatica de mas de sesenta oraciones del ruso al ingles. Los autores sostuvieron que en tres o cinco a\u00f1os la traduccion automatica seria un problema resuelto. El avance real en traduccion automatica fue mas lento, y en 1966 el reporte ALPAC demostro que la investigacion habia tenido un bajo desempe\u00f1o. Mas tarde, hasta finales de 1980, se llevaron a cabo investigaciones a menor escala en traduccion automatica, y se desarrollaron los primeros sistemas de traduccion automatica estadistica. Esto se debio tanto al aumento constante del poder de computo resultante de la ley de Moore como a la disminucion gradual del predominio de las teorias linguisticas de Noam Chomsky (por ejemplo, la gramatica transformacional), cuyos fundamentos teoricos desalentaron el tipo de linguistica de corpus, que se basa en el enfoque de aprendizaje de maquinas para el procesamiento del lenguaje. Se usaron entonces los primeros algoritmos de aprendizaje automatico, como los arboles de decision, sistemas producidos de sentencias si-entonces similares a las reglas escritas a mano. Se puede consultar un resumen de la historia de 50 a\u00f1os de publicaciones acerca del procesamiento automatico despues del proyecto NLP4NLP en una publicacion doble en Frontiers in Research Metrics and Analytics.\u200b\u200b  Entre finales de los a\u00f1os 1970 y 1985, los modelos de traduccion mas eficientes,como Systran se basaron en traduccion basada en reglas y otros enfoques similares. Hacia principios del siglo\u00a0XXI se vio que estos sistemas no eran los mas eficientes, durante los a\u00f1os 2010, la mayor parte de sistemas de traduccion automatica que proporcionaban resultados de alta calidad se basaban en metodo de inteligencia artificial, en especial, las redes neuronales artificiales y aprendizaje profundo. A partir de 2020, la mayor parte de productos comerciales y traductores web ya basaban en dichas tecnologias. Mas tarde los modelos de lenguaje colosales (LLM) como ChatGPT y Google Bard tambien se basaron en este tipo de tecnologias, y aunque eran mas generales que un sistema de traduccion automatico tambien eran muy eficientes en traduccion automatica.  Las lenguas naturales son inherentemente ambiguas en diferentes niveles:  Para resolver estos tipos de ambiguedades y otros, el problema central en el TLN es la traduccion de entradas en lenguas naturales a una representacion interna sin ambiguedad, como arboles de analisis.  En la lengua hablada no se suelen hacer pausas entre palabra y palabra. El lugar en el que se deben separar las palabras a menudo depende de cual es la posibilidad de que mantenga un sentido logico tanto gramatical como contextual. En la lengua escrita, lenguas como el chino mandarin tampoco tienen separaciones entre las palabras.  Acentos extranjeros, regionalismos o dificultades en la produccion del habla, errores de mecanografiado o expresiones no gramaticales, errores en la lectura de textos mediante OCR  Es posible identificar dentro del TLN un subcampo especializado en las relaciones semanticas y pragmaticas, denominado Comprension del lenguaje natural (CLN, en ingles Natural Language Understanding - NLU). La CLN agruparia, entonces, las areas de resumen automatico, parafrasis, analisis de sentimientos y busqueda de respuestas. De esta, la principal aplicacion serian los chatbot o bot conversacionales.\u200b  Las principales tareas de trabajo en el TLN son: ","snippet":"El tratamiento de lenguajes naturales (TLN) es un campo de las ciencias de la computacion, de la inteligencia artificial y de la linguistica que estudia las interacciones entre las computadoras y el l","enlaces_salientes":["Tratamiento_de_lenguajes_naturales","Tratamiento_de_lenguajes_naturales","Tratamiento_de_lenguajes_naturales","Ciencias_de_la_computaci%C3%B3n","Inteligencia_artificial","Ling%C3%BC%C3%ADstica","Lenguaje_humano","Lengua_natural","Lenguaje_natural","Lenguas_del_mundo","Algoritmo","Aprendizaje_autom%C3%A1tico","Alan_Turing","Computing_machinery_and_intelligence","Test_de_Turing","Inteligencia#Intentos_de_medir_la_inteligencia","Experimento_de_Georgetown","Idioma_ruso","Idioma_ingl%C3%A9s","Traducci%C3%B3n_autom%C3%A1tica","Traducci%C3%B3n_autom%C3%A1tica_estad%C3%ADstica","Ley_de_Moore","Noam_Chomsky","Gram%C3%A1tica_transformacional","Ling%C3%BC%C3%ADstica_de_corpus","Aprendizaje_autom%C3%A1tico","%C3%81rboles_de_decisi%C3%B3n","Systran","Traducci%C3%B3n_autom%C3%A1tica#Traducci\u00f3n_autom\u00e1tica_basada_en_reglas","A%C3%B1os_2010","Inteligencia_artificial","Redes_neuronales_artificiales","Aprendizaje_profundo","LLM_(modelo_grande_de_lenguaje)","ChatGPT","Google_Bard","Ambig%C3%BCedad","L%C3%A9xico","An%C3%A1fora","Cat%C3%A1fora","Sem%C3%A1ntica","%C3%81rbol_sint%C3%A1ctico","Figura_ret%C3%B3rica","%C3%81rbol_sint%C3%A1ctico","Idioma_chino_mandar%C3%ADn","OCR","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Sintaxis","Sem%C3%A1ntica_ling%C3%BC%C3%ADstica","Pragm%C3%A1tica","An%C3%A1lisis_de_sentimiento","B%C3%BAsqueda_de_respuestas","Bot_conversacional","S%C3%ADntesis_del_discurso","Comprensi%C3%B3n_del_lenguaje","Reconocimiento_del_habla","S%C3%ADntesis_de_voz","Generaci%C3%B3n_de_lenguajes_naturales","Traducci%C3%B3n_autom%C3%A1tica","Respuesta_a_preguntas","Recuperaci%C3%B3n_de_la_informaci%C3%B3n","Extracci%C3%B3n_de_la_informaci%C3%B3n","Lenguaje_natural","Felisa_Verdejo","LLM_(modelo_grande_de_lenguaje)","OCLC","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings"]}
{"url":"Generaci%C3%B3n_de_lenguajes_naturales","titulo":"Generacion de lenguajes naturales","contenido":"Es el proceso de la construccion de un texto en lenguaje natural para la comunicacion con fines especificos. Texto se refiere aqui a un termino general y repetitivo aplicable a expresiones, o partes de ellas, de cualquier tama\u00f1o, tanto habladas como escritas. En el ser humano, el que sea hablado o escrito tiene consecuencias en el nivel deliberativo y de edicion que ha tenido lugar; si el lenguaje es hablado puede faltar revision ya que la mayoria de los programas actuales pueden hablar, si bien casi todos solo presentan palabras en una pantalla. La decision de revisar o usar la palabra escrita o hablada no es una opcion para la generacion del programa en la actualidad; pero se debe abordar el tema en el dise\u00f1o de un programa en particular.  El principal enfasis de la generacion de lenguajes naturales no es solo el facilitar el uso del ordenador sino tambien el desarrollar una teoria computacional de la capacidad del lenguaje humano. En este sentido constituye una herramienta para extender, aclarar y verificar teorias que se han formulado en linguistica, psicologia y sociologia acerca de la comunicacion entre humanos.  Un generador de lenguaje natural tipicamente tiene acceso a un gran conjunto de conocimiento del cual ha de seleccionar informacion para presentar a los usuarios en varias formas. El generar texto es, pues, un problema de toma de decisiones con multiples restricciones: de conocimiento proposicional, de herramientas linguisticas disponibles, de los objetivos de la comunicacion del usuario a quien se dirige el texto, y de la situacion y del discurso pasado. Se trata de identificar los factores involucrados en este proceso y de determinar la mejor forma de representar estos factores y sus dependencias.  Para generar un texto, un sistema debe escoger cierta informacion de la base de conocimiento, decidir como organizarla, y determinar como producir el texto en lenguaje natural, lo cual incluye el decidir acerca de la entrada del lexico y de las estructuras sintacticas.  Esto hace que el proceso de generacion se divida en dos partes: una componente de planificacion del texto y una componente de generacion propiamente dicha. Esta a su vez se divide en dos tareas: la de escoger los objetos del lexico y la de efectuar selecciones gramaticales. En todo esto se trata de escoger apropiadamente para expresar lo mejor posible el significado deseado.  Cuando se hace de arriba abajo, se generan textos para sistemas complejos, en sistemas expertos para dialogar con una gran variedad de usuarios. El proceso de planificacion es algo restrictivo ya que no puede alcanzar planificacion oportunista. En algunos casos se incorporan metodos de abajo a arriba, para aprovecharse de planificacion oportunista. ","snippet":"Es el proceso de la construccion de un texto en lenguaje natural para la comunicacion con fines especificos. Texto se refiere aqui a un termino general y repetitivo aplicable a expresiones, o partes d","enlaces_salientes":["Generaci%C3%B3n_de_lenguajes_naturales","Generaci%C3%B3n_de_lenguajes_naturales","Generaci%C3%B3n_de_lenguajes_naturales","Texto","Procesamiento_de_lenguajes_naturales","Control_de_autoridades","Library_of_Congress_Control_Number"]}
{"url":"Idioma","titulo":"Idioma","contenido":"Un idioma (del latin: idioma, y este del griego: \u03b4\u03c9\u03bc\u03b1 'peculiaridad, idiosincrasia, propiedad') o lengua (del latin: lingua) es un sistema de comunicacion verbal (lengua oral y grafica) o gestual (lengua signada), propia de una sociedad humana.  Cada idioma se subdivide en dialectos (por definicion, cada una de las formas en que se habla un idioma o lengua en una region especifica), pero actualmente se duda que exista un criterio valido para hacer tal division (de idiomas o lenguas en dialectos) de una manera objetiva y segura. La determinacion de si dos variedades linguisticas son parte o no del mismo idioma es mas una cuestion sociopolitica que linguistica.  El numero de idiomas generalmente aceptado esta en torno a 6000 o 6500. El Etnologo: Lenguas del Mundo, en su resultado del a\u00f1o 2009, indica que hay alrededor de 6909 lenguas en el mundo. Sin embargo, el numero de idiomas actualmente hablados es dificil de precisar debido a los siguientes factores:  Sin embargo, la linguistica historica ha podido establecer que todas esas lenguas derivan de un numero mucho mas reducido de familias de lenguas. Ese hecho sirve habitualmente de base para la clasificacion filogenetica de las lenguas del mundo. Ademas de ese tipo de clasificacion tambien se pueden hacer diversos tipos de clasificacion tipologica, referidas al tipo de estructuras presentes en una lengua y no a su origen historico o su parentesco con otras lenguas. ","snippet":"Un idioma (del latin: idioma, y este del griego: \u03b4\u03c9\u03bc\u03b1 'peculiaridad, idiosincrasia, propiedad') o lengua (del latin: lingua) es un sistema de comunicacion verbal (lengua oral y grafica) o gestual (len","enlaces_salientes":["Idioma","Idioma","Idioma","Tizi_Uzu","Idioma_%C3%A1rabe","Idioma_franc%C3%A9s","Idioma_cabilio","Lat%C3%ADn","Griego_antiguo","Sistema","Comunicaci%C3%B3n","Lengua_de_se%C3%B1as","Sociedad","Humano","Dialecto","Variedad_ling%C3%BC%C3%ADstica","Ethnologue","Inteligibilidad_mutua","Nueva_Guinea","Selva_amaz%C3%B3nica","T%C3%ADbet","Nepal","Birmania","Lenguas_de_las_islas_Andam%C3%A1n","Kusunda","Idioma_%C3%B3pata","Familias_de_lenguas","Tipolog%C3%ADa_ling%C3%BC%C3%ADstica","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Familia_de_lenguas","Filogenia","Tipolog%C3%ADa_ling%C3%BC%C3%ADstica","Lenguas","Gram%C3%A1tica","Habla","Jerga","Escuela_Oficial_de_Idiomas","Traducci%C3%B3n","Lenguaje","Lengua_materna","Lengua_natural","Proyecto_Rosetta","ISO_639","Comunidad_imaginada","Idiomas_en_Internet","Lenguas_mutuamente_inteligibles","Control_de_autoridades","Wikcionario","Wikcionario"]}
{"url":"Morris_Swadesh","titulo":"Morris Swadesh","contenido":"Morris Swadesh (Holyoke, Massachusetts, 22 de enero de 1909-Ciudad de Mexico, 20 de julio de 1967) fue un linguista estadounidense-mexicano. Tambien fue conocido en Mexico como Mauricio Swadesh.  Junto con Claude Levi-Strauss, Roman Jakobson y Andre Martinet, fue uno de los fundadores de la Asociacion Internacional de Linguistica.\u200b  Nacio en Estados Unidos de padres judios venidos de Besarabia (un area al norte del mar Negro disputada por muchos siglos, por lo cual sus padres eran multilingues). Fue posteriormente naturalizado mexicano. Estuvo casado en primeras nupcias con la linguista Mary Rosamund Haas, posteriormente con la tambien linguista Frances Leon, y finalmente con la linguista mexicana Evangelina Arana Osnaya.  Fue discipulo de Edward Sapir, con quien trabajo en sus inicios. Se graduo en linguistica en 1930, en la Universidad de Chicago y en 1933 se doctoro en la Universidad de Yale. Su trabajo inicial se centro en la lengua de los nootka y mas tarde en el chitimacha, de la cual descubrio que era una lengua aislada. En 1937 marcha a Mexico, donde fue director del Consejo de Lenguas Indigenas, y director de linguistica en el Departamento de Asuntos Indigenas y dirigio el Proyecto Tarasco en Michoacan en el a\u00f1o de 1939. Tambien trabajo en la sierra Tarahumara y el estado de Hidalgo con otomi. En 1941 vuelve a los Estados Unidos para ayudar al ejercito preparando textos populares para ense\u00f1ar el ruso y el chino a las tropas, y en la elaboracion de diccionarios de chino, birmano, ruso y espa\u00f1ol.  Despues de la guerra fue profesor adjunto en el City College of New York (CCNY) pero en 1948 se le retira el pasaporte, acusado de actividades \"izquierdistas\". En mayo de 1949 fue despedido del CCNY acusado de comunista, como un buen numero de antropologos fue victima del \"terror anticomunista\" durante el McCartthismo, aunque continuo trabajando en los Estados Unidos con financiacion limitada de la American Philosophical Society hasta 1954.  En 1954 vuelve a Mexico (invitado nuevamente por el gobierno mexicano) para ejercer como profesor de antropologia en el Instituto Politecnico Nacional creando el programa del area de linguistica. En 1956 Swadesh se divorcio y se fue definitivamente a Mexico, donde obtuvo una plaza como investigador en la Universidad Nacional Autonoma de Mexico (UNAM) y fue profesor de linguistica en la Escuela Nacional de Antropologia e Historia\u200b en Ciudad de Mexico donde vivio hasta su muerte.  Gran parte de su trabajo aun es rechazado en los Estados Unidos debido a la politica de los tiempos de la Guerra Fria y la persecuacion politica que sufrio Swadesh. En Europa habia un extraordinario ejemplo de cambio de lenguas en la transicion del latin a los idiomas romances (italiano, espa\u00f1ol, portuques, frances, y rumano) sobre un periodo de 2000 a\u00f1os. Como los idiomas eran escritos seria facil seguir los cambios. Swadesh vio esto como un principio elemental que se podria aplicar a todos los idiomas.  Su contribucion mas conocida es la denominada glotocronologia, tecnica utilizada para definir la genealogia de las lenguas. Una de sus principales herramientas es la llamada lista Swadesh de 100 \"palabras basicas\" que se utiliza, no sin controversia, para determinar el grado de separacion temporal entre dos o mas lenguas. Desarrollo el mapa linguistico mas completo de los idiomas indigenas de las Americas.  (Abreviaturas: AA American Anthropologist; AL Anthropological Linguistics; Am. Sp. American Speech; BBAA Boletin Bibliografico de Antropologia Americana; CA Current Anthropology; ENAH Escuela Nacional de Antropologia e Historia; IJAL International Journal of American Linguistics; INAH Instituto Nacional de Antropologia e Historia; INI Instituto Nacional Indigenista; LG Language; RMEA Revista Mexicana de Estudios Antropologicos; SWJA Southwestern Journal of Anthropology; UNAM Universidad Nacional Autonoma de Mexico).   El lector interesado encontrara dos estudios biograficos y sobre la obra de Mauricio Swadesh, en \u201cMauricio Swadesh (1909-1967)\u201d, por Dell Hymes, Anales de Antropologia UNAM 5:213-226, y en el Prologo escrito por Daniel Cazes, Juan Jose Rendon y Madalena Sancho, para la obra Elementos del Tarasco Antiguo, de Mauricio Swadesh, Instituto de Investigaciones Historicas de la UNAM, en prensa.  Nueva publicacion--Diachronica: International Journal for Historical Linguistics. vol. XXVII, numero 2, verano de 2010, John Benjamins Publishing Co. Amsterdam/Philadelphia. special issue: conmemorando el centenario del nacimiento de Mauricio Swadesh ","snippet":"Morris Swadesh (Holyoke, Massachusetts, 22 de enero de 1909-Ciudad de Mexico, 20 de julio de 1967) fue un linguista estadounidense-mexicano. Tambien fue conocido en Mexico como Mauricio Swadesh.  Junt","enlaces_salientes":["Morris_Swadesh","Morris_Swadesh","Morris_Swadesh","Holyoke_(Massachusetts)","Estados_Unidos","Ciudad_de_M%C3%A9xico","M%C3%A9xico","Mary_Rosamund_Haas","Universidad_Yale","Universidad_de_Chicago","Ling%C3%BCista","Profesor_de_educaci%C3%B3n_superior","Lenguas_ind%C3%ADgenas_de_Am%C3%A9rica","Office_of_Strategic_Services","Instituto_Polit%C3%A9cnico_Nacional","Universidad_de_Wisconsin-Madison","Beca_Guggenheim","Holyoke_(Massachusetts)","Massachusetts","Ciudad_de_M%C3%A9xico","Ling%C3%BCista","Claude_L%C3%A9vi-Strauss","Roman_Jakobson","Andr%C3%A9_Martinet","Asociaci%C3%B3n_Internacional_de_Ling%C3%BC%C3%ADstica","Estados_Unidos","Besarabia","Mary_Rosamund_Haas","Edward_Sapir","1930","Universidad_de_Chicago","1933","Universidad_de_Yale","Nuu-chah-nulth","Idioma_chitimacha","1937","M%C3%A9xico","Departamento_Aut%C3%B3nomo_de_Asuntos_Ind%C3%ADgenas","Proyecto_Tarasco","Sierra_Tarahumara","Idioma_otom%C3%AD","1941","Estados_Unidos","Idioma_chino","Idioma_birmano","Idioma_ruso","Idioma_espa%C3%B1ol","City_College_of_New_York","1948","Pasaporte","Comunista","Antrop%C3%B3logo","Macarthismo","American_Philosophical_Society","1954","Antropolog%C3%ADa","Ling%C3%BC%C3%ADstica","Universidad_Nacional_Aut%C3%B3noma_de_M%C3%A9xico","Escuela_Nacional_de_Antropolog%C3%ADa_e_Historia","Ciudad_de_M%C3%A9xico","Guerra_Fr%C3%ADa","Glotocronolog%C3%ADa","Lista_Swadesh","Harry_Hoijer","Harry_Hoijer","Columbia_University_Press","Actas_(reuni%C3%B3n_acad%C3%A9mica)","University_of_California_Press","Lenguas_de_M%C3%A9xico","Lista_Swadesh","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Biblioteca_de_Catalu%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","BIBSYS","Istituto_Centrale_per_il_Catalogo_Unico","Open_Library","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lenguaje_de_alto_nivel","titulo":"Lenguaje de alto nivel","contenido":"Un lenguaje de programacion de alto nivel se caracteriza por expresar los algoritmos de una manera adecuada a la capacidad cognitiva humana, en lugar de la capacidad con que las maquinas lo ejecutan. Estos lenguajes permiten una maxima flexibilidad al programador a la hora de abstraerse o de ser literal. Permiten un camino bidireccional entre el lenguaje maquina y una expresion casi oral entre la escritura del programa y su posterior compilacion. Por lo general suelen estar orientados a objetos, a eventos o a funciones, pudiendo estos combinarse. Asimismo, pueden ser compilados o interpretados. Algunos ejemplos son: Java, PHP, Python, Javascript, C#.  En los primeros lenguajes, la limitacion era que se orientaban a un area especifica y sus instrucciones requerian de una sintaxis predefinida. Se clasifican como lenguajes procedimentales o lenguajes de bajo nivel. Otra limitacion de estos es que se requiere de ciertos conocimientos de programacion para realizar las secuencias de instrucciones logicas. Los lenguajes de alto nivel se crearon para que el usuario comun pudiese solucionar un problema de procesamiento de datos de una manera mas facil y rapida.  Por esta razon, a finales de los a\u00f1os 1950 surgio un nuevo tipo de lenguajes de programacion que evitaba estos inconvenientes, a costa de ceder un poco en las ventajas. Estos lenguajes se llaman de tercera generacion o de nivel alto, en contraposicion a los de bajo nivel o de nivel proximo a la maquina.  Lenguaje de alto nivel se refiere al nivel mas alto de abstraccion de lenguaje de maquina. En lugar de tratar con registros, direcciones de memoria y las pilas de llamadas, lenguajes de alto nivel se refieren a las variables, matrices, objetos, aritmetica compleja o expresiones booleanas, subrutinas y funciones, bucles, hilos, cierres y otros conceptos de informatica abstracta, con un enfoque en la facilidad de uso sobre la eficiencia optima del programa.    (Debido a que permite programar en nivel bajo) ","snippet":"Un lenguaje de programacion de alto nivel se caracteriza por expresar los algoritmos de una manera adecuada a la capacidad cognitiva humana, en lugar de la capacidad con que las maquinas lo ejecutan. ","enlaces_salientes":["Lenguaje_de_alto_nivel","Lenguaje_de_alto_nivel","Lenguaje_de_alto_nivel","Lenguaje_de_programaci%C3%B3n","Algoritmo","Cognici%C3%B3n","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_dirigida_por_eventos","Programaci%C3%B3n_funcional","Lenguaje_de_programaci%C3%B3n_compilado","Int%C3%A9rprete_(inform%C3%A1tica)","Java_(lenguaje_de_programaci%C3%B3n)","PHP","Python","JavaScript","C_Sharp","Lenguaje_de_bajo_nivel","A%C3%B1os_1950","Paradigma_de_programaci%C3%B3n","Python","VB.NET","Erlang","Ada_(lenguaje_de_programaci%C3%B3n)","ALGOL","BASIC","C_Sharp","FORTRAN","C%2B%2B","C_(lenguaje_de_programaci%C3%B3n)","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Abstracci%C3%B3n_(inform%C3%A1tica)","Compilador","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Programa_inform%C3%A1tico","titulo":"Programa informatico","contenido":"Un programa informatico o programa de computadora es una secuencia de instrucciones u ordenes basadas en un lenguaje de programacion que una computadora interpreta para resolver un problema o una funcion especifica.\u200b\u200b Este dispositivo requiere programas para funcionar, por lo general, ejecutando las instrucciones del programa en un procesador central.\u200b  El programa tiene un formato ejecutable que la computadora puede utilizar directamente para ejecutar las instrucciones. El mismo programa en su formato de codigo fuente legible para humanos, del cual se derivan los programas ejecutables (por ejemplo, compilados), le permite a un programador estudiar y desarrollar sus algoritmos. Una coleccion de programas de computadora y datos relacionados se conoce como software.  Generalmente, el codigo fuente lo escriben profesionales conocidos como programadores de computadora.\u200b Este codigo se escribe en un lenguaje de programacion que sigue uno de los siguientes dos paradigmas: imperativo o declarativo, y que posteriormente puede ser convertido en un archivo ejecutable (usualmente llamado un programa ejecutable o un binario) por un compilador y mas tarde ejecutado por una unidad central de procesamiento. Por otra parte, los programas de computadora se pueden ejecutar con la ayuda de un interprete, o pueden ser empotrados directamente en hardware.  De acuerdo a sus funciones, los programas informaticos se clasifican en software de sistema y software de aplicacion. En las computadoras de 2015, al hecho de ejecutar varios programas de forma simultanea y eficiente, se lo conoce como multitarea.  La programacion de computadoras es el proceso iterativo de escribir o editar codigo fuente. Dicha edicion implica probar, analizar y perfeccionar, y, a veces, coordinar con otros programadores, en el caso de un programa desarrollado en conjunto. Una persona que practica esta tecnica se le conoce como programador de computadoras, desarrollador de software, o codificador. El proceso, a veces a largo plazo, de programacion de computadoras normalmente se lo conoce como desarrollo de software. El termino ingenieria de software se esta convirtiendo en muy popular, ya que esta actividad es vista como una disciplina de ingenieria.  Los programas de ordenador se pueden clasificar segun el paradigma del lenguaje de programacion utilizado para producirlos. Dos de los principales paradigmas son imperativos y declarativos.  Los programas escritos con un lenguaje imperativo especifican un algoritmo utilizando declaraciones, expresiones e informes.\u200b Una declaracion asocia un nombre de variable a un tipo de datos. Por ejemplo:  var x: integer; . Una expresion produce un valor. Por ejemplo:  2 + 2  produce 4. Por ultimo, una declaracion puede asignar una expresion a una variable o usar el valor de una variable para alterar las estructuras de control del programa. Por ejemplo: x\u00a0:= 2 + 2; if x = 4 then hacer_algo(); Una critica de los lenguajes imperativos es el efecto secundario de una sentencia de asignacion en una clase de variables llamadas variables no locales.\u200b  Los programas escritos en un lenguaje declarativo especifican las propiedades que tienen o que deben cumplirse para la salida. No especifican detalles expresados en terminos de flujo de control de la maquina de ejecucion pero si de las relaciones matematicas entre los objetos declarados y sus propiedades. Los lenguajes funcionales y logicos son dos amplias categorias de lenguajes declarativos. El principio detras de los lenguajes funcionales (como Haskell) es el de no permitir efectos secundarios, lo que hace que sea mas facil para razonar sobre los programas como si se tratasen de funciones matematicas.\u200b El principio detras de los lenguajes logicos (como Prolog) es definir el problema a ser resuelto - la meta - y dejar la solucion detallada al propio sistema Prolog.\u200b El objetivo se define proporcionando la lista de sub-objetivos. Luego, cada subobjetivo se define mas arriba, proporcionando la lista de sus sub-objetivos, etc. Si la ruta de sub-objetivos no encuentra una solucion, entonces ese subobjetivo se retrocede y otra via se intenta sistematicamente.  La forma en que se crea el programa puede ser textual o visual. En un programa de lenguaje visual, los elementos en vez de ser textualmente especificados son manipulados graficamente.  Un programa de computadora bajo la forma de lenguaje de programacion de computadoras legible por un humano, se lo llama codigo fuente. Dicho codigo fuente se puede convertir en una imagen ejecutable por un compilador o ejecutarse inmediatamente con la ayuda de un interprete.  Cualquiera de los programas compilados o interpretados pueden ser ejecutados en un proceso por lotes sin intervencion humana, pero los programas interpretados le permiten al usuario escribir comandos en una sesion interactiva. En este caso, los programas son los comandos separados, cuya ejecucion se produce secuencialmente, y por lo tanto simultaneamente. Cuando se utiliza un lenguaje para dar ordenes a una aplicacion de software (como un shell de Unix u otra interfaz de linea de comandos), se le llama un lenguaje de scripts.  Los compiladores se utilizan para traducir el codigo fuente de un lenguaje de programacion, ya sea en codigo objeto o codigo maquina.\u200b El codigo objeto de objeto necesita procesamiento adicional para convertirse en codigo maquina, y el codigo maquina es el codigo nativo de la unidad central de procesamiento, listo para su ejecucion. Los programas de computadora compilados se conocen comunmente como ejecutables, imagenes binarias, o simplemente como binarios \u2014una referencia al formato de archivo binario utilizado para almacenar el codigo ejecutable\u2014.  Los programas de computadora \u2014interpretados en un lote o una sesion interactiva\u2014 o bien se descodifican y luego ejecutados inmediatamente o se decodifican en alguna representacion intermedia eficiente para la ejecucion futura. BASIC, Perl y Python son ejemplos de programas de computadora ejecutados inmediatamente. Por otra parte, los programas de computadora de Java se compilan antes de tiempo y se almacena como un codigo independiente de la maquina llamado bytecode. Entonces, dicho bytecode es ejecutado a peticion de un interprete llamado maquina virtual.  La principal desventaja de los interpretes es que los programas de computadora corren mas lento que cuando son compilados. La interpretacion de codigo resulta mas lenta que la ejecucion de la version compilada porque el interprete debe decodificar cada declaracion cada vez que se carga y luego realizar la accion deseada. Sin embargo, el desarrollo de software puede ser mas rapido usando un interprete porque la prueba es inmediata cuando se omite el paso de la compilacion. Otra desventaja de los interpretes es que debe estar presente al menos uno en la computadora durante la ejecucion del programa de computadora. Por el contrario, los programas de computadora compilados no necesitan compilador presente durante la ejecucion.  No se requieren propiedades de un lenguaje de programacion si se esta compilado exclusivamente o interpretandose exclusivamente. Por lo general, la clasificacion refleja el metodo mas popular de ejecucion del lenguaje. Por ejemplo, BASIC se considera un lenguaje interpretado y C un lenguaje compilado, a pesar de la existencia de compiladores de BASIC e interpretes de C. Algunos sistemas utilizan compilacion en tiempo de ejecucion (JIT) mediante la cual las secciones de la fuente se compilan 'sobre la marcha' y se almacenan para ejecuciones posteriores.  Un programa informatico en ejecucion, normalmente es tratado como algo diferente de los datos con los cuales opera. Sin embargo, en algunos casos esta distincion es ambigua, especialmente cuando un programa se modifica a si mismo. El programa modificado es ejecutado secuencialmente como parte del mismo programa. En el caso de programas escritos en codigo maquina, lenguaje ensamblador, Lisp, d, COlOL, PL/9 y Prolog y JavaScript (la funcion eval), entre otros, es posible tener codigo que se automodifica.  Tipicamente, los programas se almacenan en una memoria no volatil (por ejemplo un disco), para que luego el usuario de la computadora, directa o indirectamente, solicite su ejecucion. Al momento de dicha solicitud, el programa es cargado en la memoria de acceso aleatorio o RAM del equipo, bajo el control del software llamado sistema operativo, el cual puede acceder directamente al procesador. El procesador ejecuta (corre) el programa, instruccion por instruccion hasta que termina. A un programa en ejecucion se le suele llamar tambien proceso. Un programa puede terminar su ejecucion en forma normal o por causa de un error, dicho error puede ser de software o de hardware.  Algunos programas estan empotrados en el hardware. Una computadora con arquitectura de programas almacenados requiere un programa inicial almacenado en su ROM para arrancar. El proceso de arranque es para identificar e inicializar todos los aspectos del sistema, desde los registros del procesador, controladores de dispositivos hasta el contenido de la memoria RAM.\u200b Seguido del proceso de inicializacion, este programa inicial carga al sistema operativo e inicializa al contador de programa para empezar las operaciones normales. Independiente de la computadora, un dispositivo de hardware podria tener firmware empotrado para el control de sus operaciones. El firmware se utiliza cuando se espera que el programa cambie en raras ocasiones o nunca, o cuando el programa no debe perderse cuando haya ausencia de energia.\u200b  Historicamente, los programas eran cargados al procesador central de forma manual mediante interruptores. Una instruccion se representaba por una configuracion de estados de interruptores de abierto o cerrados. Despues de establecer la configuracion, se ejecutaba un boton de ejecucion. Este proceso era repetitivo. Asimismo, los programas se cargaban manualmente mediante una cinta de papel o tarjetas perforadas. Despues de que se cargaba el programa, se establecia la direccion de inicio mediante interruptores y se presionaba el boton de ejecucion.\u200b  La programacion automatica es un estilo de programacion que crea codigo fuente mediante clases genericas, prototipos, plantillas, aspectos, y generadores de codigo para aumentar la productividad del programador. El codigo fuente se genera con herramientas de programacion tal como un procesador de plantilla o un IDE. La forma mas simple de un generador de codigo fuente es un procesador macro, tal como el preprocesador de C, que reemplaza patrones de codigo fuente de acuerdo a reglas relativamente simples.  Un motor de software da de salida codigo fuente o lenguaje de marcado que simultaneamente se vuelve la entrada de otro proceso informatico. Podemos pensar como analogia un proceso manejando a otro siendo el codigo maquina quemado como combustible. Los servidores de aplicaciones son motores de software que entregan aplicaciones a computadoras cliente. Por ejemplo, un software para wikis es un servidor de aplicaciones que permite a los usuarios desarrollar contenido dinamico ensamblado a partir de articulos. Las wikis generan HTML, CSS, Java, y Javascript los cuales son interpretados por un navegador web.  Muchos programas pueden ejecutarse simultaneamente en la misma computadora, hecho al cual se lo conoce como multitarea, pudiendose lograr mediante mecanismos de software o de hardware. Los sistemas operativos modernos pueden ejecutar varios programas a traves del planificador de procesos \u2014 un mecanismo de software para conmutar con frecuencia la cantidad de procesos del procesador de modo que los usuarios puedan interactuar con cada programa mientras estos estan corriendo.\u200b Tambien se puede lograr la multitarea por medio del hardware; las computadoras modernas que usan varios procesadores o procesadores con varios nucleos pueden correr muchos programas a la vez.\u200b  Los programas se pueden categorizar aplicando criterios funcionales. Estas categorias funcionales son software de sistema y software de aplicacion. El software de sistema incluye al sistema operativo el cual acopla el hardware con el software de aplicacion.\u200b El proposito del sistema operativo es proveer un ambiente en el cual el software de aplicacion se ejecuta de una manera conveniente y eficiente.\u200b Ademas del sistema operativo, el software de sistema incluye programas utilitarios que ayudan a manejar y configurar la computadora. Si un programa no es software de sistema entonces es software de aplicacion. El middleware tambien es un software de aplicacion que acopla el software de sistema con la interfaz de usuario. Tambien son software de aplicacion los programas utilitarios que ayudan a los usuarios a resolver problemas de aplicaciones, como por ejemplo la necesidad de ordenamiento. ","snippet":"Un programa informatico o programa de computadora es una secuencia de instrucciones u ordenes basadas en un lenguaje de programacion que una computadora interpreta para resolver un problema o una func","enlaces_salientes":["Programa_inform%C3%A1tico","Programa_inform%C3%A1tico","Programa_inform%C3%A1tico","Software","Conjunto_de_instrucciones","Lenguaje_de_programaci%C3%B3n","Unidad_central_de_procesamiento","Ejecutable","Compilador","Algoritmo","Dato","Software","Programador","Paradigma","Archivo_ejecutable","Compilador","Unidad_central_de_procesamiento","Firmware","Hardware","Software_de_sistema","Aplicaci%C3%B3n_inform%C3%A1tica","Multitarea","Programaci%C3%B3n","Hola_mundo","C_(lenguaje_de_programaci%C3%B3n)","Hola_mundo","Java_(lenguaje_de_programaci%C3%B3n)","Hola_mundo","C_Sharp","Programaci%C3%B3n","C%C3%B3digo_fuente","Programador","Desarrollo_de_software","Ingenier%C3%ADa_de_software","Ingenier%C3%ADa","Paradigma_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n","Algoritmo","Estructuras_de_control","Efecto_secundario_(inform%C3%A1tica)","Lenguajes_funcionales","Haskell","Efecto_secundario_(inform%C3%A1tica)","Prolog","Vuelta_atr%C3%A1s","Programaci%C3%B3n_visual","Legibilidad_humana","C%C3%B3digo_fuente","Compilador","Int%C3%A9rprete_(inform%C3%A1tica)","Proceso_por_lotes","Sesi%C3%B3n_(inform%C3%A1tica)","Shell_de_Unix","Interfaz_de_l%C3%ADnea_de_comandos","Scripts","C%C3%B3digo_objeto","C%C3%B3digo_m%C3%A1quina","Microc%C3%B3digo","Archivo_binario","Formato_de_archivo","BASIC","Perl","Python","Java_(lenguaje_de_programaci%C3%B3n)","Bytecode","M%C3%A1quina_virtual","Analizador_sint%C3%A1ctico","Compilaci%C3%B3n_en_tiempo_de_ejecuci%C3%B3n","Dato","C%C3%B3digo_m%C3%A1quina","Lenguaje_ensamblador","Lisp","D_(lenguaje_de_programaci%C3%B3n)","Prolog","JavaScript","Memoria_no_vol%C3%A1til","Computadora","Memoria_de_acceso_aleatorio","Software","Sistema_operativo","Microprocesador","Proceso_(inform%C3%A1tica)","Microcontrolador","Memoria_USB","Firmware","Hardware","Computadora","Arquitectura_de_von_Neumann","Memoria_de_solo_lectura","Arranque_(inform%C3%A1tica)","Registro_(hardware)","Controlador_de_dispositivo","Memoria_RAM","Sistema_operativo","Contador_de_programa","Perif%C3%A9rico_(inform%C3%A1tica)","Firmware","Data_General_Nova","Cinta_de_papel","Tarjeta_perforada","Programaci%C3%B3n_autom%C3%A1tica","Programaci%C3%B3n","C%C3%B3digo_fuente","Clase_(inform%C3%A1tica)","Programaci%C3%B3n_gen%C3%A9rica","Programaci%C3%B3n_basada_en_prototipos","Generaci%C3%B3n_de_c%C3%B3digo","Programador","Ambiente_de_desarrollo_integrado","Macro","Preprocesador_de_C","Lenguaje_de_marcado","Proceso_(inform%C3%A1tica)","Servidor_de_aplicaciones","Cliente_(inform%C3%A1tica)","Software_para_wikis","Contenido_din%C3%A1mico","Art%C3%ADculo_(publicaci%C3%B3n)","HTML","Hojas_de_estilo_en_cascada","Java_(lenguaje_de_programaci%C3%B3n)","Javascript","Int%C3%A9rprete_(inform%C3%A1tica)","Navegador_web","Proceso_(inform%C3%A1tica)","Multiprocesamiento","Multitarea","Planificaci%C3%B3n","Cambio_de_contexto","Tiempo_compartido_(inform%C3%A1tica)","Software_de_sistema","Software_de_aplicaci%C3%B3n","Sistema_operativo","Hardware","Programa_utilitario","Middleware","Interfaz_de_usuario","Algoritmo","Aplicaci%C3%B3n_inform%C3%A1tica","Virus_inform%C3%A1tico","Estructura_de_datos","Inteligencia_artificial","Sistema_multi-agente","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","1997","ISBN","1997","ISBN","1997","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","National_Archives_and_Records_Administration","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Subrutina","titulo":"Subrutina","contenido":"En informatica, una subrutina o subprograma (tambien llamada procedimiento, funcion, rutina o metodo), como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea especifica. Algunos lenguajes de programacion, como Visual Basic .NET o Fortran, utilizan el nombre funcion para referirse a subrutinas que devuelven un valor.  Se le llama subrutina a un segmento de codigo separado del bloque principal, el cual puede ser invocado en cualquier momento desde esta u otra subrutina.  Una subrutina, al ser llamada dentro de un programa, hace que el codigo principal se detenga y se dirija a ejecutar el codigo de la subrutina.  Las declaraciones de subrutinas generalmente son especificadas por:  La siguiente funcion en C es la analogia al calculo del promedio matematico. La funcion \"Promedio\" devuelve un valor decimal correspondiente a la semisuma de 2 valores enteros de entrada (A y B):  Asi una llamada \"Promedio(3, 5)\" devolvera el valor de tipo real (float) 4,0.  Tambien se pueden escribir funciones sin parametros, por ejemplo (tambien en C):  Esta funcion, cuando sea ejecutada, imprimira en la salida estandar el texto \"\u00a1Hola, Mundo!\" ","snippet":"En informatica, una subrutina o subprograma (tambien llamada procedimiento, funcion, rutina o metodo), como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el c","enlaces_salientes":["Subrutina","Subrutina","Subrutina","Inform%C3%A1tica","Subalgoritmo","Algoritmo","Lenguajes_de_programaci%C3%B3n","Visual_Basic_.NET","Fortran","Programa_inform%C3%A1tico","%C3%81mbito_(programaci%C3%B3n)","Sobrecarga_(inform%C3%A1tica)","Polimorfismo_(inform%C3%A1tica)","Programaci%C3%B3n_orientada_a_objetos","Tipo_de_dato","Argumento_(inform%C3%A1tica)","Lenguaje_de_programaci%C3%B3n_C","Float","Lenguaje_de_programaci%C3%B3n_C","Salida_est%C3%A1ndar","Programaci%C3%B3n_estructurada","Programaci%C3%B3n_modular","Encapsulamiento_(programaci%C3%B3n_orientada_a_objetos)","Abstracci%C3%B3n_(programaci%C3%B3n_orientada_a_objetos)","Recursi%C3%B3n","Algoritmo_recursivo","Funci%C3%B3n_definida_por_el_usuario","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Compilador","titulo":"Compilador","contenido":"En informatica, un compilador es un programa que traduce codigo escrito en un lenguaje de programacion (llamado fuente) a otro lenguaje (conocido como objeto).\u200b En este tipo de traductor el lenguaje fuente es generalmente un lenguaje de alto nivel y el objeto un lenguaje de bajo nivel, como assembly o codigo maquina.\u200b Este proceso de traduccion se conoce como compilacion.\u200b  La construccion de un compilador involucra la division del proceso en una serie de fases que variara con su complejidad. Generalmente estas fases se agrupan en dos tareas: el analisis del programa fuente y la sintesis del programa objeto.\u200b:\u200a3  Alternativamente, las fases descritas para las tareas de analisis y sintesis se pueden agrupar en:  Esta division permite que el mismo generador se utilice para crear el codigo maquina de varios lenguajes de programacion distintos y que el mismo analizador que sirve para examinar el codigo fuente de un lenguaje de programacion concreto sirva para producir codigo maquina en varias plataformas.  En 1938, Konrad Zuse desarrollo la primera computadora digital electromecanica, denominada Z1 en Alemania, y posteriormente, en 1946, se desarrollo la primera computadora totalmente electronica ENIAC, sucedida principalmente por la EDVAC (1951), primera computadora electronica digital. En un principio, estas maquinas ejecutaban instrucciones consistentes en codigos numericos que se\u00f1alaban a los circuitos de la maquina los estados correspondientes a cada operacion, lo que se denomino lenguaje maquina.  Pronto los primeros usuarios de estos ordenadores descubrieron la ventaja de escribir sus programas mediante claves mas faciles de recordar que esos codigos; al final, todas esas claves juntas se traducian manualmente a lenguaje maquina. Estas claves constituyen los llamados lenguajes ensambladores.  Pese a todo, el lenguaje ensamblador seguia siendo el de una maquina, pero mas facil de manejar (las instrucciones de maquina se reemplazan por mnemonicos. Los trabajos de investigacion se orientaron hacia la creacion de un lenguaje que expresara las distintas acciones a realizar de una manera lo mas sencilla posible para una persona. El primer compilador fue escrito por Grace Hopper, en 1952 para el lenguaje de programacion A-0. En 1950 John Backus dirigio una investigacion en IBM sobre un lenguaje algebraico. En 1954 se empezo a desarrollar un lenguaje que permitia escribir formulas matematicas de manera traducible por un ordenador; le llamaron FORTRAN (FORmulae TRANslator). Fue el primer lenguaje de alto nivel y se introdujo en 1957 para el uso de la computadora IBM modelo 704.  Surgio asi por primera vez el concepto de un traductor como un programa que traducia un lenguaje a otro lenguaje. En el caso particular de que el lenguaje a traducir es un lenguaje de alto nivel y el lenguaje traducido de bajo nivel, se emplea el termino compilador.  El trabajo de realizar un compilador fue complicado de realizar. El primer compilador de FORTRAN tardo 18 a\u00f1os-persona en realizarse y era muy sencillo. Este desarrollo de FORTRAN estaba muy influenciado por la maquina objeto en la que iba a ser implementado. Como un ejemplo de ello tenemos el hecho de que los espacios en blanco fuesen ignorados, debido a que el periferico que se utilizaba como entrada de programas (una lectora de tarjetas perforadas) no contaba correctamente los espacios en blanco.  El primer compilador autocontenido, es decir, capaz de compilar su propio codigo fuente fue el creado para Lisp por Hart y Levin en el MIT en 1962. Desde 1970 se ha convertido en una practica comun escribir el compilador en el mismo lenguaje que este compila, aunque PASCAL y C han sido alternativas muy usadas.  Crear un compilador autocontenido genera un problema llamado bootstrapping, es decir el primer compilador creado para un lenguaje tiene que o bien ser compilado por un compilador escrito en otro lenguaje o bien compilado al ejecutar el compilador en un interprete.  Esta taxonomia de los tipos de compiladores no es excluyente, por lo que puede haber compiladores que se adscriban a varias categorias:  En las primeras epocas de la informatica, los compiladores eran considerados un software de los mas complejos existentes.[cita\u00a0requerida]  Los primeros compiladores se realizaron programandolos directamente en lenguaje maquina o en ensamblador. Una vez que se dispone de un compilador, se pueden escribir nuevas versiones del compilador (u otros compiladores distintos) en el lenguaje que compila ese compilador.  Existen herramientas que facilitan la tarea de escribir compiladores o interpretes informaticos. Estas herramientas permiten generar el esqueleto del analizador sintactico a partir de una definicion formal del lenguaje de partida, especificada normalmente mediante una gramatica formal y barata, dejando unicamente al programador del compilador la tarea de programar las acciones semanticas asociadas.  Es el proceso por el cual se traducen las instrucciones escritas en un determinado lenguaje de programacion a lenguaje maquina. Ademas de un traductor, se pueden necesitar otros programas para crear un programa objeto ejecutable. Un programa fuente se puede dividir en modulos almacenados en archivos distintos. La tarea de reunir el programa fuente a menudo se confia a un programa distinto, llamado preprocesador. El preprocesador tambien puede expandir abreviaturas, llamadas a macros, a proposiciones del lenguaje fuente.  Normalmente la creacion de un programa ejecutable (un tipico archivo .exe para Windows o DOS) conlleva dos pasos. El primer paso se llama compilacion (propiamente dicho) y traduce el codigo fuente escrito en un lenguaje de programacion almacenado en un archivo a codigo en bajo nivel (normalmente en codigo objeto, no directamente a lenguaje maquina). El segundo paso se llama enlazado en el cual se enlaza el codigo de bajo nivel generado de todos los ficheros y subprogramas que se han mandado a compilar y se a\u00f1ade el codigo de las funciones que hay en las bibliotecas del compilador para que el ejecutable pueda comunicarse directamente con el sistema operativo, traduciendo asi finalmente el codigo objeto a codigo maquina, y generando un modulo ejecutable.  Estos dos pasos se pueden hacer por separado, almacenando el resultado de la fase de compilacion en archivos objetos (un tipico.obj para Microsoft Windows, DOS o para Unix); para enlazarlos en fases posteriores, o crear directamente el ejecutable; con lo que la fase de compilacion se almacena solo temporalmente. Un programa podria tener partes escritas en varios lenguajes (por ejemplo C, C++ y Asm), que se podrian compilar de forma independiente y luego enlazar juntas para formar un unico modulo ejecutable.  El proceso de traduccion se compone internamente de varias etapas o fases, que realizan distintas operaciones logicas. Es util pensar en estas fases como en piezas separadas dentro del traductor, y pueden en realidad escribirse como operaciones codificadas separadamente aunque en la practica a menudo se integren juntas.  El analisis lexico constituye la primera fase, aqui se lee el programa fuente de izquierda a derecha y se agrupa en componentes lexicos (tokenes), que son secuencias de caracteres que tienen un significado. Ademas, todos los espacios en blanco, lineas en blanco, comentarios y demas informacion innecesaria se elimina del programa fuente. Tambien se comprueba que los simbolos del lenguaje (palabras clave, operadores, etc.) se han escrito correctamente.  Como la tarea que realiza el analizador lexico es un caso especial de coincidencia de patrones, se necesitan los metodos de especificacion y reconocimiento de patrones, se usan principalmente los automatas finitos que acepten expresiones regulares. Sin embargo, un analizador lexico tambien es la parte del traductor que maneja la entrada del codigo fuente, y puesto que esta entrada a menudo involucra un importante gasto de tiempo, el analizador lexico debe funcionar de manera tan eficiente como sea posible.  En esta fase los caracteres o componentes lexicos se agrupan jerarquicamente en frases gramaticales que el compilador utiliza para sintetizar la salida. Se comprueba si lo obtenido de la fase anterior es sintacticamente correcto (obedece a la gramatica del lenguaje). Por lo general, las frases gramaticales del programa fuente se representan mediante un arbol de analisis sintactico.  La estructura jerarquica de un programa normalmente se expresa utilizando reglas recursivas. Por ejemplo, se pueden dar las siguientes reglas como parte de la definicion de expresiones:  Las reglas 1 y 2 son reglas basicas (no recursivas), en tanto que la regla 3 define expresiones en funcion de operadores aplicados a otras expresiones.  La division entre analisis lexico y analisis sintactico es algo arbitraria. Un factor para determinar la division es si una construccion del lenguaje fuente es inherentemente recursiva o no. Las construcciones lexicas no requieren recursion, mientras que las construcciones sintacticas suelen requerirla. No se requiere recursion para reconocer los identificadores, que suelen ser cadenas de letras y digitos que comienzan con una letra. Normalmente, se reconocen los identificadores por el simple examen del flujo de entrada, esperando hasta encontrar un caracter que no sea ni letra ni digito, y agrupando despues todas las letras y digitos encontrados hasta ese punto en un componente lexico llamado identificador. Por otra parte, esta clase de analisis no es suficientemente poderoso para analizar expresiones o proposiciones. Por ejemplo, no podemos emparejar de manera apropiada los parentesis de las expresiones, o las palabras begin y end en proposiciones sin imponer alguna clase de estructura jerarquica o de anidamiento a la entrada.  La fase de analisis semantico revisa el programa fuente para tratar de encontrar errores semanticos y reune la informacion sobre los tipos para la fase posterior de generacion de codigo. En ella se utiliza la estructura jerarquica determinada por la fase de analisis sintactico para identificar los operadores y operandos de expresiones y proposiciones.  Un componente importante del analisis semantico es la verificacion de tipos. Aqui, el compilador verifica si cada operador tiene operandos permitidos por la especificacion del lenguaje fuente. Por ejemplo, las definiciones de muchos lenguajes de programacion requieren que el compilador indique un error cada vez que se use un numero real como indice de una matriz. Sin embargo, la especificacion del lenguaje puede imponer restricciones a los operandos, por ejemplo, cuando un operador aritmetico binario se aplica a un numero entero y a un numero real.\u200b Revisa que los arreglos tengan definido el tama\u00f1o correcto.  Consiste en generar el codigo objeto equivalente al programa fuente. Solo se generara codigo objeto cuando el programa fuente esta libre de errores de analisis.  El resultado puede ser lenguaje de maquina o codigo ensamblador.\u200b Las posiciones de memoria se seleccionan para cada una de las variables usadas por el programa. Despues, cada una de las instrucciones intermedias se traduce a una secuencia de instrucciones de maquina que ejecuta la misma tarea. Un aspecto decisivo es la asignacion de variables a registros.  Despues de los analisis sintactico y semantico, algunos compiladores generan una representacion intermedia explicita del programa fuente. Esta representacion intermedia debe tener dos propiedades importantes: debe ser facil de producir y facil de traducir al programa objeto.\u200b  La representacion intermedia puede tener diversas formas. Existe una forma intermedia llamada \u00abcodigo de tres direcciones\u00bb, similar al lenguaje ensamblador, en la que cada instruccion lleva a cabo una sola operacion. El codigo de tres direcciones consiste en una secuencia de instrucciones, cada una de las cuales tiene como maximo tres operandos. Esta representacion intermedia tiene varias propiedades:  La fase de optimizacion de codigo consiste en mejorar el codigo intermedio, de modo que resulte un codigo maquina mas rapido de ejecutar. Esta fase de la etapa de sintesis es posible sobre todo si el traductor es un compilador (dificilmente un interprete puede optimizar el codigo objeto). Hay mucha variacion en la cantidad de optimizacion de codigo que ejecutan los distintos compiladores. En los que hacen mucha optimizacion, llamados \u00abcompiladores optimizadores\u00bb, una parte significativa del tiempo del compilador se ocupa en esta fase. Sin embargo, hay optimizaciones sencillas que mejoran sensiblemente el tiempo de ejecucion del programa objeto sin retardar demasiado la compilacion.\u200b  La interaccion entre los algoritmos utilizados por las fases del compilador y las estructuras de datos que soportan estas fases es, naturalmente, muy fuerte. El escritor del compilador se esfuerza por implementar estos algoritmos de una manera tan eficaz como sea posible, sin aumentar demasiado la complejidad. De manera ideal, un compilador deberia poder compilar un programa en un tiempo proporcional al tama\u00f1o del mismo.  Cuando un analizador lexico reune los caracteres en un token, generalmente representa el token de manera simbolica, es decir, como un valor de un tipo de datos enumerado que representa el conjunto de tokens del lenguaje fuente. En ocasiones tambien es necesario mantener la cadena de caracteres misma u otra informacion derivada de ella, tal como el nombre asociado con un token identificador o el valor de un token de numero.  En la mayoria de los lenguajes el analizador lexico solo necesita generar un token a la vez. En este caso se puede utilizar una variable global simple para mantener la informacion del token. En otros casos (cuyo ejemplo mas notable es FORTRAN), puede ser necesario un arreglo (o vector) de tokenes.  Si el analizador sintactico genera un arbol sintactico, por lo regular se construye como una estructura estandar basada en un puntero que se asigna de manera dinamica a medida que se efectua el analisis sintactico. El arbol entero puede entonces conservarse como una variable simple que apunta al nodo raiz. Cada nodo en la estructura es un registro cuyos campos representan la informacion recolectada tanto por el analizador sintactico como, posteriormente, por el analizador semantico. Por ejemplo, el tipo de datos de una expresion puede conservarse como un campo en el nodo del arbol sintactico para la expresion.  En ocasiones, para ahorrar espacio, estos campos se asignan de manera dinamica, o se almacenan en otras estructuras de datos, tales como la tabla de simbolos, que permiten una asignacion y desasignacion selectivas. En realidad, cada nodo del arbol sintactico por si mismo puede requerir de atributos diferentes para ser almacenado, de acuerdo con la clase de estructura del lenguaje que represente. En este caso, cada nodo en el arbol sintactico puede estar representado por un registro variable, con cada clase de nodo conteniendo solamente la informacion necesaria para ese caso.  Esta estructura de datos mantiene la informacion asociada con los identificadores: funciones, variables, constantes y tipos de datos. La tabla de simbolos interactua con casi todas las fases del compilador: el analizador lexico, el analizador sintactico o el analizador semantico pueden introducir identificadores dentro de la tabla; el analizador semantico agregara tipos de datos y otra informacion; y las fases de optimizacion y generacion de codigo utilizaran la informacion proporcionada por la tabla de simbolos para efectuar selecciones apropiadas de codigo objeto.  Puesto que la tabla de simbolos tendra solicitudes de acceso con tanta frecuencia, las operaciones de insercion, eliminacion y acceso necesitan ser eficientes, preferiblemente operaciones de tiempo constante. Una estructura de datos estandar para este proposito es la tabla de dispersion o de calculo de direccion, aunque tambien se pueden utilizar diversas estructuras de arbol. En ocasiones se utilizan varias tablas y se mantienen en una lista o pila.  La busqueda y la insercion rapida son esenciales tambien para la tabla de literales, la cual almacena constantes y cadenas utilizadas en el programa. Sin embargo, una tabla de literales necesita impedir las eliminaciones porque sus datos se aplican globalmente al programa y una constante o cadena aparecera solo una vez en esta tabla. La tabla de literales es importante en la reduccion del tama\u00f1o de un programa en la memoria al permitir la reutilizacion de constantes y cadenas. Tambien es necesaria para que el generador de codigo construya direcciones simbolicas para las literales y para introducir definiciones de datos en el archivo de codigo objeto.  De acuerdo con la clase de codigo intermedio (por ejemplo, codigo de tres direcciones o codigo P) y de las clases de optimizaciones realizadas, este codigo puede conservarse como un arreglo de cadenas de texto, un archivo de texto temporal o bien una lista de estructuras ligadas. En los compiladores que realizan optimizaciones complejas debe ponerse particular atencion a la seleccion de representaciones que permitan una facil reorganizacion.  La fase de optimizacion de codigo trata de mejorar el codigo intermedio de modo que resulte un codigo de maquina mas rapido de ejecutar. Algunas optimizaciones son triviales. Por ejemplo, un algoritmo natural genera el codigo intermedio (2) utilizando una instruccion para cada operador de la representacion del arbol despues del analisis semantico, aunque hay una forma mejor de realizar los mismos calculos usando las dos instrucciones  Este sencillo algoritmo no tiene nada de malo, puesto que el problema se puede solucionar en la fase de optimizacion de codigo. Esto es, el compilador puede deducir que la conversion de 60 de entero a real se puede hacer de una vez por todas en el momento de la compilacion, de modo que la operacion \"entreal( )\" se puede eliminar. Ademas, temp3 se usa solo una vez, para transmitir su valor a id1. Entonces resulta seguro sustituir a id1 por temp3, a partir de lo cual la ultima proposicion de (2) no se necesita y se obtiene el codigo de (3).  Hay muchas variaciones en la cantidad de optimizacion de codigo que ejecutan los distintos compiladores. En lo que hacen mucha optimizacion llamados \u00abcompiladores optimizadores\u00bb, una parte significativa del tiempo del compilador se ocupa en esta fase. Sin embargo, hay optimizaciones sencillas que mejoran sensiblemente el tiempo de ejecucion del programa objeto sin retardar demasiado la compilacion.  Al principio las computadoras no tenian la suficiente memoria para guardar un programa completo durante la compilacion. Este problema se resolvio mediante el uso de archivos temporales para mantener los productos de los pasos intermedios durante la traduccion o bien al compilar \u00abal vuelo\u00bb, es decir, manteniendo solo la informacion suficiente de las partes anteriores del programa fuente que permita proceder a la traduccion.  Las limitaciones de memoria son ahora un problema mucho menor, y es posible requerir que una unidad de compilacion entera se mantenga en memoria, en especial si se dispone de la compilacion por separado en el lenguaje. Con todo, los compiladores ocasionalmente encuentran util generar archivos intermedios durante alguna de las etapas del procesamiento. Algo tipico de estos es la necesidad de direcciones de correccion hacia atras durante la generacion de codigo. ","snippet":"En informatica, un compilador es un programa que traduce codigo escrito en un lenguaje de programacion (llamado fuente) a otro lenguaje (conocido como objeto).\u200b En este tipo de traductor el lenguaje f","enlaces_salientes":["Compilador","Compilador","Compilador","Recopilaci%C3%B3n","Inform%C3%A1tica","Programa_inform%C3%A1tico","Lenguaje_de_programaci%C3%B3n","C%C3%B3digo_fuente","C%C3%B3digo_objeto","Lenguaje_de_alto_nivel","Lenguaje_de_bajo_nivel","Lenguaje_ensamblador","Lenguaje_de_m%C3%A1quina","An%C3%A1lisis_de_algoritmos","Lenguaje_formal","Analizador_l%C3%A9xico","Analizador_sint%C3%A1ctico","S%C3%ADntesis","C%C3%B3digo_objeto","Compilador_optimizador","Teor%C3%ADa_de_la_complejidad_computacional","Complejidad_de_Kolmog%C3%B3rov","C%C3%B3digo_fuente","Tabla_de_s%C3%ADmbolos_(compilador)","C%C3%B3digo_m%C3%A1quina","Lenguajes_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n","C%C3%B3digo_m%C3%A1quina","Historia_de_la_construcci%C3%B3n_de_los_compiladores","Konrad_Zuse","Z1","ENIAC","EDVAC","Lenguaje_m%C3%A1quina","Lenguaje_ensamblador","Mnem%C3%B3nico","Grace_Hopper","John_Backus","FORTRAN","Int%C3%A9rprete_(inform%C3%A1tica)","Compilador_cruzado","Compilador_optimizador","Compilaci%C3%B3n_en_tiempo_de_ejecuci%C3%B3n","Int%C3%A9rprete_(inform%C3%A1tica)","Inform%C3%A1tica","Lenguaje_m%C3%A1quina","Ensamblador","Int%C3%A9rprete_(inform%C3%A1tica)","Analizador_sint%C3%A1ctico","Gram%C3%A1tica_formal","Preprocesador","Ejecutable","Microsoft_Windows","DOS","Lenguaje_de_programaci%C3%B3n","Enlazador","C%C3%B3digo_objeto","C%C3%B3digo_m%C3%A1quina","Unix","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Lenguaje_ensamblador","Ejecutable","Analizador_l%C3%A9xico","Token_(programaci%C3%B3n)","Palabra_clave","Operador","Aut%C3%B3mata_finito","Expresi%C3%B3n_regular","Analizador_sint%C3%A1ctico","Recursividad","Identificador","N%C3%BAmero_real","Matriz_(programaci%C3%B3n)","C%C3%B3digo_objeto","Registro_(hardware)","C%C3%B3digo_de_tres_direcciones","Lenguaje_ensamblador","Compilador_optimizador","Int%C3%A9rprete_(inform%C3%A1tica)","Estructura_de_datos","Algoritmo","Token","Cadena_de_caracteres","FORTRAN","Vector_(programaci%C3%B3n)","Puntero_(programaci%C3%B3n)","Nodo_(inform%C3%A1tica)","Funci%C3%B3n_(programaci%C3%B3n)","Variable_(programaci%C3%B3n)","Constante_(programaci%C3%B3n)","Tipo_de_dato","Lista_(estructura_de_datos)","Pila_(estructura_de_datos)","Generador_de_c%C3%B3digo","BlueJ","Lenguaje_de_programaci%C3%B3n","Lenguaje_ensamblador","Ensamblador","Desensamblador","Decompilador","Int%C3%A9rprete_(inform%C3%A1tica)","Depurador","Lenguaje_de_alto_nivel","Lenguaje_de_bajo_nivel","Lenguaje_de_m%C3%A1quina","Historia_de_la_construcci%C3%B3n_de_los_compiladores","Principles_of_Compiler_Design","ISBN","ISBN","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","ISBN","OCLC","ISBN","OCLC","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Top-down_y_Bottom-up","titulo":"Top-down y bottom-up","contenido":" Top-down (\u2018de arriba abajo\u2019) y bottom-up (\u2018de abajo arriba\u2019) son estrategias de procesamiento de informacion caracteristicas de las ciencias de la informacion, especialmente en lo relativo al software. Por extension se aplican tambien a otras ciencias sociales y exactas.  En el modelo top-down se formula un resumen del sistema, sin especificar detalles. Cada parte nueva es entonces redefinida, cada vez con mayor detalle, hasta que la especificacion completa es lo suficientemente detallada para validar el modelo. El modelo top-down se dise\u00f1a con frecuencia con la ayuda de \"cajas negras\" que hacen mas facil cumplir requisitos aunque estas cajas negras no expliquen en detalle los componentes individuales.  En contraste, en el dise\u00f1o bottom-up las partes individuales se dise\u00f1an con detalle y luego se enlazan para formar componentes mas grandes, que a su vez se enlazan hasta que se forma el sistema completo. Las estrategias basadas en el flujo de informacion \"bottom-up\" se antojan potencialmente necesarias y suficientes porque se basan en el conocimiento de todas las variables que pueden afectar los elementos del sistema.  En el proceso de desarrollo de software, los enfoques top-down y bottom-up juegan un papel crucial.  El dise\u00f1o top-down fue promovido en la decada de 1970 por los investigadores de IBM Harlan Mills y Niklaus Wirth. Mills desarrollo los conceptos de programacion estructurada para usos practicos y los probo en un proyecto en 1969 para automatizar el indice de la morgue del New York Times. El exito administrativo e ingenieril del proyecto hicieron que el enfoque top-down se esparciera por IBM y por el resto de la industria de los computadores. Niklaus Wirth, que entre sus logros esta el desarrollo del lenguaje de programacion Pascal, escribio el articulo Program Development by Stepwise Refinement, que tuvo mucha influencia.  Los metodos top-down fueron favorecidos en la ingenieria de software hasta que llego la programacion orientada a objetos a finales de los 1980s.  El enfoque top-down enfatiza la planificacion y conocimiento completo del sistema. Se entiende que la codificacion no puede comenzar hasta que no se haya alcanzado un nivel de detalle suficiente, al menos en alguna parte del sistema. Esto retrasa las pruebas de las unidades funcionales del sistema hasta que gran parte del dise\u00f1o se ha completado.  Bottom-up hace enfasis en la programacion y pruebas tempranas, que pueden comenzar tan pronto se ha especificado el primer modulo. Este enfoque tiene el riesgo de programar cosas sin saber como se van a conectar al resto del sistema, y esta conexion puede no ser tan facil como se creyo al comienzo. La reutilizacion del codigo es uno de los mayores beneficios del enfoque bottom-up.  El desarrollo de software moderno usualmente combina tanto top-down como bottom-up. Aunque un conocimiento completo del sistema se considera usualmente necesario para un buen dise\u00f1o, haciendo que teoricamente sea un enfoque top-down, la mayoria de proyectos de desarrollo de software tratan de usar codigo existente en algun grado. El uso de modulos existentes le dan al dise\u00f1o un sabor bottom-up. Algunos enfoques usan un enfoque en el que un sistema parcialmente funcional es dise\u00f1ado y programado completamente, y este sistema se va expandiendo para llenar los requisitos del proyecto.  En ecologia, el control top-down se refiere a cuando un superdepredador controla la estructura o la dinamica de la poblacion del ecosistema. Las interacciones entre estos superdepredadores y sus presas es lo que influye en los niveles troficos inferiores. Los cambios en el nivel superior de los niveles troficos tienen un efecto inverso en los niveles troficos inferiores. El control top-down puede afectar de forma negativa al ecosistema circundante si hay un cambio drastico en el numero de depredadores. El ejemplo clasico es el de los ecosistemas de bosques de algas. En tales ecosistemas, las nutrias marinas son un depredador clave. Se alimentan de erizos que a su vez comen algas marinas. Cuando se eliminan las nutrias, las poblaciones de erizos crecen y reducen el bosque de algas creando paramos de erizos. Esto reduce la diversidad del ecosistema en su conjunto y puede tener efectos perjudiciales en todos los demas organismos. En otras palabras, estos ecosistemas no estan controlados por la productividad de las algas marinas, sino por un superdepredador. En este ejemplo se puede ver el efecto inverso que tiene el control top-down; cuando disminuyo la poblacion de nutrias, aumento la poblacion de erizos.  El control bottom-up en los ecosistemas se refiere a ecosistemas en los que el suministro de nutrientes, la productividad y el tipo de productores primarios (plantas y fitoplancton) controlan la estructura del ecosistema. Si no hay suficientes recursos o productores en el ecosistema, no queda suficiente energia para el resto de animales de la cadena alimentaria debido a la biomagnificacion y la eficiencia ecologica. Un ejemplo seria como las poblaciones de plancton estan controladas por la disponibilidad de nutrientes. Las poblaciones de plancton tienden a ser mas altas y mas complejas en areas donde el afloramiento costero trae nutrientes a la superficie.  Hay muchos ejemplos diferentes de estos conceptos. Es comun que las poblaciones se vean influenciadas por ambos tipos de control, y todavia hay debates sobre que tipo de control afecta a las redes troficas en ciertos ecosistemas. ","snippet":" Top-down (\u2018de arriba abajo\u2019) y bottom-up (\u2018de abajo arriba\u2019) son estrategias de procesamiento de informacion caracteristicas de las ciencias de la informacion, especialmente en lo relativo al softwar","enlaces_salientes":["Top-down_y_bottom-up","Top-down_y_bottom-up","Top-down_y_bottom-up","Ciencias_de_la_informaci%C3%B3n_(tecnolog%C3%ADa)","Software","D%C3%A9cada_de_1970","IBM","Niklaus_Wirth","Programaci%C3%B3n_estructurada","New_York_Times","Niklaus_Wirth","Lenguaje_de_programaci%C3%B3n_Pascal","Ingenier%C3%ADa_de_software","Programaci%C3%B3n_orientada_a_objetos","ISBN","ISBN","ISBN","Control_de_autoridades","Gemeinsame_Normdatei","Enciclopedia_Brit%C3%A1nica"]}
{"url":"BASIC","titulo":"BASIC","contenido":"BASIC, siglas de Beginners' All-purpose Symbolic Instruction Code\u200b (en castellano: \u2018Codigo simbolico de instrucciones de proposito general para principiantes\u2019), es una familia de lenguajes de programacion de alto nivel.  El BASIC original, el Dartmouth BASIC, fue dise\u00f1ado en 1964 por John George Kemeny, Thomas Eugene Kurtz y Mary Kenneth Keller en el Dartmouth College en New Hampshire, Estados Unidos, como un medio para facilitar la programacion en ordenadores a estudiantes (y profesores) que no fueran de ciencias.  En aquella epoca, casi todo el uso de los computadores requeria codificar software hecho a medida, con lo cual quedaba restringido a personas con formacion como cientificos y matematicos.  BASIC originalmente fue desarrollado como una herramienta de ense\u00f1anza. El lenguaje y sus variantes llegaron a estar ampliamente disponibles en las microcomputadoras a finales de los a\u00f1os 1970 y en los a\u00f1os 1980.  BASIC sigue siendo popular a dia de hoy en un pu\u00f1ado de dialectos altamente modificados, y en nuevos lenguajes, influenciados por BASIC tales como Microsoft Visual Basic o Gambas en GNU/Linux.  En el a\u00f1o 2006, el 59\u00a0% de los desarrolladores para la plataforma .NET usaban Visual Basic .NET como su unico lenguaje.\u200b  A principios de la decada de 1960, las computadoras eran sumamente caras y se utilizaban unicamente para propositos especiales, ejecutando \"una unica tarea\" a la vez. Sin embargo, durante el transcurso de esa decada, los precios bajaron al punto que incluso algunas peque\u00f1as empresas ya podian costearlas. La velocidad de proceso de las maquinas se incremento al grado que a menudo quedaban demasiado tiempo ociosas, porque no habia suficientes tareas para ellas. Todo ello fue debido a la rapida evolucion del hardware. Los lenguajes de programacion de aquellos tiempos estaban dise\u00f1ados para propositos especificos, como las maquinas en las que eran ejecutados; por ejemplo para desarrollar aplicaciones calculo o procesamiento de formulas se dise\u00f1o el lenguaje FORTRAN, en tanto que para la programacion en administracion o gestion de informacion se desarrollo especificamente el COBOL.  A fin de incrementar el rendimiento y amortizar mejor los costos (por reduccion del tiempo ocioso del procesador), y siendo que ya la velocidad de las maquinas comenzo a permitirlo, se propuso la idea de ejecutar mas de una tarea \"simultaneamente\", fue asi que surgio el concepto de sistema de tiempo compartido, que comenzo a ganar mucha popularidad. En sistemas de ese tipo, el tiempo de procesamiento del procesador central se dividia, y a cada usuario se le otorgaba secuencialmente y ciclicamente una peque\u00f1a porcion o \"cuota\" de tiempo de proceso. Las maquinas eran lo suficientemente rapidas como para provocar en los usuarios la ilusion de que disponian de la funcionalidad de la maquina todo el tiempo para ellos (\"seudo-simultaneidad\" de procesos). Esa distribucion del tiempo de computo entre los usuarios redujo considerablemente el costo de la computacion, ya que una sola maquina podia ser compartida por numerosos usuarios.  El lenguaje BASIC fue inventado en 1964 por John George Kemeny (1926-1992) y Thomas Eugene Kurtz (1928-) en el Dartmouth College, con la ayuda de otros como la programadora Mary Kenneth Keller. En a\u00f1os subsiguientes, mientras que otros dialectos de BASIC aparecian, el BASIC original de Kemeny y Kurtz fue conocido como Dartmouth BASIC.  BASIC fue dise\u00f1ado para permitir a los estudiantes escribir programas usando terminales de un computador en tiempo compartido. Estaba pensado para reducir notablemente la complejidad de los otros lenguajes del momento, con uno dise\u00f1ado especificamente para la clase de usuarios que los sistemas de tiempo compartido permitian: un usuario mas sencillo, fuera del area de las ciencias de la computacion, a quien no le interesaba tanto la velocidad, solo el hecho de ser capaz de programar y usar la maquina sin demasiadas complicaciones. Los dise\u00f1adores del lenguaje tambien querian que permaneciera en el dominio publico, lo cual contribuyo a que se diseminara rapidamente.  Los ocho principios que rigieron el dise\u00f1o de BASIC fueron:  El lenguaje fue en parte basado en FORTRAN II y otra parte en Algol 60, con adiciones para hacerlo apropiado en sistemas de tiempo compartido y con elementos que facilitaran la operacion aritmetica de matrices. BASIC fue implementado por primera vez para la mainframe GE-265, maquina que soportaba multiples terminales.  En 1968 Edsger Dijkstra publico una carta con una famosa critica en la que consideraba que los lenguajes de programacion que usaban sentencias GOTO para estructurar un programa eran nocivos para la productividad del programador, y para la calidad del codigo resultante. En este articulo no se menciona a ningun lenguaje de programacion en particular; unicamente se indica que el uso excesivo de GOTO en lenguajes de alto nivel es algo no recomendable, y proporciona las razones tecnicas por las que esto es asi. Pero si se observo, desde sus inicios, una marcada tendencia de los programadores a utilizar excesivamente el GOTO en BASIC, maxime en los noveles; hecho este que fue decreciendo con la incorporacion al lenguaje de otros recursos, tales como subrutinas parametradas, y posteriormente con la aparicion de tecnicas de programacion estructurada.  Contrario a la creencia popular, BASIC inicialmente no era un lenguaje interpretado sino compilado. Casi inmediatamente despues de su lanzamiento, los profesionales de computacion comenzaron a alegar que BASIC era muy lento y simple. Tal argumento, hasta no hace mucho, fue un tema recurrente en la industria de las computadoras.  Aun asi, BASIC se extendio hacia muchas maquinas y plataformas, y se popularizo moderadamente en las minicomputadoras como las de la serie DEC PDP y la Data General Nova. En estos casos, el lenguaje era implementado como  interprete, en vez de un compilador, o alternativamente, en ambas formas de funcionamiento.  Sin embargo, fue con la introduccion de la microcomputadora Altair 8800 en 1975 que BASIC se extendio ampliamente. La mayoria de los lenguajes de programacion eran demasiado grandes para ser albergados por las peque\u00f1as memorias de que disponian la mayor parte de las maquinas en esa epoca; y con el lento almacenamiento que permitia la cinta de papel, y mas tarde la cinta de audiocasete (los discos magneticos aun no existian), y la falta de editores de texto adecuados, un lenguaje peque\u00f1o como BASIC resultaba una buena opcion.  Uno de los primeros en aparecer fue Tiny BASIC, una implementacion simple de BASIC escrita originalmente por el Dr. Li-Chen Wang, y portada mas tarde a la maquina Altair por Dennis Allison, a peticion de Bob Albrecht (quien despues fundo Dr. Dobb's Journal (DDJ)). El dise\u00f1o de Tiny BASIC y el codigo fuente completo fue publicado en DDJ en 1976.  En 1975 Microsoft (entonces formado por dos personas: Bill Gates y Paul Allen) lanzo el Altair BASIC. Luego comenzaron a aparecer bajo licencia versiones para otras plataformas, y millones de copias y variantes pronto estarian en uso. MS BASIC se convirtio en uno de los lenguajes estandar en el Apple II.  En 1979 Microsoft estaba negociando con varios vendedores de microcomputadores, incluyendo IBM, para licenciar un interprete de BASIC para sus ordenadores. Se incluyo una version en las memorias ROM de los PC IBM para los equipos sin discos.  En los equipos que disponian de una unidad de disquete, el BASIC era iniciado automaticamente siempre que no se colocara ningun disquete de arranque como sistema operativo.  Las nuevas compa\u00f1ias intentaban seguir los pasos del exito de Altair: IMSAI, North Star, y Apple, creando la revolucion de la computadora casera. BASIC se convirtio en una caracteristica estandar para casi todas las computadoras hogare\u00f1as; la mayoria venia con un sistema operativo basico e interprete de BASIC, todo alojado en una ROM (algo hecho por primera vez en la Commodore PET en 1977).  Pronto habria muchos millones de computadores alrededor del mundo ejecutando BASIC, un numero mucho mas grande que el de todos los usuarios de otros lenguajes juntos. Muchos programas, especialmente los de la Apple II e IBM PC, dependian de la presencia del interprete de BASIC de Microsoft y no podian ejecutarse sin este; por lo que Microsoft uso la licencia de copyright en los interpretes de BASIC para influir en las negociaciones con los vendedores de computadores.  El BASIC fue tambien el lenguaje preinstalado en los computadores hogare\u00f1os europeos de la decada de los 80 como el ZX Spectrum (Sinclair BASIC), Amstrad CPC (Locomotive BASIC), MSX (MSX BASIC), el Commodore 64 y 128 (Basic 2.0, Basic 7.0, Simons' Basic), los Commodore Amiga (AmigaBASIC) o la familia Atari de 8 bits (Atari BASIC) y en los computadores hogare\u00f1os japoneses NEC PC-8801 y NEC PC-9801 (N88-BASIC), haciendo muchas veces la funcion de interprete y sistema operativo primitivo, ya que venian implementados ambos en ROM. Texas Instruments incorporo su propia version en sus microcomputadoras, tal como la TI99/4A, y tambien con una version extendida en una ROM externa o cartuchos (TI-Basic y TI Extended  En este periodo se crearon versiones de BASIC nuevas y mas poderosas. Microsoft vendio varias versiones de BASIC para MS-DOS/PC-DOS, incluyendo BASICA, GW-BASIC (una version compatible con BASICA que no necesitaba la ROM de IBM), y Quick BASIC. El fabricante de Turbo Pascal, Borland, publico Turbo BASIC 1.0 en 1985 (versiones sucesoras aun se venden bajo el nombre de PowerBASIC por otra compa\u00f1ia). Aparecieron varias extensiones de BASIC para computadores caseros, tipicamente con capacidad para graficos, sonido, y comandos DOS, asi como facilidades para Programacion estructurada. Hubo lenguajes que usaron la sintaxis de BASIC como base para otros sistemas totalmente diferentes, por ejemplo GRASS.  Sin embargo a finales de la decada de 1980 las computadoras nuevas eran mucho mas complejas, e incluian caracteristicas (como la Interfaz grafica de usuario) que hacian a BASIC menos apropiado para programarlas. Al mismo tiempo las computadoras progresaban de ser interes para aficionados a herramientas usadas principalmente para ejecutar aplicaciones escritas por otros, y la programacion en si se fue haciendo menos importante para una creciente mayoria de usuarios. BASIC comenzo a desvanecerse, aunque numerosas versiones aun estaban disponibles.  Una de las mas poderosas fue el denominado Locomotive BASIC 2 dise\u00f1ado para el entorno grafico GEM. Esta nueva version del lenguaje permitia crear aplicaciones con interfaces graficas dotadas de ventanas, menus y diferentes tipos de graficos estadisticos.  La suerte de BASIC dio un giro nuevamente con la introduccion de Visual Basic de Microsoft. Si bien este lenguaje utiliza practicamente todas las palabras clave (sentencias, estructuras de control y funciones intrinsecas) y forma de manejo y tipo de datos que versiones BASIC anteriores (DOS); VB es abismalmente mas potente y evolucionado; y se ha convertido en uno de los lenguajes mas utilizados en la plataforma Windows;  se estima [cita\u00a0requerida] que entre el 70 y el 80% del total de aplicaciones comerciales son programadas en VB. A partir de 2002, y con la introduccion de la plataforma .NET Framework de Microsoft, Visual Basic comienza a utilizar el paradigma \"orientado a objetos\", aumentando la potencia del lenguaje y haciendolo multiplataforma. Visual Basic for Applications (VBA) fue a\u00f1adido a Microsoft Excel 5.0 en 1993 y al resto de la linea de productos de Microsoft Office en 1997. Windows 98 incluyo un interprete de VBScript. La version mas reciente de Visual Basic es llamada VB.NET. Por otra parte, tambien existe la variante OpenOffice.org Basic menos poderosa pero similar a VBA de Microsoft.  La sintaxis minima de BASIC solo necesita los comandos LET, INPUT, PRINT, IF y GOTO. Un interprete que ejecuta programas con esta sintaxis minima no necesita una pila. Algunas de las primeras implementaciones eran asi de simples. Si se le agrega una pila, se pueden agregar tambien ciclos FOR anidados y el comando GOSUB. Un interprete de BASIC con estas caracteristicas necesita que el codigo tenga numeros de linea.  Los numeros de linea fueron un aspecto muy distintivo del BASIC clasico. Sin embargo, el uso de numeros de linea tiene la desventaja de requerir que el programador estime cuantas lineas ocupara la parte del programa que escribe. Este requerimiento se cumple generalmente incrementando los numeros de linea en un intervalo regular, como 10, pero esto lleva a problemas a la hora que el codigo despues agregado exceda el espacio disponible entre las lineas originales. Para aliviar este problema de los primeros interpretes de BASIC, los usuarios expertos pronto escribieron sus propios programas utilitarios para renumerar sus programas, despues del ingreso inicial. Mas tarde aparecieron interpretes de BASIC que incluian un comando especifico RENUMBER, el que permitia renumerar rapidamente (y las veces que se quisiera) todo el codigo nuevamente, con cualquier intervalo entre lineas indicado y a partir de un numero entero dado; eliminando asi el principal problema de la numeracion de lineas obligatoria.  En los dialectos modernos de BASIC MIUN ya no es necesario incluir numeros de linea (aunque son permitidos), y la mayoria (o todos) han a\u00f1adido control de flujo estructurado y los constructores de declaracion de datos similares a los de otros lenguajes, tales como C y Pascal:  Casi todos los dialectos de BASIC incluyen el comando REM (remark), que posteriormente fue sustituido por el simbolo \u00b4 (apostrofo o comilla simple).  Es un comando no ejecutable, se utiliza a los fines de incluir lineas y notas aclaratorias en el codigo fuente, para la mejor comprension (y documentacion) del programa.  Variantes recientes como Visual Basic han introducido algunas caracteristicas orientadas a objetos, y hasta herencia en la ultima version. La administracion de memoria es mas facil que con muchos otros lenguajes de programacion procedurales por el uso de un Recolector de basura (y a costas de la velocidad de ejecucion).  BASIC no tiene una biblioteca externa estandar como otros lenguajes como C. En cambio, el interprete (o compilador) contiene una biblioteca incorporada de procedimientos intrinsecos. Estos procedimientos incluyen la mayoria de las herramientas que un programador necesita para aprender a programar y escribir aplicaciones sencillas, asi como funciones para realizar calculos matematicos, manejar cadenas, entrada desde la consola, graficos y manipulacion de archivos.  Viejos dialectos de BASIC no permitian a los programadores escribir sus propios procedimientos. Los programadores en cambio debian escribir sus programas con un gran numero de enunciados GOTO para hacer las derivaciones de flujo y retorno del programa. Esto podia producir un codigo fuente muy confuso (la mayoria de las veces era asi), comunmente conocido como Codigo espagueti; el cual era sumamente dificil de mantener, mucho menos por programadores ajenos al desarrollo del software.  Con la inclusion posterior de enunciados GOSUB (Go-Subroutine) se ramificaba el programa a especies de subrutinas, sin parametros o variables locales. Ellas proveen una forma de implementar una suerte de procedimientos (realmente no lo son, sencillamente es un \"salto y retorno\") y estructurar mas el programa, evitando bastante la utilizacion de la da\u00f1ina sentencia GOTO.  La mayoria de las versiones de BASIC mas modernas, como Microsoft QuickBASIC (1985-1988) y BASIC PDS (Profesional Developmen System - 1990) a\u00f1adieron soporte completo para subrutinas, funciones y programacion estructurada. Esta es otra area donde BASIC difiere de muchos lenguajes de programacion. Sin embargo la primitiva GOSUB se ha mantenido hasta las versiones actuales, por razones compatibilidad.  BASIC, como Pascal, hace una distincion entre un procedimiento que no devuelve un valor (llamado subrutina) y un procedimiento que lo hace (llamado funcion). Muchos otros lenguajes (como C) no hacen esa distincion y consideran todo como una funcion (algunas que devuelven un valor \u201cvoid\u201d [vacio]).  Mientras que las funciones que devuelven un valor son una adicion relativamente reciente a los dialectos de BASIC, muchos de los primeros sistemas soportaban la definicion de funciones matematicas en linea, con DEF FN (\u201cDEFine FunctioN\u201d [DEFinir FuncioN]). El Dartmouth BASIC original tambien soportaba funciones al estilo de Algol, asi como subrutinas desde sus primeros tiempos.  BASIC es reconocido por tener muy buenas funciones para manipular cadenas de caracteres. Los primeros dialectos ya tenian un juego de funciones fundamentales (LEFT$, MID$, RIGHT$) para extraer y/o reemplazar subcadenas facilmente. Como las cadenas son utilizadas en aplicaciones diarias, esta era una ventaja considerable sobre otros lenguajes al momento de su introduccion.  El Dartmouth BASIC original soportaba unicamente datos de tipo numerico y cadenas. No habia un tipo entero. Todas las variables numericas eran de coma flotante. Las cadenas eran de tama\u00f1o dinamico. Soportaba arreglos de ambos, numeros y cadenas, en una o dos dimensiones.  Cada dialecto moderno de BASIC posee al menos los tipos de datos numerico y cadena. Estos tipos de datos se pueden distinguir usando un posfijo: los identificadores de cadenas terminan con $ (signo dolar, ejemplo la variable NOMBRE$), mientras que los numericos sencillamente no llevan posfijo; a menos que se requiera indicar y forzar explicitamente que tipo de numerico es, por ejemplo A% es entero, A! es real simple precision y A# es real doble precision.  En BASIC las variables no necesitan forzosamente ser declaradas antes de usarse, excepto los arreglos de mas de 10 elementos;  aunque versiones BASIC relativamente modernas poseen la opcion (considerada buena practica de programacion) para obligar al programador a declarar toda variable antes de su uso (una directiva como OPTION EXPLICIT). La declaracion de variables en BASIC se hace usando la palabra clave DIM.  Muchos dialectos tambien soportan tipos numericos adicionales, como enteros de 16 y 32 bits (simple y long, respectivamente), ademas de sus numeros de coma flotante. Adicionalmente algunos permiten la utilizacion de tipos de datos definidos por el usuario, similar a los \"records\" de Pascal, o las \"structs\" de C.  Versiones modernas de BASIC (como VBA) soportan una gran variedad de tipos de datos primitivos (o intrinsecos), ademas de los definidos por el usuario.  La mayoria de los dialectos de BASIC soporta arreglos en todos sus tipos de datos; es comun tambien el soporte para arreglos mulidimensionales  Ejemplos:  Dependiendo del dialecto de BASIC y del uso del enunciado OPTION BASE, el primer indice de los arreglos que se declaren sera 1, por defecto es cero.  En los ejemplos anteriores, si no se declara previamente \"OPTION BASE 1\", el primero es un arreglo en dos dimensiones de enteros 16 bits, con indices que van desde 0 hasta 100 (matriz de 101 x 101 elementos); en tanto que el segundo es un arreglo de enteros en una sola dimension, de 0 a 30 (vector de 31 elementos). Observar que las dos formas de declaracion de enteros son equivalentes, explicitandolo o con el uso del posfijo\u00a0%. Analogamente para cadenas o string de caracteres, que en este caso ademas son de longitud variable (dinamicas, por defecto).  BASIC esta disponible para casi todas las plataformas y sistemas operativos existentes. Una implementacion gratuita que cumple con estandares y es multiplataforma es Bywater BASIC (bwBASIC). El interprete esta escrito en C y viene bajo la licencia GNU. Esta dise\u00f1ado para interfaz de texto o consola (no grafica), no incluye soporte para crear interfaces graficas de usuario (GUI's, Graphical User Interface). Hay un BASIC gratuito que si incluye soporte para GUI, es similar a Visual Basic y se ejecuta en Windows y GNU/Linux, es Phoenix Object BASIC.  Las versiones de interpretes/compiladores mas conocidos son la linea de productos Quick BASIC y QBASIC, este ultimo es solo interprete, ambos son de Microsoft. En la actualidad lo es el moderno Visual BASIC, que Microsoft ha tratado de mantener al menos minimamente compatible con incluso las primeras versiones de sus BASIC (en realidad es escasamente compatible), si bien existe FreeBASIC que es un compilador libre, compatible en sintaxis con QBASIC/QuickBASIC.  Otras versiones comerciales incluyen PowerBASIC de PowerBASIC, PureBasic de Fantaisie Software, asi como TrueBASIC de TrueBASIC, que cumple con los ultimos estandares oficiales de BASIC. (True BASIC Inc. fue fundada por los creadores originales de Dartmouth BASIC.)  REALbasic es una variante disponible para Mac OS Classic, Mac OS X, Microsoft Windows y GNU/Linux, comercializada por los actuales propietarios de Rapid-Q, otra implementacion inicialmente libre de BASIC actualmente abandonada. Una version de un dialecto simple de BASIC para la parrot virtual machine, muestra como se implementa un interprete de BASIC en un lenguaje similar al ensamblador. SmallBASIC es un dialecto que ejecuta en muchas plataformas (Win32, DOS, GNU/Linux y PalmOS) y viene bajo la licencia GNU (GPL).  Existen muchas implementaciones de BASIC freeware o GNU, como BCX, YaBasic, HBasic, XBasic, Gambas o Just BASIC, entre otras.  Implementaciones de BASIC  BASICs de Microsoft:  BASICs de Mac:  BASICs de GNU/Linux:  Otros ","snippet":"BASIC, siglas de Beginners' All-purpose Symbolic Instruction Code\u200b (en castellano: \u2018Codigo simbolico de instrucciones de proposito general para principiantes\u2019), es una familia de lenguajes de programa","enlaces_salientes":["BASIC","BASIC","BASIC","Thomas_Eugene_Kurtz","John_G._Kemeny","Mary_Kenneth_Keller","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_imperativa","John_George_Kemeny","Thomas_Eugene_Kurtz","Mary_Kenneth_Keller","Sistema_de_tipos","Fortran","ALGOL","Sistema_operativo","Idioma_espa%C3%B1ol","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_alto_nivel","Dartmouth_BASIC","John_George_Kemeny","Thomas_Eugene_Kurtz","Mary_Kenneth_Keller","Dartmouth_College","New_Hampshire","Estados_Unidos","Cient%C3%ADfico","Matem%C3%A1tico","Microcomputadora","Microsoft_Visual_Basic","Gambas","GNU/Linux","Microsoft_.NET","Visual_Basic_.NET","Atari_BASIC","1960","Hardware","FORTRAN","Programaci%C3%B3n","COBOL","Unidad_central_de_procesamiento","Tiempo_compartido_(inform%C3%A1tica)","John_George_Kemeny","Thomas_Eugene_Kurtz","Dartmouth_College","Mary_Kenneth_Keller","Dartmouth_BASIC","Terminal_de_computadora","Tiempo_compartido_(inform%C3%A1tica)","Programa_(inform%C3%A1tica)","Sistema_operativo","Fortran","ALGOL","Tiempo_compartido_(inform%C3%A1tica)","Matriz_(matem%C3%A1tica)","Mainframe","Edsger_Dijkstra","GOTO","GOTO","GOTO","Compilador","Minicomputadora","Digital_Equipment_Corporation","Programmed_Data_Processor","Data_General","Int%C3%A9rprete_(inform%C3%A1tica)","Compilador","Microordenador","Commodore_International","Commodore_PET","Programa_inform%C3%A1tico","Emulador","VICE","GNU/Linux","Microcomputador","Altair_8800","1975","Tiny_BASIC","Li-Chen_Wang","Dr._Dobb%27s_Journal","1976","1975","Microsoft","Bill_Gates","Paul_Allen","Altair_BASIC","Apple_II","1979","ROM","Computadora_personal","Commodore_PET","1977","ZX_Spectrum","Sinclair_BASIC","Amstrad_CPC","Locomotive_BASIC","MSX","MSX_BASIC","Commodore_64","Commodore_128","Simons%27_Basic","Commodore_Amiga","Familia_Atari_de_8_bits","Atari_BASIC","NEC_PC-8801","NEC_PC-9801","TI-Basic","MS-DOS","PC-DOS","BASICA","GW-BASIC","Quick_BASIC","Turbo_Pascal","Borland","Turbo_BASIC","1985","DOS","Programaci%C3%B3n_estructurada","GRASS","1980","Interfaz_gr%C3%A1fica","Locomotive_BASIC_2","Graphical_Environment_Manager","Visual_Basic","Windows",".NET_Framework","Visual_Basic","VBA","1993","1997","VBScript","VB.NET","OpenOffice.org_Basic","Estructuras_de_control","C_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n_Pascal","Ap%C3%B3strofo","Visual_Basic","Herencia_(programaci%C3%B3n_orientada_a_objetos)","Recolector_de_basura","C%C3%B3digo_espagueti","QuickBASIC","Programaci%C3%B3n_estructurada","Licencia_p%C3%BAblica_general_de_GNU","GUI","GNU/Linux","Quick_BASIC","QBASIC","FreeBASIC","PureBasic","REALbasic","Rapid-Q","Licencia_p%C3%BAblica_general_de_GNU","Freeware","GNU","BCX","YaBasic","HBasic","XBasic","Gambas","Just_BASIC","Applesoft_BASIC","BasictoPHP","Dartmouth_BASIC","Tiny_BASIC","Locomotive_BASIC","XBasic","Xblite","SuperBASIC","FreeBASIC","Gfa-BASIC","Rapid-Q","AutoIt","LSE_(lenguaje)","Microsoft_BASIC","Altair_BASIC","AMOS_(lenguaje_de_programaci%C3%B3n)","Applesoft_BASIC","MSX_BASIC","IBM","PC_DOS","BASICA","MS-DOS","GW-BASIC","QBASIC","QuickBASIC","Microsoft_Windows","Visual_Basic","Visual_Basic_.NET","Internet","VBScript","Mac_OS","GNU/Linux","Software_propietario","REALbasic","Software_libre","Gambas","HBasic","KBasic","Programaci%C3%B3n","Inform%C3%A1tica","Software","L%C3%ADnea_de_c%C3%B3digo_fuente","Lenguaje_de_alto_nivel","Lenguaje_interpretado","Int%C3%A9rprete_(inform%C3%A1tica)","ISBN","ISSN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Enciclopedia_Brit%C3%A1nica"]}
{"url":"ALGOL","titulo":"ALGOL","contenido":"Se denomina ALGOL (o Algol) a un lenguaje de programacion. La voz es un acronimo de las palabras inglesas Algorithmic Language ('lenguaje algoritmico').  Fue muy popular en las universidades durante los a\u00f1os 1960, pero no llego a cuajar como lenguaje de utilizacion comercial.  Sin embargo, Algol influyo profundamente en varios lenguajes posteriores que si alcanzaron gran difusion, como Pascal, C y Ada.  Hacia 1965 dos corrientes se distinguieron sobre el tema de un sucesor para Algol. Como resultado se definieron los lenguajes Algol W que es un lenguaje minimalista, rapidamente implementado y distribuido y, por otra parte, Algol 68 que para la epoca esta en la frontera entre un lenguaje para programar en el y un lenguaje para investigar sobre el.  Lenguaje elaborado dise\u00f1ado por Niklaus Wirth y Tony Hoare a partir de los trabajos del grupo ALGOL de la IFIP. Se trata de un lenguaje conciso, simple de implementar, que evita todos los defectos conocidos del lenguaje Algol e incluye sus propias caracteristicas adicionales. Sin embargo, el grupo Algol no lo adopto como sucesor de Algol prefiriendo en su lugar al que termino siendo Algol 68. Algol W fue utilizado por gran cantidad de usuarios y sembro el camino para el nacimiento del lenguaje Pascal.  Entre las caracteristicas del lenguaje se destacan: Aritmetica de doble precision, numeros complejos, Strings y estructuras de datos dinamicas, evaluacion por valor, pasaje de parametros por valor, valor resultado o resultado.  La definicion del lenguaje fue presentada en la reunion del comite ALGOL de la IFIP en 1965. Despues de varios a\u00f1os de revision del dise\u00f1o se llego a una version definitiva en 1968. El principal autor es Adriaan van Wijngaarden.  Los objetivos principales de ALGOL 68 son permitir comunicar algoritmos, permitir una eficiente ejecucion de los mismos en diferentes arquitecturas y servir como herramienta para la ense\u00f1anza.  Una caracteristica interesante de ALGOL 68 es que su semantica fue definida formalmente antes de ser implementado en base al formalismo llamado gramaticas de dos niveles.                 ","snippet":"Se denomina ALGOL (o Algol) a un lenguaje de programacion. La voz es un acronimo de las palabras inglesas Algorithmic Language ('lenguaje algoritmico').  Fue muy popular en las universidades durante l","enlaces_salientes":["ALGOL","ALGOL","ALGOL","John_Backus","John_McCarthy_(cient%C3%ADfico)","Peter_Naur","Adriaan_van_Wijngaarden","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_procedural","Programaci%C3%B3n_estructurada","1958","John_Backus","Alan_Perlis","Peter_Naur","Adriaan_van_Wijngaarden","Julien_Green","John_McCarthy_(cient%C3%ADfico)","Sistema_de_tipos","Fortran","Simula","C_(lenguaje_de_programaci%C3%B3n)","Combined_Programming_Language","Pascal_(lenguaje_de_programaci%C3%B3n)","Ada_(lenguaje_de_programaci%C3%B3n)","BASIC","Lenguaje_de_programaci%C3%B3n","Acr%C3%B3nimo","Idioma_ingl%C3%A9s","Lenguaje_de_programaci%C3%B3n_Pascal","C_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n_Ada","Niklaus_Wirth","C._A._R._Hoare","Lenguaje_de_programaci%C3%B3n_Pascal","N%C3%BAmeros_complejos","Adriaan_van_Wijngaarden","ABC_ALGOL","ISSN","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Fortran","titulo":"Fortran","contenido":"Fortran (previamente FORTRAN,\u200b contraccion del ingles The IBM Mathematical Formula Translating System) es un lenguaje de programacion de alto nivel de proposito general,\u200b procedural\u200b e imperativo, que esta especialmente adaptado al calculo numerico y a la computacion cientifica. Desarrollado originalmente por IBM en 1957 para el equipo IBM 704, y usado para aplicaciones cientificas y de ingenieria, el FORTRAN vino a dominar esta area de la programacion desde el principio y ha estado en uso continuo por mas de medio siglo en areas de computo intensivo tales como la prediccion numerica del tiempo, analisis de elementos finitos, dinamica de fluidos computacional (CFD), fisica computacional y quimica computacional. Es uno de los lenguajes mas populares en el area de la computacion de alto rendimiento y es el lenguaje usado para programas que evaluan el desempe\u00f1o (benchmark) y el ranking de los supercomputadores mas rapidos del mundo.\u200b  El FORTRAN abarca un linaje de versiones, cada una de las cuales evoluciono para a\u00f1adir extensiones al lenguaje mientras que usualmente retenia compatibilidad con las versiones previas. Versiones sucesivas han a\u00f1adido soporte para procesamiento de datos basados en caracteres (FORTRAN 77), programacion de matrices, programacion modular y programacion orientada a objetos (Fortran 90/95), y programacion generica (Fortran 2003).  A finales de 1953, John W. Backus sometio una propuesta a sus superiores en IBM para desarrollar una alternativa mas practica al lenguaje ensamblador para programar el computador central IBM 704..\u200b:\u200a69\u200a El historico equipo FORTRAN de Backus consistio en los programadores Richard Goldberg, Sheldon F. Best, Harlan Herrick, Peter Sheridan, Roy Nutt, Robert Nelson, Irving Ziller, Lois Haibt y David Sayre.\u200b  A mediados de 1954 fue terminada una especificacion del borrador para el IBM Mathematical Formula Translating System. El primer manual de FORTRAN aparecio en octubre de 1956, porque los clientes eran reacios a usar un lenguaje de programacion de alto nivel a menos que su compilador pudiera generar codigo cuyo desempe\u00f1o fuera comparable al de un codigo hecho a mano en lenguaje ensamblador.  Mientras que la comunidad era esceptica sobre este nuevo lenguaje, este redujo en 20 veces el numero de sentencias de programacion necesarias para operar una maquina, y rapidamente gano aceptacion. Durante una entrevista en 1979 con Think, la revista de los empleados de IBM, el creador John Backus, dijo: \"Mucho de mi trabajo surgio por ser perezoso. No me gustaba escribir programas y por eso, cuando estaba trabajando en el IBM 701 escribiendo programas para computar trayectorias de misiles, comence a trabajar en un sistema de programacion para hacer mas facil escribir programas\".\u200b  El lenguaje fue ampliamente adoptado por los cientificos para escribir programas numericamente intensivos, que incentivo a los escritores de compiladores a producir compiladores que pudieran generar un codigo mas rapido y mas eficiente. La inclusion en el lenguaje de un tipo de datos y de la aritmetica de numeros complejos amplio la gama de aplicaciones para las cuales el lenguaje se adaptaba especialmente e hizo al FORTRAN especialmente adecuado para aplicaciones tecnicas tales como la ingenieria electrica.  Hacia 1960, las versiones de FORTRAN estaban disponibles para los computadores IBM 709, 650, 1620, y 7090. La cada vez mayor popularidad del FORTRAN estimulo significativamente a fabricantes de computadores de la competencia a proporcionar compiladores FORTRAN para sus maquinas, asi que alla por 1963 existian mas de 40 compiladores FORTRAN. Por estas razones, el FORTRAN es considerado el primer lenguaje de programacion ampliamente usado soportado a traves de una variedad de arquitecturas de computador.  El desarrollo del FORTRAN fue paralelo a la temprana evolucion de la tecnologia del compilador. De hecho, muchos avances en la teoria y el dise\u00f1o de compiladores fueron motivados especificamente por la necesidad de generar codigo eficiente para los programas en FORTRAN.  El primer manual de FORTRAN lo describe como un Sistema Traductor de Formulas (Formula Translating System), y mostraba el nombre en versalita, FORTRAN.\u200b \u200b Otras fuentes sugieren que el nombre significa Traductor de Formulas (Formula Translator),\u200b o Traduccion de Formulas (Formula Translation.\u200b Los primeros ordenadores IBM no soportaban minusculas y los nombres de las versiones del lenguaje hasta FORTRAN 77 se escribian normalmente en mayusculas\u200b (FORTRAN 77 fue la ultima version en la que el juego de caracteres de Fortran incluia solo mayusculas\u200b). Desde Fortran 90, las normas oficiales del lenguaje Fortran lo denominan \"Fortran\" con mayuscula inicial.  Algunas otras versiones subsiguientes fueron:  El lenguaje fue dise\u00f1ado teniendo en cuenta que los programas serian escritos en tarjetas perforadas de 80 columnas. Asi por ejemplo, las lineas debian ser numeradas y la unica alteracion posible en el orden de ejecucion era producida con la instruccion goto. Estas caracteristicas han evolucionado de version en version. Las actuales contienen subprogramas, recursion y una variada gama de estructuras de control.  Como fue una primera tentativa de creacion de un lenguaje de programacion de alto nivel, tiene una sintaxis considerada arcaica por muchos programadores que aprenden lenguajes mas modernos. Es dificil escribir un bucle \"for\", y errores en la escritura de un solo caracter pueden llevar a errores durante el tiempo de ejecucion en vez de errores de compilacion, en el caso de que no se usen las construcciones mas frecuentes. Algunas de las primeras versiones no poseian facilidades que son consideradas muy utiles, tal como la asignacion dinamica de memoria.  Se debe tener en cuenta que la sintaxis de Fortran fue orientada para el uso en trabajos numericos y cientificos. Muchas de sus deficiencias han sido abordadas en revisiones recientes del lenguaje. Por ejemplo, Fortran 95 posee comandos mucho mas breves para efectuar operaciones matematicas con matrices y dispone de tipos. Esto no solo mejora mucho la lectura del programa sino que ademas aporta informacion util al compilador.  Por estas razones Fortran practicamente no se usa fuera de los campos cientificos y del analisis numerico, pero permanece como el lenguaje preferido para desarrollar aplicaciones de computacion numerica de alto rendimiento.  Existen dos versiones normalizadas del lenguaje.  A continuacion se muestra el codigo fuente en lenguaje Fortran de un programa que permite realizar un ajuste o regresion lineal de una serie de datos:  Basicamente, en el programa se lee desde un archivo ASCII cierta cantidad de pares ordenados, se convoca a una rutina que calcula la recta de ajuste correspondiente, usando el metodo de minimos cuadrados, para luego retornar aportando los coeficientes o parametros de la recta en cuestion.  La portabilidad era un problema en los primeros tiempos porque no habia un estandar acordado -ni siquiera el manual de referencia de IBM- y las empresas informaticas competian por diferenciar sus ofertas de las de los demas ofreciendo caracteristicas incompatibles.  Los estandares han mejorado la portabilidad.  El estandar de 1966 proporcionaba una sintaxis y una semantica de referencia, pero los vendedores seguian proporcionando extensiones incompatibles.  Aunque los programadores cuidadosos se daban cuenta de que el uso de extensiones incompatibles causaba costosos problemas de portabilidad, y por ello utilizaban programas como The PFORT Verifier,\u200b\u200b no fue hasta despues de la norma de 1977, cuando la Oficina Nacional de Estandares (ahora NIST) publico FIPS PUB 69, que los procesadores comprados por el Gobierno de Estados Unidos debian diagnosticar las extensiones de la norma.  En lugar de ofrecer dos procesadores, esencialmente cada compilador finalmente tenia al menos una opcion para diagnosticar extensiones.\u200b\u200b  Las extensiones incompatibles no eran el unico problema de portabilidad.  Para los calculos numericos, es importante tener en cuenta las caracteristicas de la aritmetica.  Esto fue abordado por Fox et al. en el contexto del estandar de 1966 por la biblioteca PORT.\u200b Las ideas en ella se utilizaron ampliamente, y finalmente se incorporaron en el estandar de 1990 por medio de funciones intrinsecas de consulta.  La adopcion generalizada (ahora casi universal) del estandar IEEE 754 para la aritmetica binaria de punto flotante ha eliminado esencialmente este problema.  El acceso al entorno informatico (por ejemplo, la linea de comandos del programa, las variables de entorno, la explicacion textual de las condiciones de error) siguio siendo un problema hasta que fue abordado por la norma de 2003.  Grandes colecciones de software de biblioteca que podrian describirse como vagamente relacionadas con la ingenieria y los calculos cientificos, como las bibliotecas de graficos, se han escrito en C, y por lo tanto el acceso a ellas presentaba un problema de portabilidad.  Esto se ha solucionado con la incorporacion de la interoperabilidad de C en la norma de 2003.  Ahora es posible (y relativamente facil) escribir un programa totalmente portable en Fortran, incluso sin recurrir a un preprocesador. ","snippet":"Fortran (previamente FORTRAN,\u200b contraccion del ingles The IBM Mathematical Formula Translating System) es un lenguaje de programacion de alto nivel de proposito general,\u200b procedural\u200b e imperativo, que","enlaces_salientes":["Fortran","Fortran","Fortran","IBM","John_Backus","Extensi%C3%B3n_de_archivo","1957","John_Backus","Speedcoding","Licencia_de_software","Licencia_MIT","Idioma_ingl%C3%A9s","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_alto_nivel","Programaci%C3%B3n_procedural","Programaci%C3%B3n_imperativa","C%C3%A1lculo_num%C3%A9rico","Computaci%C3%B3n_cient%C3%ADfica","IBM","1957","IBM_704","M%C3%A9todo_de_los_elementos_finitos","Din%C3%A1mica_de_fluidos_computacional","F%C3%ADsica_computacional","Qu%C3%ADmica_computacional","Computaci%C3%B3n_de_alto_rendimiento","Benchmark_(inform%C3%A1tica)","Supercomputador","TOP500","Arreglo_(computaci%C3%B3n)","Programaci%C3%B3n_modular","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_gen%C3%A9rica","Tarjeta_perforada","John_W._Backus","IBM","Lenguaje_ensamblador","Computador_central","IBM_704","1956","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_alto_nivel","Tipo_de_dato","N%C3%BAmero_complejo","IBM_709","IBM_650","IBM_1620","IBM_7090","Versalita","Estructuras_de_control","ANSI","ANSI","ASCII","M%C3%ADnimos_cuadrados","Sintaxis_(lenguajes_de_programaci%C3%B3n)","Instituto_Nacional_de_Est%C3%A1ndares_y_Tecnolog%C3%ADa","IEEE_754-2008","Preprocesador","American_National_Standards_Institute","John_Backus","Digital_object_identifier","International_Business_Machines_Corporation","IBM","New_York_City","McGraw_Hill_Education","ISBN","ASCII","ISBN","Digital_object_identifier","ISSN","Semantic_Scholar","Digital_object_identifier","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Bloque_de_c%C3%B3digo","titulo":"Bloque de codigo","contenido":"El bloque de codigo es un usuario o seccion de codigo con una o mas declaraciones y sentencias. Un lenguaje de programacion que permite bloques, incluyendo bloques anidados dentro de otros bloques es llamado un lenguaje de programacion estructurado por bloques.  Ideas de la estructura del bloque se desarrollaron en la decada de los a\u00f1os 1950, durante el desarrollo de los primeros autocodes y fueron formalizados en los informes de Algol 58 y Algol 60. Algol 58 introdujo la nocion de la \"sentencia compuesta\", que estaba relacionada unicamente con control de flujo.\u200b El posterior informe revisado que describe la sintaxis y la semantica de Algol 60 introdujo la nocion de un bloque, consistiendo en \"una secuencia de sentencias encerrada entre begin y end...\" en la que \"cada declaracion aparece en un bloque de esta manera y es valida solo para ese bloque\".\u200b  La funcion de los bloques de programacion es permitir que grupos sentencias sean tratados como si fueran una sola sentencia, y restringir el ambito lexico de las variables, los procedimientos y funciones declaradas en un bloque para que no entre en conflicto con variables con el mismo nombre utilizadas para diferentes propositos en otras partes de un programa.  La nocion de bloques es introducida por diferentes sintaxis en diferentes lenguajes, pero hay dos grandes familias: la familia del ALGOL en que los bloques estan delimitados por las palabras clave begin y end, y la familia de C en la que los bloques estan delimitados por llaves { y }. Algunas otras tecnicas utilizadas son el uso de sangria, y s-expression con una palabra clave sintactica como lambda o let (como en la familia del Lisp).  En un lenguaje de programacion estructurado en bloque, los nombres de las variables y otros objetos, como los procedimientos que son declarados en bloques externos son visibles dentro de otros bloques internos, a menos que sean sombreado por un objeto del mismo nombre.  Algunos lenguajes que soportan bloques con declaraciones de variables no soportan completamente todas las declaraciones; por ejemplo muchos lenguajes derivados de C no permitan la definicion de una funcion dentro de un bloque. Y a diferencia de su antecesor Algol, Pascal no soporta el uso de bloques con sus propias declaraciones dentro del begin y end de un bloque existente, solo sentencias compuestas permitiendo una secuencia de declaraciones agrupadas en if, while, repeat y otras sentencias de control.  Con la aparicion de miniprocesadores mas potentes, la programacion planificada pierde sus fundamentos en favor de la programacion de sistemas dirigidos por datos. Esto marca el final del uso de la programacion monolitica gobernada por Assembler, C, Pascal y fundamentalmente COBOL. Con la liberacion de su Clipper version 5.0, (en 1990) Nantucket proporciona un nuevo tipo de datos al cual llamo CodeBlock. Este nace de la necesidad de suprimir el uso de macroinstrucciones o macrosubstituciones. Estas macroinstrucciones o macrosubstituciones tambien se abreviaron para pasar a llamarse simplemente \"macros\". En la actualidad existen otros lenguajes de programacion que encontraron utiles la definicion y conceptos subyacentes en el termino CodeBlock.  Sea un arreglo con datos, el recorrido iterativo del mismo se produce con la instruccion AEVAL(), la cual posee la sintaxis:  <aArreglo>  <bBloqueDeCodigo>  <nInicio>  <nCantidad>  <lAsignar>   Sea una porcion de codigo ejecutable agrupado en una rutina llamada \"Procedimiento()\".  <bBloqueDeCodigo>  <ListaDeExpresiones,...>  Los Bloques de Codigo son el intento de substituto de las macroinstrucciones de Clipper. Las macros tienen fundamento de existencia en la necesidad de crear variables dinamicamente, construir expresiones regulares y ejecutarlas en tiempo de ejecucion.  Esa posibilidad, sobreexplotada, ocasiona una gran carga en los mantenimientos de los sistemas desarrollados con estas macros debido a que ocultan las fallas en tiempo de desarrollo y detonan en tiempo de ejecucion, en el ambiente del usuario final. Generalmente las macros son preferidas para el desarrollo de aplicaciones con escasa o nula planificacion. ","snippet":"El bloque de codigo es un usuario o seccion de codigo con una o mas declaraciones y sentencias. Un lenguaje de programacion que permite bloques, incluyendo bloques anidados dentro de otros bloques es ","enlaces_salientes":["Bloque_de_c%C3%B3digo","Bloque_de_c%C3%B3digo","Bloque_de_c%C3%B3digo","Bloque_de_programaci%C3%B3n","Entorno_de_desarrollo_integrado","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Algol_60","ALGOL","S-expression","Lisp","%C3%81mbito_(programaci%C3%B3n)","Algol","Pascal_(lenguaje_de_programaci%C3%B3n)","Clipper_(lenguaje_de_programaci%C3%B3n)","Digital_object_identifier","ISSN","Digital_object_identifier","Control_de_autoridades"]}
{"url":"Lista_enlazada","titulo":"Lista enlazada","contenido":"En ciencias de la computacion, una lista enlazada es una de las estructuras de datos fundamentales, y puede ser usada para implementar otras estructuras de datos. Consiste en una secuencia de nodos, en los que se guardan campos de datos arbitrarios y una o dos referencias, enlaces o punteros al nodo anterior o posterior. El principal beneficio de las listas enlazadas respecto a los vectores convencionales es que el orden de los elementos enlazados puede ser diferente al orden de almacenamiento en la memoria o el disco, permitiendo que el orden de recorrido de la lista sea diferente al de almacenamiento.  Una lista enlazada es un tipo de dato autorreferenciado porque contienen un puntero o enlace (en ingles link, del mismo significado) a otro dato del mismo tipo. Las listas enlazadas permiten inserciones y eliminacion de nodos en cualquier punto de la lista en tiempo constante (suponiendo que dicho punto esta previamente identificado o localizado), pero no permiten un acceso aleatorio. Existen diferentes tipos de listas enlazadas: listas enlazadas simples, listas doblemente enlazadas, listas enlazadas circulares y listas enlazadas doblemente circulares.  Las listas enlazadas pueden ser implementadas en muchos lenguajes. Lenguajes tales como Lisp, Scheme y Haskell tienen estructuras de datos ya construidas, junto con operaciones para acceder a las listas enlazadas. Lenguajes imperativos u orientados a objetos tales como C o C++ y Java, respectivamente, disponen de referencias para crear listas enlazadas.  Las listas enlazadas fueron desarrolladas en 1955-56 por Cliff Shaw y Herbert Simon en RAND Corporation, como la principal estructura de datos para su Lenguaje de Procesamiento de la Informacion (IPL). IPL fue usado por los autores para desarrollar varios programas relacionados con la inteligencia artificial, incluida la Maquina de la Teoria General, el Solucionador de Problemas Generales, y un programa informatico de ajedrez. Se publico en IRE Transactions on Information Theory en 1956, y en distintas conferencias entre 1957-1959, incluida Proceedings of the Western Joint Computer en 1957 y 1958, y en Information Processing (Procedentes de la primera conferencia internacional del procesamiento de la informacion de la Unesco) en 1959. El diagrama clasico actual, que consiste en bloques que representan nodos de la lista con flechas apuntando a los sucesivos nodos de la lista, aparecio en Programming the Logic Theory Machine, de Newell y Shaw. Newell y Simon fueron reconocidos por el ACM Turing Award en 1975 por \u201chacer contribuciones basicas a la inteligencia artificial, a la psicologia del conocimiento humano y al procesamiento de las listas\u201d.  El problema de los traductores del procesamiento natural del lenguaje condujo a Victor Yngve del Instituto Tecnologico de Massachusetts (MIT) a usar listas enlazadas como estructura de datos en su COMIT, lenguaje de programacion para computadoras, que investigo en el campo de la Linguistica computacional. Un informe de este lenguaje, titulado \u201cA programming language for mechanical translation\u201d aparecio en Mechanical Translation en 1958.  LISP, el principal procesador de listas, fue creado en 1958. Una de las principales estructuras de datos de LISP es la lista enlazada.  En torno a los 60, la utilidad de las listas enlazadas y los lenguajes que utilizaban estas estructuras como su principal representacion de datos estaba bien establecida. Bert Green, del Lincoln Laboratory del MIT, publico un estudio titulado Computer languages for symbol manipulation en IRE Transaction on Human Factors in Electronics en marzo de 1961 que resumia las ventajas de las listas enlazadas. Un posterior articulo, A Comparison of list-processing computer languages de Bobrow y Raphael, aparecia en Communications of the ACM en abril de 1964.  Muchos sistemas operativos desarrollados por la empresa Technical Systems Consultants (originalmente de West Lafayette Indiana y despues de Raleigh, Carolina del Norte) usaron listas enlazadas simples como estructuras de ficheros. Un directorio de entrada apuntaba al primer sector de un fichero y daba como resultado porciones de la localizacion del fichero mediante punteros. Los sistemas que utilizaban esta tecnica incluian Flex (para el Motorola 6800 CPU), mini-Flex (la misma CPU) y Flex9 (para el Motorola 6809 CPU). Una variante desarrollada por TSC se comercializo a Smoke Signal Broadcasting en California, usando listas doblemente enlazadas del mismo modo.  El sistema operativo TSS, desarrollado por IBM para las maquinas System 360/370, usaba una lista doblemente enlazada para su catalogo de ficheros de sistema. La estructura de directorios era similar a Unix, donde un directorio podia contener ficheros u otros directorios que se podian extender a cualquier profundidad. Una utilidad fue creada para arreglar problemas del sistema despues de un fallo desde las porciones modificadas del catalogo de ficheros que estaban a veces en memoria cuando ocurria el fallo. Los problemas eran detectados por comparacion de los enlaces posterior y anterior por consistencia. Si el siguiente de ellos era corrupto y el anterior enlace del nodo infectado era encontrado, el enlace posterior era asignado al nodo marcado con el enlace anterior.  Es una lista enlazada de nodos, donde cada nodo tiene un unico campo de enlace. Una variable de referencia contiene una referencia al primer nodo, cada nodo (excepto el ultimo) enlaza con el nodo siguiente, y el enlace del ultimo nodo contiene NULL para indicar el final de la lista. Aunque normalmente a la variable de referencia se la suele llamar top, se le podria llamar como se desee.  Un tipo de lista enlazada mas sofisticado es la lista doblemente enlazada o lista enlazadas de dos vias. Cada nodo tiene dos enlaces: uno apunta al nodo anterior, o apunta al valor NULL si es el primer nodo; y otro que apunta al nodo siguiente, o apunta al valor NULL si es el ultimo nodo.  En algun lenguaje de muy bajo nivel, XOR-Linking ofrece una via para implementar listas doblemente enlazadas, usando una sola palabra para ambos enlaces, aunque esta tecnica no se suele utilizar.  En una lista enlazada circular, el primer y el ultimo nodo estan unidos juntos. Esto se puede hacer tanto para listas enlazadas simples como para las doblemente enlazadas. Para recorrer una lista enlazada circular podemos empezar por cualquier nodo y seguir la lista en cualquier direccion hasta que se regrese hasta el nodo original. Desde otro punto de vista, las listas enlazadas circulares pueden ser vistas como listas sin comienzo ni fin. Este tipo de listas es el mas usado para dirigir buffers para \u201cingerir\u201d datos, y para visitar todos los nodos de una lista a partir de uno dado.  Cada nodo tiene un enlace, similar al de las listas enlazadas simples, excepto que el siguiente nodo del ultimo apunta al primero. Como en una lista enlazada simple, los nuevos nodos pueden ser solo eficientemente insertados despues de uno que ya tengamos referenciado. Por esta razon, es usual quedarse con una referencia solamente al ultimo elemento en una lista enlazada circular simple, esto nos permite rapidas inserciones al principio, y tambien permite accesos al primer nodo desde el puntero del ultimo nodo.\u200b  En una lista enlazada doblemente circular, cada nodo tiene dos enlaces, similares a los de la lista doblemente enlazada, excepto que el enlace anterior del primer nodo apunta al ultimo y el enlace siguiente del ultimo nodo, apunta al primero. Como en una lista doblemente enlazada, las inserciones y eliminaciones pueden ser hechas desde cualquier punto con acceso a algun nodo cercano. Aunque estructuralmente una lista circular doblemente enlazada no tiene ni principio ni fin, un puntero de acceso externo puede establecer el nodo apuntado que esta en la cabeza o al nodo cola, y asi mantener el orden tan bien como en una lista doblemente enlazada.  A veces las listas enlazadas tienen un nodo centinela (tambien llamado falso nodo o nodo ficticio) al principio o al final de la lista, el cual no es usado para guardar datos. Su proposito es simplificar o agilizar algunas operaciones, asegurando que cualquier nodo tiene otro anterior o posterior, y que toda la lista (incluso alguna que no contenga datos) siempre tenga un \u201cprimer y ultimo\u201d nodo.  Las listas enlazadas son usadas como modulos para otras muchas estructuras de datos, tales como pilas, colas y sus variaciones.  El campo de datos de un nodo puede ser otra lista enlazada. Mediante este mecanismo, podemos construir muchas estructuras de datos enlazadas con listas; esta practica tiene su origen en el lenguaje de programacion Lisp, donde las listas enlazadas son una estructura de datos primaria (aunque no la unica), y ahora es una caracteristica comun en el estilo de programacion funcional.  A veces, las listas enlazadas son usadas para implementar vectores asociativos, y estas en el contexto de las llamadas listas asociativas. Hay pocas ventajas en este uso de las listas enlazadas; hay mejores formas de implementar estas estructuras, por ejemplo con arboles binarios de busqueda equilibrados. Sin embargo, a veces una lista enlazada es dinamicamente creada fuera de un subconjunto propio de nodos semejante a un arbol, y son usadas mas eficientemente para recorrer esta serie de datos.  Como muchas opciones en programacion y desarrollo, no existe un unico metodo correcto para resolver un problema. Una estructura de lista enlazada puede trabajar bien en un caso pero causar problemas en otros. He aqui una lista con algunas de las ventajas mas comunes que implican las estructuras de tipo lista. En general, teniendo una coleccion dinamica donde los elementos estan siendo a\u00f1adidos y eliminados frecuentemente e importa la localizacion de los nuevos elementos introducidos se incrementa el beneficio de las listas enlazadas.  Las listas enlazadas poseen muchas ventajas sobre los vectores. Los elementos se pueden insertar en una lista indefinidamente mientras que un vector tarde o temprano se llenara o necesitara ser redimensionado, una costosa operacion que incluso puede no ser posible si la memoria se encuentra fragmentada.  En algunos casos se pueden lograr ahorros de memoria almacenando la misma \u2018cola\u2019 de elementos entre dos o mas listas \u2013 es decir, la lista acaba en la misma secuencia de elementos. De este modo, uno puede a\u00f1adir nuevos elementos al frente de la lista manteniendo una referencia tanto al nuevo como a los viejos elementos - un ejemplo simple de una estructura de datos persistente.  Por otra parte, los vectores permiten acceso aleatorio mientras que las listas enlazadas solo permiten acceso secuencial a los elementos. Las listas enlazadas simples, de hecho, solo pueden ser recorridas en una direccion. Esto hace que las listas sean inadecuadas para aquellos casos en los que es util buscar un elementos por su indice rapidamente, como el heapsort. El acceso secuencial en los vectores tambien es mas rapido que en las listas enlazadas.  Otra desventaja de las listas enlazadas es el almacenamiento extra necesario para las referencias, que a menudos las hacen poco practicas para listas de peque\u00f1os datos como caracteres o valores booleanos.  Tambien puede resultar lento y abusivo el asignar memoria para cada nuevo elemento. Existe una variedad de listas enlazadas que contemplan los problemas anteriores para resolver los mismos. Un buen ejemplo que muestra los pros y contras del uso de vectores sobre listas enlazadas es la implementacion de un programa que resuelva el problema de Flavio Josefo. Este problema consiste en un grupo de personas dispuestas en forma de circulo. Se empieza a partir de una persona predeterminadas y se cuenta n veces, la persona n-esima se saca del circulo y se vuelve a cerrar el grupo. Este proceso se repite hasta que queda una sola persona, que es la que gana. Este ejemplo muestra las fuerzas y debilidades de las listas enlazadas frente a los vectores, ya que viendo a la gente como nodos conectados entre si en una lista circular se observa como es mas facil suprimir estos nodos. Sin embargo, se ve como la lista perdera utilidad cuando haya que encontrar a la siguiente persona a borrar. Por otro lado, en un vector el suprimir los nodos sera costoso ya que no se puede quitar un elemento sin reorganizar el resto. Pero en la busqueda de la n-esima persona tan solo basta con indicar el indice n para acceder a el resultando mucho mas eficiente.  Las listas doblemente enlazadas requieren mas espacio por nodo y sus operaciones basicas resultan mas costosas pero ofrecen una mayor facilidad para manipular ya que permiten el acceso secuencial a lista en ambas direcciones. En particular, uno puede insertar o borrar un nodo en un numero fijo de operaciones dando unicamente la direccion de dicho nodo (Las listas simples requieren la direccion del nodo anterior para insertar o suprimir correctamente). Algunos algoritmos requieren el acceso en ambas direcciones para poder adquirir las listas enlazadas.  Las listas circulares son mas utiles para describir estructuras circulares y tienen la ventaja de poder recorrer la lista desde cualquier punto. Tambien permiten el acceso rapido al primer y ultimo elemento por medio de un puntero simple.  La busqueda comun y los algoritmos de ordenacion son menos complicados si se usan los llamados Nodos Centinelas o Nodos Ficticios, donde cada elemento apunta a otro elemento y nunca a nulo. El Nodo Centinela o Puntero Cabeza contiene, como otro, un puntero siguiente que apunta al que se considera como primer elemento de la lista. Tambien contiene un puntero previo que hace lo mismo con el ultimo elemento. El Nodo Centinela es definido como otro nodo en una lista doblemente enlazada, la asignacion del puntero frente no es necesaria y los puntero anterior y siguiente estaran apuntando a si mismo en ese momento. Si los punteros anterior y siguiente apuntan al Nodo Centinela la lista se considera vacia. En otro caso, si a la lista se le a\u00f1aden elementos ambos puntero apuntaran a otros nodos. Estos Nodos Centinelas simplifican muchos las operaciones pero hay que asegurarse de que los punteros anterior y siguiente existen en cada momento. Como ventaja eliminan la necesidad de guardar la referencia al puntero del principio de la lista y la posibilidad de asignaciones accidentales. Por el contrario, usan demasiado almacenamiento extra y resultan complicados en algunas operaciones.  Los lenguajes que no aceptan cualquier tipo de referencia pueden crear uniones reemplazando los punteros por indices de un vector. La ventaja es de mantener un vector de entradas, donde cada entrada tiene campos enteros indicando el indice del siguiente elemento del vector. Pueden haber nodos sin usarse. Si no hay suficiente espacio, pueden usarse vectores paralelos.  Entonces una lista enlazada puede ser construida, creado un vector con esta estructura, y una variable entera para almacenar el indice del primer elemento. (ver en la seccion de implementaciones).  Las utilidades de esta propuesta son:  Algunas desventajas son:  Por estas razones, la propuesta se usa principalmente para lenguajes que no soportan asignacion de memoria dinamica. Estas desventajas se atenuan tambien si el tama\u00f1o maximo de la lista se conoce en el momento en el que el vector se crea.  Muchos lenguajes de programacion tales como Lisp y Scheme tienen listas enlazadas simples ya construidas. En muchos lenguajes de programacion, estas listas estan construidas por nodos, cada uno llamado cons o celda cons. Las celdas cons tienen dos campos: el car, una referencia del dato al nodo, y el cdr, una referencia al siguiente nodo. Aunque las celdas cons pueden ser usadas para construir otras estructuras de datos, este es su principal objetivo.  En lenguajes que soportan tipos abstractos de datos o plantillas, las listas enlazadas ADTs o plantillas estan disponibles para construir listas enlazadas. En otros lenguajes, las listas enlazadas son tipicamente construidas usando referencias junto con el tipo de dato record.  En la seccion de implementaciones hay un ejemplo completo en C y en Maude  Cuando se construye una lista enlazada, nos enfrentamos a la eleccion de si almacenar los datos de la lista directamente en los nodos enlazados de la lista, llamado almacenamiento interno, o simplemente almacenar una referencia al dato, llamado almacenamiento externo. El almacenamiento interno tiene la ventaja de hacer accesos a los datos mas eficientes, requiriendo menos almacenamiento global, teniendo mejor referencia de localidad, y simplifica la gestion de memoria para la lista (los datos son alojados y desalojados al mismo tiempo que los nodos de la lista).  El almacenamiento externo, por otro lado, tiene la ventaja de ser mas generico, en la misma estructura de datos y codigo maquina puede ser usado para una lista enlazada, no importa cual sea su tama\u00f1o o los datos. Esto hace que sea mas facil colocar el mismo dato en multiples listas enlazadas. Aunque con el almacenamiento interno los mismos datos pueden ser colocados en multiples listas incluyendo multiples referencias siguientes en la estructura de datos del nodo, esto podria ser entonces necesario para crear rutinas separadas para a\u00f1adir o borrar celdas basadas en cada campo. Esto es posible creando listas enlazadas de elementos adicionales que usen almacenamiento interno usando almacenamiento externo, y teniendo las celdas de las listas enlazadas adicionales almacenadas las referencias a los nodos de las listas enlazadas que contienen los datos.  En general, si una serie de estructuras de datos necesita ser incluida en multiples listas enlazadas, el almacenamiento externo es el mejor enfoque. Si una serie de estructuras de datos necesitan ser incluidas en una sola lista enlazada, entonces el almacenamiento interno es ligeramente mejor, a no ser que un paquete generico de listas genericas que use almacenamiento externo este disponible. Asimismo, si diferentes series de datos que pueden ser almacenados en la misma estructura de datos son incluidos en una lista enlazada simple, entonces el almacenamiento interno puede ser mejor.  Otro enfoque que puede ser usado con algunos lenguajes implica tener diferentes estructuras de datos, pero todas tienen los campos iniciales, incluyendo la siguiente (y anterior si es una lista doblemente enlazada) referencia en la misma localizacion. Despues de definir estructuras distintas para cada tipo de dato, una estructura generica puede ser definida para que contenga la minima cantidad de datos compartidos por todas las estructuras y contenidos al principio de las estructuras. Entonces las rutinas genericas pueden ser creadas usando las minimas estructuras para llevar a cabo las operaciones de los tipos de las listas enlazadas, pero separando las rutinas que pueden manejar los datos especificos. Este enfoque es usado a menudo en rutinas de analisis de mensajes, donde varios tipos de mensajes son recibidos, pero todos empiezan con la misma serie de campos, generalmente incluyendo un campo para el tipo de mensaje. Las rutinas genericas son usadas para a\u00f1adir nuevos mensajes a una cola cuando son recibidos, y eliminarlos de la cola en orden para procesarlos. El campo de tipo de mensaje es usado para llamar a la rutina correcta para procesar el tipo especifico de mensaje.  En la seccion implementaciones (en este mismo articulo) se expone codigo referente a este tema.  Hay que notar que cuando usamos almacenamiento externo, se necesita dar un paso extra para extraer la informacion del nodo y hacer un casting dentro del propio tipo del dato. Esto es porque ambas listas, de familias y miembros, son almacenadas en dos listas enlazadas usando la misma estructura de datos (nodo), y este lenguaje no tiene tipos parametricos.  Si conocemos el numero de familias a las que un miembro puede pertenecer en tiempo de compilacion, el almacenamiento interno trabaja mejor. Si, sin embargo, un miembro necesita ser incluido en un numero arbitrario de familias, sabiendo el numero especifico de familias solo en tiempo de ejecucion, el almacenamiento externo sera necesario.  Buscando un elemento especifico en una lista enlazada, incluso si esta es ordenada, normalmente requieren tiempo O (n) (busqueda lineal). Esta es una de las principales desventajas de listas enlazadas respecto a otras estructuras. Ademas algunas de las variantes expuestas en la seccion anterior, hay numerosas vias simples para mejorar el tiempo de busqueda.  En una lista desordenada, una forma simple para decrementar el tiempo de busqueda medio es el mover al frente de forma heuristica, que simplemente mueve un elemento al principio de la lista una vez que es encontrado. Esta idea, util para crear caches simples, asegura que el item usado mas recientemente es tambien el mas rapido en ser encontrado otra vez.  Otro enfoque comun es indizar una lista enlazada usando una estructura de datos externa mas eficiente. Por ejemplo, podemos construir un arbol rojo-negro o una tabla hash cuyos elementos estan referenciados por los nodos de las listas enlazadas. Pueden ser construidos multiples indices en una lista simple. La desventaja es que estos indices puede necesitar ser actualizados cada vez que un nodo es a\u00f1adido o eliminado (o al menos, antes que el indice sea utilizado otra vez).  Tanto las pilas como las colas son a menudo implementadas usando listas enlazadas, y simplemente restringiendo el tipo de operaciones que son soportadas.  La skip list, o lista por saltos, es una lista enlazada aumentada con capas de punteros para saltos rapidos sobre grandes numeros de elementos, y descendiendo hacia la siguiente capa. Este proceso continua hasta llegar a la capa inferior, la cual es la lista actual.  Un arbol binario puede ser visto como un tipo de lista enlazada donde los elementos estan enlazados entre ellos mismos de la misma forma. El resultado es que cada nodo puede incluir una referencia al primer nodo de una o dos listas enlazadas, cada cual con su contenido, formando asi los subarboles bajo el nodo.  Una lista enlazada desenrollada es una lista enlazada cuyos nodos contiene un vector de datos. Esto mejora la ejecucion de la cache, siempre que las listas de elementos esten contiguas en memoria, y reducen la sobrecarga de la memoria, porque necesitas menos metadatos para guardar cada elemento de la lista.  Una tabla hash puede usar listas enlazadas para guardar cadenas de items en la misma posicion de la tabla hash.  Aqui se expone el codigo necesario para complementar el articulo a fin de poder realizar una lectura agil sobre el articulo y a su vez quien necesite el codigo pueda facilmente encontrar el mismo si esta contenido.  Cuando se manipulan listas enlazadas, hay que tener cuidado con no usar valores que hayamos invalidado en asignaciones anteriores. Esto hace que los algoritmos de insertar y borrar nodos en las listas sean algo especiales. A continuacion se expone el pseudocodigo para a\u00f1adir y borrar nodos en listas enlazadas simples, dobles y circulares.  Nuestra estructura de datos tendra dos campos. Vamos a mantener la variable firstNodo que siempre apunta al primer nodo de tal lista, o nulo para la lista vacia.  El recorrido en una lista enlazada es simple, empezamos por el primer nodo y pasamos al siguiente hasta que la lista llegue al final.  El siguiente codigo inserta un elemento a continuacion de otro en una lista simple. El diagrama muestra como funciona.  Insertar al principio de una lista requiere una funcion por separado. Se necesita actualizar firstNodo (primer nodo).  De forma similar, tambien tenemos funciones para borrar un nodo dado o para borrar un nodo del principio de la lista. Ver diagrama.  Advertimos que BorrarPrincipio pone PrimerNodo a nulo cuando se borra el ultimo elemento de la lista. Adjuntar una lista enlazada a otra puede resultar ineficiente a menos que se guarde una referencia a la cola de la lista, porque si no tendriamos que recorrer la lista en orden hasta llegar a la cola y luego a\u00f1adir la segunda lista.  Con estas listas es necesario actualizar muchos mas punteros pero tambien se necesita menos informacion porque podemos usar un puntero para recorrer hacia atras y consultar elementos. Se crean nuevas operaciones y elimina algunos casos especiales. A\u00f1adimos el campo anterior a nuestros nodos, apuntando al elemento anterior, y lastNodo a nuestra estructura, el cual siempre apunta al ultimo elemento de la lista. firstNodo y lastNodo siempre estan a nulo en la lista vacia.  Formas de recorrer la lista:  Hacia Delante  Hacia Atras  Estas funciones simetricas a\u00f1aden un nodo despues o antes de uno dado:  Tambien necesitamos una funcion para insertar un nodo al comienzo de una lista posiblemente vacia.  Una funcion simetrica que inserta al final:  Borrar un nodo es facil, solo requiere usar con cuidado firstNode y lastNode.  Una consecuencia especial de este procedimiento es que borrando el ultimo elemento de una lista se ponen PrimerNodo y UltimoNodo a nulo, habiendo entonces un problema en una lista que tenga un unico elemento.  Estas pueden ser simples o doblemente enlazadas. En una lista circular todos los nodos estan enlazados como un circulo, sin usar nulo. Para listas con frente y final (como una cola), se guarda una referencia al ultimo nodo de la lista. El siguiente nodo despues del ultimo seria el primero de la lista. Los elementos se pueden a\u00f1adir por el final y borrarse por el principio en todo momento. Ambos tipos de listas circulares tienen la ventaja de poderse recorrer completamente empezando desde cualquier nodo. Esto nos permite normalmente evitar el uso de PrimerNodo y UltimoNodo, aunque si la lista estuviera vacia necesitariamos un caso especial, como una variable UltimoNodo que apunte a algun nodo en la lista o nulo si esta vacia. Las operaciones para estas listas simplifican el insertar y borrar nodos en una lista vacia pero introducen casos especiales en la lista vacia.  Asumiendo que someNodo es algun nodo en una lista no vacia, esta lista presenta el comienzo de una lista con someNode.  Hacia Delante  Hacia Atras  Esta funcion inserta un nodo en una lista enlazada doblemente circular despues de un elemento dado:  Para hacer  \"insertBefore\", podemos simplificar \"insertAfter (node.prev, newNode)\". Insertar un elemento en una lista que puede estar vacia requiere una funcion especial.  Para insertar al principio simplificamos \"insertAfter (list.lastNode, node)\".  Como una lista doblemente enlazada, \"removeAfter\" y \"removeBefore\" puede ser implementada con \"remove (list, node.prev)\" y \"remove (list, node.next)\".  Previamente se crea una estructura que contiene los apuntadores:  Y finalmente se declara el vector: integer listHead;  Las listas enlazadas son tipicamente construidas usando referencias junto con el tipo de dato record  Listas simplemente enlazada con el empleo de punteros y direcciones de memoria. En este ejemplo empleamos dos clases una clase TElemento (nodo, item o elemento) y una clase TlistaSL (simplemente ligada, o simplemente enlazada). Cada una de ellas con sus atributos y metodos se\u00f1alando como mas importante aInfo(informacion del elemento) y aSeguinte (puntero al proximo elemento).   En este ejemplo se hace uso de dos clases, una que corresponde a los nodos, que van a ser parte de la lista y la otra clase que corresponde a la lista enlazada simple, en donde se incorporan los metodos de verificar si la lista esta vacia, es decir, no tiene nodos insertados, tambien las operaciones de insercion de nodos (por enfrente y por atras), eliminacion (por enfrente o por atras), impresion y el metodo principal.     Suponiendo que queremos crear una lista enlazada de familias y sus miembros. Usando almacenamiento interno, la estructura podria ser como la siguiente:  Para mostrar una lista completa de familias y sus miembros usando almacenamiento interno podriamos escribir algo como esto:  Usando almacenamiento externo, nosotros podriamos crear las siguientes estructuras:  Para mostrar una lista completa de familias y sus miembros usando almacenamiento externo, podriamos escribir: ","snippet":"En ciencias de la computacion, una lista enlazada es una de las estructuras de datos fundamentales, y puede ser usada para implementar otras estructuras de datos. Consiste en una secuencia de nodos, e","enlaces_salientes":["Lista_enlazada","Lista_enlazada","Lista_enlazada","Lista_(tipo_de_dato_abstracto)","Ciencias_de_la_computaci%C3%B3n","Estructura_de_datos","Nodo_(inform%C3%A1tica)","Puntero_(inform%C3%A1tica)","Vector_(inform%C3%A1tica)","Acceso_aleatorio","Lenguaje_de_programaci%C3%B3n","Lisp","Scheme","Haskell","Programaci%C3%B3n_orientada_a_objetos","Lenguaje_de_programaci%C3%B3n_C","C%2B%2B","Lenguaje_de_programaci%C3%B3n_Java","RAND","Inteligencia_artificial","Ajedrez","Unesco","Instituto_Tecnol%C3%B3gico_de_Massachusetts","COMIT","Ling%C3%BC%C3%ADstica_computacional","LISP","LISP","NULL","Lista_doblemente_enlazada","NULL","NULL","Pila_(estructura_de_datos)","Cola_(estructura_de_datos)","Persistencia_de_objetos","Persistencia_de_objetos","Heapsort","Problema_de_Flavio_Josefo","Lenguajes_de_programaci%C3%B3n","Lisp","Scheme","CAR_y_CDR","CAR_y_CDR","Lenguaje_de_programaci%C3%B3n_C","Maude_(lenguaje_de_programaci%C3%B3n)","%C3%81rbol_rojo-negro","Hash","%C3%8Dndice_(base_de_datos)","Pila_(estructura_de_datos)","Cola_(estructura_de_datos)","Skip_list","%C3%81rbol_binario","Nodo_(inform%C3%A1tica)","Hash","Hash","Pseudoc%C3%B3digo","Maude_(lenguaje_de_programaci%C3%B3n)","ISBN","National_Institute_of_Standards_and_Technology","2004","2004","MIT_Press","John_McCarthy_(cient%C3%ADfico)","Donald_Knuth","Thomas_H._Cormen","Charles_E._Leiserson","Ronald_L._Rivest","Clifford_Stein","Introduction_to_Algorithms","Allen_Newell","Maurice_Vincent_Wilkes","Maurice_Vincent_Wilkes","2005","Wayback_Machine","Control_de_autoridades","Gemeinsame_Normdatei"]}
{"url":"Argumento_(inform%C3%A1tica)#Paso_de_Argumentos","titulo":"Argumento (informatica)","contenido":"En ciencias de la computacion, un parametro es una variable utilizada para recibir valores de entrada en una rutina, subrutina o metodo. Dichos valores, que seran enviados desde la rutina invocante, son llamados argumentos. La subrutina usa los valores asignados a sus parametros para alterar su comportamiento en tiempo de ejecucion. La mayor parte de los lenguajes de programacion pueden definir subrutinas que aceptan cero o mas argumentos.  Existen cinco formas de pasar un argumento a una funcion (subrutina) o procedimiento: por valor, por referencia, por resultado, por valor-resultado y por nombre.  El paso de parametros por valor consiste en copiar el contenido de la variable que queremos pasar en otra dentro del ambito local de la subrutina, consiste pues en copiar el contenido de la memoria del argumento que se quiere pasar a otra direccion de memoria, correspondiente al argumento dentro del ambito de dicha subrutina. Se tendran dos valores duplicados e independientes, con lo que la modificacion de uno no afecta al otro.  El paso de parametros por referencia consiste en proporcionar a la subrutina a la que se le quiere pasar el argumento la direccion de memoria del dato. En este caso se tiene un unico valor referenciado (o apuntado) desde dos puntos diferentes, el programa principal y la subrutina a la que se le pasa el argumento, por lo que cualquier accion sobre el parametro se realiza sobre la misma posicion de memoria.  El paso de la direccion de memoria debe ser transparente al programador. Los lenguajes que permiten tratar con direcciones de memoria, como C, permiten simular el paso de argumentos por referencia, sin disponer realmente de esta caracteristica.  Es un tipo poco usado en los lenguajes de programacion actuales. Se basa en que dentro de la funcion se trabaja como si los argumentos hubieran sido pasados por valor pero al acabar la funcion los valores que tengan los argumentos seran copiados a las variables que pertenecian.  Este tipo puede ser simulado en cualquier lenguaje que permita el paso de valores por referencia de la siguiente forma:  Tal y como indica el ejemplo de simulacion de valor-resultado, el orden de copia depende del compilador, lo que implica que la misma funcion pueda dar resultados diferentes segun el compilador usado.  Aqui se exponen unos ejemplos que demuestran las diferencias de estos tipos: ","snippet":"En ciencias de la computacion, un parametro es una variable utilizada para recibir valores de entrada en una rutina, subrutina o metodo. Dichos valores, que seran enviados desde la rutina invocante, s","enlaces_salientes":["Argumento_(inform%C3%A1tica)","Argumento_(inform%C3%A1tica)","Argumento_(inform%C3%A1tica)","Ciencias_de_la_computaci%C3%B3n","Variable_(programaci%C3%B3n)","Rutina_(inform%C3%A1tica)","Subrutina","M%C3%A9todo","Subrutina","Lenguajes_de_programaci%C3%B3n","Funci%C3%B3n_(programaci%C3%B3n)","Procedimiento_(Programaci%C3%B3n)","Memoria_principal","Direcci%C3%B3n_de_memoria","Direcci%C3%B3n_de_memoria","Direcci%C3%B3n_de_memoria","Variable_(programaci%C3%B3n)","Subalgoritmo","Control_de_autoridades"]}
{"url":"PSeInt","titulo":"PSeInt","contenido":"PSeInt es un software libre educativo multiplataforma dirigido a personas que se inician en la programacion.\u200b  PSeInt es la abreviatura de los estados de computacion de  PSeudocodigo Interprete, una herramienta educativa creada en Argentina, utilizada principalmente por estudiantes para aprender los fundamentos de la programacion y el desarrollo de la logica. Es un software muy popular de su tipo y es ampliamente utilizado en universidades de Hispanoamerica y Espa\u00f1a.  Utiliza pseudocodigo para la solucion de algoritmos.  PSeInt esta pensado para asistir a los estudiantes que se inician en la construccion de programas o algoritmos computacionales. El pseudocodigo se suele utilizar como primer contacto para introducir conceptos basicos como el uso de estructuras de control, expresiones, variables, etc, sin tener que lidiar con las particularidades de la sintaxis de un lenguaje real. Este software pretende facilitarle al principiante la tarea de escribir algoritmos en este pseudolenguaje presentando un conjunto de ayudas y asistencias, y brindarle ademas algunas herramientas adicionales que le ayuden a encontrar errores y comprender la logica de los algoritmos.  PSeInt es una herramienta para asistir a un estudiante en sus primeros pasos en programacion. Mediante un simple e intuitivo pseudolenguaje en espa\u00f1ol (complementado con un editor de diagramas de flujo), le permite centrar su atencion en los conceptos fundamentales de la algoritmia computacional, minimizando las dificultades propias de un lenguaje y proporcionando un entorno de trabajo con numerosas ayudas y recursos didacticos.  PSeInt fue uno de los Proyectos del Mes en SourceForge en tres oportunidades, desde el 1 de septiembre de 2015,\u200b\u200b desde el 19 de diciembre de 2016\u200b\u200b y desde el 16 de noviembre de 2019.\u200b Asimismo tiene la distincion Open Source Excellence (mas de 100 000 descargas totales o 10 000 descargas mensuales por primera vez.)\u200b  Al iniciar la aplicacion se muestra la estructura basica desde donde es posible escribir el codigo.  Es muy importante, aunque no obligatorio, documentar el codigo (comentar algunas lineas) para que permita rapidamente identificar que partes del mismo hace que cosa, ya que a medida que se avance en el desarrollo y aumente considerablemente la cantidad de lineas, se hara mas dificil encontrar en cual de ellas se encuentra la sentencia que hace algo especifico. Esto se consigue utilizando la doble barra \"//\"  Los ejemplos que se muestran en esta seccion corresponde al mismo programa, pero construido en los tres ciclos While (Mientras), Repeat (Repetir) y For (Para).  El while es una estructura que se ejecuta mientras la pregunta de control obtiene una respuesta verdadera, cuando la respuesta a la pregunta de control es falsa esta abandona el ciclo. Este tipo de estructura es recomendable cuando dentro del programa se desconoce el momento en que se va abandonar el ciclo. Por ejemplo, si necesitamos realizar un programa que solicite numeros y los sume hasta que el usuario ingrese un numero negativo, como no se sabe en que momento el usuario ingresara un valor negativo, la estructura recomendable es el While (Mientras). La caracteristica principal del While es que este primero pregunta y despues hace.  Funciona de igual manera que el While (Mientras), la gran diferencia es que primero hace y despues pregunta, y en lugar de abandonar su ejecucion al obtener una respuesta falsa en la pregunta de control, lo hace al momento de obtener una verdadera.  Es una estructura repetitiva que se emplea cuando se conoce cuantos giros debe realizar el ciclo, por ejemplo, si se realiza un algoritmo que le solicite al usuario cuantos numeros va a sumar, el algoritmo conoceria la cantidad de giros a partir de la cantidad de numeros ingresados por el usuario. ","snippet":"PSeInt es un software libre educativo multiplataforma dirigido a personas que se inician en la programacion.\u200b  PSeInt es la abreviatura de los estados de computacion de  PSeudocodigo Interprete, una h","enlaces_salientes":["PSeInt","PSeInt","PSeInt","Pseudoc%C3%B3digo","Desarrollador_de_software","Licencia_de_software","GNU_General_Public_License","Lenguaje_de_programaci%C3%B3n","C%2B%2B","Plataforma_(inform%C3%A1tica)","32_bits","X86","Ciclo_de_vida_del_lanzamiento_de_software","Software_libre","Software_educativo","Multiplataforma","Programaci%C3%B3n","Argentina","Hispanoam%C3%A9rica","Espa%C3%B1a","Pseudoc%C3%B3digo","Algoritmo","Sintaxis_(lenguajes_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","C_Sharp","Java_(lenguaje_de_programaci%C3%B3n)","PHP","JavaScript","Visual_Basic_.NET","Python","Matlab","Diagrama_de_flujo","Multiplataforma","Microsoft_Windows","GNU/Linux","Mac_OS_X","Android","SourceForge","SourceForge","Control_de_autoridades"]}
{"url":"Bucle_do","titulo":"Bucle do","contenido":"El bucle do, bucle hacer, hacer-mientras, repetir o tambien llamado ciclo do-while, es una estructura de control de la mayoria de los lenguajes de programacion estructurados cuyo proposito es ejecutar un bloque de codigo y repetir la ejecucion mientras se cumpla cierta condicion expresada en la clausula while. La diferencia con el bucle while radica en que este evalua la condicion al principio, y si esta no se cumple, el codigo que esta encerrado dentro del cuerpo no se ejecuta. En cambio, el bucle do-while evalua la condicion para seguir ejecutandose luego de haber ejecutado el codigo dentro de su cuerpo; es decir, siempre se ejecuta por lo menos una vez el codigo.\u200b  La sintaxis en pseudocodigo es la siguiente:  Al igual que en el bloque while, la condicion de salida ha de ser una sentencia que devuelva un valor booleano, y esta puede ser el valor booleano si, verdadero (true) si la condicion se cumple, o falso si esta no se cumple (false). Tambien puede contener el nombre de una variable booleana, y el valor de la expresion dependera de su contenido. Se debe tener en cuenta que ademas de las variables tambien puede haber llamadas a funciones que devuelvan un valor.  La forma mas obvia tal vez, y la mas usada sin duda, son las sentencias comparativas, que usan los operandos igual, diferente, menor o igual, mayor o igual, menor y mayor. En el caso del lenguaje C, se utilizan los siguientes simbolos para representar las comparaciones anteriores: ==,\u00a0!=, <=, >=, <, >,  Suma 1 al valor de a (que inicialmente valia 3) mientras este sea menor o igual que b (que vale 5), lo que da como resultado 6 (notese que, en la ultima ejecucion del bucle, la variable a comienza valiendo 5, por lo que cumple la condicion \"mientras\", y se le suma 1). ","snippet":"El bucle do, bucle hacer, hacer-mientras, repetir o tambien llamado ciclo do-while, es una estructura de control de la mayoria de los lenguajes de programacion estructurados cuyo proposito es ejecutar","enlaces_salientes":["Bucle_do","Bucle_do","Bucle_do","Bucle_while","Estructuras_de_control","Lenguaje_de_programaci%C3%B3n","Programaci%C3%B3n_estructurada","Bloque_de_c%C3%B3digo","Pseudoc%C3%B3digo","%C3%81lgebra_de_Boole","Verdadero","Mentira","C_(lenguaje_de_programaci%C3%B3n)","L%C3%A9xico","ISBN","Control_de_autoridades"]}
{"url":"Microcomputadora","titulo":"Microcomputadora","contenido":"Una microcomputadora, un microcomputador o un microordenador es una computadora peque\u00f1a, con un microprocesador como su unidad central de procesamiento CPU.\u200b Generalmente, el microprocesador incluye los circuitos de almacenamiento (o memoria cache) y entrada/salida en el mismo circuito integrado (o chip).\u200b Las microcomputadoras se hicieron populares desde 1970 y 1980 con el surgimiento de microprocesadores mas potentes. Los antecesores de estas computadoras, las supercomputadoras y las minicomputadoras, eran mucho mas grandes y costosas (aunque las supercomputadoras modernas, como las IBM System z, utilizan uno o mas microprocesadores como CPUs). Muchas microcomputadoras (cuando estan equipadas con un teclado y una pantalla para entrada y salida) son tambien computadoras personales (en sentido general). La abreviatura micro fue comunmente utilizada durante las decadas de 1970 y de 1980,\u200b aunque actualmente este en desuso.  El termino microcomputadora se hizo popular despues de la introduccion del termino minicomputadoras, aunque Isaac Asimov ya lo habia utilizado en su relato \"The Dying Night\" en 1956 (publicado en The Magazine of Fantasy and Science Fiction en julio de ese a\u00f1o).\u200b Notablemente, la microcomputadora reemplazo los diferentes componentes que conformaban el CPU de las minicomputadoras por un solo microprocesador integrado.  El primer microordenador fue el japones SMP80/08 de Sord Computer Corporation (1972), que fue seguido por el SMP80/x (1974).\u200b Los desarrolladores franceses del Micral N (1973) archivaron sus patentes con el termino \"Micro-ordinateur\", equivalente literalmente a \"Microcomputer\" (microcomputador), para nombrar la primera maquina de estado solido con un microprocesador.  En los Estados Unidos, los primeros modelos como el Altair 8800, fueron a menudo vendidos como un conjunto que debia ser ensamblado por el usuario, y venian con una RAM de 256 bytes; y como unicos dispositivos de entrada y salida, los indicadores de luz y switches, demostrando a modo de prueba de concepto, cuan simple podia ser un dispositivo.\u200b  En la medida que los microprocesadores y las memorias semiconductores se hicieron menos costosas, las microcomputadoras se hicieron mas baratas y faciles de usar:  Todas estas mejoras en costo y usabilidad resultaron en una explosion de popularidad al final de los a\u00f1os 1970 y principios de los a\u00f1os 1980. Un largo numero de fabricantes de computadoras empacaron microcomputadoras para ser usadas en aplicaciones de peque\u00f1os negocios. Para 1979, muchas compa\u00f1ias, tales como  Cromemco, Processor Technology, IMSAI, North Star Computers, Southwest Technical Products Corporation, Ohio Scientific, Altos Computer Systems, Morrow Designs y otras, produjeron sistemas como sistemas de bases de datos, contables y procesamiento de texto, dise\u00f1ados tanto para usuarios con todos los recursos o firmas consultoras, como para sistemas de negocio especificos. Esto permitio a los negocios incapaces de proveer licencias de minicomputadoras o compartir tiempo de servicio, la oportunidad de automatizar sus funciones, sin contratar personal a tiempo completo para operar las computadoras. Un representante de estos sistemas utilizaba un bus S-100, un procesador de 8 bits como Intel 8080 o Zilog Z80, y como sistema operativo CP/M o MP/M.  En la decada de 1980 se vive el boom del ordenador domestico (y las videoconsolas) de 8 bits con multitud de competidores (Sinclair Research, Amstrad, Commodore International, Atari, Dragon Data, Texas Instruments, Tandy, los fabricantes de MSX...) pero el paso a los 16 bits deja solo a los Atari ST, Commodore Amiga, Macintosh y los compatible IBM PC como contendientes por el mercado del ordenador personal. Casos espaciales son los equipos Tandy compatibles con el IBM PCjr y el Sinclair QL.  El salto a los 32 bits traera la caida de Atari, Commodore y Tandy (pese a presentar potentes equipos), quedando el mercado repartido entre el minoritario pero siempre innovador Mac (salvado por los pelos con la vuelta de Steve Jobs) y el inmenso mercado del compatible IBM PC, que se ha impuesto en el mercado por el uso de componentes estandar y que el consorcio de fabricantes descubren que es mas productivo definir nuevos estandares que todos adoptan que reinventar la rueda, causa principal del hundimiento de Atari y Commodore. El ultimo episodio en este camino fue la adopcion por Apple de procesadores Intel para sus Mac y el permitir un arranque dual en sus equipos Mac OS/Windows.  De hecho el termino compatible IBM PC ha quedado sin sentido pues IBM salio del mercado con el fracaso de su gama IBM Personal System/2 (que sin embargo aporta dos estandares al actual PC), la mayoria de puertos y controladores del IBM PC son considerados legacy por la industria, que raramente los implementa en sus nuevos equipos y Microsoft Windows ha sustituido al DOS y OS/2  Las computadoras de escritorio y portatiles modernas, las videoconsolas, tabletas, y muchos otros tipos de dispositivos, incluidos smartphones, y sistemas industriales embebidos, pueden ser considerados todos ejemplos de microcomputadoras de acuerdo con las definiciones dadas.  Cada dia el uso de la expresion \"microcomputadora\" (y particularmente la abreviacion \"micro\") ha caido mas en desuso desde la mitad de la decada de 1980, y desde el 2000 ya no es considerado un termino comun.\u200b Este termino, comunmente es asociado con la primera ola de computadoras domesticas y para negocios peque\u00f1os de 8 bits (tales como Apple II, Commodore 64, BBC Micro, y TRS 80). Ademas, quizas influye la gran variedad de los dispositivos modernos basados en microprocesadores que se ajustan a la definicion de \"microcomputadoras\".  En el uso comun, \"microcomputadora\" ha sido suplantado por \"computadora personal\" o \"PC,\" el cual describe equipos que han sido creados para ser utilizados por una persona a la vez, un termino acu\u00f1ado en 1959.\u200b IBM fue el primero en promover el termino \"computadora personal\" para diferenciarlas a ellas mismas de otras microcomputadoras, a menudo llamadas \"computadoras caseras\", ademas de las propias supercomputadoras de IBM y las minicomputadoras. Sin embargo, despues de su lanzamiento, el IBM PC de IBM fue ampliamente imitada, asi como el termino microcomputadora. Los componentes estaban comunmente disponibles para los productores y el BIOS estaba reservado a los ingenieros. Los \"clones\" de las PC de IBM se convirtieron populares, y los terminos \"computadora personal,\" y especialmente \"PC\" utilizado por el publico en general.  Desde la llegada de los microcontroladores (circuitos integrados monoliticos que contienen RAM, ROM y CPU todos sobre una misma placa), el termino \"micro\" es mas comunmente utilizado para referirse a ese significado.  Monitores, teclados y otros dispositivos de entrada y salida pueden estar integrados o separados.  La memoria de computadora en forma de RAM, y al menos otro dispositivo de almacenamiento de memoria menos volatil se suele combinar con la CPU en un bus de sistema en una unidad. Otros dispositivos que componen un sistema de microordenador completo incluyen las baterias, una fuente de alimentacion, un teclado y varios dispositivos de entrada/salida que se utilizan para transmitir informacion hacia y desde un operador humano (impresoras, monitores, dispositivos de interfaz humana). Los microordenadores estan dise\u00f1ados para servir a un unico usuario a la vez, aunque a menudo se pueden modificar mediante software o hardware para servir al mismo tiempo a mas de un usuario.  Los microordenadores encajan bien dentro o debajo de los escritorios o mesas, de manera que sean de facil acceso de los usuarios. Computadoras mas grandes como minicomputadoras, mainframes, y supercomputadoras ocupan grandes armarios o incluso salas dedicadas.  Una microcomputadora viene equipada con al menos un tipo de almacenamiento de datos, normalmente RAM. Aunque algunos microordenadores (particularmente los primeros micros de 8 bits) realizan tareas utilizando solo la RAM, es preferible alguna forma de almacenamiento secundario. En los primeros equipos, este era a menudo un reproductor de casetes de datos (en muchos casos como una unidad externa). Mas tarde, sistemas de almacenamiento secundario (sobre todo disquete y unidad de disco duro) fueron incluidas dentro de la computadora.  Aunque no contenian ningun microprocesador, y estaban construidas alrededor de la Tecnologia TTL, las calculadoras Hewlett-Packard ya en 1968 tenian varios niveles de programacion tales que se las podria llamar microordenadores. El HP 9100B (1968) tenia sentencias condicionales (if), declaraciones de salto (GOTO), los registros que se podrian utilizar como variables y subrutinas primitivas.  El lenguaje de programacion era parecido al lenguaje ensamblador en muchos aspectos. Modelos posteriores fueron a\u00f1adiendo mas caracteristicas, incluyendo el lenguaje de programacion BASIC (HP 9830A en 1971). Algunos modelos tenian almacenamiento en cinta e impresoras peque\u00f1as. Sin embargo, las pantallas se limitaban a una sola linea a la vez.\u200b El HP 9100A fue denominado un ordenador personal en un anuncio en un ejemplar de la  revista Science de 1968,\u200b pero ese anuncio fue abandonado rapidamente. Se sospecha que HP era reacio a llamarlas  \"computadoras\" ya que complicaria los procedimientos de contratacion y de exportacion del gobierno.\u200b  El Datapoint 2200, hecho por CTC en 1970, es quizas el mejor candidato para el titulo de \"primer microordenador\". A pesar de que no contiene microprocesador, el conjunto de instrucciones de su procesador TTL era la base del conjunto de instrucciones del procesador Intel 8008, y para fines practicos, el sistema se comporta aproximadamente como si contiene un 8008.  Esto es debido a que Intel fue el contratista a cargo de desarrollar el CPU de la Datapoint, pero en ultima instancia CTC rechazo el dise\u00f1o de 8008 porque necesitaba el soporte de 20 chips de soporte.\u200b  Otro de los primeros sistemas, la Kenbak-1, fue lanzado en 1971. Al igual que el Datapoint 2200, utilizo Tecnologia TTL de logica discreta en lugar de un microprocesador, pero funcionaba como un microordenador en la mayoria de los aspectos. Se comercializo como una herramienta educativa y un hobby, pero no fue un exito comercial; su produccion ceso poco despues.\u200b  En 1972, un equipo frances dirigido por Francois Gernelle dentro de una peque\u00f1a empresa, Realisations y Etudes Electroniques (R2E), desarrollo y patento un equipo basado en un microprocesador, el Intel 8008 de 8 bits. El Micral-N se comercializo a principios de 1973 como un Micro-ordinateur o microordenador, principalmente para aplicaciones cientificas y de procesos tecnicos. Alrededor de un centenar de Micral-N fueron instalados en los proximos dos a\u00f1os, seguido de una nueva version basada en el Intel 8080. Mientras tanto, otro equipo frances desarrollo el Alvan, un peque\u00f1o ordenador para la automatizacion de la oficina que encontro clientes en los bancos y otros sectores. La primera version se basa en chips LSI con un controlador periferico Intel 8008 (teclado, monitor e impresora), antes de adoptar el Zilog Z80 como procesador principal.  En 1972, un equipo de la Universidad Estatal de Sacramento liderado por Bill Pentz construyo el equipo Sac State 8008,\u200b capaz de manejar miles de registros medicos de los pacientes. El Sac State 8008 fue dise\u00f1ado con el Intel 8008. Tenia un sistema completo de componentes de hardware y software: un sistema operativo de disco incluido en una serie de chips de memoria programable de solo lectura (PROM); 8 Kilobytes de memoria RAM; el IBM Basic Assembly Language (BAL), un disco duro, una pantalla a color; una salida de la impresora; una interfaz serie a 150 bits por segundo  para la conexion a un ordenador central; e incluso el primer panel frontal de microordenador del mundo. \u200b  A principios de 1973, Sord Computer Corporation (actualmente Toshiba Personal Computer System Corporation) completaron el SMP80/08, que utilizo el microprocesador Intel 8008. El SMP80/08, sin embargo, no tienen un lanzamiento comercial. Despues de que se anunciara el primer microprocesador de proposito general en abril de 1974, el Intel 8080, Sord anuncio el SMP80/x, el primer microordenador en utilizar el 8080, en mayo de 1974.\u200b  Practicamente los primeros microordenadores eran esencialmente cajas con luces e interruptores; habia que leer y entender los numeros binarios y el lenguaje de maquina para programarlos y usarlos (el Datapoint 2200 fue una excepcion notable, con un dise\u00f1o moderno basado en un monitor, el teclado y la cinta y las unidades de disco).  De las primeras \"cajas de switches\" para microordenadores, el MITS Altair 8800 (1975) fue sin duda el mas famoso. La mayoria de estos primeros microordenadores simples, fueron vendidos como un conjunto de componentes electronicos que el comprador tenia que armar antes de que el sistema pudiera ser utilizado.  Los microordenadores del periodo de 1971 a 1976 a veces son llamados la primera generacion de microordenadores. Muchas compa\u00f1ias como DEC,\u200b National Semiconductor,\u200b Texas Instruments\u200b ofrecen sus microordenadores para su uso en el control de terminal, control de interfaz de dispositivo periferico y control de maquinaria industrial. Tambien habia maquinas para el desarrollo de la ingenieria y de uso personal aficionado.\u200b En 1975, Processor Technology dise\u00f1a el SOL-20, que consistia en una tarjeta, que incluia todas las partes del sistema informatico. El SOL-20 incorporaba software en EPROM que elimino la necesidad de filas de switches y luces. El MITS Altair jugo un papel instrumental en despertar el interes significativo de aficionados, que a su vez condujo a la fundacion y el exito de muchas empresas de hardware y software de ordenador personal, como Microsoft y Apple Computer. Aunque la propia Altair solo tuvo un exito comercial moderado, ayudo a desatar una enorme industria.  En 1977, la introduccion de la segunda generacion, conocidos como ordenador domestico (home computer), hizo las microcomputadoras considerablemente mas faciles de usar que sus predecesores porque la operativa practica de estas a menudo exigio una profunda familiaridad con la electronica practica. La posibilidad de conectar un monitor (pantalla) o un televisor permite la manipulacion visual de texto y numeros. El lenguaje BASIC, que era mas facil de aprender y usar que el lenguaje de maquina puro, se convirtio en una caracteristica estandar. Estas caracteristicas ya eran comunes en los miniordenadores, con la que muchos aficionados y los primeros productores estaban familiarizados.  En 1979, el lanzamiento de la hoja de calculo VisiCalc (inicialmente para el Apple II) convirtio el microcomputador de un hobby para entusiastas de la informatica en una herramienta de negocios. Despues del lanzamiento en 1981 del IBM PC, el termino ordenador personal (PC) se convirtio en termino generalmente usado para microcomputadoras compatible IBM PC.  En 2012, fue lanzado el computador con una sola tarjeta del tama\u00f1o de una tarjeta de credito Raspberry Pi directamente inspirado en el BBC Micro de Acorn Computers (1981), y contaba con el soporte de BBC BASIC.\u200b Se ha convertido en todo un exito hasta el punto de que ademas del sistema operativo Raspbian Microsoft le da soporte en Windows 10. Multitud de clones como el Orange Pi y el Banana Pi nacen en la estela de su exito.[cita\u00a0requerida] ","snippet":"Una microcomputadora, un microcomputador o un microordenador es una computadora peque\u00f1a, con un microprocesador como su unidad central de procesamiento CPU.\u200b Generalmente, el microprocesador incluye l","enlaces_salientes":["Microcomputadora","Microcomputadora","Microcomputadora","Commodore_64","Computadora","Microprocesador","Unidad_central_de_procesamiento","CPU","Memoria_cach%C3%A9","Chip","Supercomputadora","Minicomputadora","Minicomputadora","Isaac_Asimov","The_Magazine_of_Fantasy_and_Science_Fiction","Sord_Computer_Corporation","Micral","Estados_Unidos","Altair_8800","Memoria_de_acceso_aleatorio","Byte","Perif%C3%A9rico_de_entrada/salida","Serie_7400","Interfaz_gr%C3%A1fica_de_usuario","Casete","Puerta_logica","Memoria_de_solo_lectura","EPROM","Memoria_de_acceso_aleatorio","Kilobyte","Televisi%C3%B3n","Teleimpresora","Minicomputadora","Supercomputadora","Cromemco","Bus_S-100","Intel_8080","Zilog_Z80","CP/M","MP/M","D%C3%A9cada_de_1980","Ordenador_dom%C3%A9stico","Videoconsola","Sinclair_Research","Amstrad","Commodore_International","Atari","Dragon_Data","Texas_Instruments","Tandy","MSX","Atari_ST","Commodore_Amiga","Macintosh","Compatible_IBM_PC","Ordenador_personal","IBM_PCjr","Sinclair_QL","Steve_Jobs","Compatible_IBM_PC","Intel","IBM_Personal_System/2","IBM_PC","Microsoft_Windows","DOS","OS/2","Videoconsola","Tableta_(computadora)","Smartphone","Ordenador_dom%C3%A9stico","Apple_II","Commodore_64","BBC_Micro","TRS_80","Computadora_personal","IBM_PC","BIOS","Microcontroladores","Memoria_de_acceso_aleatorio","Fuente_de_alimentaci%C3%B3n","Impresora","Monitor","Dispositivo_de_interfaz_humana","Minicomputadora","Mainframe","Supercomputadora","Memoria_de_acceso_aleatorio","Almacenamiento_secundario","Casete","Disquete","Unidad_de_disco_duro","Altair_8800","TV_Typewriter","Apple_I","Raspberry_Pi","Tecnolog%C3%ADa_TTL","Hewlett-Packard","HP_9100B","Sentencia_condicional","GOTO","Lenguaje_ensamblador","BASIC","HP_9830A","HP_9100A","Ordenador_personal","Science","Datapoint_2200","Conjunto_de_instrucciones","Intel_8008","Kenbak-1","Tecnolog%C3%ADa_TTL","Intel_8008","Micral","Intel_8080","Zilog_Z80","Universidad_Estatal_de_Sacramento","PROM","Kilobyte","Memoria_RAM","Interfaz_serie","Bits_por_segundo","Sord_Computer_Corporation","Toshiba","Intel_8008","Intel_8080","Altair_8800","Digital_Equipment_Corporation","National_Semiconductor","Texas_Instruments","Altair_8800","Ordenador_personal","Microsoft","Apple_Computer","Ordenador_dom%C3%A9stico","Monitor_de_computadora","BASIC","Hoja_de_c%C3%A1lculo","VisiCalc","Apple_II","IBM_PC","Ordenador_personal","Compatible_IBM_PC","Raspberry_Pi","BBC_Micro","Acorn_Computers","BBC_BASIC","Sistema_operativo","Raspbian","Microsoft","Windows_10","Orange_Pi","Historia_de_los_computadores_personales","Ordenador_dom%C3%A9stico","Minicomputadora","Computadora_central","Supercomputadora","ISSN","Digital_object_identifier","MIT_Press","ISBN","Oxford_University_Press","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings"]}
{"url":"Commodore_International","titulo":"Commodore International","contenido":"Commodore, el nombre comun usado para la empresa Commodore International, fue una compa\u00f1ia estadounidense de electronica y hardware con sede en West Chester, Pensilvania que tuvo un papel primordial en el desarrollo de la industria del ordenador domestico/ordenador personal en la decada de 1980. La compa\u00f1ia es tambien conocida bajo el nombre de su departamento de I+D, Commodore Business Machines (CBM). Commodore desarrollo y comercializo el ordenador de sobremesa mas vendido a nivel mundial, el Commodore 64 (1982), pero no supo conducir a buen puerto una mejora competitiva para el dise\u00f1o de hardware de sus equipos de 16 bits, los Commodore Amiga, que fueron paulatinamente desplazados en relacion de precio y caracteristicas por los cada vez mas masivos IBM PC y sus clones compatibles con DOS y Windows.\u200b Se declara en bancarrota en 1994, siendo sus activos vendidos a diversos compradores. La linea Amiga ve sucederse los intentos por relanzarla sin ningun resultado positivo, mientras que la marca Commodore pasa por diversos propietarios hasta que la neerlandesa Tulip Computers se hace con los derechos. Comercializa bajo esta marca diferentes perifericos (teclados multimedia, ratones, reproductores MP3, pendrives, etc) y consumibles, y utiliza los derechos para comercializar el C64 Direct-to-TV. En 2004 Tulip vende la marca Commodore a Yeahronimo Media Ventures por 22 millones de euros.\u200b La venta se concreta en marzo de 2005 tras meses de negociaciones.  Desde entonces la nueva compa\u00f1ia se ha centrado en los equipos con moddings especiales para jugadores, y presento en el Consumer Electronics Show de 2009 un netbook y un par de PDAs\u200b  Tuvo sus inicios en la compa\u00f1ia que fundo Jack Tramiel en los a\u00f1os 50, que comenzo reparando maquinas de escribir y luego a principios de los 70 tomo el control de MOS Technology, propiedad de Chuck Peddle, e introdujo la KIM-1, una computadora de placa madre sencilla que se programaba en lenguaje de maquina.  Parte del exito de esta compa\u00f1ia se debe a la utilizacion del procesador MOS 6502, desarrollado por MOS Technology. Luego desarrollaron computadoras tales como la PET, VIC-20, Commodore 64, Commodore 128, Commodore 16, Plus/4 y otras.  La posterior compra de Amiga Computer trajo la salida al mercado del modelo Commodore Amiga 1000.  En Espa\u00f1a los productos de Commodore fueron inicialmente distribuidos por Microelectronica y Control, si bien en junio de 1987 se constituyo oficialmente la filial Commodore S.A., dependiente directamente de Commodore International.\u200b\u200b\u200b La nueva filial, dirigida primero por Santiago de Gracia y luego por Miguel Angel Esteban,\u200b asumio los activos y la estructura de Microelectronica y Control. Tras la marcha de Esteban, paso a depender de Commodore Italia, hasta que en septiembre de 1993 fue cerrada definitivamente esta filial.  Actualmente los productos Commodore son muy conocidos en Espa\u00f1a y Argentina por el impacto tecnologico en el dise\u00f1o sofisticado y moderno de sus productos y componentes. Garbarino S.A. es la responsable del ensamble y distribucion en el area Argentina siendo venta exclusiva en locales propios a la empresa, la misma es filial de la actual firma espa\u00f1ola de la marca siendo la unica distribuidora del pais. ","snippet":"Commodore, el nombre comun usado para la empresa Commodore International, fue una compa\u00f1ia estadounidense de electronica y hardware con sede en West Chester, Pensilvania que tuvo un papel primordial e","enlaces_salientes":["Commodore_International","Commodore_International","Commodore_International","Tipos_de_entidad_empresarial","Sociedad_an%C3%B3nima","Industria","Hardware","Personalidad_jur%C3%ADdica","Sociedad_por_acciones","1954","Jack_Tramiel","Sociedad_mercantil#Disoluci\u00f3n","Sede_central","West_Chester_(Pensilvania)","Pensilvania","Estados_Unidos","Presidente","Marca","Bien_econ%C3%B3mico","Commodore_VIC-20","Commodore_64","Commodore_128","Commodore_Amiga","Filial","MOS_Technology","Estructura_econ%C3%B3mica","1994","Bancarrota","2005","Presente","Estados_Unidos","Electr%C3%B3nica","Hardware","West_Chester_(Pensilvania)","Pensilvania","Ordenador_dom%C3%A9stico","Ordenador_personal","I%2BD","Commodore_64","Commodore_Amiga","IBM_PC","Compatible_IBM_PC","DOS","Windows","Bancarrota","1994","Tulip_Computers","C64_Direct-to-TV","2004","Euro","Modding","Consumer_Electronics_Show","2009","Netbook","PDA","Jack_Tramiel","A%C3%B1os_1950","M%C3%A1quina_de_escribir","MOS_Technology","Chuck_Peddle","KIM-1","Lenguaje_de_m%C3%A1quina","MOS_6502","MOS_Technology","Commodore_PET","Commodore_VIC-20","Commodore_64","Commodore_128","Commodore_16","Commodore_Plus/4","Commodore_Amiga","Junio","1987","1993","Garbarino","Commodore_PET","Commodore_VIC-20","Commodore_16","Commodore_64","Commodore_Plus/4","Commodore_128","Commodore_Amiga","Jack_Tramiel","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Gemeinsame_Normdatei","Syst%C3%A8me_universitaire_de_documentation","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Emulador","titulo":"Emulador","contenido":"En informatica, un emulador es un software que permite ejecutar programas o videojuegos en una plataforma (sea una arquitectura de hardware o un sistema operativo) diferente de aquella para la cual fueron escritos originalmente.\u200b A diferencia de un simulador, que solo trata de reproducir el comportamiento del programa, un emulador trata de modelar de forma precisa el dispositivo de manera que este funcione como si estuviese siendo usado en el aparato original\u200b.  Un uso popular de los emuladores es el de imitar la experiencia de los videojuegos de maquinas recreativas o videoconsolas en computadoras personales, o el poder ser jugados en otras videoconsolas. La emulacion de videojuegos de sistemas antiguos (abandonware) en las modernas computadoras personales y videoconsolas de hoy dia resulta generalmente mas comoda y practico que en los dispositivos originales. Sin embargo, puede ser requerido a los creadores de emuladores una licencia de software para escribir programas originales que dupliquen la funcionabilidad de la ROM y BIOS del hardware original, lo que comunmente se conoce como high-level emulation o emulacion de alto nivel.  Otro uso comun es el de emular sistemas operativos obsoletos, o vigentes para otra maquina o dispositivo, para utilizar programas compatibles con estos sistemas operativos.  En sentido teorico, la tesis de Church-Turing implica que cualquier ambiente funcional puede ser emulado dentro de cualquier otro. En la practica, esto puede resultar realmente dificil, particularmente cuando el comportamiento exacto del sistema emulado no esta documentado y debe ser deducido mediante ingenieria inversa. Tampoco se habla en la tesis sobre las diferencias en sincronizacion; si el emulador no actua tan rapidamente como el hardware original, el software de emulacion va a ir mas lento que si fuese el hardware original.  La mayoria de los emuladores solo emulan una determinada configuracion arquitectura de hardware - si el sistema de explotacion (o sistema operativo) tambien se requiere para emular cierto programa entonces ha de ser emulado tambien. Tanto el sistema de explotacion como el programa deben ser interpretados por el emulador, como si estuviese ejecutandose en el equipo original. Aparte de la interpretacion del lenguaje de la maquina emulada, es preciso emular el resto del equipo, como los dispositivos de entrada y salida, de forma virtual: si escribir en una region especifica de la memoria debe influir en el contenido en pantalla, por ejemplo, esto tambien debe ser emulado.  En vez de una emulacion completa del equipo, una compatibilidad superficial puede ser suficiente. Esto traduce las llamadas del sistema emulado a llamadas del sistema anfitrion.  Los desarrolladores de programas para maquinas con sistemas computarizados y consolas de videojuego comunmente utilizan emuladores especialmente exactos llamados simuladores antes de ejecutarlos en el equipo real. Esto permite que el programa pueda ser producido y probado antes de que la version final del equipo para el cual se esta desarrollando sea producida en grandes cantidades, de esta forma puede ser probado sin tener que copiar el programa en el equipo, de modo que puedan ser eliminados errores en un nivel bajo sin tener los efectos colaterales de un depurador.\u200b  Tipicamente, un emulador se divide en modulos que corresponden de forma precisa a los subsistemas del equipo emulado. Lo mas comun, es que un emulador este compuesto por los siguientes modulos:  Lo mas comun es que los buses no sean emulados, por razones de simplicidad y rendimiento, y para que los perifericos virtuales se comuniquen directamente con la UCP y los subsistemas de memoria.  El simulador de la unidad central de procesamiento (CPU) es a menudo la parte mas compleja de un emulador. Muchos emuladores son escritos utilizando simuladores de CPU \"preempaquetados\", para asi poder realizar una emulacion fiel y eficiente de una maquina especifica.  El simulador de CPU mas simple seria un interprete informatico, que sigue el flujo de ejecucion del codigo de programacion emulado y, por cada instruccion de codigo de la maquina emulada, ejecuta en el procesador en que se carga, instrucciones semanticamente equivalentes a las originales.  Esto es posible asignando una variable a cada registro y flag de la CPU emulada. La logica de la CPU simulada puede ser mas o menos traducida directamente a algoritmos de software, creando una reimplementacion del software que basicamente refleja la implementacion original del hardware.  El ejemplo siguiente ilustra el modo en que la simulacion de CPU por un interprete. En este caso, las interrupciones se revisan despues de la ejecucion de cada instruccion, aunque este comportamiento no es usual en los emuladores en la realidad, por razones de rendimiento.  Los interpretes son muy populares en el caso de los simuladores de CPU, ya que son mas sencillos de implementar que otras soluciones alternativas de mejor rendimiento, y su velocidad es mas que adecuada para emular computadoras de hace mas de una decada en maquinas modernas.  Aun asi, la penalizacion de velocidad inherente en la interpretacion puede ser un problema al emular computadores cuya velocidad de procesador esta en el mismo orden de magnitud que la maquina huesped. Hasta no hace tantos a\u00f1os, la emulacion en tales situaciones era considerada impracticable.  Lo que permite el rompimiento de esta restriccion son las tecnicas avanzadas de recompilacion dinamica. Una translacion simple a priori del codigo del programa emulado al codigo que corre en la arquitectura original es usualmente imposible por varias razones:  Varias formas de recompilacion dinamica, incluyendo la popular tecnica de compilacion en tiempo de ejecucion (compilacion JIT), trata de bordear estos temas esperando hasta que el proceso de control de flujo se mueva hasta donde esta la parte donde esta localizado el codigo sin traducir, y es solo entonces {\"en tiempo de ejecucion\") cuando los bloques traducidos del codigo al codigo anfitrion pueden ser ejecutados.  El codigo traducido se mantiene en el codigo cache, y el codigo original no se pierde ni es afectado; de esta forma, incluso los segmentos de data pueden ser trasladados por el recompilador, resultando solo en un gasto de tiempo de traslado.  La mayoria de los emuladores, como dicho anteriormente, no emulan el sistema principal bus; cada dispositivo de entrada y salida es tratado a menudo como un caso especial, y no existe una interfaz constante para los perifericos virtuales.  Esto puede resultar en una ventaja en el funcionamiento, proveyendo que cada modulo de entrada y salida pueda ser adaptado a las caracteristicas del dispositivo emulado; dise\u00f1os basados en un estandar, entradas y salidas unificadas por medio de API pueden sin embargo proveer modelos mas simples, y ademas tienen la ventaja adicional de permitir de forma \"automatica\" la utilizacion de servicios plugins para proveer dispositivos virtuales de terceros en el emulador.  Las entradas y salidas unificadas por medio de API no necesariamente reflejan la estructura del bus del hardware real: el dise\u00f1o del bus esta limitado por varios parametros electricos y la necesidad del manejo de programacion paralela que la mayoria de las veces puede ser ignorada en la implementacion del software.  Aun los emuladores que tratan cada dispositivo como un caso especial poseen una infraestructura basica en comun para ello:  Los emuladores arrancan imagenes ROM, o sea el contenido de los cartuchos, disquetes o cintas que se usaban con los sistemas antiguos. Fisicamente en las PC las ROM son archivos binarios que se pueden cargar en la memoria. Es decir, el emulador es un programa que hace las funciones de una consola, por ejemplo la Game Boy Advance o una PDA, y la ROM es un archivo que hace de cartucho, CD-ROM, o cinta, por ejemplo Mario Bros..  La emulacion puede ser utilizada para obtener una maquina virtual que se ejecuta dentro de otra maquina. Esta maquina virtual puede emular tanto maquinas que existen fisicamente como maquinas que solo existen como una especificacion (por ejemplo la maquina virtual de Java, la maquina virtual del entorno .NET, Open Firmware o la maquina virtual p-code de Pascal). De esta forma se puede conseguir ejecutar software escrito para una maquina con solo llevar la maquina virtual a cada una de las plataformas..  Los emuladores de videoconsolas son un tipo de emuladores dise\u00f1ados para emular una o varias videoconsolas y asi poder jugar un videojuego dise\u00f1ado para ser jugado en esta(s). Los emuladores multiples suelen emular consolas con caracteristicas similares (por ejemplo MEKA emula todas las consolas de Sega de 8 bits y la Colecovision) ","snippet":"En informatica, un emulador es un software que permite ejecutar programas o videojuegos en una plataforma (sea una arquitectura de hardware o un sistema operativo) diferente de aquella para la cual fu","enlaces_salientes":["Emulador","Emulador","Emulador","DOSBox","DOS","Inform%C3%A1tica","Software","Programa_inform%C3%A1tico","Videojuego","Hardware","Sistema_operativo","Simulador","Arcade","Videoconsola","Computadora_personal","Abandonware","Software","Memoria_de_solo_lectura","BIOS","Sistema_operativo","Tesis_de_Church-Turing","Ingenier%C3%ADa_inversa","Hardware","Sistema_operativo","M%C3%A1quina_virtual","Memoria_de_computadora","Simulador","Depuraci%C3%B3n_de_programas","M%C3%B3dulo_(inform%C3%A1tica)","Unidad_central_de_procesamiento","Bus_de_datos","Perif%C3%A9rico_(inform%C3%A1tica)","Unidad_central_de_procesamiento","Int%C3%A9rprete_(inform%C3%A1tica)","Variable_(programaci%C3%B3n)","Registro_(hardware)","Software","Hardware","Orden_de_magnitud","A_priori","Sistema_operativo","Compilaci%C3%B3n_en_tiempo_de_ejecuci%C3%B3n","Cach%C3%A9_(desambiguaci%C3%B3n)","Perif%C3%A9rico_(inform%C3%A1tica)","Interfaz_de_programaci%C3%B3n_de_aplicaciones","Plugin","Interfaz_de_programaci%C3%B3n_de_aplicaciones","Interruptor","Imagen_ROM","Imagen_ROM","Disquete","Archivo_inform%C3%A1tico","Game_Boy_Advance","CD-ROM","M%C3%A1quina_virtual","M%C3%A1quina_virtual","M%C3%A1quina_virtual_de_Java",".NET","Open_Firmware","Emulador_de_videoconsola","Videoconsola","Videojuego","MEKA","Sega","Colecovision","Emulador_de_consola","Imagen_ROM","Virtualizaci%C3%B3n","Retrogaming","ISSN","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"VICE","titulo":"VICE","contenido":"Un emulador VIC o VICE (siglas en ingles de VersatIle Commodore Emulator) es un programa informatico que emula a la gama de ordenadores Commodore de 8 bits.\u200b  Los ordenadores emulados son: Toda la gama de Commodore pet (menos el Superpet 9000), el Commodore VIC-20, el Commodore 64, el Commodore 128, asi como la unidad de grabacion de datos (Datassette) y las unidades de almacenamiento Commodore 1541 y Commodore 1571, joysticks y expansiones.  El programa se distribuye bajo la licencia GNU GPL y funciona en Unix, Linux, MS-DOS, Win32, Acorn RISC OS y BeOS. ","snippet":"Un emulador VIC o VICE (siglas en ingles de VersatIle Commodore Emulator) es un programa informatico que emula a la gama de ordenadores Commodore de 8 bits.\u200b  Los ordenadores emulados son: Toda la gam","enlaces_salientes":["VICE","VICE","VICE","Emulador","1993","Licencia_de_software","Lenguaje_de_programaci%C3%B3n","C_(lenguaje_de_programaci%C3%B3n)","Ciclo_de_vida_del_lanzamiento_de_software","29_de_diciembre","2022","Idioma_ingl%C3%A9s","Commodore_International","Commodore_PET#Serie_SuperPET_9000_2","Commodore_VIC-20","Commodore_64","Commodore_128","Commodore_1541","Commodore_1571","Joystick","GNU","Licencia_p%C3%BAblica_general_de_GNU","Unix","GNU/Linux","MS-DOS","Windows","RISC_OS","BeOS","Control_de_autoridades"]}
{"url":"GNU/Linux","titulo":"GNU/Linux","contenido":"  GNU/Linux (pronunciado oficialmente como \u00f1u linux o tambien ge-ene-u linux en espa\u00f1ol),\u200b es una familia de sistemas operativos tipo Unix compuesto por software libre y de codigo abierto.\u200b GNU/Linux surge de las contribuciones de varios proyectos de software, entre los cuales destacan GNU (iniciado por Richard Stallman en 1983) y el nucleo Linux (iniciado por Linus Torvalds en 1991).\u200b  A pesar de que en la jerga cotidiana la mayoria de las personas usan el vocablo Linux para referirse a este sistema operativo,\u200b\u200b en realidad ese es solo el nombre del kernel o nucleo, que representa menos del 50 por ciento de todo el codigo del sistema. El sistema completo esta formado tambien por una gran cantidad de componentes del Proyecto GNU junto a componentes de terceros, que van desde compiladores hasta entornos de escritorio.\u200b \u200b Cabe se\u00f1alar que existen derivados que usan el nucleo Linux pero que no tienen componentes GNU, como por ejemplo el sistema operativo Android.\u200b Tambien existen distribuciones de software GNU donde el nucleo Linux esta ausente.  Los sistemas operativos GNU/Linux se encuentran normalmente en forma de compendios conocidos como distribuciones o distros.\u200b Entre las mas populares se encuentran Debian, Ubuntu, Red Hat y SUSE. El proposito de estas distribuciones es ofrecer GNU/Linux como un producto final para instalar o probar en un ordenador, cubriendo una gama de necesidades, las cuales que van desde el uso cotidiano personal hasta aplicaciones muy especificas en ambientes especializados. Al sistema base las distros a\u00f1aden su propia seleccion de aplicaciones y programas preinstalados (por ejemplo ambientes graficos basados en X11, Gnome y KDE), o aplicaciones que pueden descargarse desde un repositorio para su posterior instalacion.  Algunas de estas distribuciones son especialmente conocidas por su uso en servidores de Internet, en supercomputadoras, y en sistemas embebidos;\u200b mercados donde GNU/Linux tiene la mayor cuota de participacion. El proyecto de ranking Top500.org informa que, desde 2017, las 500 supercomputadoras mas potentes del mundo utilizan todas ellas alguna version del sistema operativo GNU/Linux; y desde 2004 ya era el sistema dominante\u200b Diversas encuestas lo han posicionado constantemente como el sistema operativo mas popular para servidores web.\u200b\u200b\u200b En aplicaciones embebidas es comun encontrar Linux instalado en routers, smart TV y relojes inteligentes, sistemas de entretenimiento de automoviles, y grabadoras de video digital.\u200b\u200b Aunque con menor participacion, el sistema GNU/Linux tambien se usa en el segmento de las computadoras de escritorio, portatiles, dispositivos moviles, computadoras de bolsillo, videoconsolas y otros.  GNU/Linux es uno de los ejemplos mas prominentes de software libre: todo su codigo fuente puede ser utilizado, modificado y redistribuido libremente por cualquier persona, empresa o institucion, bajo los terminos de la Licencia Publica General de GNU, asi como de otra serie de licencias de derechos de autor.\u200b  El acronimo recursivo GNU, GNU's Not Unix (GNU no es Unix), proviene de las herramientas basicas de sistema operativo creadas por el proyecto GNU, iniciado por Richard Stallman en 1983 y mantenido por la Free Software foundation. El nombre Linux viene del nucleo Linux, inicialmente escrito por Linus Torvalds en 1991.\u200b  La contribucion del proyecto GNU al sistema es la razon por la que existe controversia a la hora de utilizar Linux o GNU/Linux para referirse al sistema operativo formado por el sistema GNU y el nucleo Linux en su conjunto.\u200b\u200b  El sistema operativo Unix fue concebido e implementado en 1969 en los laboratorios Bell de AT&T en los Estados Unidos por Ken Thompson, Dennis Ritchie, Douglas McIlroy, y Joe Ossanna.\u200b Unix se escribio completamente en lenguaje ensamblador por primera vez en 1971, ya que era una practica comun en el momento. Mas tarde, en 1973, en un enfoque innovador, se volvio a escribir en el lenguaje de programacion C, por Dennis Ritchie (a excepcion del nucleo y del sistema de entrada y salida de datos). La disponibilidad de un lenguaje de alto nivel para implementar Unix propicio su portabilidad a diferentes plataformas de computacion con mayor facilidad; ayudando asi a su propagacion.  Debido a un anterior caso antimonopolio que le prohibia entrar en el negocio de las computadoras, AT&T licenciaba gratuitamente el codigo fuente del sistema operativo Unix a cualquier persona que lo solicitara.\u200b Como resultado, Unix crecio rapidamente y llego a ser ampliamente adoptado por las instituciones academicas y empresas. En 1984, AT&T se despojo de Bell Labs; quedando libre de la obligacion legal que requeria la concesion de dichas licencias.\u200b  El proyecto GNU, iniciado en 1983 por Richard Stallman, tiene el objetivo de crear un \u00absistema de software compatible con Unix, compuesto enteramente de software libre\u00bb. El trabajo comenzo en el a\u00f1o 1984.\u200b Mas tarde, en 1985, Stallman fundo la Free Software Foundation para financiar el desarrollo de GNU, y redacto la Licencia Publica General de GNU en 1989. A principios de la decada de 1990, muchos de los programas que se requieren en un sistema operativo (como bibliotecas, compiladores, editores de texto, un shell Unix, y un sistema de ventanas) ya se habian conseguido desarrollar y estaban operativos en el proyecto GNU. Sin embargo, otros elementos, como los controladores de dispositivos y los daemons, estaban todavia en desarrollo e incompletos.\u200b  En retrospectiva, Linus Torvalds declaro que si el nucleo del proyecto GNU hubiera estado disponible en 1991, no se habria decidido a desarrollar su propio nucleo.\u200b Asimismo, tambien declaro que si el nucleo 386BSD (del cual NetBSD, OpenBSD y FreeBSD descienden), cuyo desarrollo es anterior al nucleo Linux y que no se libero hasta 1992 por temas legales, hubiera estado disponible probablemente tampoco lo habria desarrollado.\u200b  En 1991, cuando Torvalds asistia a la Universidad de Helsinki y era usuario del sistema operativo MINIX, creado en 1987 por Andrew S. Tanenbaum, y de los programas provenientes del proyecto GNU, estaba muy interesado por el funcionamiento de los sistemas operativos.\u200b Frustrado por la concesion de licencias de uso que utilizaba MINIX, que en ese momento se limitaba a uso educativo, ese mismo a\u00f1o decidio comenzar a desarrollar su propio nucleo\u200b\u200b adoptando la estructura y codigo del nucleo de MINIX.  Hacia 1992, Torvalds habia trabajado tanto en el desarrollo del nucleo Linux que llego a superar a otros nucleos que se encontraban tambien en desarrollo en ese momento.\u200b Las aplicaciones GNU tambien se fueron desarrollando de modo que reemplazaron todos los componentes de MINIX, porque era mas ventajoso utilizar el codigo libre del proyecto GNU con el nuevo sistema operativo. El codigo GNU con licencia bajo la GPL puede ser reutilizado en otros programas de computadora, siempre y cuando tambien se liberen bajo la misma licencia o una licencia compatible. Posteriormente Torvalds inicio un cambio de su licencia original, la cual prohibia la redistribucion comercial, y lo difundio bajo la licencia GPL.\u200b Los desarrolladores de ambas partes trabajaron para integrar componentes de GNU con el nucleo Linux, consiguiendo un sistema operativo completamente funcional.\u200b  Muchos desarrolladores de codigo abierto estan de acuerdo en que el nucleo Linux no fue dise\u00f1ado, sino que evoluciono a traves de una forma de \u00abseleccion natural\u00bb. Torvalds considera que, aunque el dise\u00f1o de Unix sirvio como andamiaje, \u00abLinux crecio con muchas mutaciones, y debido a que las mutaciones eran menos que aleatorias, eran mas rapidas y mas dirigidas que las particulas alfa en el ADN\u00bb.\u200b Raymond considera que los aspectos revolucionarios de Linux son sociales, no tecnicos, antes de que el software complejo de Linux fuera dise\u00f1ado cuidadosamente por grupos peque\u00f1os, pero \u00abLinux evoluciono de una manera completamente diferente. Desde casi el principio, fue pirateado de manera bastante casual por un gran numero de voluntarios coordinando solo a traves de Internet. La calidad se mantuvo no por estandares rigidos o autocracia, sino por la estrategia ingenuamente simple de publicar cada semana y obtener comentarios de cientos de usuarios en unos dias, creando una especie de seleccion darwiniana rapida sobre las mutaciones introducidas por los desarrolladores\u00bb.\u200b Bryan Cantrill, un ingeniero de un sistema operativo de la competencia, esta de acuerdo en que \u00abLinux no se dise\u00f1o, evoluciono\u00bb, pero considera que esto es una limitacion, y propone que algunas caracteristicas, especialmente las relacionadas con la seguridad, no se pueden convertir en, \u00abeste no es un sistema biologico al final del dia, es un sistema de software\u00bb.\u200b Un sistema basado en Linux es un sistema operativo modular tipo Unix, que deriva gran parte de su dise\u00f1o basico de los principios establecidos en Unix durante las decadas de 1970 y 1980. Dicho sistema utiliza un nucleo monolitico, el nucleo Linux, que maneja el control de procesos, las redes, el acceso a los perifericos y los sistemas de archivos. Los controladores de dispositivos se integran directamente con el nucleo o se agregan como modulos que se cargan mientras el sistema esta en ejecucion.  El espacio de usuario de GNU es una parte clave de la mayoria de los sistemas basados en el nucleo Linux, siendo Android la excepcion notable. La implementacion del Proyecto de la biblioteca C funciona como un contenedor para las llamadas al sistema del nucleo Linux necesarias para la interfaz kernel-espacio de usuario. La cadena de herramientas es una amplia coleccion de herramientas de programacion vitales para el desarrollo de Linux (incluidos los compiladores utilizados para construir el nucleo Linux asi mismo), y las coreutils implementan muchas herramientas basicas de Unix. El proyecto tambien desarrolla Bash, un popular shell CLI. La interfaz grafica de usuario (o GUI) que utilizan la mayoria de los sistemas Linux se basa en una implementacion del sistema X Window.\u200b Mas recientemente, la comunidad Linux busca avanzar a Wayland como el nuevo protocolo de servidor de visualizacion en lugar de X11. Muchos otros proyectos de software de codigo abierto contribuyen a los sistemas Linux.  Los componentes instalados de un sistema GNU/Linux incluyen los siguientes:\u200b\u200b  Los sistemas operativos GNU/Linux pueden funcionar tanto en entorno grafico como en modo consola, ya que el entorno grafico no va explicitamente unido al resto de programas de manejo del sistema y puede usarse de forma opcional.\u200b La consola es comun en distribuciones para servidores, mientras que la interfaz grafica esta orientada al usuario final, tanto de hogar como empresarial. Asimismo, tambien existen los entornos de escritorio, que son un conjunto de programas formado por gestores de ventanas, iconos y muchas aplicaciones que facilitan la utilizacion de la computadora en modo grafico. Los escritorios mas populares en GNU/Linux son: GNOME, KDE Plasma, LXQt, Xfce, MATE y Cinnamon, aunque existen muchos mas, tambien puede usarse con solo los gestores de ventanas, que son la columna vertebral de los entornos de escritorio, y los encargados de dibujar la interfaz de las aplicaciones y la composicion.  Escritorio GNOME 43  Escritorio KDE Plasma 5.22  Escritorio XFCE 4.18  Entorno de escritorio de Deepin 23  Escritorio Cinnamon 4.4.8  Escritorio MATE 1.20  Escritorio LXQt  Escritorio Openbox  La coleccion de utilidades para la programacion de GNU es con diferencia la familia de compiladores mas utilizada en este sistema operativo. Cuenta con capacidad para compilar codigo fuente de lenguajes de programacion como: C, C++, Java, Ada, Pascal, D y Fortran, entre muchos otros.\u200b Ademas, soporta diversas arquitecturas de procesador mediante la compilacion cruzada, lo que hace que sea un entorno adecuado para desarrollos heterogeneos.  Existen varios entornos de desarrollo integrados disponibles para GNU/Linux, incluyendo Anjuta, KDevelop, Lazarus, Ultimate++, Code::Blocks, NetBeans IDE y Eclipse. Tambien existen editores extensibles como Emacs o Vim. GNU/Linux tambien dispone de capacidades para lenguajes de guion (script), aparte de los clasicos lenguajes de programacion de shell, o el de procesado de textos por patrones y expresiones regulares conocido como awk. La mayoria de las distribuciones tienen instalado Python, Perl, PHP y Ruby y en caso de no venir instalados estos lenguajes, es muy sencilla su instalacion, generalmente a traves de un repositorio comun.  Las aplicaciones para GNU/Linux se distribuyen en una variedad de formatos debido a la diversidad de metodos de manejo de paquetes de software, algunos mas preparados para ser ejecutados que otros. Mientras que en sistemas como Windows o MacOS el usuario normalmente busca el software de terceros por su cuenta; las distribuciones GNU/Linux fueron pioneras en los repositorios de aplicaciones soportadas oficialmente por el sistema operativo, similar a las tiendas de aplicaciones modernas, donde el usuario acude a buscar el software que desea instalar.\u200b\u200b Las aplicaciones precompiladas existen mayoritariamente en los formatos .deb y .rpm, usados en Debian y Red Hat respectivamente y sus descendientes. Tambien existe la posibilidad de compilar los programas en forma de recetas make a partir de su codigo fuente, y algunos desarrolladores de aplicaciones solo distribuyen su software de esta manera, transfiriendo la labor de crear un programa ejecutable a las distribuciones interesadas en empaquetar su aplicacion, o al usuario por su propia cuenta, si lo desea.  Durante la primera epoca habia pocas aplicaciones de codigo cerrado para GNU/Linux. Con el tiempo se fueron uniendo programas no libres al sistema GNU/Linux, entre ellos Adobe Reader, Adobe Flash, Opera, entre muchos otros. Algunos ejemplos de aplicaciones en GNU/Linux se pueden ver a continuacion.  Redes Sociales  En el entorno de GNU/Linux, los dispositivos de bloques, como los discos duros, desempe\u00f1an un papel esencial en el almacenamiento de datos. Estos dispositivos se dividen en unidades logicas mas peque\u00f1as llamadas particiones, lo que permite una organizacion y gestion eficiente del espacio de almacenamiento.  Cada particion se representa como un archivo en el sistema de archivos de GNU/Linux y se encuentra ubicada en el directorio /dev. Por ejemplo, el archivo /dev/sda representa el primer disco duro, mientras que /dev/sdb representa el segundo. Estos archivos de dispositivo de bloques se pueden acceder y manipular como cualquier otro archivo en el sistema.  Para asociar una particion a un sistema de archivos accesible, es necesario realizar un proceso de montaje. Durante el montaje, se conecta el sistema de archivos asociado a la particion a un punto especifico en el arbol de directorios. Esto se puede hacer de forma explicita o mediante programacion en el arranque del sistema.  La estructura y configuracion de los dispositivos de bloques se puede examinar y modificar utilizando comandos como fdisk. Con fdisk, es posible examinar la estructura de un dispositivo conocido o realizar cambios en su estructura particionando el disco.  En el sistema de archivos de GNU/Linux, cada particion se puede formatear con un sistema de archivos especifico, como ext4, XFS o NTFS. El sistema de archivos define la forma en que se organizan y almacenan los datos en la particion, permitiendo la creacion y gestion de archivos y directorios.  La informacion sobre los dispositivos de almacenamiento disponibles en el sistema se puede obtener de diferentes maneras. Una de ellas es a traves del archivo /etc/fstab, que indica los dispositivos preparados para el montaje durante el arranque del sistema o los dispositivos extraibles que se pueden montar. Sin embargo, no es necesario que esten listados todos los dispositivos del sistema en este archivo, ya que es posible montarlos bajo demanda utilizando el comando mount o desmontarlos mediante el comando umount.  Con la adopcion por numerosas empresas fabricantes, un buen numero de computadoras se venden con distribuciones preinstaladas, y GNU/Linux ha comenzado a tomar su lugar en el vasto mercado de las computadoras de escritorio.  Algunas de las empresas que colaboran en la difusion de este sistema operativo ya sea trabajando en el nucleo Linux, proporcionando soluciones de software o preinstalando el sistema operativo, son: Intel ,\u200b\u200b\u200b Google,\u200b\u200b IBM,\u200b AMD,\u200b\u200b\u200b\u200b Sun Microsystems,\u200b Dell,\u200b\u200b Lenovo,\u200b\u200b Asus,\u200b Hewlett-Packard (HP),\u200b\u200b\u200b Silicon Graphics International (SGI),\u200b Renesas Technology,\u200b Fujitsu,\u200b Analog Devices,\u200b Freescale,\u200b VIA Technologies,\u200b Oracle,\u200b Novell\u200b y RedHat,\u200b entre otras.\u200b  El respaldo de compa\u00f1ias de software tambien esta presente, ya que, entre otras aplicaciones, Nero, Java, Google Earth, Google Desktop, Adobe Reader, Adobe Flash, RealPlayer y Yahoo! Messenger estan disponibles para GNU/Linux. Al haber software equivalente, es innecesario instalar los precisamente mencionados con anterioridad.  Numerosos estudios cuantitativos sobre software de codigo abierto estan orientados a temas como la cuota de mercado y la fiabilidad, y ciertamente muchos de estos estudios examinan especificamente a GNU/Linux.\u200b  La medicion \"cuota de mercado\" puede resultar inservible ya que es un concepto basado en ventas comerciales (unidades materiales vendidas). Por otro lado Linux es utilizado frecuentemente en servidores con acceso publico desde Internet por lo que la cuota de mercado es extremadamente inferior a la cuota de uso. Baste notar, p.ej, que Facebook, Gmail, LinkedIn o Yahoo funcionan sobre servidores GNU/Linux, de tal forma que cuando estamos accediendo desde un navegador ejecutandose en Windows/Mac, la aplicacion real se esta ejecutando en servidores Linux y los datos estan almacenandose igualmente en dichos servidores.\u200b  Hay varias empresas que comercializan soluciones basadas en GNU/Linux: IBM, Red Hat (RHEL), Rxart, Canonical Ltd. (Ubuntu), asi como miles de PYMES que ofrecen productos o servicios basados en esta tecnologia.  Una aproximacion estadistica basica y estimada sobre numero de usuarios de GNU/Linux a escala global lo ofrece el proyecto Linux Counter.  Dentro del segmento de las supercomputadoras, a noviembre de 2017, el uso de este sistema ascendio al 100% de las computadoras mas potentes del mundo por su confiabilidad, seguridad y libertad para modificar el codigo.\u200b De acuerdo con TOP500.org, que lleva estadisticas sobre las 500 principales supercomputadoras del mundo, a noviembre de 2017: las 500 usaban una distribucion basada en GNU/Linux.  GNU/Linux, ademas de liderar el mercado de servidores de Internet debido, entre otras cosas, a la gran cantidad de soluciones que tiene para este segmento, tiene un crecimiento progresivo en computadoras de escritorio y portatiles. Ademas, es el sistema base que se ha elegido para el proyecto OLPC: One Laptop Per Child.\u200b  El CERN (Organizacion Europea para la Investigacion Nuclear) usa Linux, primero Scientific Linux y luego crearon CCentSO (CERN CentOS), una version de CentOS especifica para las aplicaciones del CERN.\u200b\u200b  Para saber mas sobre las arquitecturas soportadas, lea el articulo \"Portabilidad del nucleo Linux y arquitecturas soportadas\".  Hay una serie de administraciones publicas que han mostrado su apoyo al software libre, sea migrando total o parcialmente sus servidores y sistemas de escritorio, sea subvencionandolo. Como ejemplos se tiene a Alemania, Argentina, Australia, Brasil, Espa\u00f1a, Chile, China, Cuba, Mexico, Peru, Ecuador, El Salvador, Uruguay y Venezuela.  El sistema operativo del General Atomics MQ-1 Predator esta basado en GNU/Linux, asi como el del Boeing P-8 Poseidon.  Parte de la comunidad y numerosos medios prefieren denominar a esta combinacion como Linux, aunque GNU/Linux (con las variantes GNU con Linux y GNU+Linux) es la denominacion defendida por el Proyecto GNU y la FSF junto con otros desarrolladores y usuarios para el conjunto que utiliza el sistema operativo Linux con las aplicaciones de sistema creadas por el proyecto GNU y por muchos otros proyectos de software.\u200b\u200b  Desde 1984, Richard Stallman y muchos voluntarios estan intentando crear un sistema operativo libre con un funcionamiento similar a UNIX, recreando todos los componentes necesarios para tener un sistema operativo funcional. A comienzos de los a\u00f1os 90, unos seis a\u00f1os desde el inicio del proyecto, GNU tenia muchas herramientas importantes listas, como editores de texto, compiladores, depuradores, interpretes de comandos de ordenes etc., excepto por el componente central: el nucleo.  GNU tiene su propio proyecto de nucleo, llamado Hurd. Sin embargo, su desarrollo no continuo como se esperaba al aparecer el nucleo Linux. De esta forma, se completaron los requisitos minimos y surgio el sistema operativo GNU que utilizaba el nucleo Linux.  El principal argumento de los defensores de la denominacion GNU/Linux es resolver la posible confusion que se puede dar entre el nucleo (Linux) y gran parte de las herramientas basicas del resto del sistema operativo (GNU), y del sistema completo que usualmente se usa como combinacion de GNU, Linux, y otros proyectos de software. Ademas, tambien se espera que con el uso del nombre GNU, se de al proyecto GNU el reconocimiento por haber creado las herramientas de sistema imprescindibles para ser un sistema operativo compatible con UNIX, y se destaque la cualidad de estar compuesto solo por software libre. La primera distribucion que incluyo el GNU en su nombre fue Yggdrasyl en 1992, donde aparecia como Linux/GNU/X. La FSF denomino a este sistema \"Linux\" hasta al menos junio de 1994\u200b y recien a partir de enero de 1995 empezo a llamarlo \"GNU/Linux\" (tambien GNU+Linux y lignux, terminos que han caido en desuso a instancias del propio Stallman).\u200b  Algunas distribuciones apoyan esta denominacion, e incluyen GNU/Linux en sus nombres, como Debian GNU/Linux o GNU/LinEx, mientras que otras, como Slackware, Gentoo o Ubuntu, eligen denominarse basadas en Linux.\u200b\u200b\u200b  En ocasiones, el proyecto KDE ha utilizado una tercera denominacion: GNU/Linux/X para enfatizar los tres proyectos sobre los que se apoya su entorno de escritorio.  Una distribucion de Linux es una\u00a0distribucion de software\u00a0basada en el\u00a0nucleo Linux\u00a0que incluye determinados\u00a0paquetes de software\u00a0para satisfacer las necesidades de un grupo especifico de usuarios, dando asi origen a ediciones domesticas, empresariales y para servidores.\u00a0La distribucion mas famosa es Ubuntu, la cual ha sido una de las que han hecho famoso a Linux en el mundo y equiparable a otros sistemas como Windows o macOS, pero Ubuntu no existiria sin Debian, una de las mas antiguas y grandes distribuciones de la cual se baso Canonical para desarrollar Ubuntu.  El proyecto Debian tambien desarrolla sistemas GNU basados en otros nucleos aparte de Linux como (Debian GNU/Hurd, Debian GNU/NetBSD y Debian GNU/kFreeBSD). El modelo de desarrollo del proyecto es ajeno a motivos empresariales o comerciales, siendo llevado adelante por los propios usuarios, aunque cuenta con el apoyo de varias empresas en forma de infraestructuras. Debian no vende directamente su software, lo pone a disposicion de cualquiera en Internet, aunque si permite a personas o empresas distribuirlo comercialmente mientras se respete su licencia.\u200b  Es la quinta distribucion mas popular segun DistroWatch.\u200b  Cada seis meses se publica una nueva version de Ubuntu. Esta recibe soporte por parte de Canonical durante nueve meses por medio de actualizaciones de seguridad, parches para bugs criticos y actualizaciones menores de programas. Las versiones LTS (Long Term Support), que se liberan cada dos a\u00f1os,\u200b reciben soporte durante cinco a\u00f1os en los sistemas de escritorio y de servidor.\u200b  El proyecto no busca solo incluir software libre y de codigo abierto, sino ser el lider en ese ambito tecnologico.\u200b\u200b Algo que hay que destacar es que los desarrolladores de Fedora prefieren hacer cambios en las fuentes originales en lugar de aplicar los parches especificos en su distribucion, de esta forma se asegura que las actualizaciones esten disponibles para todas las variantes de GNU/Linux.\u200b Max Spevack en una entrevista afirmo que: \"Hablar de Fedora es hablar del rapido progreso del software libre y de codigo abierto.\"\u200b  De acuerdo a DistroWatch, Fedora es la octava distribucion de GNU/Linux mas popular, por detras de MX Linux, Manjaro, Linux Mint, Ubuntu, Debian, elementary OS y SolusOS.\u200b   A diferencia de las distribuciones populares basadas en el Nucleo Linux como Ubuntu o Linux Mint, Arch Linux se caracteriza por la gran necesidad de manualmente configurar el sistema operativo, comparandose con otras distribuciones como Slackware o Gentoo Linux. Para instalar y configurar este sistema operativo se necesita un grado de conocimiento superior al basico. No obstante, se puede mantener y administrar el sistema de forma sencilla.  Esta distribucion llego al segundo puesto en DistroWatch, esta enfocada en la facilidad de uso. Usa un modelo de desarrollo denominado rolling release o de Liberacion continua.  Debido a esto, es compatible con una gran multitud de arquitecturas por el hecho que se tiene que compilar los paquetes (a partir del codigo fuente) que se deseen instalar a medida del usuario y maquina destino. Todo esto esta permitido por Portage, un gestor de paquetes basado en Ports, la base de los gestores de paquetes en los sistemas operativos basados en BSD.  Son distribuciones seriamente comprometidas con el Software libre y se abstienen de incluir aplicaciones, manuales y documentacion que no sean libres. Algunas de ellas son:  Distribuciones para dispositivos peque\u00f1os con recursos limitados, como por ejemplo un router inalambrico. Estas distribuciones no son autonomas sino que deben poder ser desarrolladas y compiladas sobre una de las distribuciones libres completas de la lista anterior, posiblemente con el auxilio de herramientas de desarrollo libres distribuidas junto a la misma.  elementary OS Hera  Deepin 15.4  Zorin OS 15  KDE neon  SolusOS 4.1  Qubes OS  Xubuntu 20.04  MX Linux 19  Linux Mint 20.3  Error en la cita: La etiqueta <ref> definida en las <references> no tiene atributo de nombre. Error en la cita: La etiqueta <ref> definida en las <references> no tiene atributo de nombre. ","snippet":"  GNU/Linux (pronunciado oficialmente como \u00f1u linux o tambien ge-ene-u linux en espa\u00f1ol),\u200b es una familia de sistemas operativos tipo Unix compuesto por software libre y de codigo abierto.\u200b GNU/Linux ","enlaces_salientes":["GNU/Linux","GNU/Linux","GNU/Linux","N%C3%BAcleo_Linux","GNU","Linux_(desambiguaci%C3%B3n)","Linux_(desambiguaci%C3%B3n)","Unix-like","Proyecto_GNU","%C3%91u","N%C3%BAcleo_Linux","Ping%C3%BCino","Tux","Sistema_operativo","Desarrollador_de_software","Richard_Stallman","Proyecto_GNU","Linus_Torvalds","N%C3%BAcleo_Linux","Ingenier%C3%ADa_de_software","Software_libre_y_c%C3%B3digo_abierto","FLOSS","GNU","N%C3%BAcleo_Linux","N%C3%BAcleo_Linux","GPL","Licencia_de_software","GNU_General_Public_License","Idioma","Lenguaje_de_programaci%C3%B3n","C_(lenguaje_de_programaci%C3%B3n)","Rust_(lenguaje_de_programaci%C3%B3n)","N%C3%BAcleo_(inform%C3%A1tica)","N%C3%BAcleo_Linux","N%C3%BAcleo_monol%C3%ADtico","Plataforma_(inform%C3%A1tica)","DEC_Alpha","Arquitectura_ARM","Blackfin","ETRAX_CRIS","Itanium","M68k","MIPS","PA-RISC","PowerPC","SuperH","SPARC","X86","Interfaz_gr%C3%A1fica_de_usuario","Interfaz_de_l%C3%ADnea_de_comandos","GUI","Sistema_de_gesti%C3%B3n_de_paquetes","Advanced_Packaging_Tool","Dandified_Yum","Pacman_(gestor_de_paquetes)","Sistema_operativo","Unix-like","Software_libre","C%C3%B3digo_abierto","GNU","Richard_Stallman","N%C3%BAcleo_Linux","Linus_Torvalds","Jerga","N%C3%BAcleo_(inform%C3%A1tica)","Proyecto_GNU","GNU_Compiler_Collection","Entorno_de_escritorio","Android","Distribuci%C3%B3n_Linux","Debian_GNU/Linux","Ubuntu","Red_Hat_Enterprise_Linux","SUSE_Linux","Software_de_aplicaci%C3%B3n","Sistema_de_ventanas_X","GNOME","KDE","Repositorio","Servidor","Supercomputadora","Sistema_embebido","TOP500","Servidor_web","Router","Televisi%C3%B3n_inteligente","Reloj_inteligente","Grabador_de_video_digital","Computadora_de_escritorio","Computador_port%C3%A1til","Dispositivo_m%C3%B3vil","PDA","Videoconsola","Software_libre","C%C3%B3digo_fuente","GPL","Controversia_por_la_denominaci%C3%B3n_GNU/Linux","Acr%C3%B3nimo_recursivo","Software_de_sistema","GNU","Richard_Stallman","1983","Free_Software_Foundation","Linux_(n%C3%BAcleo)","Linus_Torvalds","1991","Unix","Laboratorios_Bell","Ken_Thompson","Dennis_Ritchie","Douglas_McIlroy","Lenguaje_ensamblador","C_(lenguaje_de_programaci%C3%B3n)","Dennis_Ritchie","Antimonopolio","AT%26T","Laboratorios_Bell","GNU","Richard_Stallman","Software_libre","Free_Software_Foundation","GNU_General_Public_License","Sistema_operativo","Biblioteca_(inform%C3%A1tica)","Compilador","Editor_de_texto","Shell_de_Unix","Sistema_de_ventanas_X","Controlador_de_dispositivo","Demonio_(inform%C3%A1tica)","Linus_Torvalds","GNU_Hurd","NetBSD","OpenBSD","FreeBSD","Universidad_de_Helsinki","MINIX","1987","Andrew_S._Tanenbaum","MINIX","N%C3%BAcleo_Linux","GNU_General_Public_License","Bourne-again_shell","Bourne-again_shell","LibreOffice","GIMP","Blender_(software)","0_A.D._(video_game)","Mozilla_Firefox","Daemon_(inform%C3%A1tica)","Systemd","Runit","PulseAudio","X11","Wayland_(display_server_protocol)","GTK%2B","Qt_(software)","Enlightenment_Foundation_Libraries","Simple_DirectMedia_Layer","Simple_and_Fast_Multimedia_Library","FLTK","GNUstep","Mesa_(computer_graphics)","Biblioteca_est%C3%A1ndar_de_C","Subrutina","GNU_C_Library","Musl","UClibc","Bionic_(software)","Android","POSIX","Single_UNIX_Specification","N%C3%BAcleo_Linux","Ioctl","Llamada_al_sistema","POSIX","Single_UNIX_Specification","Planificador","Advanced_Linux_Sound_Architecture","Direct_Rendering_Infrastructure","Evdev","Logical_Volume_Manager_(Linux)","Netfilter","Security-Enhanced_Linux","TOMOYO_Linux","AppArmor","Central_processing_unit","Random-access_memory","Computer_data_storage","Proceso_de_arranque_en_Linux","GNU_GRUB","Biblioteca_(inform%C3%A1tica)","Biblioteca_est%C3%A1ndar_de_C","GNU_Core_Utilities","GTK","Clutter","GNOME","Qt","Sistema_de_gesti%C3%B3n_de_paquetes","Formatos_de_paquetes_en_GNU/Linux","Compilador","Tar","C%C3%B3digo_binario","C%C3%B3digo_fuente","Interfaz_gr%C3%A1fica_de_usuario","Shell","Orden_(inform%C3%A1tica)","Gestor_de_ventanas","Entorno_de_escritorio","Interfaz_gr%C3%A1fica","Interfaz_de_l%C3%ADnea_de_comandos","Entorno_de_escritorio","GNOME","KDE_Plasma_5","LXQt","Xfce","MATE","Cinnamon","GNOME","KDE_Plasma_5","XFCE","Deepin","Cinnamon","MATE","LXQt","Openbox","Programaci%C3%B3n","Compilador","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Lenguaje_de_programaci%C3%B3n_Java","Lenguaje_de_programaci%C3%B3n_Ada","Pascal_(lenguaje_de_programaci%C3%B3n)","D_(lenguaje_de_programaci%C3%B3n)","Fortran","Arquitectura_de_computadoras","Entorno_de_desarrollo_integrado","Anjuta","KDevelop","Lazarus_(entorno_de_desarrollo)","Ultimate%2B%2B","NetBeans_IDE","Eclipse_(software)","Emacs","Vim","Int%C3%A9rprete_de_comandos","Awk","Python","Perl","PHP","Ruby","Sistema_de_gesti%C3%B3n_de_paquetes","Distribuci%C3%B3n_GNU/Linux","Tienda_de_software","Deb","RPM_Package_Manager","Debian","Red_Hat","Compilador","Make","Ejecutable","C%C3%B3digo_cerrado","Software_privativo","Adobe_Reader","Adobe_Flash","Opera_(navegador)","Ofim%C3%A1tica","Libreoffice","Calligra_Suite","WPS_Office","Softmaker_Office","Navegador_web","Mozilla_Firefox","Google_Chrome","Opera_(navegador)","Epiphany","Midori_(navegador)","Brave_(navegador_web)","Waterfox","Pale_Moon","GNU_IceCat","Reproductor_de_medios","VLC_media_player","Rhythmbox","Amarok_(software)","Audacious_Media_Player","Edici%C3%B3n_de_im%C3%A1genes","GIMP","Krita","Inkscape","Editor_de_audio","Audacity","Edici%C3%B3n_de_v%C3%ADdeo","DaVinci_Resolve","Kdenlive","Lightworks","OpenShot","Pitivi","Plataforma_de_videojuegos","Steam","RetroArch","Entorno_de_desarrollo_integrado","Visual_Studio_Code","Sublime_Text","Geany","Qt_Creator","Anjuta","GNOME_Builder","Vim","Emacs","Virtualizaci%C3%B3n","VirtualBox","QEMU","Servicio_de_alojamiento_de_archivos","Dropbox","Mega_(sitio_web)","Dispositivo_de_bloques","Disco_duro","Partici%C3%B3n_de_disco","Sistema_de_archivos","Proceso_de_arranque_en_Linux","Fdisk","Ext4","XFS","NTFS","Computadora","Distribuci%C3%B3n_Linux","Intel","Google","IBM","AMD","Sun_Microsystems","Dell","Lenovo","Asus","Hewlett-Packard","Silicon_Graphics","Renesas_Technology","Fujitsu","Analog_Devices","Freescale","VIA_Technologies","Oracle","Novell","RedHat","Nero_Linux","Lenguaje_de_programaci%C3%B3n_Java","Google_Earth","Google_Desktop","Adobe_Reader","Adobe_Flash","RealPlayer","Yahoo!_Messenger","Adopci%C3%B3n_de_Linux","IBM_Roadrunner","Supercomputadora","Red_Hat_Enterprise_Linux","C%C3%B3digo_abierto","Internet","Facebook","Gmail","LinkedIn","Yahoo","IBM","Red_Hat","RHEL","Rxart","Canonical_Ltd.","Ubuntu","PYME","Linux_Counter","TOP500","Servidor","Internet","OLPC","Organizaci%C3%B3n_Europea_para_la_Investigaci%C3%B3n_Nuclear","Scientific_Linux","CentOS","Portabilidad_del_n%C3%BAcleo_Linux_y_arquitecturas_soportadas","Software_libre_en_la_Administraci%C3%B3n_P%C3%BAblica","Alemania","Argentina","Australia","Brasil","Espa%C3%B1a","Chile","Rep%C3%BAblica_Popular_China","Cuba","M%C3%A9xico","Per%C3%BA","Ecuador","El_Salvador","Uruguay","Venezuela","General_Atomics_MQ-1_Predator","Boeing_P-8_Poseidon","Controversia_por_la_denominaci%C3%B3n_GNU/Linux","GNU","Free_Software_Foundation","Sistema_operativo","Linux_(n%C3%BAcleo)","Proyecto_GNU","Software","1984","Software_libre","UNIX","A%C3%B1os_1990","GNU","Editor_de_texto","Compilador","Depurador","Int%C3%A9rprete_inform%C3%A1tico","N%C3%BAcleo_(inform%C3%A1tica)","GNU","N%C3%BAcleo_(inform%C3%A1tica)","Hurd","N%C3%BAcleo_Linux","Sistema_operativo","GNU","N%C3%BAcleo_Linux","Proyecto_GNU","Sistema_operativo","UNIX","Yggdrasil_Linux","GNU","Linux_(n%C3%BAcleo)","Distribuci%C3%B3n_Linux","Debian_GNU/Linux","GNU/LinEx","Slackware","Gentoo","Ubuntu","KDE","Distribuci%C3%B3n_Linux","Distribuci%C3%B3n_de_software","N%C3%BAcleo_Linux","Paquetes_de_software","Microsoft_Windows","MacOS","Debian","Debian_GNU/Linux","Proyecto_Debian","Ubuntu","Linux_Mint","SteamOS","Kali_Linux","PureOS","Deepin","Proyecto_Debian","GNU","N%C3%BAcleo_Linux","Debian_GNU/Hurd","Debian_GNU/NetBSD","Debian_GNU/kFreeBSD","Usuario","Empresa","Software","Internet","Empresa","Licencia_de_software","Ubuntu","Canonical","Ubuntu","Kubuntu","Xubuntu","Lubuntu","Error_de_software","Computadoras_de_escritorio","Fedora_(distribuci%C3%B3n_Linux)","RPM_Package_Manager","Red_Hat","Software_libre","C%C3%B3digo_abierto","DistroWatch","MX_Linux","Manjaro","Linux_Mint","Ubuntu","Debian","Elementary_OS","SolusOS","OpenSUSE","RPM_Package_Manager","Arch_Linux","Distribuci%C3%B3n_Linux","Computadora","X86","Software_libre_y_de_c%C3%B3digo_abierto","Liberaci%C3%B3n_continua","Idioma_ingl%C3%A9s","Principio_KISS","N%C3%BAcleo_Linux","Ubuntu","Linux_Mint","Slackware","Gentoo_Linux","Sistema_operativo","Manjaro_Linux","Arch_Linux","Repositorio_de_software","Pacman_(gestor_de_paquetes)","Arch_Linux","Liberaci%C3%B3n_continua","Gentoo_Linux","Gentoo_Linux","Liberaci%C3%B3n_continua","Idioma_ingl%C3%A9s","Portage_(software)","Ports","Berkeley_Software_Distribution","Software_libre","Dragora","GNewSense","GNU_Guix","Hyperbola_GNU/Linux-libre","Parabola_GNU/Linux","PureOS","Trisquel_GNU/Linux","Ututo","LibreCMC","Elementary_OS","Deepin","Zorin_OS","KDE_neon","SolusOS","Qubes_OS","Xubuntu","MX_Linux","Linux_Mint","Linux","Software_libre","GNU_Hurd","Historia_de_Linux","Linux-libre","Controversia_por_la_denominaci%C3%B3n_GNU/Linux","O%27Reilly_Media","Wayback_Machine","Idioma_ingl%C3%A9s","Idioma_ingl%C3%A9s","Idioma_ingl%C3%A9s","Linus_Torvalds","ISBN","YouTube","Ian_Murdock","ISSN","Wayback_Machine","Wayback_Machine","DistroWatch","ISBN","Linux_(n%C3%BAcleo)","YouTube","Control_de_autoridades"]}
{"url":"C%C3%B3digo_fuente","titulo":"Codigo fuente","contenido":"El codigo fuente de un programa informatico (o software) es un conjunto de lineas de texto con los pasos que debe seguir la computadora para ejecutar un cargador.\u200b  El codigo fuente de un programa esta escrito por un programador en algun lenguaje de programacion legible por humanos, normalmente en forma de texto plano.\u200b Sin embargo, el programa escrito en un lenguaje legible por humanos no es directamente ejecutable por la computadora en su primer estado, sino que debe ser traducido a otro lenguaje o codigo binario; asi sera mas facil para la maquina interpretarlo  (lenguaje maquina o codigo objeto que si pueda ser ejecutado por el hardware de la computadora). Para esta traduccion se usan los llamados compiladores, ensambladores, interpretes y otros sistemas de traduccion.  El termino codigo fuente tambien se usa para hacer referencia al codigo fuente de otros elementos del software, como, por ejemplo, el codigo fuente de una pagina web, que esta escrito en lenguaje de marcado HTML o en Javascript, u otros lenguajes de programacion web, y que es posteriormente ejecutado por el navegador web para visualizar dicha pagina cuando es visitada.  El area de la informatica que se dedica a la creacion de programas, y por tanto a la creacion de su codigo fuente, es la ingenieria de software.  Un aspecto interesante a tener en cuenta cuando se habla del codigo fuente de un programa informatico es si su licencia permite que dicho codigo fuente este disponible para que cualquiera pueda estudiarlo, modificarlo o reutilizarlo. Cuando se cumple este aspecto se dice que el programa es de codigo abierto y son, en general, software libre, en contraposicion al software privativo sobre el cual no se tiene ninguno de estos permisos. ","snippet":"El codigo fuente de un programa informatico (o software) es un conjunto de lineas de texto con los pasos que debe seguir la computadora para ejecutar un cargador.\u200b  El codigo fuente de un programa est","enlaces_salientes":["C%C3%B3digo_fuente","C%C3%B3digo_fuente","C%C3%B3digo_fuente","Source_Code","Java_(lenguaje_de_programaci%C3%B3n)","Programa_inform%C3%A1tico","Software","L%C3%ADnea_de_c%C3%B3digo_fuente","Computadora","Programador","Lenguaje_de_programaci%C3%B3n","Legible_por_humanos","Texto_plano","C%C3%B3digo_binario","Lenguaje_m%C3%A1quina","C%C3%B3digo_objeto","Hardware","Compilador","Ensamblador","Int%C3%A9rprete_(inform%C3%A1tica)","P%C3%A1gina_web","Lenguaje_de_marcado","HTML","Javascript","Navegador_web","Inform%C3%A1tica","Ingenier%C3%ADa_de_software","Licencia_de_software","Software_libre","Software_privativo","Software_de_c%C3%B3digo_abierto","Lenguaje_de_programaci%C3%B3n","GNU/Linux","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation"]}
{"url":"Compilado","titulo":"Compilador","contenido":"En informatica, un compilador es un programa que traduce codigo escrito en un lenguaje de programacion (llamado fuente) a otro lenguaje (conocido como objeto).\u200b En este tipo de traductor el lenguaje fuente es generalmente un lenguaje de alto nivel y el objeto un lenguaje de bajo nivel, como assembly o codigo maquina.\u200b Este proceso de traduccion se conoce como compilacion.\u200b  La construccion de un compilador involucra la division del proceso en una serie de fases que variara con su complejidad. Generalmente estas fases se agrupan en dos tareas: el analisis del programa fuente y la sintesis del programa objeto.\u200b:\u200a3  Alternativamente, las fases descritas para las tareas de analisis y sintesis se pueden agrupar en:  Esta division permite que el mismo generador se utilice para crear el codigo maquina de varios lenguajes de programacion distintos y que el mismo analizador que sirve para examinar el codigo fuente de un lenguaje de programacion concreto sirva para producir codigo maquina en varias plataformas.  En 1938, Konrad Zuse desarrollo la primera computadora digital electromecanica, denominada Z1 en Alemania, y posteriormente, en 1946, se desarrollo la primera computadora totalmente electronica ENIAC, sucedida principalmente por la EDVAC (1951), primera computadora electronica digital. En un principio, estas maquinas ejecutaban instrucciones consistentes en codigos numericos que se\u00f1alaban a los circuitos de la maquina los estados correspondientes a cada operacion, lo que se denomino lenguaje maquina.  Pronto los primeros usuarios de estos ordenadores descubrieron la ventaja de escribir sus programas mediante claves mas faciles de recordar que esos codigos; al final, todas esas claves juntas se traducian manualmente a lenguaje maquina. Estas claves constituyen los llamados lenguajes ensambladores.  Pese a todo, el lenguaje ensamblador seguia siendo el de una maquina, pero mas facil de manejar (las instrucciones de maquina se reemplazan por mnemonicos. Los trabajos de investigacion se orientaron hacia la creacion de un lenguaje que expresara las distintas acciones a realizar de una manera lo mas sencilla posible para una persona. El primer compilador fue escrito por Grace Hopper, en 1952 para el lenguaje de programacion A-0. En 1950 John Backus dirigio una investigacion en IBM sobre un lenguaje algebraico. En 1954 se empezo a desarrollar un lenguaje que permitia escribir formulas matematicas de manera traducible por un ordenador; le llamaron FORTRAN (FORmulae TRANslator). Fue el primer lenguaje de alto nivel y se introdujo en 1957 para el uso de la computadora IBM modelo 704.  Surgio asi por primera vez el concepto de un traductor como un programa que traducia un lenguaje a otro lenguaje. En el caso particular de que el lenguaje a traducir es un lenguaje de alto nivel y el lenguaje traducido de bajo nivel, se emplea el termino compilador.  El trabajo de realizar un compilador fue complicado de realizar. El primer compilador de FORTRAN tardo 18 a\u00f1os-persona en realizarse y era muy sencillo. Este desarrollo de FORTRAN estaba muy influenciado por la maquina objeto en la que iba a ser implementado. Como un ejemplo de ello tenemos el hecho de que los espacios en blanco fuesen ignorados, debido a que el periferico que se utilizaba como entrada de programas (una lectora de tarjetas perforadas) no contaba correctamente los espacios en blanco.  El primer compilador autocontenido, es decir, capaz de compilar su propio codigo fuente fue el creado para Lisp por Hart y Levin en el MIT en 1962. Desde 1970 se ha convertido en una practica comun escribir el compilador en el mismo lenguaje que este compila, aunque PASCAL y C han sido alternativas muy usadas.  Crear un compilador autocontenido genera un problema llamado bootstrapping, es decir el primer compilador creado para un lenguaje tiene que o bien ser compilado por un compilador escrito en otro lenguaje o bien compilado al ejecutar el compilador en un interprete.  Esta taxonomia de los tipos de compiladores no es excluyente, por lo que puede haber compiladores que se adscriban a varias categorias:  En las primeras epocas de la informatica, los compiladores eran considerados un software de los mas complejos existentes.[cita\u00a0requerida]  Los primeros compiladores se realizaron programandolos directamente en lenguaje maquina o en ensamblador. Una vez que se dispone de un compilador, se pueden escribir nuevas versiones del compilador (u otros compiladores distintos) en el lenguaje que compila ese compilador.  Existen herramientas que facilitan la tarea de escribir compiladores o interpretes informaticos. Estas herramientas permiten generar el esqueleto del analizador sintactico a partir de una definicion formal del lenguaje de partida, especificada normalmente mediante una gramatica formal y barata, dejando unicamente al programador del compilador la tarea de programar las acciones semanticas asociadas.  Es el proceso por el cual se traducen las instrucciones escritas en un determinado lenguaje de programacion a lenguaje maquina. Ademas de un traductor, se pueden necesitar otros programas para crear un programa objeto ejecutable. Un programa fuente se puede dividir en modulos almacenados en archivos distintos. La tarea de reunir el programa fuente a menudo se confia a un programa distinto, llamado preprocesador. El preprocesador tambien puede expandir abreviaturas, llamadas a macros, a proposiciones del lenguaje fuente.  Normalmente la creacion de un programa ejecutable (un tipico archivo .exe para Windows o DOS) conlleva dos pasos. El primer paso se llama compilacion (propiamente dicho) y traduce el codigo fuente escrito en un lenguaje de programacion almacenado en un archivo a codigo en bajo nivel (normalmente en codigo objeto, no directamente a lenguaje maquina). El segundo paso se llama enlazado en el cual se enlaza el codigo de bajo nivel generado de todos los ficheros y subprogramas que se han mandado a compilar y se a\u00f1ade el codigo de las funciones que hay en las bibliotecas del compilador para que el ejecutable pueda comunicarse directamente con el sistema operativo, traduciendo asi finalmente el codigo objeto a codigo maquina, y generando un modulo ejecutable.  Estos dos pasos se pueden hacer por separado, almacenando el resultado de la fase de compilacion en archivos objetos (un tipico.obj para Microsoft Windows, DOS o para Unix); para enlazarlos en fases posteriores, o crear directamente el ejecutable; con lo que la fase de compilacion se almacena solo temporalmente. Un programa podria tener partes escritas en varios lenguajes (por ejemplo C, C++ y Asm), que se podrian compilar de forma independiente y luego enlazar juntas para formar un unico modulo ejecutable.  El proceso de traduccion se compone internamente de varias etapas o fases, que realizan distintas operaciones logicas. Es util pensar en estas fases como en piezas separadas dentro del traductor, y pueden en realidad escribirse como operaciones codificadas separadamente aunque en la practica a menudo se integren juntas.  El analisis lexico constituye la primera fase, aqui se lee el programa fuente de izquierda a derecha y se agrupa en componentes lexicos (tokenes), que son secuencias de caracteres que tienen un significado. Ademas, todos los espacios en blanco, lineas en blanco, comentarios y demas informacion innecesaria se elimina del programa fuente. Tambien se comprueba que los simbolos del lenguaje (palabras clave, operadores, etc.) se han escrito correctamente.  Como la tarea que realiza el analizador lexico es un caso especial de coincidencia de patrones, se necesitan los metodos de especificacion y reconocimiento de patrones, se usan principalmente los automatas finitos que acepten expresiones regulares. Sin embargo, un analizador lexico tambien es la parte del traductor que maneja la entrada del codigo fuente, y puesto que esta entrada a menudo involucra un importante gasto de tiempo, el analizador lexico debe funcionar de manera tan eficiente como sea posible.  En esta fase los caracteres o componentes lexicos se agrupan jerarquicamente en frases gramaticales que el compilador utiliza para sintetizar la salida. Se comprueba si lo obtenido de la fase anterior es sintacticamente correcto (obedece a la gramatica del lenguaje). Por lo general, las frases gramaticales del programa fuente se representan mediante un arbol de analisis sintactico.  La estructura jerarquica de un programa normalmente se expresa utilizando reglas recursivas. Por ejemplo, se pueden dar las siguientes reglas como parte de la definicion de expresiones:  Las reglas 1 y 2 son reglas basicas (no recursivas), en tanto que la regla 3 define expresiones en funcion de operadores aplicados a otras expresiones.  La division entre analisis lexico y analisis sintactico es algo arbitraria. Un factor para determinar la division es si una construccion del lenguaje fuente es inherentemente recursiva o no. Las construcciones lexicas no requieren recursion, mientras que las construcciones sintacticas suelen requerirla. No se requiere recursion para reconocer los identificadores, que suelen ser cadenas de letras y digitos que comienzan con una letra. Normalmente, se reconocen los identificadores por el simple examen del flujo de entrada, esperando hasta encontrar un caracter que no sea ni letra ni digito, y agrupando despues todas las letras y digitos encontrados hasta ese punto en un componente lexico llamado identificador. Por otra parte, esta clase de analisis no es suficientemente poderoso para analizar expresiones o proposiciones. Por ejemplo, no podemos emparejar de manera apropiada los parentesis de las expresiones, o las palabras begin y end en proposiciones sin imponer alguna clase de estructura jerarquica o de anidamiento a la entrada.  La fase de analisis semantico revisa el programa fuente para tratar de encontrar errores semanticos y reune la informacion sobre los tipos para la fase posterior de generacion de codigo. En ella se utiliza la estructura jerarquica determinada por la fase de analisis sintactico para identificar los operadores y operandos de expresiones y proposiciones.  Un componente importante del analisis semantico es la verificacion de tipos. Aqui, el compilador verifica si cada operador tiene operandos permitidos por la especificacion del lenguaje fuente. Por ejemplo, las definiciones de muchos lenguajes de programacion requieren que el compilador indique un error cada vez que se use un numero real como indice de una matriz. Sin embargo, la especificacion del lenguaje puede imponer restricciones a los operandos, por ejemplo, cuando un operador aritmetico binario se aplica a un numero entero y a un numero real.\u200b Revisa que los arreglos tengan definido el tama\u00f1o correcto.  Consiste en generar el codigo objeto equivalente al programa fuente. Solo se generara codigo objeto cuando el programa fuente esta libre de errores de analisis.  El resultado puede ser lenguaje de maquina o codigo ensamblador.\u200b Las posiciones de memoria se seleccionan para cada una de las variables usadas por el programa. Despues, cada una de las instrucciones intermedias se traduce a una secuencia de instrucciones de maquina que ejecuta la misma tarea. Un aspecto decisivo es la asignacion de variables a registros.  Despues de los analisis sintactico y semantico, algunos compiladores generan una representacion intermedia explicita del programa fuente. Esta representacion intermedia debe tener dos propiedades importantes: debe ser facil de producir y facil de traducir al programa objeto.\u200b  La representacion intermedia puede tener diversas formas. Existe una forma intermedia llamada \u00abcodigo de tres direcciones\u00bb, similar al lenguaje ensamblador, en la que cada instruccion lleva a cabo una sola operacion. El codigo de tres direcciones consiste en una secuencia de instrucciones, cada una de las cuales tiene como maximo tres operandos. Esta representacion intermedia tiene varias propiedades:  La fase de optimizacion de codigo consiste en mejorar el codigo intermedio, de modo que resulte un codigo maquina mas rapido de ejecutar. Esta fase de la etapa de sintesis es posible sobre todo si el traductor es un compilador (dificilmente un interprete puede optimizar el codigo objeto). Hay mucha variacion en la cantidad de optimizacion de codigo que ejecutan los distintos compiladores. En los que hacen mucha optimizacion, llamados \u00abcompiladores optimizadores\u00bb, una parte significativa del tiempo del compilador se ocupa en esta fase. Sin embargo, hay optimizaciones sencillas que mejoran sensiblemente el tiempo de ejecucion del programa objeto sin retardar demasiado la compilacion.\u200b  La interaccion entre los algoritmos utilizados por las fases del compilador y las estructuras de datos que soportan estas fases es, naturalmente, muy fuerte. El escritor del compilador se esfuerza por implementar estos algoritmos de una manera tan eficaz como sea posible, sin aumentar demasiado la complejidad. De manera ideal, un compilador deberia poder compilar un programa en un tiempo proporcional al tama\u00f1o del mismo.  Cuando un analizador lexico reune los caracteres en un token, generalmente representa el token de manera simbolica, es decir, como un valor de un tipo de datos enumerado que representa el conjunto de tokens del lenguaje fuente. En ocasiones tambien es necesario mantener la cadena de caracteres misma u otra informacion derivada de ella, tal como el nombre asociado con un token identificador o el valor de un token de numero.  En la mayoria de los lenguajes el analizador lexico solo necesita generar un token a la vez. En este caso se puede utilizar una variable global simple para mantener la informacion del token. En otros casos (cuyo ejemplo mas notable es FORTRAN), puede ser necesario un arreglo (o vector) de tokenes.  Si el analizador sintactico genera un arbol sintactico, por lo regular se construye como una estructura estandar basada en un puntero que se asigna de manera dinamica a medida que se efectua el analisis sintactico. El arbol entero puede entonces conservarse como una variable simple que apunta al nodo raiz. Cada nodo en la estructura es un registro cuyos campos representan la informacion recolectada tanto por el analizador sintactico como, posteriormente, por el analizador semantico. Por ejemplo, el tipo de datos de una expresion puede conservarse como un campo en el nodo del arbol sintactico para la expresion.  En ocasiones, para ahorrar espacio, estos campos se asignan de manera dinamica, o se almacenan en otras estructuras de datos, tales como la tabla de simbolos, que permiten una asignacion y desasignacion selectivas. En realidad, cada nodo del arbol sintactico por si mismo puede requerir de atributos diferentes para ser almacenado, de acuerdo con la clase de estructura del lenguaje que represente. En este caso, cada nodo en el arbol sintactico puede estar representado por un registro variable, con cada clase de nodo conteniendo solamente la informacion necesaria para ese caso.  Esta estructura de datos mantiene la informacion asociada con los identificadores: funciones, variables, constantes y tipos de datos. La tabla de simbolos interactua con casi todas las fases del compilador: el analizador lexico, el analizador sintactico o el analizador semantico pueden introducir identificadores dentro de la tabla; el analizador semantico agregara tipos de datos y otra informacion; y las fases de optimizacion y generacion de codigo utilizaran la informacion proporcionada por la tabla de simbolos para efectuar selecciones apropiadas de codigo objeto.  Puesto que la tabla de simbolos tendra solicitudes de acceso con tanta frecuencia, las operaciones de insercion, eliminacion y acceso necesitan ser eficientes, preferiblemente operaciones de tiempo constante. Una estructura de datos estandar para este proposito es la tabla de dispersion o de calculo de direccion, aunque tambien se pueden utilizar diversas estructuras de arbol. En ocasiones se utilizan varias tablas y se mantienen en una lista o pila.  La busqueda y la insercion rapida son esenciales tambien para la tabla de literales, la cual almacena constantes y cadenas utilizadas en el programa. Sin embargo, una tabla de literales necesita impedir las eliminaciones porque sus datos se aplican globalmente al programa y una constante o cadena aparecera solo una vez en esta tabla. La tabla de literales es importante en la reduccion del tama\u00f1o de un programa en la memoria al permitir la reutilizacion de constantes y cadenas. Tambien es necesaria para que el generador de codigo construya direcciones simbolicas para las literales y para introducir definiciones de datos en el archivo de codigo objeto.  De acuerdo con la clase de codigo intermedio (por ejemplo, codigo de tres direcciones o codigo P) y de las clases de optimizaciones realizadas, este codigo puede conservarse como un arreglo de cadenas de texto, un archivo de texto temporal o bien una lista de estructuras ligadas. En los compiladores que realizan optimizaciones complejas debe ponerse particular atencion a la seleccion de representaciones que permitan una facil reorganizacion.  La fase de optimizacion de codigo trata de mejorar el codigo intermedio de modo que resulte un codigo de maquina mas rapido de ejecutar. Algunas optimizaciones son triviales. Por ejemplo, un algoritmo natural genera el codigo intermedio (2) utilizando una instruccion para cada operador de la representacion del arbol despues del analisis semantico, aunque hay una forma mejor de realizar los mismos calculos usando las dos instrucciones  Este sencillo algoritmo no tiene nada de malo, puesto que el problema se puede solucionar en la fase de optimizacion de codigo. Esto es, el compilador puede deducir que la conversion de 60 de entero a real se puede hacer de una vez por todas en el momento de la compilacion, de modo que la operacion \"entreal( )\" se puede eliminar. Ademas, temp3 se usa solo una vez, para transmitir su valor a id1. Entonces resulta seguro sustituir a id1 por temp3, a partir de lo cual la ultima proposicion de (2) no se necesita y se obtiene el codigo de (3).  Hay muchas variaciones en la cantidad de optimizacion de codigo que ejecutan los distintos compiladores. En lo que hacen mucha optimizacion llamados \u00abcompiladores optimizadores\u00bb, una parte significativa del tiempo del compilador se ocupa en esta fase. Sin embargo, hay optimizaciones sencillas que mejoran sensiblemente el tiempo de ejecucion del programa objeto sin retardar demasiado la compilacion.  Al principio las computadoras no tenian la suficiente memoria para guardar un programa completo durante la compilacion. Este problema se resolvio mediante el uso de archivos temporales para mantener los productos de los pasos intermedios durante la traduccion o bien al compilar \u00abal vuelo\u00bb, es decir, manteniendo solo la informacion suficiente de las partes anteriores del programa fuente que permita proceder a la traduccion.  Las limitaciones de memoria son ahora un problema mucho menor, y es posible requerir que una unidad de compilacion entera se mantenga en memoria, en especial si se dispone de la compilacion por separado en el lenguaje. Con todo, los compiladores ocasionalmente encuentran util generar archivos intermedios durante alguna de las etapas del procesamiento. Algo tipico de estos es la necesidad de direcciones de correccion hacia atras durante la generacion de codigo. ","snippet":"En informatica, un compilador es un programa que traduce codigo escrito en un lenguaje de programacion (llamado fuente) a otro lenguaje (conocido como objeto).\u200b En este tipo de traductor el lenguaje f","enlaces_salientes":["Compilador","Compilador","Compilador","Recopilaci%C3%B3n","Inform%C3%A1tica","Programa_inform%C3%A1tico","Lenguaje_de_programaci%C3%B3n","C%C3%B3digo_fuente","C%C3%B3digo_objeto","Lenguaje_de_alto_nivel","Lenguaje_de_bajo_nivel","Lenguaje_ensamblador","Lenguaje_de_m%C3%A1quina","An%C3%A1lisis_de_algoritmos","Lenguaje_formal","Analizador_l%C3%A9xico","Analizador_sint%C3%A1ctico","S%C3%ADntesis","C%C3%B3digo_objeto","Compilador_optimizador","Teor%C3%ADa_de_la_complejidad_computacional","Complejidad_de_Kolmog%C3%B3rov","C%C3%B3digo_fuente","Tabla_de_s%C3%ADmbolos_(compilador)","C%C3%B3digo_m%C3%A1quina","Lenguajes_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n","C%C3%B3digo_m%C3%A1quina","Historia_de_la_construcci%C3%B3n_de_los_compiladores","Konrad_Zuse","Z1","ENIAC","EDVAC","Lenguaje_m%C3%A1quina","Lenguaje_ensamblador","Mnem%C3%B3nico","Grace_Hopper","John_Backus","FORTRAN","Int%C3%A9rprete_(inform%C3%A1tica)","Compilador_cruzado","Compilador_optimizador","Compilaci%C3%B3n_en_tiempo_de_ejecuci%C3%B3n","Int%C3%A9rprete_(inform%C3%A1tica)","Inform%C3%A1tica","Lenguaje_m%C3%A1quina","Ensamblador","Int%C3%A9rprete_(inform%C3%A1tica)","Analizador_sint%C3%A1ctico","Gram%C3%A1tica_formal","Preprocesador","Ejecutable","Microsoft_Windows","DOS","Lenguaje_de_programaci%C3%B3n","Enlazador","C%C3%B3digo_objeto","C%C3%B3digo_m%C3%A1quina","Unix","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Lenguaje_ensamblador","Ejecutable","Analizador_l%C3%A9xico","Token_(programaci%C3%B3n)","Palabra_clave","Operador","Aut%C3%B3mata_finito","Expresi%C3%B3n_regular","Analizador_sint%C3%A1ctico","Recursividad","Identificador","N%C3%BAmero_real","Matriz_(programaci%C3%B3n)","C%C3%B3digo_objeto","Registro_(hardware)","C%C3%B3digo_de_tres_direcciones","Lenguaje_ensamblador","Compilador_optimizador","Int%C3%A9rprete_(inform%C3%A1tica)","Estructura_de_datos","Algoritmo","Token","Cadena_de_caracteres","FORTRAN","Vector_(programaci%C3%B3n)","Puntero_(programaci%C3%B3n)","Nodo_(inform%C3%A1tica)","Funci%C3%B3n_(programaci%C3%B3n)","Variable_(programaci%C3%B3n)","Constante_(programaci%C3%B3n)","Tipo_de_dato","Lista_(estructura_de_datos)","Pila_(estructura_de_datos)","Generador_de_c%C3%B3digo","BlueJ","Lenguaje_de_programaci%C3%B3n","Lenguaje_ensamblador","Ensamblador","Desensamblador","Decompilador","Int%C3%A9rprete_(inform%C3%A1tica)","Depurador","Lenguaje_de_alto_nivel","Lenguaje_de_bajo_nivel","Lenguaje_de_m%C3%A1quina","Historia_de_la_construcci%C3%B3n_de_los_compiladores","Principles_of_Compiler_Design","ISBN","ISBN","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","ISBN","OCLC","ISBN","OCLC","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Ejecutable","titulo":"Ejecutable","contenido":"En informatica, un ejecutable o archivo ejecutable, es tradicionalmente un archivo binario, cuyo contenido se interpreta por el ordenador como un programa.\u200b  Generalmente, contiene instrucciones en codigo maquina de un procesador en concreto, pero tambien puede contener bytecode que requiera un interprete para ejecutarlo. Ademas, suele contener llamadas a funciones especificas de un sistema operativo (llamadas al sistema).  Dependiendo del tipo de instrucciones de que se traten, hablaremos de ejecutables portables (se pueden ejecutar en varias plataformas) y no portables (destinado a una plataforma concreta). Por ejemplo, un ejecutable Java es portable ya que utiliza un bytecode no asociado a un procesador en concreto.\u200b  Sin embargo en un sentido mas general, un programa ejecutable no tiene por que necesariamente contener codigo de maquina, sino que puede tener instrucciones a interpretar por otro programa. Este tipo de ejecutables son conocidos con el nombre de scripts.  Determinar si un archivo es ejecutable es sobre todo una cuestion de convencion. Unos sistemas operativos se basan en la extension de archivo (como la terminacion .exe) y otros lo hacen leyendo los metadatos (como los bits de permiso de ejecucion en Unix).\u200b  En la mayoria de los sistemas modernos, un archivo ejecutable contiene mucha informacion que no es parte del programa en si: recursos como textos e imagenes, requisitos del entorno de ejecucion, informacion simbolica y de depuracion, u otra informacion que ayude al sistema operativo a ejecutar el programa. ","snippet":"En informatica, un ejecutable o archivo ejecutable, es tradicionalmente un archivo binario, cuyo contenido se interpreta por el ordenador como un programa.\u200b  Generalmente, contiene instrucciones en co","enlaces_salientes":["Ejecutable","Ejecutable","Ejecutable","Inform%C3%A1tica","Archivo_binario","Ordenador","Programa_(computaci%C3%B3n)","Conjunto_de_instrucciones","C%C3%B3digo_m%C3%A1quina","Unidad_central_de_procesamiento","Bytecode","Int%C3%A9rprete_inform%C3%A1tico","Llamadas_al_sistema","Portabilidad","Plataforma_Java","Java_bytecode","Script","Metadato","Unix","Archivo_(computaci%C3%B3n)","Informaci%C3%B3n","Im%C3%A1genes","Depuraci%C3%B3n_de_programas","Biblioteca_(inform%C3%A1tica)","C%C3%B3digo_nativo","Lenguaje_de_m%C3%A1quina","Portable_Executable","EXE_(inform%C3%A1tica)","Archivo_COM","Editorial_Revert%C3%A9","ISBN","Universidad_Nacional_Mayor_de_San_Marcos","ISBN","Control_de_autoridades"]}
{"url":"Instrucci%C3%B3n_(inform%C3%A1tica)","titulo":"Instruccion (informatica)","contenido":"Se denomina instruccion en informatica al conjunto de datos insertados en una secuencia estructurada o especifica que el procesador interpreta y ejecuta.  Los tipos de instruccion son aquellos permitidos estan definidos y determinados dentro de cada importante  plataforma en el conjunto de instrucciones (en ingles ISA, instruction set architecture), que tambien determina los registros de origen y destino de la CPU, y en ocasiones un dato inmediato (aquellos que son especificados explicitamente en la instruccion).  Estas instrucciones del computador son las que determinan el funcionamiento de la CPU que las ejecuta. La CPU puede realizar una diversidad de funciones, que son el reflejo de la variedad de las instrucciones definidas para dicha CPU. El programador tiene un repertorio de instrucciones como medio para controlar la CPU.  Normalmente una instruccion se divide en dos campos:  El tama\u00f1o (longitud en bits) de la instruccion depende de cada arquitectura, pudiendo variar de 4 hasta 128 bits.  La instruccion debe almacenarse temporalmente (en el registro de instruccion, RI) para que la CPU analice su contenido y extraiga los datos que la forman. A este paso se le llama decodificacion.  Las instrucciones de un lenguaje de programacion se pueden clasificar en 4 grupos: ","snippet":"Se denomina instruccion en informatica al conjunto de datos insertados en una secuencia estructurada o especifica que el procesador interpreta y ejecuta.  Los tipos de instruccion son aquellos permiti","enlaces_salientes":["Instrucci%C3%B3n_(inform%C3%A1tica)","Instrucci%C3%B3n_(inform%C3%A1tica)","Instrucci%C3%B3n_(inform%C3%A1tica)","Inform%C3%A1tica","Microprocesador","Plataforma_(inform%C3%A1tica)","Conjunto_de_instrucciones","Registro_(hardware)","CPU","CPU","Programador","Repertorio_de_instrucciones","Opcode","Lenguaje_ensamblador","Mnem%C3%B3nico","MIPS_(procesador)","Bits","Registro_de_instrucci%C3%B3n","Decodificador","Memoria_virtual","Cach%C3%A9_(inform%C3%A1tica)","Contador_de_programa","Subrutinas","Ciencias_de_la_computaci%C3%B3n","Enlazado","Mapa_de_memoria","Lenguaje_(programaci%C3%B3n)","Computadora_electr%C3%B3nica","Lenguaje_de_m%C3%A1quina","Comando_(inform%C3%A1tica)","Control_de_autoridades"]}
{"url":"Sistema_inform%C3%A1tico","titulo":"Sistema informatico","contenido":"Un sistema informatico (SI) es un sistema que permite almacenar y procesar informacion; es el conjunto de partes interrelacionadas: hardware, software y personal informatico. El hardware incluye computadoras o cualquier tipo de dispositivo electronico, que consisten en procesadores, memoria, sistemas de almacenamiento externo, etc. El software incluye al sistema operativo, firmware y aplicaciones, siendo especialmente importante los sistemas de gestion de bases de datos. Por ultimo, el componente humano incluye al personal tecnico que apoya y mantienen el sistema (analistas, programadores, operarios, etc.) y a los usuarios que lo utilizan.  Los sistemas informaticos pasan por diferentes fases en su ciclo de vida, desde la captura de requisitos hasta el mantenimiento. En la actualidad se emplean numerosos sistemas informaticos en la administracion publica, por ejemplo, las operadoras de la policia, el servicio al cliente, entre otras.  Empezo como una maquina de calculo aritmetico conocida como la maquina analitica. Sin embargo, podemos situar el origen de las computadoras en un sentido estricto en el a\u00f1o 1936, cuando Konrad Zuse invento la Z1, la primera computadora programable. Aqui comienza la llamada primera generacion, que abarca hasta el a\u00f1o 1946, teniendo propositos basicamente militares. Fue en esta decada donde se implementarian nuevos protocolos en la computacion, una de ellas dio pie a los primeros pasos del Internet de aquel entonces (ARPANET).  Los sistemas informaticos suelen estructurarse en subsistemas:  Los sistemas informaticos pueden clasificarse con base a numerosos criterios. Las clasificaciones no son estancas y es comun encontrar sistemas hibridos que no encajen en una unica categoria.   Es el a\u00f1o 1983 el que normalmente se marca como el a\u00f1o en que \u00abnacio Internet\u00bb. Fue entonces cuando el Departamento de Defensa de los Estados Unidos decidio usar el protocolo TCP/IP en su red Arpanet creando asi la red Arpa Internet. Con el paso de los a\u00f1os se quedo con el nombre de unicamente \u00abInternet\u00bb.  La ENIAC se ha considerado, historicamente, como la primera computadora de proposito general, aunque el titulo le pertenece en realidad a la computadora alemana Z1. ","snippet":"Un sistema informatico (SI) es un sistema que permite almacenar y procesar informacion; es el conjunto de partes interrelacionadas: hardware, software y personal informatico. El hardware incluye compu","enlaces_salientes":["Sistema_inform%C3%A1tico","Sistema_inform%C3%A1tico","Sistema_inform%C3%A1tico","Teor%C3%ADa_de_sistemas","Informaci%C3%B3n","Hardware","Software","Computadora","Aparato_electr%C3%B3nico","Unidad_central_de_procesamiento","Memoria_(inform%C3%A1tica)","Sistema_operativo","Firmware","Aplicaci%C3%B3n_inform%C3%A1tica","Base_de_datos","M%C3%A1quina_anal%C3%ADtica","Konrad_Zuse","Z1","Arpanet","Hardware","Unidad_central_de_procesamiento","Memoria_principal","Placa_base","Perif%C3%A9rico_(inform%C3%A1tica)","Software","Sistema_operativo","Firmware","Software_de_aplicaci%C3%B3n","Base_de_datos","Sistema_de_detecci%C3%B3n_de_intrusos","Sistema_de_monitorizaci%C3%B3n","MIMD","SIMD","SISD","Estaci%C3%B3n_de_trabajo","Computadoras_personales","Cliente_liviano","Cliente-servidor","Servidor_de_aplicaciones","Inform%C3%A1tica","Sistema_de_informaci%C3%B3n","Sistema_embebido","Sistema_Integral_de_Informaci%C3%B3n","Control_de_autoridades","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Art_%26_Architecture_Thesaurus","Medical_Subject_Headings"]}
{"url":"Beta_tester","titulo":"Beta tester","contenido":"Un probador beta o betatesteador (del ingles beta tester) es un usuario de programas cuyos ejecutables estan pendientes de terminar su fase de desarrollo, que tienen un funcionamiento completo, pero que aun no estan totalmente terminados presentando fallos de diversos tipos o caracteristicas pendientes de implementar.\u200b  Los probadores betas usan sus conocimientos informaticos y su tiempo para detectar errores en la version beta del software y asi poder informar de estos para que los desarrolladores los corrijan, o corregirlos ellos mismos. Algunas compa\u00f1ias los contratan para asegurarse de que sus programas van a funcionar lo mejor posible en el mercado. Otro tipo de probadores betas son los que trabajan desinteresadamente ofreciendo soporte y ayuda a la comunidad GNU.  Generalmente el beta tester comparte una cierta afinidad con la herramienta puesta a prueba en cuestion, de ahi el entusiasmo por probarla, verificar nuevas funcionalidades y detectar anomalias con el proposito de mejorar el desarrollo de dicha herramienta.  Es el mismo concepto, pero aplicado a la version alfa del software, es decir, al programa que se encuentra en la fase alfa del desarrollo. ","snippet":"Un probador beta o betatesteador (del ingles beta tester) es un usuario de programas cuyos ejecutables estan pendientes de terminar su fase de desarrollo, que tienen un funcionamiento completo, pero q","enlaces_salientes":["Beta_tester","Beta_tester","Beta_tester","Software","Error_de_software","Versi%C3%B3n_beta","GNU","Versi%C3%B3n_alfa","Fases_del_desarrollo_de_software","Control_de_autoridades"]}
{"url":"Depurador","titulo":"Depurador","contenido":"Un depurador (en ingles: debugger) es un programa que se utiliza para detectar e identificar los errores en un software (el programa \"objetivo\") y, por lo tanto, los desarrolladores pueden encontrar los fallos en el programa de forma mas facil, facilitando el proceso de correccion\u200b. El codigo a ser examinado puede alternativamente estar corriendo en un simulador de conjunto de instrucciones (ISS), una tecnica que permite gran potencia en su capacidad de detenerse cuando son encontradas condiciones especificas pero sera tipicamente algo mas lento que ejecutando el codigo directamente en el apropiado (o el mismo) procesador. Algunos depuradores ofrecen dos modos de operacion, la simulacion parcial o completa, para limitar este impacto.  Si es un depurador de nivel de fuente o depurador simbolico, comunmente ahora visto en entornos de desarrollo integrados, cuando el programa \"se estrella\" o alcanza una condicion predefinida, la depuracion tipicamente muestra la posicion en el codigo original. Si es un depurador de bajo nivel o un depurador de lenguaje de maquina, muestra la linea en el fuente desensamblado (a menos que tambien tenga acceso en linea al codigo fuente original y pueda exhibir la seccion apropiada del codigo del ensamblador o del compilador). Un \"estrellamiento\" sucede cuando el programa no puede continuar normalmente debido a un error de programacion. Por ejemplo, el programa pudo haber intentado usar una instruccion no disponible en la version actual del CPU o haber intentado tener acceso a memoria protegida o no disponible.  Tipicamente, los depuradores tambien ofrecen funciones mas sofisticadas tales como correr un programa paso a paso (un paso o animacion del programa), parar el programa (breaking), es decir, pausar el programa para examinar el estado actual en cierto evento o instruccion especificada por medio de un breakpoint, y el seguimiento de valores de algunas variables. Algunos depuradores tienen la capacidad de modificar el estado del programa mientras que esta corriendo, en vez de simplemente observarlo. Tambien es posible continuar la ejecucion en una posicion diferente en el programa bypaseando un estrellamiento o error logico.  La importancia de un buen depurador no puede ser exagerada. De hecho, la existencia y la calidad de tal herramienta para un lenguaje y una plataforma dadas a menudo puede ser el factor de decision en su uso, incluso si otro lenguaje/plataforma es mas adecuado para la tarea.[cita\u00a0requerida] La ausencia de un depurador, una vez estando acostumbrado a usar uno, se ha dicho que \"hace que usted se sienta como un hombre ciego en un cuarto oscuro buscando un gato negro que no esta alli\".\u200b Sin embargo, el software puede (y a menudo) se comporta diferentemente corriendo bajo un depurador que normalmente, debido a los cambios inevitables que la presencia de un depurador hara a la temporizacion interna de un programa de software. Como resultado, incluso con una buena herramienta de depuracion, es a menudo muy dificil rastrear problemas de tiempo de corrida en complejos sistemas distribuidos con multiples hilos.  La misma funcionalidad que hace a un depurador util para eliminar errores permite ser usado como herramienta de craqueo de software para evadir la proteccion anticopia, la gestion digital de derechos, y otras caracteristicas de proteccion de software. A menudo tambien lo hace util como herramienta general de verificacion de pruebas, cobertura de fallas, o analizador de desempe\u00f1o, especialmente si son mostradas las longitudes de trayectoria de instruccion.  La mayoria de los motores de depuracion actuales, tales como gdb y dbx proporcionan interfaces basadas en linea de comandos. Los frontales de depuracion son extensiones populares a los motores de depuracion, que proporcionan integracion al IDE, animacion del programa, y caracteristicas de visualizacion. Algunos depuradores de los primeros mainframes tales como el Oliver y el SIMON proporcionaron esta misma funcionalidad para el IBM System/360 y posteriores sistemas operativos, hasta los a\u00f1os 1970.  Algunos depuradores operan en un simple lenguaje especifico mientras que otros pueden manejar multiples lenguajes transparentemente. Por ejemplo si el programa objetivo principal es escrito en COBOL, pero llama a subrutinas en assembler y tambien subrutinas en PL/1, el depurador puede cambiar modos dinamicamente para acomodar los cambios en el lenguaje a medida que ocurren.  Algunos depuradores tambien incorporan proteccion de memoria para evitar violaciones del almacenamiento tales como desbordamiento de bufer. Esto puede ser extremadamente importante en los ambientes de procesamiento de transacciones donde la memoria es dinamicamente asignada desde \"pools\" de memoria en una base de tarea por tarea.  La mayoria de los microprocesadores modernos tienen al menos una de estas caracteristicas en su dise\u00f1o de CPU para hacer la depuracion mas facil:  El depurador lanza el programa a depurar. Este se ejecuta normalmente hasta que el depurador detiene su ejecucion, permitiendo al usuario examinar la situacion.  El depurador permite detener el programa en:  Durante esa interrupcion, el usuario puede:  El depurador depende de la arquitectura y sistema en el que se ejecute, por lo que sus funcionalidades cambian de un sistema a otro. Aqui se han mostrado las mas comunes.  Para poder aprovechar todas las posibilidades de depuracion es necesario que, al compilar el programa a depurar, se indique al compilador que debe incluir instrucciones e informacion extra para la depuracion del codigo. Dicha informacion extra consiste basicamente en la correspondencia entre las instrucciones del codigo ejecutable y las instrucciones del codigo fuente que las originan, asi como informacion sobre nombres de variables y funciones.  Aun si no se incluye esta informacion de depuracion, sigue siendo posible monitorizar la ejecucion del programa. Sin embargo, resultara mas dificil y compleja debido a esa falta de informacion del contexto en el que se ejecuta el programa.  Un depurador tambien puede usarse para realizar ingenieria inversa o evitar protecciones de copia. Mediante el uso del depurador se puede conocer el funcionamiento interno del programa examinado, ayudando al proceso de ingenieria inversa o permitiendo desarrollar tecnicas para evadir las restricciones impuestas por el programa.  Es importante notar que un programa que esta siendo depurado puede presentar un comportamiento diferente a si se ejecuta en solitario debido a que el depurador cambia ligeramente los tiempos internos del programa. Estos cambios en los tiempos de ejecucion afectan especialmente a complejos sistemas distribuidos. ","snippet":"Un depurador (en ingles: debugger) es un programa que se utiliza para detectar e identificar los errores en un software (el programa \"objetivo\") y, por lo tanto, los desarrolladores pueden encontrar l","enlaces_salientes":["Depurador","Depurador","Depurador","Programa_de_computadora","Error_de_software","CPU","Entorno_de_desarrollo_integrado","Desensamblado","C%C3%B3digo_fuente","Lenguaje_ensamblador","Compilador","Error_de_programaci%C3%B3n","Conjunto_de_instrucciones","CPU","Memoria_protegida","Computaci%C3%B3n_distribuida","Hilo_(inform%C3%A1tica)","Cracking_(software)","Protecci%C3%B3n_de_copia","Gesti%C3%B3n_digital_de_derechos","Gdb","Dbx_(depurador)","L%C3%ADnea_de_comandos","Entorno_de_desarrollo_integrado","Mainframe","IBM_System/360","COBOL","Lenguaje_assembler","PL/1","Desbordamiento_de_b%C3%BAfer","Procesamiento_de_transacciones","Microprocesador","Registro_de_estado","Conjunto_de_instrucciones","Requerimientos_de_virtualizaci%C3%B3n_de_Popek_y_Goldberg","In-system_programming","Fallo_de_p%C3%A1gina","JTAG","Arquitectura_ARM","Sistema_empotrado","Microcontrolador","Pila_de_llamadas","Compilaci%C3%B3n","Compilador","C%C3%B3digo_fuente","Variable_en_programaci%C3%B3n","Funci%C3%B3n_(programaci%C3%B3n)","Ingenier%C3%ADa_inversa","Protecci%C3%B3n_de_copia","Sistema_distribuido","GNU_Debugger","SoftICE","OllyDbg","Cheat_Engine","Depuraci%C3%B3n_de_programas","Error_de_software","Lenguaje_ensamblador","Lenguaje_ensamblador_x86","Ensamblador","Desensamblador","Compilador","Decompilador","Int%C3%A9rprete_(inform%C3%A1tica)","BOCHS","Control_de_autoridades"]}
{"url":"Int%C3%A9rprete_(inform%C3%A1tica)","titulo":"Interprete (informatica)","contenido":"En ciencias de la computacion, interprete o interpretador es un programa informatico capaz de analizar y ejecutar otros programas. Los interpretes se diferencian de los compiladores o de los ensambladores en que mientras estos traducen un programa desde su descripcion en un lenguaje de programacion al codigo de maquina del sistema, los interpretes solo realizan la traduccion a medida que sea necesaria, tipicamente, instruccion por instruccion, y normalmente no guardan el resultado de dicha traduccion.  Usando un interprete, un solo archivo fuente puede producir resultados iguales incluso en sistemas sumamente diferentes (ejemplo. una PC y una PlayStation 4). Usando un compilador, un solo archivo fuente puede producir resultados iguales solo si es compilado a distintos ejecutables especificos a cada sistema.  Los programas interpretados suelen ser mas lentos que los compilados debido a la necesidad de traducir el programa mientras se ejecuta, pero a cambio son mas flexibles como entornos de programacion y depuracion (lo que se traduce, por ejemplo, en una mayor facilidad para reemplazar partes enteras del programa o a\u00f1adir modulos completamente nuevos), y permiten ofrecer al programa interpretado un entorno no dependiente de la maquina donde se ejecuta el interprete, sino del propio interprete (lo que se conoce comunmente como maquina virtual).  Para mejorar el desempe\u00f1o, algunas implementaciones de algunos lenguajes de programacion pueden interpretar o compilar el codigo fuente original en una forma intermedia  mas compacta, y despues traducir eso al codigo de maquina (ej. Perl, Python, MATLAB, y Ruby). Algunos aceptan los archivos fuente guardados en esta representacion intermedia (ej. Python, UCSD Pascal y Java).  En la actualidad, uno de los entornos mas comunes de uso de los interpretes es en los navegadores web, debido a la posibilidad que estos tienen de ejecutarse independientemente de la plataforma.  Hay un espectro de posibilidades entre la interpretacion y la compilacion, dependiendo de la cantidad de analisis realizados antes de que el programa sea ejecutado. Por ejemplo, el Emacs Lisp es compilado a bytecode, que es una representacion altamente comprimida y optimizada del codigo fuente del Lisp, pero no es codigo de maquina (y por lo tanto no esta atado a cualquier hardware particular). Este bytecode es entonces interpretado por un interprete de bytecode (que esta escrito en C). En este caso, el codigo compilado es el codigo de maquina para una maquina virtual, que no esta implementada en el hardware, sino en el interprete de bytecode. El mismo acercamiento es utilizado con el codigo Forth usado en sistemas Open Firmware: el lenguaje fuente es compilado en \"codigo F\" (un bytecode).  La desventaja principal de los interpretadores es que cuando se interpreta un programa, tipicamente corre mas lentamente que si hubiera sido compilado. La diferencia en velocidades puede ser minuscula o grande; a menudo un orden de magnitud y a veces mas. Generalmente toma mas tiempo correr un programa bajo un interpretador que correr el codigo compilado, pero puede tomar menos tiempo para interpretarlo que el tiempo total requerido para compilarlo y ejecutarlo. Esto es especialmente importante si se esta haciendo y probando un codigo prototipo cuando un ciclo de editar, interpretar y depurar del interpretador, a menudo puede ser mucho mas corto que el ciclo de editar, compilar, ejecutar y depurar del compilador.  La interpretacion de codigo es mas lenta que la ejecucion de codigo compilado porque el interpretador debe analizar cada sentencia en el programa cada vez que es ejecutada y entonces realizar la accion deseada, mientras que el codigo compilado solo realiza la accion dentro de un determinado contexto fijo por la compilacion. Este analisis en tiempo de ejecucion se conoce como \"sobrecarga interpretativa\". En un interpretador, el acceso a las variables es tambien mas lento porque el mapeo de identificadores hacia las localizaciones de almacenamiento debe hacerse repetidamente en tiempo de ejecucion en vez de en el tiempo de compilacion. Hay varios compromisos entre la velocidad de desarrollo al usar un interpretador y la velocidad de ejecucion al usar un compilador. Algunos sistemas (ej., algunos LISPs) permiten al codigo interpretado y al compilado llamarse el uno al otro y compartir variables. Esto significa que una vez que una rutina ha sido probada y depurada bajo el interpretador puede ser compilada y por lo tanto beneficiarse de una ejecucion mas rapida mientras que otras rutinas estan siendo desarrolladas. Muchos interpretadores no ejecutan el codigo fuente tal y como esta sino que lo convierten en una forma interna mas compacta. Por ejemplo, algunos interpretadores BASIC reemplazan palabras clave (keywords) con tokens de un simple byte que pueden ser usados para encontrar la instruccion en una tabla de saltos. Un interpretador puede bien usar el mismo analizador lexicografico y el analizador sintactico (parser) que el compilador y entonces interpretar el arbol de sintaxis abstracta resultante.  En el espectro entre la interpretacion y la compilacion, otro acercamiento esta transformando el codigo fuente en un arbol de sintaxis abstracta optimizado (AST), y despues procediendo a ejecutar el programa siguiendo esta estructura arborescente.\u200b En este acercamiento cada sentencia necesita ser analizada (parsed) solo una vez. Como una ventaja sobre el bytecode, el AST mantiene la estructura y las relaciones globales del programa entre las sentencias (que se pierden en una representacion de bytecode), y proporciona una representacion mas compacta.\u200b  Asi, el AST se ha propuesto como un mejor formato intermedio para los compiladores justo a tiempo que el bytecode. Tambien, permite realizar un mejor analisis durante tiempo de ejecucion. Un interpretador Java basado en AST ha demostrado ser mas rapido que un interpretador similar basado en bytecode,\u200b gracias a las mas poderosas optimizaciones permitidas al tener la estructura completa del programa, asi como tipos de datos de alto nivel, disponibles durante la ejecucion.  Para desdibujar mas la distincion entre los interpretadores, los interpretadores de bytecode y la compilacion, esta la compilacion justo a tiempo (o JIT), una tecnica en la cual la representacion intermedia es compilada a codigo de maquina nativo en tiempo de ejecucion. Esto confiere la eficiencia de ejecutar el codigo nativo, al costo de tiempo de inicio y de un uso creciente de la memoria cuando el bytecode o el AST es compilado por primera vez. La optimizacion adaptativa es una tecnica complementaria en la cual el interpretador hace un analisis de desempe\u00f1o del programa que esta corriendo (profiling) y compila sus partes mas frecuentemente ejecutadas a codigo nativo. Ambas tecnicas tienen algunas decadas, apareciendo en lenguajes tales como Smalltalk en la decada de 1980.  En a\u00f1os recientes, la compilacion justo a tiempo ha ganado la atencion de la mayoria de los implementadores de lenguajes de programacion, con Java, Python, y el Microsoft .NET Framework todos ahora incluyendo JITs.  Algunos ejemplos de interpretes:  Un lenguaje interpretado es un lenguaje de programacion para el que la mayoria de sus implementaciones ejecuta las instrucciones directamente, sin una previa compilacion del programa a instrucciones en lenguaje maquina. El interprete ejecuta el programa directamente, traduciendo cada sentencia en una secuencia de una o mas subrutinas ya compiladas en codigo maquina.  Los terminos lenguaje interpretado y lenguaje compilado\u200b no estan bien definidos porque, en teoria, cualquier lenguaje de programacion puede ser interpretado o compilado. Cada vez es mas popular, en las implementaciones mas modernas de un lenguaje de programacion, ofrecer ambas opciones.  Los lenguajes interpretados tambien pueden diferenciarse de los lenguajes de maquina. Funcionalmente, tanto la ejecucion y la interpretacion significan lo mismo -obtener la siguiente instruccion/sentencia del programa y su ejecucion-. Aunque el bytecode (codigo byte) interpretado es ademas identico a su forma en codigo maquina y tiene una representacion en ensamblador, el termino \"interpretado\" se reserva en la practica para lenguajes \"procesados por software\" (como las maquinas virtuales o emuladores) por encima del procesado nativo (por ejemplo, por hardware).  En principio, los programas de muchos lenguajes se pueden compilar o interpretar, emular o ejecutar nativamente, asi que esta designacion se aplica solamente a la implementacion practica mas usual, en vez de representar una propiedad esencial del lenguaje. De forma parecida al microcodigo del procesador, muchos interpretes, internamente recaen en una compilacion en tiempo de ejecucion.  Evitando la compilacion, los programas interpretados son mas faciles de evolucionar durante el desarrollo y la ejecucion (transformandose en ocasiones de uno en la otra). De otra parte, ya que la compilacion implica una traduccion a un formato mas amigable con la maquina, los programas interpretados corren mas lentamente y menos eficientemente (es decir, gastan considerablemente mas energia). Esto es especialmente verdad para los lenguajes de guion, cuyas sentencias son mas complejas de analizar comparadas con las instrucciones maquina.  Muchos lenguajes se han implementado usando tanto compiladores como interpretes, incluyendo  BASIC, C, Lisp, Pascal y Python. Java y C# se compilan a codigo byte, el lenguaje interpretado especifico para la maquina virtual. Muchas implementaciones de Lisp pueden mezclar libremente codigo interpretado y compilado.  En los comienzos de la computacion, el dise\u00f1o de lenguajes fue fuertemente influenciado por la decision de usar la compilacion o la interpretacion como modos de ejecucion. Por ejemplo, algunos lenguajes compilados requieren que los programas deban indicar explicitamente el tipo de dato de una variable en el momento en que sea declarada o al ser usada por primera vez, mientras que algunos lenguajes interpretados toman ventaja de los aspectos dinamicos de la interpretacion para hacer tales declaraciones innecesarias. Por ejemplo, Smalltalk (1980), que fue dise\u00f1ado para ser interpretado en tiempo de ejecucion, permite a objetos genericos interactuar dinamicamente entre si.  Inicialmente, los lenguajes interpretados eran compilados linea por linea, es decir, cada linea era compilada a medida que estaba a punto de ser ejecutada, y si un bucle o una subrutina hicieran que ciertas lineas se ejecutaran multiples veces, serian recompiladas repetidamente. Esto ha llegado a ser mucho menos comun. La mayoria de los lenguajes interpretados usan una representacion intermedia, que combina tanto la compilacion como la interpretacion. En este caso, un compilador puede producir el codigo byte o el codigo enhebrado, que entonces es ejecutado por un interprete de codigo byte.  Los ejemplos incluyen:  La representacion intermedia se puede compilar una sola vez (como en Java), cada vez que se vaya a ejecutar (como en Perl o Ruby), o cada vez que se detecte un cambio en el codigo fuente antes de la ejecucion (como en Python).  Interpretar un lenguaje da a las implementaciones una flexibilidad adicional sobre las implementaciones compiladas. Algunas caracteristicas son mas faciles de implementar en interpretes que en compiladores son (pero no se limitan a estas):  La principal desventaja de la interpretacion es una velocidad de ejecucion del programa mucho mas lenta, comparada con la ejecucion directa del codigo maquina en la CPU del ordenador. Una tecnica utilizada para mejorar las prestaciones es la compilacion en tiempo de ejecucion, que convierte las secuencias ejecutadas mas frecuentes en codigo maquina del ordenador.  Muchos lenguajes interpretados son primero compilados a codigo byte, que luego es normalmente interpretado por la maquina virtual usando la compilacion en tiempo de ejecucion, del codigo byte a codigo nativo. Sin embargo, algunas veces, el codigo byte tambien puede ser compilado a un binario nativo usando un compilador Ahead-of-time compilation (compilacion por adelantado), o ejecutado nativamente, por el procesador hardware. ","snippet":"En ciencias de la computacion, interprete o interpretador es un programa informatico capaz de analizar y ejecutar otros programas. Los interpretes se diferencian de los compiladores o de los ensamblad","enlaces_salientes":["Int%C3%A9rprete_(inform%C3%A1tica)","Int%C3%A9rprete_(inform%C3%A1tica)","Int%C3%A9rprete_(inform%C3%A1tica)","Int%C3%A9rpretes_(%C3%A1lbum)","Ciencias_de_la_computaci%C3%B3n","Programa_(computaci%C3%B3n)","Compilador","Ensamblador","Lenguaje_de_programaci%C3%B3n","C%C3%B3digo_de_m%C3%A1quina","Proceso_de_traducci%C3%B3n_de_programas","Computador_personal","PlayStation_4","Programaci%C3%B3n","Depuraci%C3%B3n_de_programas","M%C3%A1quina_virtual","Implementaci%C3%B3n","Perl","Python","MATLAB","Ruby","UCSD_Pascal","Lenguaje_de_programaci%C3%B3n_Java","Navegadores_web","Bytecode","Emacs_Lisp","Bytecode","C%C3%B3digo_fuente","Lisp","C%C3%B3digo_de_m%C3%A1quina","Lenguaje_de_programaci%C3%B3n_C","M%C3%A1quina_virtual","Forth","Open_Firmware","Tiempo_de_ejecuci%C3%B3n","Tiempo_de_compilaci%C3%B3n","LISP","BASIC","Palabra_clave","Byte","Tabla_de_saltos","Analizador_l%C3%A9xico","Analizador_sint%C3%A1ctico","%C3%81rbol_de_sintaxis_abstracta","%C3%81rbol_de_sintaxis_abstracta","%C3%81rbol_(estructura_de_datos)","Compilador_justo_a_tiempo","Tipo_de_dato","Compilaci%C3%B3n_justo_a_tiempo","C%C3%B3digo_de_m%C3%A1quina","Smalltalk","Lenguaje_de_programaci%C3%B3n_Java","Python","Microsoft",".NET_Framework","Motor_Zend","CPython","Lenguaje_de_programaci%C3%B3n","Compilador","C%C3%B3digo_de_m%C3%A1quina","Lenguaje_de_programaci%C3%B3n_compilado","Lenguaje_de_m%C3%A1quina","Bytecode","Ensamblador","M%C3%A1quinas_virtuales","Emuladores","Microc%C3%B3digo","Compilaci%C3%B3n_en_tiempo_de_ejecuci%C3%B3n","Script","BASIC","C_(lenguaje_de_programaci%C3%B3n)","Lisp","Pascal_(lenguaje_de_programaci%C3%B3n)","Python","Java_(lenguaje_de_programaci%C3%B3n)","C_Sharp","Tipo_de_dato","Variable_(programaci%C3%B3n)","Smalltalk","Bucle_(programaci%C3%B3n)","Subrutina","Lenguaje_intermedio#Representaci\u00f3n_intermedia","C%C3%B3digo_enhebrado","Lenguaje_de_programaci%C3%B3n_Java","Python","Ruby","%C3%81rbol_de_sintaxis_abstracta","Forth","Perl","C%C3%B3digo_fuente","Python","Plataforma_(inform%C3%A1tica)","Bytecode_Java","Reflexi%C3%B3n_(inform%C3%A1tica)","Eval","Tipo_de_dato","%C3%81mbito_(programaci%C3%B3n)","Depuraci%C3%B3n_de_programas","CPU","APL","J","BASIC","ECMAScript","ActionScript","JavaScript","JScript","GNU_Octave","IDL","Mathematica","MATLAB","EUPHORIA_(lenguaje_de_programaci%C3%B3n)","Forth","Game_Maker_Language","Java_(lenguaje_de_programaci%C3%B3n)","Perl","PHP","PostScript","Python","Lisp","Logo_(lenguaje_de_programaci%C3%B3n)","Scheme","REXX","Ruby","JRuby","Smalltalk","Bistro","Squeak","VisualWorks","Hojas_de_c%C3%A1lculo","Excel","R_(lenguaje_de_programaci%C3%B3n)","Tcl","VBScript","Windows_PowerShell","Wayback_Machine","Compilaci%C3%B3n_anticipada","Java_(lenguaje_de_programaci%C3%B3n)","Groovy_(lenguaje_de_programaci%C3%B3n)","ColdFusion","Scala_(lenguaje_de_programaci%C3%B3n)","Lua",".NET_Framework","C","C%2B%2B","C_Sharp","Visual_Basic_.NET","Python","Squeak","Visual_FoxPro","Lisp","AppleScript","Estados_Unidos","ISBN","Lenguaje_de_programaci%C3%B3n","Proceso_de_traducci%C3%B3n_de_programas","Compilador","Depurador","Lenguaje_interpretado","Lenguaje_compilado","Internet_Archive","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lenguaje_de_m%C3%A1quina","titulo":"Lenguaje de maquina","contenido":"El lenguaje de maquina o codigo maquina es el sistema de codigos directamente interpretable por un circuito microprogramable, como el microprocesador de una computadora o el microcontrolador de un automata. Este lenguaje esta compuesto por un conjunto de instrucciones que determinan acciones a ser tomadas por la maquina. Un programa consiste en una cadena de estas instrucciones mas un conjunto  cual se trabaja. Estas instrucciones son normalmente ejecutadas en secuencia, con eventuales cambios de flujo causados por el propio programa o eventos externos. El lenguaje de maquina es especifico de la arquitectura de la maquina, aunque el conjunto de instrucciones disponibles pueda ser similar entre arquitecturas distintas.  Los circuitos microprogramables son digitales, lo que significa que trabajan con dos unicos niveles de tension. Dichos niveles, por abstraccion, se simbolizan con los numeros 0 y 1, por eso el lenguaje de maquina solo utiliza dichos signos. Esto permite el empleo de las teorias del algebra booleana y del sistema binario en el dise\u00f1o de este tipo de circuitos y en su programacion.  Claude Elwood Shannon, en su libro Analysis of Relay and Switching Circuits, y con sus experiencias en redes de conmutacion, sento las bases para la aplicacion del algebra de Boole a las redes de conmutacion. Una red de conmutacion es un circuito de interruptores electricos que al cumplir ciertas combinaciones booleanas con las variables de entrada, define el estado de la salida. Este concepto es el nucleo de las puertas logicas, las cuales son, por su parte, los ladrillos con que se construyen sistemas logicos cada vez mas complejos. Shannon utilizaba el rele como dispositivo fisico de conmutacion en sus redes, dado que el rele, a igual que una lampara electrica, posee dos estados: activado (encendido) o (apagado).  El desarrollo tecnologico ha permitido evolucionar desde las redes de reles electromagneticos a circuitos con tubos de vacio, luego a redes transistorizadas, hasta llegar a los modernos circuitos integrados, en cuya cuspide se encuentran los circuitos microprogramados.  El llamado codigo maquina consistia en introducir la programacion de la maquina mediante unos y ceros. cualquier programa de ordenador debe, finalmente, ser convertido a este codigo para que un ordenador pueda ejecutar las instrucciones de dicho programa.  Los ordenadores solo leen este tipo de lenguaje, en donde la combinacion de numeros logra convertirse en acciones. Dada su complejidad existen los lenguajes de programacion como JavaScript para programar paginas web o C++ para programar videojuegos entre muchos otros.\u200b ","snippet":"El lenguaje de maquina o codigo maquina es el sistema de codigos directamente interpretable por un circuito microprogramable, como el microprocesador de una computadora o el microcontrolador de un aut","enlaces_salientes":["Lenguaje_de_m%C3%A1quina","Lenguaje_de_m%C3%A1quina","Lenguaje_de_m%C3%A1quina","Intel_8086_y_8088","Sistema_hexadecimal","Lenguaje_ensamblador","ASCII","Microprocesador","Computadora_electr%C3%B3nica","Microcontrolador","Aut%C3%B3mata_programable","Conjunto_de_instrucciones","Programa_inform%C3%A1tico","Arquitectura_de_computadoras","Sistema_digital","%C3%81lgebra_de_Boole","Sistema_binario","Claude_Elwood_Shannon","Puerta_l%C3%B3gica","Sistema_digital","Rel%C3%A9","V%C3%A1lvula_termoi%C3%B3nica","Transistor","Circuito_integrado","JavaScript","C%2B%2B","L%C3%B3gica_binaria","Lenguaje_ensamblador","Lenguaje_de_bajo_nivel","Lenguaje_de_alto_nivel","Control_de_autoridades","Gemeinsame_Normdatei"]}
{"url":"Depuraci%C3%B3n_de_programas","titulo":"Depuracion de programas","contenido":"La depuracion de programas es el proceso de identificar y corregir errores de programacion.\u200b Es conocido tambien por el termino ingles debugging, cuyo significado es eliminacion de bugs (bichos), manera en que se conoce informalmente a los errores de programacion.  Si bien existen tecnicas para la revision sistematica del codigo fuente y se cuenta con medios computacionales para la deteccion de errores (depuradores) y facilidades integradas en los sistemas lower CASE y en los ambientes de desarrollo integrado, sigue siendo en buena medida una actividad manual, que desafia la paciencia, la imaginacion y la intuicion de programadores. Muchas veces se requiere incluir en el codigo fuente instrucciones auxiliares que permitan el seguimiento de la ejecucion del programa, presentando los valores de variables y direcciones de memoria y ralentizando la salida de datos (\"modo de depuracion\"). Dentro de un proceso formal de aseguramiento de la calidad, puede ser asimilado al concepto de \"prueba unitaria\".  Como el software y los sistemas  electronicos  se vuelven generalmente mas complejos, se han desarrollado varias tecnicas comunes de depuracion para detectar anomalias, corregir funcionalidades y optimizar codigo fuente. Existen algunos aficionados que consideran la depuracion como una forma de arte. ","snippet":"La depuracion de programas es el proceso de identificar y corregir errores de programacion.\u200b Es conocido tambien por el termino ingles debugging, cuyo significado es eliminacion de bugs (bichos), mane","enlaces_salientes":["Depuraci%C3%B3n_de_programas","Depuraci%C3%B3n_de_programas","Depuraci%C3%B3n_de_programas","Error_de_software","Idioma_ingl%C3%A9s","Arthropoda","C%C3%B3digo_fuente","Depurador","Herramientas_CASE","Entorno_de_desarrollo_integrado","Variable_(programaci%C3%B3n)","Direcci%C3%B3n_de_memoria","Aseguramiento_de_la_calidad","Prueba_unitaria","Software","Electr%C3%B3nica","C%C3%B3digo_fuente","Arte","Depurador","Error_de_software","BOCHS","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Palabra_(matem%C3%A1ticas)","titulo":"Palabra (matematicas)","contenido":"En matematicas, una palabra es una sucesion ordenada de elementos tomados de un conjunto fijo de simbolos denominado alfabeto.  Por ejemplo, si X={a,e,i,o,u} es el conjunto alfabeto, todos los siguientes son ejemplos de palabras:  El numero de elementos de una palabra se denomina la longitud de la misma.  Se define el concepto de palabra como sigue:\u200b  Si A es un conjunto, denominado alfabeto, una palabra sobre el alfabeto A es una sucesion a 1 , a 2 , a 3 , \u2026 , a n ,a_{2},a_{3},\\ldots ,a_{n}} en que cada entrada a k } es un elemento de A.  A pesar de ser sucesiones, es comun listar los elementos concatenados en vez de separarlos por comas. A los elementos del alfabeto tambien se les denomina los simbolos del alfabeto.  Si \u03c9 = a 1 a 2 \u22ef a n a_{2}\\cdots a_{n}} es una palabra sobre un alfabeto A, al valor de n se denomina la longitud de la palabra y se denota | \u03c9 | . Una palabra de longitud n se denomina una n-palabra (sobre el alfabeto A).  Para cada conjunto alfabeto existe una palabra de longitud cero, denominada palabra vacia, que se denota \"\" o \u2205 entre otras variantes.  Cuando el alfabeto consta de dos elementos, las palabras reciben el nombre de palabras binarias. En este caso, suele escogerse como alfabeto el conjunto A={0, 1}.  Si \u03c9 = a 1 a 2 \u22ef a n a_{2}\\cdots a_{n}} es una palabra, su palabra reversa es \u03c9 ~ = a n a n \u2212 1 \u22ef a 1 }=a_{n}a_{n-1}\\cdots a_{1}} . Una palabra \u03c9 es un palindromo si \u03c9 = \u03c9 ~ }} .  Las palabras son un objeto fundamental en el area de combinatoria enumerativa, pues por el principio de la biyeccion, es posible reducir una gran variedad de problemas a enumerar conjuntos de palabras que cumplan ciertas restricciones.  El resultado basico es el que determina el numero de palabras de longitud fija:  El numero de palabras de longitud n sobre un alfabeto con r elementos es rn.  La demostracion es una consecuencia del principio del producto pues para determinar una palabra hay que realizar n elecciones sucesivas, cada una de las cuales tiene exactamente r formas de realizarse.  A continuacion se da un ejemplo clasico de aplicacion de palabras a un problema de enumeracion.  Un conjunto con n elementos posee 2n subconjuntos distintos.  Ahora, cada subconjunto S \u2286 X corresponde a una palabra binaria (sobre el alfabeto A={0,1}) mediante la siguiente regla:  Por ejemplo, si el conjunto es X = { a , e , i , o , u } } , con los elementos listados en ese orden, el subconjunto S={a,o,u} corresponde a la palabra 10011:  De manera similar, cualquier palabra binaria de longitud n corresponde a un subconjunto de X, determinado por las posiciones iguales a 1 en la palabra. Por tanto, la correspondencia entre subconjuntos y palabras es una biyeccion, de manera que el numero de subconjuntos es igual al numero de palabras consideradas.  Pero por el teorema basico de conteo de palabras, el numero de palabras de longitud n sobre un alfabeto que tiene dos simbolos es precisamente 2 n } , por lo que el numero de subconjuntos que tiene un conjunto con n elementos es tambien 2 n } .  Para cada alfabeto fijo A, es posible definir una operacion binaria en el conjunto A* de todas las palabras sobre A mediante la operacion de concatenacion:\u200b    Si \u03c9 1 = a 1 a 2 \u22ef a n =a_{1}a_{2}\\cdots a_{n}} y \u03c9 2 = b 1 b 2 \u22ef b m =b_{1}b_{2}\\cdots b_{m}} son dos palabras, la concatenacion de \u03c9 1 } y \u03c9 2 } es la palabra   \u03c9 1 \u03c9 2 = a 1 a 2 \u22ef a n b 1 b 2 \u22ef b m \\omega _{2}=a_{1}a_{2}\\cdots a_{n}b_{1}b_{2}\\cdots b_{m}}  Se puede verificar que la longitud de una concatenacion es igual a la suma de las longitudes: | \u03c9 1 \u03c9 2 | = | \u03c9 1 | + | \u03c9 2 | \\omega _{2}|=|\\omega _{1}|+|\\omega _{2}|} .  La operacion de concatenacion es asociativa y tiene a la palabra vacia como elemento neutro, por lo que el conjunto A* adquiere estructura de monoide, mientras que el conjunto de palabras no vacias adquiere estructura de semigrupo,\u200b denominados respectivamente monoide libre y semigrupo libre (sobre el alfabeto A).  Una palabra \u03bb es un factor de otra palabra \u03c9 si existen palabras \u03b1 , \u03b2 (posiblemente vacias) tal que \u03c9 = \u03b1 \u03bb \u03b2 . Si \u03b1 es una palabra vacia, se dice que \u03bb es un prefijo de \u03c9 mientras que si \u03b2 es vacia, hablamos de un sufijo.  Es posible representar el monoide libre con una estructura de arbol con la palabra vacia como nodo raiz y en donde los nodos descendientes de \u03c9 son la concatenacion de esta con cualquier elemento del alfabeto.  El conjunto de todas las palabras sobre un alfabeto posee tambien estructura de conjunto parcialmente ordenado, con el orden denominado orden prefijo  dado por la relacion   \u03c9 \u2264 \u03c4 si \u03c9 es un prefijo de \u03c4 .   Este es precisamente el orden cuyo diagrama de Hasse es la representacion del monoide descrita en la seccion anterior (con la salvead que se dibujaria de abajo hacia arriba, con la palabra vacia en la parte inferior).  El alfabeto de un lenguaje formal L (que no es otra cosa que un conjunto de palabras) es el conjunto de todas las letras que se usan en L. Es posible considerar lenguajes donde el alfabeto tiene distintas cardinalidades, o incuso que usan palabras infinitas.  Por ejemplo, el lenguaje de la logica de primer orden usa un alfabeto que contiene a las conectivas logicas, los cuantificadores, una cantidad infinita de variables, el simbolo igual '=' y parentesis. Es posible que use tambien simbolos para constantes, funciones y relaciones. Si se quiere usar un alfabeto finito, esto se puede lograr tomando un solo simbolo de variable x junto con una comilla ('); se pueden obtener infinitas variables como x, x', x'', x''', etc.  Tambien se utilizan alfabetos en teoria de automatas, sobre todo alfabetos finitos.  En ciencias de la computacion es comun identificar los conceptos de palabra con el de cadena de caracteres[cita\u00a0requerida], el cual es una sucesion de caracteres o unidades de informacion, y que constituye uno de los tipos de datos mas fundamentales.  Usualmente en computacion, los elementos de las cadenas pertenecen suelen ser bytes formando un arreglo que representa, mediante una codificacion de caracteres, entidades de informacion. Por el contrario, en la estructura matematica, el alfabeto subyacente puede ser un conjunto cualquiera (incluso infinito) cuyos elementos no tienen restriccion de representacion o codificacion (los elementos del alfabeto pueden, en teoria, ser incluso otros conjuntos).    Se desea determinar el numero de palabras binarias de longitud n. Es decir, series de longitud n formadas por cifras 0 o 1.  Por ejemplo, las palabras binarias de longitud 4 son:  Se debe hacer la observacion que estrictamente hablando, una palabra binaria no es lo mismo que un numero binario. Una palabra binaria es unicamente una lista formal de simbolos, y por tanto las palabras 0010, 010, 10 son diferentes aunque puedan interpretarse todas ellas como el numero binario 10.  Para poder elegir una palabra, es necesario hacer n elecciones, una para cada posicion de la palabra. Por ejemplo: la primera posicion puede ser 0 o 1 (dos opciones), la segunda posicion es independiente de la primera y por tanto puede ser 0 o 1 (dos opciones), y asi sucesivamente.  Cada serie de n elecciones corresponde a una palabra y cada palabra corresponde a n elecciones, por lo que el numero de palabras binarias es igual al numero de formas de realizar n elecciones cada una de las cuales tiene 2 posibilidades. El principio del producto establece entonces que el resultado ha de ser 2 \u00d7 2 \u00d7 2 \u00d7 \u22ef \u00d7 2 = 2 n } .   Un argumento similar permite concluir que si se desea enumerar palabras de longitud n, en donde cada posicion puede ser cualquiera de r posibles simbolos, el numero de formas de hacerlo sera r n } . ","snippet":"En matematicas, una palabra es una sucesion ordenada de elementos tomados de un conjunto fijo de simbolos denominado alfabeto.  Por ejemplo, si X={a,e,i,o,u} es el conjunto alfabeto, todos los siguien","enlaces_salientes":["Palabra_(matem%C3%A1ticas)","Palabra_(matem%C3%A1ticas)","Palabra_(matem%C3%A1ticas)","F%C3%B3rmula_bien_formada","Teorema","Matem%C3%A1ticas","Combinatoria","Principio_del_producto","Biyecci%C3%B3n","Operaci%C3%B3n_binaria","%C3%81rbol_binario","Asociatividad_(%C3%A1lgebra)","Elemento_neutro","Monoide","Semigrupo","%C3%81rbol_(teor%C3%ADa_de_gr%C3%A1ficas)","Conjunto_parcialmente_ordenado","Diagrama_de_Hasse","Lenguaje_formal","Cardinalidad","L%C3%B3gica_de_primer_orden","Conectiva_l%C3%B3gica","Cuantificador","Variable_(matem%C3%A1tica)","%3D","Par%C3%A9ntesis","Teor%C3%ADa_de_aut%C3%B3matas","Cadena_de_caracteres","Ciencias_de_la_computaci%C3%B3n","Cadena_de_caracteres","Car%C3%A1cter_(inform%C3%A1tica)","Tipo_de_dato","Bytes","Codificaci%C3%B3n_de_caracteres","ISBN","Cambridge_University_Press","ISBN","Control_de_autoridades","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Token_(inform%C3%A1tica)","titulo":"Token (informatica)","contenido":"La tokenizacion, cuando se aplica a la seguridad de los datos, se refiere al proceso de sustitucion de un elemento de datos sensible por un equivalente no sensible denominado token, que no tiene un significado o valor extrinseco o explotable. El token es una referencia (un identificador) que regresa a los datos sensibles a traves de un sistema de tokenizacion. El mapeo de datos originales a un token utiliza metodos que hacen que los tokens no sean factibles de revertir en ausencia del sistema de tokenizacion, por ejemplo, utilizando tokens creados a partir de numeros aleatorios. El sistema de tokenizacion debe ser asegurado y validado utilizando las mejores practicas de seguridad aplicables a la proteccion de datos confidenciales, el almacenamiento seguro, la auditoria, la autenticacion y la autorizacion. El sistema de tokenizacion proporciona a las aplicaciones de procesamiento de datos la autoridad y las interfaces para solicitar tokens o destokenizar datos sensibles.  Los beneficios de seguridad y reduccion de riesgos de la tokenizacion requieren que el sistema de tokenizacion este logicamente aislado y segmentado de los sistemas y aplicaciones de procesamiento de datos que anteriormente procesaban o almacenaban datos confidenciales reemplazados por tokens. Solo el sistema de tokenizacion puede tokenizar datos para crear tokens, o destokenizar de nuevo para canjear datos confidenciales bajo estrictos controles de seguridad. Se debe demostrar que el metodo de generacion de tokens tiene la propiedad de que no hay medios viables a traves de ataques directos, criptoanalisis, analisis de canales laterales, exposicion de tablas de mapeo de tokens o tecnicas de fuerza bruta para revertir los tokens a datos en vivo.  Cuando los tokens sustituyen a los datos activos en los sistemas, el resultado es una exposicion minima de los datos confidenciales a esas aplicaciones, almacenes, personas y procesos, lo que reduce el riesgo de exposicion accidental y de acceso no autorizado a los datos confidenciales. Las aplicaciones pueden funcionar utilizando tokens en lugar de datos en tiempo real, con la excepcion de un peque\u00f1o numero de aplicaciones de confianza explicitamente autorizadas a destokenizar cuando sea estrictamente necesario para un fin comercial aprobado. Los sistemas de Tokenizacion pueden ser operados internamente dentro de un segmento aislado y seguro del centro de datos, o como un servicio de un proveedor de servicios seguro.  La Tokenizacion puede ser utilizada para salvaguardar datos sensibles que involucren, por ejemplo, cuentas bancarias, estados financieros, registros medicos, antecedentes penales, licencias de conducir, solicitudes de prestamos, transacciones bursatiles, registros de votantes y otros tipos de informacion personal identificable (PII, por sus siglas en ingles). La tokenizacion se utiliza a menudo en el procesamiento de tarjetas de credito. El Consejo de la Industria de Tarjeta de Pago (PCI, por sus siglas en ingles) define el tokenizacion como \"un proceso por el cual el numero de cuenta primario (PAN) es reemplazado por un valor sustituto llamado token. Por otro lado, la destoquizacion es el proceso inverso de canjear un token por su valor PAN asociado. La seguridad de una ficha individual se basa predominantemente en la imposibilidad de determinar el PAN original conociendo solo el valor sustitutivo\". La eleccion de una ficha como alternativa a otras tecnicas tales como el cifrado dependera de los diversos requisitos reglamentarios, la interpretacion y la aceptacion por parte de las respectivas entidades de auditoria o evaluacion. Esto se suma a cualquier restriccion tecnica, arquitectonica u operativa que la simbologia imponga en la practica.  El concepto de \"tokenizacion\", tal y como lo adopta hoy en dia la industria, ha existido desde que surgieron los primeros sistemas monetarios hace siglos como medio para reducir el riesgo en el manejo de moneda fisica de alto valor, sustituyendolos por equivalentes sustitutivos. En el mundo fisico, las fichas de moneda tienen una larga historia de uso en sustitucion del instrumento financiero de las monedas y billetes acu\u00f1ados. En una historia mas reciente, las fichas de metro y las fichas de casino fueron adoptadas por sus respectivos sistemas para reemplazar la moneda fisica y los riesgos de manejo de efectivo, como el robo. Exonumia y dinero de emergencia son terminos sinonimos de tales fichas.  En el mundo digital, desde los a\u00f1os 70 se han utilizado tecnicas de sustitucion similares para aislar los elementos de datos reales de la exposicion a otros sistemas de datos. En las bases de datos, por ejemplo, se han utilizado valores claves artificiales desde 1976 para aislar los datos asociados con los mecanismos internos de las bases de datos y sus equivalentes externos para una variedad de usos en el procesamiento de datos. Mas recientemente, estos conceptos se han ampliado para considerar esta tactica de aislamiento con el fin de proporcionar un mecanismo de seguridad a los efectos de la proteccion de datos.  En la industria de las tarjetas de pago, la conversion a token es un medio de proteger los datos sensibles de los titulares de las tarjetas para cumplir con los estandares de la industria y las regulaciones gubernamentales.\u200b  En 2001, TrustCommerce creo el concepto de Tokenizacion para proteger los datos de pago sensibles de un cliente, classmates.com.\u200b Contrataron a TrustCommerce porque el riesgo de almacenar los datos del titular de la tarjeta era demasiado grande si sus sistemas eran pirateados. TrustCommerce desarrollo TC Citadel\u00ae, donde los clientes podian referenciar un token en lugar de los datos del titular de la tarjeta y TrustCommerce procesaba un pago en nombre de los comerciantes.\u200b Esta aplicacion de facturacion segura permite a los clientes procesar pagos recurrentes de forma segura y sin necesidad de almacenar la informacion de pago del titular de la tarjeta. La tokenizacion reemplaza el numero de tarjeta bancaria (siglas en ingles, PAN) con tokens seguros generados aleatoriamente. Si se interceptan, los datos no contienen informacion del titular de la tarjeta, lo que los hace inutiles para los hackers. El Numero de Tarjeta Bancaria no puede ser recuperado incluso si el testigo y los sistemas en los que reside estan comprometidos, ni tampoco puede el testigo ser sometido a ingenieria inversa para llegar al PAN.  Shift4 Corporation aplico la tokenizacion a los datos de las tarjetas de pago y la dio a conocer al publico durante una Cumbre de Seguridad de la industria celebrada en Las Vegas (Nevada) en 2005.\u200b\u200b La tecnologia esta destinada a prevenir el robo de la informacion de la tarjeta de credito almacenada. Shift4 define la tokenizacion como: \"El concepto de usar un trozo de datos no desencriptados para representar, por referencia, datos sensibles o secretos. En el contexto de la industria de las tarjetas de pago (PCI), los tokens se utilizan para referirse a los datos del titular de la tarjeta que se gestionan en un sistema de tokenizacion, una aplicacion o una instalacion de seguridad externa\".\u200b  Para proteger los datos a lo largo de todo su ciclo de vida, la conversion mediante tokenizacion se combina a menudo con un cifrado de extremo a extremo para asegurar los datos en transito hacia el sistema o servicio de conversion de token, con un token que sustituye a los datos originales a su regreso. Por ejemplo, para evitar los riesgos de que el malware robe datos de sistemas de baja confianza, como los terminales de puntos de venta (TPV), como en el caso del incumplimiento del objetivo de 2013, la encriptacion de los datos del titular de la tarjeta debe realizarse antes de que los datos de la tarjeta entren en el TPV y no despues. La encriptacion tiene lugar dentro de los limites de un dispositivo de lectura de tarjetas validado y reforzado en materia de seguridad y los datos permanecen encriptados hasta que son recibidos por el host de procesamiento, un enfoque en el que Heartland Payment Systems\u200b fue pionero como medio para asegurar los datos de pago frente a amenazas avanzadas, ahora ampliamente adoptado por las empresas de procesamiento de pagos y las empresas de tecnologia de la industria.\u200b El Consejo PCI tambien ha especificado la encriptacion de extremo a extremo (encriptacion certificada de punto a punto-P2PE) para diversas implementaciones de servicios en varios documentos de encriptacion de punto a punto del Consejo PCI.  La tokenizacion y el cifrado \"clasico\" protegen eficazmente los datos si se aplican correctamente, y una solucion de seguridad ideal utilizara ambas. Si bien son similares en ciertos aspectos, la tokenizacion y la encriptacion clasica difieren en algunos aspectos clave. Ambos son metodos de seguridad de los datos criptograficos y tienen esencialmente la misma funcion, pero lo hacen con procesos diferentes y tienen efectos distintos en los datos que protegen.  La tokenizacion es un enfoque no matematico que sustituye los datos sensibles por sustitutos no sensibles sin alterar el tipo o la longitud de los datos. Se trata de una distincion importante con respecto al cifrado porque los cambios en la longitud y el tipo de los datos pueden hacer que la informacion sea ilegible en sistemas intermedios como las bases de datos. Los datos convertidos en tokens son seguros, pero aun asi pueden ser procesados por sistemas heredados, lo que hace que la conversion en tokens sea mas flexible que el cifrado clasico.  Otra diferencia es que los tokens requieren muchos menos recursos computacionales para su procesamiento. Con la conversion en tokens, los datos especificos se mantienen total o parcialmente visibles para su procesamiento y analisis, mientras que la informacion sensible se mantiene oculta. Esto permite que los datos con tokens se procesen con mayor rapidez y reduce la carga de los recursos del sistema. Esto puede ser una ventaja clave en los sistemas que dependen de un alto rendimiento.  Con la creciente adopcion de la tokenizacion, han surgido nuevos enfoques de tecnologia de tokenizacion para eliminar esos riesgos y complejidades operacionales y permitir una mayor escala adecuada a los casos de uso de los macrodatos que estan surgiendo y al procesamiento de transacciones de alto rendimiento, especialmente en los servicios financieros y la banca.\u200b Entre los ejemplos recientes figuran la tokenizacion sin bovedas de Protegrity, la tokenizacion de Privitar Publisher y la tecnologia de tokenizacion segura sin estado de Voltage Security\u200b y la solucion patentada de tokenizacion sin estado SecurDPS de Comfort. La tokenizacion sin boveda y la tokenizacion sin estado han sido validados independientemente\u200b para proporcionar una limitacion significativa de los controles aplicables del Estandar de Seguridad de Datos para la Industria de Tarjeta de Pago (PCI DSS) para reducir el alcance de las evaluaciones. La conversion de tokens sin estado permite el mapeo aleatorio de elementos de datos en directo para sustituir valores sin necesidad de una base de datos, conservando al mismo tiempo las propiedades de aislamiento de la conversion de tokens.  En noviembre de 2014, American Express lanzo su servicio de tokens que cumple con el estandar de tokens de EMV.\u200b  Los sistemas de tokenizacion de primera generacion utilizan una base de datos para trazar un mapa de los datos en directo para sustituir los tokens sustitutivos y volver. Esto requiere el almacenamiento, la gestion y el respaldo continuo de cada nueva transaccion a\u00f1adida a la base de datos de tokens para evitar la perdida de datos. Otro problema es asegurar la consistencia entre los centros de datos, lo que requiere una sincronizacion continua de las bases de datos de los simbolos. La consistencia significativa, la disponibilidad y los intercambios de rendimiento, segun la conjetura de Brewer, son inevitables con este enfoque. Esta sobrecarga a\u00f1ade complejidad al procesamiento de transacciones en tiempo real para evitar la perdida de datos y asegurar la integridad de los datos en todos los centros de datos, y tambien limita la escala. El almacenamiento de todos los datos sensibles en un servicio crea un blanco atractivo para el ataque y el compromiso, e introduce la privacidad y el riesgo legal en la agregacion de datos de la privacidad en Internet, particularmente en la U. E..  Otra limitacion de las tecnologias de conversion en tokens es la medicion del nivel de seguridad de una solucion determinada mediante una validacion independiente. Ante la falta de normas, esta ultima es fundamental para establecer la solidez de la conversion en tokens ofrecida cuando se utilizan tokens para el cumplimiento de la reglamentacion. El Consejo de Normas de Seguridad de la Industria de las Tarjetas de Pago (PCI Council) recomienda la investigacion y validacion independientes de toda reclamacion de seguridad y cumplimiento: \"Los comerciantes que consideren la posibilidad de utilizar tokens deben realizar una evaluacion exhaustiva y un analisis de riesgos para identificar y documentar las caracteristicas unicas de su aplicacion particular, incluidas todas las interacciones con los datos de las tarjetas de pago y los sistemas y procesos particulares de utilizacion de tokens\".\u200b  El metodo de generacion de tokens tambien puede tener limitaciones desde el punto de vista de la seguridad. En lo que respecta a la seguridad y los ataques a los generadores de numeros aleatorios, que son una opcion comun para la generacion de tokens y las tablas de asignacion de tokens, debe aplicarse un escrutinio para garantizar que se utilicen metodos probados y validados frente a un dise\u00f1o arbitrario.\u200b  Los generadores de numeros aleatorios tienen limitaciones en cuanto a velocidad, entropia, sembrado y sesgo, y las propiedades de seguridad deben analizarse y medirse cuidadosamente para evitar la previsibilidad y el equilibrio.  Hay muchas maneras de clasificar los tokens, pero actualmente no existe una clasificacion unificada. Los tokens pueden ser: de uso unico o multiple, criptografico o no criptografico, reversibles o irreversibles, autentico o no autentico, y diversas combinaciones de las mismas.  Los tres tipos principales de tokens son:  En el contexto de los pagos, la diferencia entre los tokens de alto y bajo valor juega un papel importante.  Los TAVs sirven como sustitutos de los PAN reales en las transacciones de pago y se utilizan como instrumento para completar una transaccion de pago. Para funcionar, deben parecerse a los PAN reales. Multiples TAVs pueden ser asignados a un solo PAN y a una sola tarjeta de credito fisica sin que el due\u00f1o lo sepa.  Ademas, los TAVs pueden limitarse a ciertas redes y/o comerciantes, mientras que los PAN no pueden.  Los TAVs tambien pueden estar vinculados a dispositivos especificos, de modo que las anomalias entre el uso de tokens, los dispositivos fisicos y las ubicaciones geograficas puedan ser marcadas como potencialmente fraudulentas.  Los TBVs tambien actuan como sustitutos de los PAN reales en las transacciones de pago, sin embargo sirven para un proposito diferente. Los TBVs no pueden ser utilizados por si mismos para completar una transaccion de pago. Para que un TBV funcione, debe ser posible compararlo con el PAN real que representa, aunque solo de manera estrictamente controlada. El uso de tokens para proteger los PAN se vuelve ineficaz si se viola un sistema de tokens, por lo que asegurar el sistema de tokens en si es extremadamente importante.  La creacion de un sistema de pagos alternativo requiere que varias entidades trabajen juntas para prestar a los usuarios finales servicios de comunicacion de campo cercano (NFC) u otros servicios de pago basados en la tecnologia. Uno de los problemas es la interoperabilidad entre los actores y para resolver este problema se propone la funcion de gestor de servicios de confianza (TSM) para establecer un vinculo tecnico entre los operadores de redes moviles (MNO) y los proveedores de servicios, de modo que estas entidades puedan trabajar conjuntamente. La tokenizacion puede desempe\u00f1ar una funcion de mediacion de esos servicios.  La utilizacion de tokens como estrategia de seguridad radica en la capacidad de sustituir un numero de tarjeta real por uno de sustitucion (eliminacion de objetivos) y las consiguientes limitaciones que se imponen al numero de tarjeta de sustitucion (reduccion de riesgos). Si el valor sustitutivo puede utilizarse de manera ilimitada o incluso de forma generalizada, como en el caso de Apple Pay, el valor simbolico gana tanto valor como el numero real de la tarjeta de credito. En estos casos, el token puede estar asegurado por una segundo token dinamico unico para cada transaccion y tambien asociado a una tarjeta de pago especifica. Entre los ejemplos de tokens dinamicos y especificos de una transaccion figuran los criptogramas utilizados en la especificacion EMV.  El Estandar de Seguridad de Datos para la Industria de Tarjeta de Pago (PCI DSS), es un conjunto de directrices para toda la industria que debe cumplir cualquier organizacion que almacene, procese o transmita datos de titulares de tarjetas, ordena que los datos de las tarjetas de credito deben estar protegidos cuando se almacenen. La tokenizacion, aplicada a los datos de las tarjetas de pago, se suele implementar para cumplir este mandato, sustituyendo en algunos sistemas los numeros de las tarjetas de credito y de la Camara de Compensacion Automatizada por un valor aleatorio o una cadena de caracteres. Los tokens se pueden formatear de diversas maneras. Algunos proveedores de servicios de tokens o productos de tokenizacion generan los valores sustitutivos de manera que coincidan con el formato de los datos sensibles originales. En el caso de los datos de las tarjetas de pago, un token puede tener la misma longitud que un numero de cuenta principal (numero de tarjeta bancaria) y contener elementos de los datos originales como los cuatro ultimos digitos del numero de la tarjeta. Cuando se hace una solicitud de autorizacion de una tarjeta de pago para verificar la legitimidad de una transaccion, se podria devolver al comerciante un token en lugar del numero de la tarjeta, junto con el codigo de autorizacion de la transaccion. El token se almacena en el sistema receptor mientras que los datos reales del titular de la tarjeta se asignan un token en un sistema seguro de tokens. El almacenamiento de los tokens y los datos de las tarjetas de pago debe cumplir las normas vigentes de la PCI, incluido el uso de criptografia fuerte.  La tokenizacion se encuentra actualmente en la definicion de normas en ANSI X9. X9 se encarga de las normas de la industria en materia de criptografia financiera y proteccion de datos, incluida la gestion del numero de identificacion personal (PIN) de las tarjetas de pago, la codificacion de las tarjetas de credito y de debito y las tecnologias y procesos conexos.  El Consejo de la PCI tambien ha declarado su apoyo a la utilizacion de tokens para reducir el riesgo de violacion de datos, cuando se combina con otras tecnologias como el cifrado punto a punto (P2PE) y las evaluaciones del cumplimiento de las directrices del PCI DSS.\u200b  Visa Inc. publico las practicas optimas de tokenizacion de Visa para su uso en aplicaciones y servicios de gestion de tarjetas de credito y debito.\u200b  En marzo de 2014, EMVCo LLC publico su primera especificacion de tokenizacion de pago para EMV.\u200b  El NIST estandarizo los algoritmos de encriptacion de preservacion de formato FF1 y FF3 en su publicacion especial 800-38G.\u200b  Cuando se valida adecuadamente y con una evaluacion independiente apropiada, la tokenizacion puede hacer mas dificil que los atacantes accedan a datos confidenciales fuera del sistema o servicio de tokenizacion. La aplicacion de la tokenizacion puede simplificar los requisitos del PCI DSS, ya que los sistemas que ya no almacenan o procesan datos sensibles pueden tener una reduccion de los controles aplicables exigidos por las directrices del PCI DSS.  Como practica optima en materia de seguridad, es preciso que se efectue una evaluacion y validacion independientes de toda tecnologia utilizada para la proteccion de datos, incluida la utilizacion de tokens, a fin de establecer la seguridad y la solidez del metodo y la aplicacion antes de que se pueda hacer cualquier reclamacion de cumplimiento de la privacidad, el cumplimiento de las normas y la seguridad de los datos. Esta validacion es particularmente importante en la conversion en tokens, ya que los tokens se comparten externamente en el uso general y, por lo tanto, estan expuestos en entornos de alto riesgo y baja confianza. La inviabilidad de convertir un token o un conjunto de tokens en un dato sensible vivo debe establecerse utilizando mediciones y pruebas aceptadas por la industria por parte de expertos apropiados, independientes del proveedor de servicios o soluciones.\u200b  Supongamos la siguiente linea de un programa:  Los tokenes son:  Y se describen por lo general en dos partes, un tipo o clase y un valor, asi: Token=(Tipo,Valor)  Para la secuencia anterior, los tokenes pueden describirse ","snippet":"La tokenizacion, cuando se aplica a la seguridad de los datos, se refiere al proceso de sustitucion de un elemento de datos sensible por un equivalente no sensible denominado token, que no tiene un si","enlaces_salientes":["Token_(inform%C3%A1tica)","Token_(inform%C3%A1tica)","Token_(inform%C3%A1tica)","Cuenta_bancaria","Estados_financieros","Historia_cl%C3%ADnica","Antecedente_penal","Autorizaci%C3%B3n_para_la_conducci%C3%B3n_de_veh%C3%ADculos","Empr%C3%A9stito","Moneda_(divisa)","Monetiforme","Ceca","Papel_moneda","Exonumia","Clave_sustituta","Tarjeta_de_pago","N%C3%BAmero_de_tarjeta_bancaria","%C3%81rea_metropolitana_de_Las_Vegas","Cifrado_de_extremo_a_extremo","Malware","Terminal_punto_de_venta","Host","Cifrado_(criptograf%C3%ADa)","Criptograf%C3%ADa","Macrodatos","PCI_DSS","American_Express","EMV","Teorema_CAP","Privacidad_en_Internet","Directiva_de_Protecci%C3%B3n_de_Datos","Generador_de_n%C3%BAmeros_pseudoaleatorios_criptogr%C3%A1ficamente_seguro","Comisi%C3%B3n_de_Bolsa_y_Valores","Autoridad_Suiza_Supervisora_del_Mercado_Financiero","Criptomoneda","N%C3%BAmero_de_tarjeta_bancaria","Near_field_communication","Operador_de_red_m%C3%B3vil","Apple_Pay","PCI_DSS","Automated_Clearing_House","N%C3%BAmero_de_tarjeta_bancaria","EMV","Token_de_seguridad","Token_Ring","Control_de_autoridades"]}
{"url":"Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","titulo":"Morfologia linguistica","contenido":"La morfologia (del griego \u03bc\u03bf\u03c1\u03c6o morphe \u2018forma\u2019, y \u03bb\u03bf\u03b3\u03b1 logia \u2018tratado o estudio\u2019) es la rama de la linguistica que estudia la estructura interna de las palabras para definir y clasificar sus unidades: las variantes de las palabras (morfologia flexiva) y la formacion de nuevas palabras (morfologia derivativa y composicion).  La palabra \u00abmorfologia\u00bb fue introducida en el siglo\u00a0XIX y originalmente trataba simplemente de la forma de las palabras, aunque en su acepcion mas moderna estudia fenomenos mas complejos que la forma en si.    El termino morfologia proviene del griego \u03bc\u03bf\u03c1\u03c6o-, morpho ('forma') y \u03bb\u03bf\u03b3\u03b1 logia ('tratado', 'ciencia'); asi, el todo significa literalmente 'ciencia (o estudio) de la forma'. En efecto, se habla de la morfologia de las plantas, de la morfologia de los seres vivos, de la morfologia del relieve terrestre, etc.  En linguistica, este termino adquiere un significado especializado: 'estudio de las formas de las palabras' y, por extension, 'estudio de la palabra'. Esto se remonta a una tradicion iniciada en los trabajos de Baudouin de Courtenay segun la cual las palabras estan formadas por raices y afijos que realizan la funcion del signo saussureano. Y aunque tambien se deba hablar en linguistica de la forma de los sintagmas y/o de las frases, el termino morfologia no se aplica a estos ultimos; es la palabra, y solamente la palabra, lo que constituye el objeto de la morfologia linguistica de acuerdo a un uso general.  La posicion en la morfologia gramatical es intermedia. Para la tradicion estructuralista americana de Bloomfield, la morfologia era esencial; en la tradicion generativista chomskyana, en cambio, la sintaxis es central y la morfologia o bien es relegada a la fonologia o bien es ignorada como disciplina independiente. Esas posturas han hecho de la morfologia linguistica un campo polemico y de dificil definicion en la moderna teoria linguistica. Habitualmente se considera que los patrones morfologicos son el resultado de la gramaticalizacion y que, en cierto sentido eso es todo lo que hay en morfologia. Por tanto, la busqueda de universales morfologicos y el propio analisis morfologico no serian otra cosa que un estudio de los patrones de gramaticalizacion.  La gramatica tradicional divide el estudio de todas las lenguas del mundo por convencion, en dos secciones: morfologia y sintaxis. La relacion entre las dos es la siguiente:  Sin embargo, en el seno de la gramatica generativa se ha sostenido que la morfologia es insostenible como rama autonoma. En ocasiones hay alternacias morfologicas que estan ocasionadas por restricciones fonologicas por lo que ciertos aspectos de la morfologia tradicional caen dentro de la morfofonemica. Algunos otros procesos morfologicos no parecen facilmente separables de la sintaxis, por lo que su estudio recae en el estudio llamado morfosintaxis. Para algunos autores la morfologia se restringe solo al proceso de formacion de palabras, dejando fuera los procesos morfofonemicos y morfosintacticos.  Desde el punto de vista de la morfologia, es importante la tradicional clasificacion de las lenguas humanas en 3 grupos:  No todas las lenguas entran claramente en estos 3 grupos.  En todas las lenguas, con independencia de los procedimientos morfologicos que posea, se puede identificar en una palabra un morfo basico, una secuencia de sonidos que identifica el significado principal de la palabra, al que se llama lexema o raiz. Sin embargo, en lenguas con morfos que no son afijos, como las lenguas semiticas, los lexemas son \"esqueletos\" de dos o tres consonantes entre las cuales se insertan vocales. Estas vocales entran en forma de esquemas paradigmaticos y son un ejemplo de morfo discontinuo (en este tipo de lenguas los lexemas tambien son de hecho discontinuos, es decir, no forman una secuencia de fonemas consecutivos).  Los lexemas forman la mayor parte del lexico de una lengua, su numero es siempre muy superior al de gramemas (los morfemas que no son lexemas), y en principio se considera una clase abierta. Es decir, forman un conjunto susceptible de ser ampliada con nuevos prestamos lexicos u otros procedimientos creativos para designar nuevos conceptos o realidades.  Los morfemas gramaticales son las unidades que constituyen la parte variable de la palabra y son las responsables de expresar relaciones gramaticales que no alteran el significado referencial basico de una palabra. Usualmente no son autonomos y su aparicion no es facultativa sino que esta sujeta a restricciones gramaticales. Estos morfemas expresan relaciones o accidentes gramaticales como:  Son formantes facultativos mediante los cuales se forman significados composicionales y conceptos derivados del significado basico. Algunos ejemplos de esto:  Segun su posicion respecto al lexema, se distinguen tres tipos de morfemas gramaticales derivativos:  Son formantes constitutivos que ocupan siempre la posicion final de la palabra y la informacion que ofrecen es de tipo gramatical, como el genero, el numero, la persona, el modo, etc.  Existe otra clase de morfemas denominados morfemas libres o independientes que no van unidos a ningun lexema pero confieren de significacion gramatical a las palabras con las que se asocian. Los determinantes, las preposiciones y las conjunciones puede actuar como morfemas libres. Casi todos ellos son atonos. Por ejemplo, el articulo hace de morfema flexivo para el sustantivo de la oracion.  Los alomorfos son las diferentes realizaciones fonicas de un determinado morfema. Por ejemplo, en espa\u00f1ol el plural puede realizarse como -s o -es, estas dos formas son por tanto alomorfos del morfema de numero plural del espa\u00f1ol. Tambien son alomorfos -ble y -bil, como en imposible e imposibilidad, o nece- y neci, como en necio y necedad.  Un tipo de morfo interesante es aquel que no tiene realizacion fonemica audible. La consideracion de esta ausencia de contenido fonico como una relacion con frecuencia ayuda a hacer mas sencillo y sistematico el analisis morfologico, ya que el hecho de que un determinado morfema no tenga realizacion fonica no impide considerarlo un miembro de pleno derecho de la clase de equivalencia que forma el morfema sobre la base de relaciones paradigmaticas sistematicas.  Un ejemplo de esto lo encontramos en espa\u00f1ol en la palabra atlas. Aqui el morfema de numero no esta presente, y esa es precisamente la razon por la cual el numero es singular. Otro ejemplo son los morfos de genero en nombres o adjetivos acabados en consonante:  La consideracion de los alomorfos ceros \u2205M y \u2205F permite decir que en una oracion atributiva el sujeto y el atributo concuerdan en genero siempre. Un analisis alternativo en la linea de Vossler negando que estos alomorfos cero sean reales necesitaria explicar que a veces hay concordancia (cuando hay morfemas de genero) y a veces no hay concordancia, siendo en ese caso la regla mas complicada. Es decir, la consideracion de morfemas cero simplifica las generalizaciones sobre la concordancia y otros aspectos de la estructura gramatical. Igualmente las marcas de persona de en la tercera persona del singular pueden ser consideradas morfos ceros: ","snippet":"La morfologia (del griego \u03bc\u03bf\u03c1\u03c6o morphe \u2018forma\u2019, y \u03bb\u03bf\u03b3\u03b1 logia \u2018tratado o estudio\u2019) es la rama de la linguistica que estudia la estructura interna de las palabras para definir y clasificar sus unidades:","enlaces_salientes":["Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Morfolog%C3%ADa_ling%C3%BC%C3%ADstica","Griego_antiguo","Ling%C3%BC%C3%ADstica","Palabra","Morfolog%C3%ADa_flexiva","Morfolog%C3%ADa_derivativa","Composici%C3%B3n_(ling%C3%BC%C3%ADstica)","Monema","Flexi%C3%B3n_(ling%C3%BC%C3%ADstica)","Ling%C3%BC%C3%ADstica","Palabra","Jan_Baudouin_de_Courtenay","Lexema","Afijo","Ferdinand_de_Saussure","Sintagma","Estructuralismo_(ling%C3%BC%C3%ADstica)","Leonard_Bloomfield","Gram%C3%A1tica_generativa","Noam_Chomsky","Sintaxis","Fonolog%C3%ADa","Gramaticalizaci%C3%B3n","Gram%C3%A1tica_tradicional","Sintaxis","Sintagma","Oraci%C3%B3n_(gram%C3%A1tica)","Gram%C3%A1tica_generativa","Lengua_aislante","Chino_mandar%C3%ADn","Lengua_aglutinante","Euskera","Idioma_h%C3%BAngaro","Idioma_japon%C3%A9s","Lengua_fusionante","Griego_antiguo","Idioma_espa%C3%B1ol","Idioma_%C3%A1rabe","Morfema","Lenguas_sem%C3%ADticas","Pr%C3%A9stamo_ling%C3%BC%C3%ADstico","N%C3%BAmero_gramatical","G%C3%A9nero_gramatical","Caso_(gram%C3%A1tica)","Tiempo_gramatical","Sufijo","Prefijo","Infijo#Diferencia_con_los_interfijos","Infijo","Alomorfo","Karl_Vossler","Caso_(gram%C3%A1tica)","Derivaci%C3%B3n_(ling%C3%BC%C3%ADstica)","Control_de_autoridades","Gemeinsame_Normdatei","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lenguaje_inform%C3%A1tico","titulo":"Lenguaje informatico","contenido":"Un lenguaje informatico es un lenguaje usado por ordenadores. Muchas veces, este termino se usa como sinonimo de lenguaje de programacion, pero un lenguaje informatico no tiene por que ser un lenguaje de programacion.  Como ejemplo un lenguaje de marcas como el HTML no es un lenguaje de programacion, pero si es un lenguaje informatico.  En general, como cualquier otro lenguaje, un lenguaje de ordenador se crea cuando hay que transmitir una informacion de algo a alguien basado en computadora.  El lenguaje de programacion es el medio que utilizan los programadores para crear un programa de ordenador; un lenguaje de marcas es el medio para describir a un ordenador el formato o la estructura de un documento; etc.  Los lenguajes informaticos se pueden clasificar en varias clases, entre las que se incluyen las siguientes:   ","snippet":"Un lenguaje informatico es un lenguaje usado por ordenadores. Muchas veces, este termino se usa como sinonimo de lenguaje de programacion, pero un lenguaje informatico no tiene por que ser un lenguaje","enlaces_salientes":["Lenguaje_inform%C3%A1tico","Lenguaje_inform%C3%A1tico","Lenguaje_inform%C3%A1tico","Computadora","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_marcado","HTML","Programa_inform%C3%A1tico","Documento","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_especificaci%C3%B3n","Lenguaje_de_consulta","SQL","XQuery","Lenguaje_de_marcas","XML","Lenguaje_de_marcas_ligero","XSLT","Protocolo_de_comunicaciones","Http","Ftp","Pseudoc%C3%B3digo","Lenguaje_de_Definici%C3%B3n_de_Procesos_(Process_Definition_Language,_PDL)","Control_de_autoridades"]}
{"url":"HTML","titulo":"HTML","contenido":"HTML, siglas en ingles de HyperText Markup Language (\u2018lenguaje de marcado de hipertexto\u2019), hace referencia al lenguaje de marcado para la elaboracion de paginas web. Es un estandar que sirve de referencia del software que conecta con la  elaboracion de paginas web en sus diferentes versiones, define una estructura basica y un codigo (denominado codigo HTML) para la definicion de contenido de una pagina web, como texto, imagenes, videos, juegos, entre otros. Es un estandar a cargo del World Wide Web Consortium (W3C) o Consorcio WWW, organizacion dedicada a la estandarizacion de casi todas las tecnologias ligadas a la web, sobre todo en lo referente a su escritura e interpretacion. HTML se considera el lenguaje web mas importante siendo su invencion crucial en la aparicion, desarrollo y expansion de la World Wide Web (WWW). Es el estandar que se ha impuesto en la visualizacion de paginas web y es el que todos los navegadores actuales han adoptado.\u200b  El lenguaje HTML basa su filosofia de desarrollo en la diferenciacion. Para a\u00f1adir un elemento externo a la pagina (imagen, video, script, entre otros.), este no se incrusta directamente en el codigo de la pagina, sino que se hace una referencia a la ubicacion de dicho elemento mediante texto. De este modo, la pagina web contiene solamente texto mientras que recae en el navegador web (interpretador del codigo) la tarea de unir todos los elementos y visualizar la pagina final. Al ser un estandar, HTML busca ser un lenguaje que permita que cualquier pagina web escrita en una determinada version, pueda ser interpretada de la misma forma (estandar) por cualquier navegador web actualizado.  HTML es un lenguaje de marcado que nos permite indicar la estructura de nuestro documento mediante etiquetas. Este lenguaje nos ofrece una gran adaptabilidad, una estructuracion logica y es facil de interpre\u00adtar tanto por humanos como por maquinas.  Sin embargo, a lo largo de sus diferentes versiones, se han incorporado y suprimido diversas caracteristicas, con el fin de hacerlo mas eficiente y facilitar el desarrollo de paginas web compatibles con distintos navegadores y plataformas (PC de escritorio, portatiles, telefonos inteligentes, tabletas, etc.) No obstante, para interpretar correctamente una nueva version de HTML, los desarrolladores de navegadores web deben incorporar estos cambios y el usuario debe ser capaz de usar la nueva version del navegador con los cambios incorporados. Normalmente los cambios son aplicados mediante parches de actualizacion automatica (Firefox, Chrome) u ofreciendo una nueva version del navegador con todos los cambios incorporados, en un sitio web de descarga oficial (Internet Explorer). Por lo que un navegador desactualizado no sera capaz de interpretar correctamente una pagina web escrita en una version de HTML superior a la que pueda interpretar, lo que obliga muchas veces a los desarrolladores a aplicar tecnicas y cambios que permitan corregir problemas de visualizacion e incluso de interpretacion de codigo HTML. Asi mismo, las paginas escritas en una version anterior de HTML deberian ser actualizadas o reescritas, lo que no siempre se cumple. Es por ello que ciertos navegadores todavia mantienen la capacidad de interpretar paginas web de versiones HTML anteriores. Por estas razones, todavia existen diferencias entre distintos navegadores y versiones al interpretar una misma pagina web.  Tim Berners-Lee (TBL) en 1991\u200b\u200b describe 18 elementos que incluyen el dise\u00f1o inicial y relativamente simple de HTML. Trece de estos elementos todavia existen en HTML 4.\u200b  Berners-Lee consideraba el HTML una ampliacion de SGML, pero no fue formalmente reconocida como tal hasta la publicacion a mediados de 1993, por la IETF (en espa\u00f1ol: Grupo de Trabajo de Ingenieria de Internet), de una primera proposicion para una especificacion del HTML: el borrador del Hypertext Markup Language de Berners-Lee y Dan Connolly, que incluia una Definicion de Tipo de Documento SGML para definir la gramatica.\u200b El borrador expiro a los seis meses, pero fue notable por su reconocimiento de la etiqueta propia del navegador Mosaic usada para insertar imagenes sin cambio de linea, que reflejaba la filosofia del IETF de basar estandares en prototipos con exito.\u200b De la misma manera, el borrador competidor de Dave Raggett HTML+ (Hypertext Markup Format) (Formato de Marcaje de Hipertexto), de finales de 1993, sugeria estandarizar caracteristicas ya implementadas, como las tablas.\u200b  El HTML se escribe en forma de \u00abetiquetas\u00bb, rodeadas por corchetes angulares (<,>,/). El HTML tambien puede describir, hasta un cierto punto, la apariencia de un documento, y puede incluir o hacer referencia a un tipo de programa llamado script, el cual puede afectar el comportamiento de navegadores web y otros procesadores de HTML.\u200b  HTML tambien sirve para referirse al contenido del tipo de MIME text/html o todavia mas ampliamente como un termino generico para el HTML, ya sea en forma descendida del XML (como XHTML 1.0 y posteriores) o en forma descendida directamente de SGML (como HTML 4.01 y anteriores). HTML consta de varios componentes vitales, entre ellos los elementos y sus atributos, tipos de data y la declaracion de tipo de documento.  Los elementos son la estructura basica de HTML. Los elementos tienen dos propiedades basicas: atributos y contenido. Cada atributo y contenido tiene ciertas restricciones para que se considere valido al documento HTML. Un elemento generalmente tiene una etiqueta de inicio (por ejemplo, <nombre-de-elemento>) y una etiqueta de cierre (por ejemplo, </nombre-de-elemento>). Los atributos del elemento estan contenidos en la etiqueta de inicio y el contenido esta ubicado entre las dos etiquetas (por ejemplo, <nombre-de-elemento\u00a0atributo=\"valor\">Contenido</nombre-de-elemento>). Algunos elementos, tales como <br>, no tienen contenido ni llevan una etiqueta de cierre. Debajo se listan varios tipos de elementos de marcado usados en HTML.  El marcado estructural describe el proposito del texto. Por ejemplo, <h2>Golf</h2> establece \u00abGolf\u00bb como un encabezamiento de segundo nivel, el cual se mostraria en un navegador de una manera similar al titulo \u00abMarcador HTML\u00bb al principio de esta seccion. El marcado estructural no define como se vera el elemento, pero la mayoria de los navegadores web han estandarizado el formato de los elementos. Puede aplicarse un formato especifico al texto por medio de hojas de estilo en cascada.  El marcado presentacional describe la apariencia del texto, sin importar su funcion. Por ejemplo, <b>negrita</b> indica que los navegadores web visuales deben mostrar el texto en negrita, pero no indica que deben hacer los navegadores web que muestran el contenido de otra manera (por ejemplo, los que leen el texto en voz alta). En el caso de <b>negrita</b> e <i>italica</i>, existen elementos que se ven de la misma manera pero tienen una naturaleza mas semantica: <strong>enfasis fuerte</strong> y <em>enfasis</em>. Es facil ver como un lector de pantalla deberia interpretar estos dos elementos. Sin embargo, son equivalentes a sus correspondientes elementos presentacionales: un lector de pantalla no deberia decir mas fuerte el nombre de un libro, aunque el nombre resalte en italicas en una pantalla. La mayoria del marcado presentacional ha sido desechada desde la version 4.01, en favor de las hojas de estilo en cascada.  El marcado hipertextual se utiliza para enlazar partes del documento con otros documentos o con otras partes del mismo documento. Para crear un enlace es necesario utilizar la etiqueta de ancla <a> junto con el atributo href, que establecera la direccion URL a la que apunta el enlace. Por ejemplo, un enlace que muestre el texto de la direccion y vaya hacia nuestra Wikipedia podria ser de la forma <a href=\u201dhttps://www.wikipedia.org\u201d>https://www.wikipedia.org</a>. Tambien se pueden crear enlaces sobre otros objetos, tales como imagenes <a href=\u201denlace\u201d><img src=\u201dimagen\u201d /></a>.  En su mayoria los atributos de un elemento son pares nombre-valor, separados por un signo de igual \u00ab=\u00bb y escritos en la etiqueta de comienzo de un elemento, despues del nombre del elemento. El valor puede estar rodeado por comillas dobles o simples, aunque ciertos tipos de valores pueden estar sin comillas en HTML (pero no en XHTML).\u200b\u200b De todas maneras, dejar los valores sin comillas es considerado poco seguro.\u200b En contraste con los pares nombre-elemento, hay algunos atributos que afectan al elemento simplemente por su presencia\u200b (tal como el atributo ismap para el elemento img).\u200b  La mayoria de etiquetas deben cerrarse como se abren, pero con una barra ( / ) tal como se muestra en los siguientes ejemplos:  El lenguaje HTML puede ser creado y editado con cualquier editor de textos basico, como puede ser Gedit en GNU/Linux, el Bloc de notas de Windows, o cualquier otro editor que admita texto sin formato como GNU Emacs, Microsoft Wordpad, TextPad, Vim, Notepad++, Atom, Visual Studio Code, entre muchos otros.  Existen, ademas, otros editores para la realizacion de sitios web con caracteristicas WYSIWYG (What You See Is What You Get, o en espa\u00f1ol: \u00ablo que ves es lo que obtienes\u00bb). Estos editores permiten ver el resultado de lo que se esta editando en tiempo real, a medida que se va desarrollando el documento. Ahora bien, esto no significa una manera distinta de realizar sitios web, sino que una forma un tanto mas simple, ya que estos programas, ademas de tener la opcion de trabajar con la vista preliminar, tiene su propia seccion HTML, la cual va generando todo el codigo a medida que se va trabajando. Algunos ejemplos de editores WYSIWYG son KompoZer, Microsoft FrontPage o Adobe Dreamweaver.  Combinar estos dos metodos resulta muy interesante, ya que de alguna manera se ayudan entre si. Por ejemplo, si se edita todo en HTML y el desarrollador olvida algun codigo o etiqueta, basta con dirigirse al editor visual o WYSIWYG y se continua ahi la edicion o viceversa, ya que hay casos en que resulta mas rapido y facil escribir directamente el codigo de alguna caracteristica que el usuario desea adherir al sitio que buscar la opcion en el programa mismo.  Existe otro tipo de editores HTML llamados WYSIWYM que dan mas importancia al contenido y al significado que a la apariencia visual. Entre los objetivos que tienen estos editores es la separacion del contenido y la presentacion, fundamental en el dise\u00f1o web.  HTML utiliza etiquetas o marcas, que consisten en breves instrucciones de comienzo y final, mediante las cuales se determina la forma en la que debe aparecer en su navegador el texto, asi como tambien las imagenes y los demas elementos, en la pantalla del ordenador.  Toda etiqueta se identifica porque esta encerrada entre los signos menor que y mayor que (<>), y algunas tienen atributos que pueden tomar algun valor. En general las etiquetas se aplicaran de dos formas especiales:  Para el desarrollo web los programadores se auxilian de un editor de texto. Estos normalmente estan hechos con el fin de facilitar la programacion. Existen actualmente muchos, como son estos: Notepad++, Adobe Dreamweaver, Sublime text, entre otros.  Seleccionando la opcion \u00abver codigo fuente\u00bb en el navegador, se puede ver realmente la informacion que esta recibiendo el navegador web y como la esta interpretando.  Por ejemplo: en Internet Explorer, simplemente hay que desplegar el menu \u00abver\u00bb y luego elegir \u00abcodigo fuente\u00bb, mientras que en Chrome y Firefox presionar Ctrl+U. De esta forma, se abrira una pesta\u00f1a con el codigo fuente de la pagina que se este viendo en ese momento en el navegador. Otra forma mas rapida consiste en hacer clic con el boton derecho del raton en cualquier punto del area donde el navegador muestra la pagina web y elegir \u00abVer codigo fuente de la pagina\u00bb.  Aparte de poder ver el codigo fuente HTML de una pagina web con las opciones antes descritas, Internet Explorer, Firefox y Google Chrome incorporan tambien unas herramientas conocidas como inspectores de pagina que se puede activar con F12.  Con estas herramientas es posible visualizar una pagina web y seleccionar dentro de ella un elemento concreto del cual queremos conocer cual es el codigo HTML con el que esta hecho se\u00f1alando el elemento en cuestion simplemente con el raton. Al hacer esto, el codigo se mostrara en un area especial dentro del navegador en el que el usuario podra ver el codigo HTML en cuestion (ver imagen), ademas, de las reglas CSS que aplican a ese codigo HTML en concreto. Este tipo de analisis resulta sumamente instructivo para aprender a desarrollar en HTML.  Para el navegador Firefox, ademas, existe como alternativa a la herramienta nativa el plugin Firebug, muy similar a la herramienta que Firefox incorpora por defecto.  En 1989 existian dos tecnicas que permitian vincular documentos electronicos, por un lado los hipervinculos o enlaces (hiperlinks o links) y por otro lado un poderoso lenguaje de etiquetas denominado SGML. Por entonces, Tim Berners-Lee, quien trabajaba en el Centro Europeo de Investigaciones Nucleares CERN da a conocer a la prensa que estaba trabajando en un sistema que va a permitir acceder a ficheros en linea que funcionaba sobre redes de computadoras o maquinas electronicas basadas en el protocolo TCP/IP. Inicialmente fue desarrollado para que se pudiera compartir facilmente informacion entre cientificos de distintas universidades e institutos de investigacion de todo el mundo.\u200b  A principios de 1990, define por fin el HTML como un subconjunto del conocido SGML y crea algo mas valioso incluso, el World Wide Web.  Tim Berners-Lee creo el proyecto World Wide Web (Tejido o Telara\u00f1a Mundial), asi como un sistema que facilitaba la lectura de informacion, mediante un programa de navegacion. Seria el primer navegador web, llamado WorldWideWeb, y desarrollado durante la segunda mitad del a\u00f1o 1990; siendo tiempo despues rebautizado como Nexus, para evitar confusiones por su nombre que era igual al de la tecnologia que representaba. Le siguieron otros dos navegadores: el Line Mode Browser y el ViolaWWW. Este ultimo, desarrollado en 1992, fue el primer navegador en popularizarse entre los primeros usuarios de la World Wide Web.\u200b  Pei-Yuan Wei presento el ViolaWWW,\u200b que funcionaria en modo texto y sobre un sistema operativo UNIX.  Los trabajos para crear un sucesor del HTML, denominado HTML+, comenzaron a finales de 1993. HTML+ se dise\u00f1o originalmente para ser un superconjunto del HTML que permitiera evolucionar gradualmente desde el formato HTML anterior. A la primera especificacion formal de HTML+ se le dio, por lo tanto, el numero de version 2 para distinguirla de las propuestas no oficiales previas. Los trabajos sobre HTML+ continuaron, pero nunca se convirtio en un estandar, a pesar de ser la base formalmente mas parecida al aspecto compositivo de las especificaciones actuales.  El borrador del estandar HTML 3.0 fue propuesto por el recien formado W3C en marzo de 1995. Con el se introdujeron muchas nuevas capacidades; por ejemplo, facilidades para crear tablas, hacer que el texto fluyese alrededor de las figuras y mostrar elementos matematicos complejos. Aunque se dise\u00f1o para ser compatible con HTML 2.0, era demasiado complejo para ser implementado con la tecnologia de la epoca, y cuando el borrador del estandar expiro en septiembre de 1995, se abandono debido a la carencia de apoyos de los fabricantes de navegadores web. El HTML 3.1 nunca llego a ser propuesto oficialmente, y el estandar siguiente fue el HTML 3.2, que abandonaba la mayoria de las nuevas caracteristicas del HTML 3.0 y, a cambio, adoptaba muchos elementos desarrollados inicialmente por los navegadores web Netscape y Mosaic. La posibilidad de trabajar con formulas matematicas que se habia propuesto en el HTML 3.0 paso a quedar integrada en un estandar distinto llamado MathML.  En 1997, HTML 4.0 se publico como una recomendacion del W3C. HTML 4.0 adopto muchos elementos especificos desarrollados inicialmente para un navegador web concreto, pero al mismo tiempo comenzo a limpiar el HTML se\u00f1alando algunos de ellos como \u00abdesaprobados\u00bb (deprecated, en ingles).  HTML 4.0 implementa caracteristicas como XForms 1.0 que no necesitan implementar motores de navegacion que eran incompatibles con algunas paginas web HTML. En 2004 la W3C reabrio el debate de la evolucion del HTML, y se dieron a conocer las bases para la version HTML5. No obstante, este trabajo fue rechazado por los miembros del W3C y se daria  preferencia al desarrollo del XML.  Apple, Mozilla y Opera anunciaron su interes en seguir trabajando en el proyecto bajo el nombre de WHATWG,\u200b que se basa en la compatibilidad con  tecnologias anteriores.  En 2006, el W3C se intereso en el desarrollo de HTML5, y en 2007 se unio al grupo de trabajo del WHATWG para unificar el proyecto.  El dise\u00f1o en HTML, aparte de cumplir con las especificaciones propias del lenguaje, debe respetar ciertos criterios de accesibilidad web, siguiendo unas pautas o las normativas y leyes vigentes en los paises donde se regule dicho concepto. Se encuentra disponible y desarrollado por el W3C a traves de las Pautas de Accesibilidad al Contenido Web 1.0 WCAG (actualizadas recientemente con la especificacion 2.0),\u200b aunque muchos paises tienen especificaciones propias, como es el caso de Espa\u00f1a con la Norma UNE 139803.\u200b  Muchos caracteres especiales, letras con tilde, dieresis o simbolos de escritura del lenguaje pueden representarse en un documento HTML tanto por si mismos, como por una referencia a una entidad. Entre las ventajas de usar una referencia a entidad, estan la de poder representar caracteres Unicode usando una codificacion de caracteres distinta, o para suplir la falta de algunos caracteres en el teclado usado. ","snippet":"HTML, siglas en ingles de HyperText Markup Language (\u2018lenguaje de marcado de hipertexto\u2019), hace referencia al lenguaje de marcado para la elaboracion de paginas web. Es un estandar que sirve de refere","enlaces_salientes":["HTML","HTML","HTML","World_Wide_Web_Consortium","Grupo_de_Trabajo_de_Ingenier%C3%ADa_de_Internet","Web_Hypertext_Application_Technology_Working_Group","Extensi%C3%B3n_de_archivo","Multipurpose_Internet_Mail_Extensions","Type_code","1993","Lenguaje_de_marcado","SGML","XHTML","Est%C3%A1ndar_internacional","Formato_abierto","Lenguaje_de_marcado","P%C3%A1gina_web","World_Wide_Web_Consortium","World_Wide_Web","Script","Tel%C3%A9fonos_inteligentes","Tableta_(computadora)","Firefox","Google_Chrome","Internet_Explorer","Tim_Berners-Lee","SGML","IETF","DTD","Mosaic","Par%C3%A9ntesis","Script","Navegador_web","Multipurpose_Internet_Mail_Extensions","XML","XHTML","SGML","L%C3%ADnea_de_c%C3%B3digo","Hojas_de_estilo_en_cascada","Lector_de_pantalla","Atributo_HTML","Coloreado_de_sintaxis","Navegador_web","De_facto","DOCTYPE","Script","Multipurpose_Internet_Mail_Extensions","JavaScript","Cabecera_(inform%C3%A1tica)","Usuario","Hojas_de_estilo_en_cascada","Hojas_de_estilo_en_cascada","HTML_(colores)","Hiperv%C3%ADnculo","Sitio_web","Editor_de_texto","Gedit","GNU/Linux","Bloc_de_notas","GNU_Emacs","Wordpad","TextPad","Vim","Notepad%2B%2B","Atom_(software)","Visual_Studio_Code","WYSIWYG","KompoZer","Microsoft_FrontPage","Adobe_Dreamweaver","Navegador_web","Notepad%2B%2B","Adobe_Dreamweaver","Sublime_text","Navegador_web","Internet_Explorer","Google_Chrome","Firefox","Hojas_de_estilo_en_cascada","Firebug","SGML","CERN","TCP/IP","1990","ViolaWWW","UNIX","HTML%2B","1993","Normalizaci%C3%B3n","HTML_2","1995","HTML_3.0","Netscape_Navigator","Mosaic","MathML","HTML_4.0","W3C","HTML_4.0","HTML_4.0","XForms","HTML5","Apple_Inc.","Fundaci%C3%B3n_Mozilla","Opera_Software","WHATWG","W3C","HTML5","Accesibilidad_web","Accesibilidad_web","Codificaci%C3%B3n_de_caracteres","Colores_HTML","Hojas_de_estilo_en_cascada","JavaScript","Wayback_Machine","W3C","Pdf","Pdf","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lenguaje_de_marcado","titulo":"Lenguaje de marcado","contenido":"Un lenguaje de marcado o lenguaje de marcas es una forma de codificar un documento que, junto con el texto, incorpora etiquetas o marcas que contienen informacion adicional acerca de la estructura del texto o su presentacion.  El lenguaje de marcas mas extendido es el HTML (HyperText Markup Language, lenguaje de marcado de hipertexto), fundamento del World Wide Web (entramado de comunicacion de alcance mundial).  Los lenguajes de marcado suelen confundirse con lenguajes de programacion. Sin embargo, no son lo mismo, ya que el lenguaje de marcado no tiene funciones aritmeticas o variables, como poseen los lenguajes de programacion. Historicamente, el marcado se usaba y se usa en la industria editorial y de la comunicacion, asi como entre autores, editores e impresores.  Un ejemplo de como funciona el lenguaje de marcado puede observarse en el dictado de viva voz de un documento a una persona que lo transcribe a maquina:  Se suele diferenciar entre tres clases de lenguajes de marcado, aunque en la practica pueden combinarse varias clases en un mismo documento. Por ejemplo, el HTML contiene etiquetas puramente procedimentales, como la B de bold (negrita), junto con otras puramente descriptivas (BLOCKQUOTE, el atributo HREF). El HTML tambien incluye el elemento PRE, que indica que el texto debe representarse tal y como esta escrito.  El marcado de presentacion es aquel que indica el formato del texto. Este tipo de marcado es util para maquetar la presentacion de un documento para su lectura, pero resulta insuficiente para el procesamiento automatico de la informacion. El marcado de presentacion resulta mas facil de elaborar, sobre todo para cantidades peque\u00f1as de informacion. Sin embargo resulta complicado de mantener o modificar, por lo que su uso se ha ido reduciendo en proyectos grandes en favor de otros tipos de marcado mas estructurados.  Se puede tratar de averiguar la estructura de un documento de esta clase buscando pistas en el texto. Por ejemplo, el titulo puede ir precedido de varios saltos de linea (o renglon), y estar ubicado centrado en la pagina web. Varios programas pueden deducir la estructura del texto basandose en esta clase de datos, aunque el resultado suele ser bastante imperfecto. Un ejemplo de marcado de presentacion, puede ser RTF.  El marcado de procedimientos esta enfocado hacia la presentacion del texto, sin embargo, tambien es visible para el usuario que edita el texto. El programa que representa el documento debe interpretar el codigo en el mismo orden en que aparece. Por ejemplo, para formatear un titulo, debe haber una serie de directivas inmediatamente antes del texto en cuestion, indicandole al software instrucciones tales como centrar, aumentar el tama\u00f1o de la fuente, o cambiar a negrita. Inmediatamente despues del titulo debera haber etiquetas inversas que reviertan estos efectos. En sistemas mas avanzados se utilizan macros o pilas que facilitan el trabajo.  Algunos ejemplos de marcado de procedimientos son nroff, troff, TeX. Este tipo de marcado se ha usado extensivamente en aplicaciones de edicion profesional, manipulados por tipografos calificados, ya que puede llegar a ser extremadamente complejo.  El marcado descriptivo o semantico utiliza etiquetas para describir los fragmentos de texto, pero sin especificar como deben ser representados, o en que orden. Los lenguajes expresamente dise\u00f1ados para generar marcado descriptivo son el SGML y el XML.  Las etiquetas pueden utilizarse para a\u00f1adir al contenido cualquier clase de metadatos. Por ejemplo, el estandar Atom, un lenguaje de sindicacion, proporciona un metodo para marcar la hora \u00abactualizada\u00bb, que es el dato facilitado por el editor de cuando ha sido modificada por ultima vez cierta informacion. El estandar no especifica como se debe representar, o siquiera si se debe representar. El software puede emplear este dato de multiples maneras, incluyendo algunas no previstas por los dise\u00f1adores del estandar.  Una de las virtudes del marcado descriptivo es su flexibilidad: los fragmentos de texto se etiquetan tal como son, y no tal como deben aparecer. Estos fragmentos pueden utilizarse para mas usos de los previstos inicialmente. Por ejemplo, los hiperenlaces fueron dise\u00f1ados en un principio para que un usuario que lee el texto los pulse. Sin embargo, los buscadores los emplean para localizar nuevas paginas con informacion relacionada, o para evaluar la popularidad de determinado sitio web.  El marcado descriptivo tambien simplifica la tarea de reformatear un texto, debido a que la informacion del formato esta separada del propio contenido. Por ejemplo, un fragmento indicado como cursiva (<i>texto</i>), puede emplearse para marcar enfasis o bien para se\u00f1alar palabras en otro idioma. Esta ambiguedad, presente en el marcado presentacional y en el procedimental, no puede soslayarse mas que con una tediosa revision a mano. Sin embargo, si ambos casos se hubieran diferenciado descriptivamente con etiquetas distintas, podrian representarse de manera diferente sin esfuerzo.  El marcado descriptivo esta evolucionando hacia el marcado generico. Los nuevos sistemas de marcado descriptivo estructuran los documentos en arbol, con la posibilidad de a\u00f1adir referencias cruzadas. Esto permite tratarlos como bases de datos, en las que el propio almacenamiento tiene en cuenta la estructura, no como en los grandes objetos binarios (blobs) como en el pasado. Estos sistemas no tienen un esquema estricto como las bases relacionales, por lo que a menudo se las considera bases semiestructuradas.  Esta es una relacion de los principales lenguajes de marcas ordenados por su campo de aplicacion. Notese que los lenguajes de ambito general pueden usarse para aplicaciones mas especificas (pero no al reves).  Los lenguajes de marcas se llaman asi por la practica tradicional de marcar los manuscritos con instrucciones de impresion en los margenes. En la epoca de la imprenta, esta tarea ha correspondido a los marcadores, que indicaban el tipo de letra, el estilo y el tama\u00f1o, asi como la correccion de errores, para que otras personas compusieran la tipografia. Esto condujo a la creacion de un grupo de marcas estandarizadas.\u200b Con la introduccion de las computadoras, se traslado un concepto similar al mundo de la informatica.  El concepto de lenguaje de marcas fue expuesto por primera vez por William W. Tunnicliffe en 1967.\u200b La mayor novedad consistia en la separacion entre la presentacion y la estructura del texto. Tunnicliffe, que preferia referirse a este concepto como codificacion generica (generic coding), dirigiria mas tarde el desarrollo de un estandar al que bautizaria como GenCode, destinado a la industria editorial. El editor Stanley Fish tambien expuso ideas similares a finales de los a\u00f1os 1960. Brian Reid, en su disertacion de 1980 en la Carnegie Mellon University, mostro su teoria y una implementacion practica de un lenguaje descriptivo todavia en uso.  Sin embargo, quien es considerado el padre de los lenguajes de marcas es Charles Goldfarb, investigador para la compa\u00f1ia IBM. Goldfarb participo en la creacion del lenguaje GML, y posteriormente dirigio el comite que elaboro el estandar SGML, la piedra angular de los lenguajes de marcas. En cualquier caso, y a pesar de las controversias sobre su origen, es comunmente aceptado que la idea surgio de forma independiente varias veces durante los 70, y que se generalizo en los a\u00f1os 1980.  El primer lenguaje que diferencio claramente la estructura de la presentacion fue ciertamente el Scribe, desarrollado por Brian Reid y descrito en 1980 en su tesis doctoral.\u200b Scribe era revolucionario por varios motivos, no solo porque separaba el estilo de las propias marcas del documento, tambien por el control gramatico del empleo de elementos descriptivos. Scribe influyo en el desarrollo de los lenguajes posteriores.  Otro de los principales estandares de publicacion es TeX, creado y mantenido por Donald Knuth en los a\u00f1os 70 y 80. TeX se centra en la estructura detallada del texto y la descripcion de las fuentes, fundamentalmente en el campo de las publicaciones matematicas especializadas. Esto obligo a Knuth a dedicar un tiempo considerable en el estudio de la tipografia. Sin embargo, TeX requiere amplios conocimientos para ser utilizado, por lo que solo ha cuajado en entornos academicos, en los que es el estandar de facto en varias disciplinas cientificas. El software mas extendido para el empleo de TeX es LaTeX.  Al margen de la industria editorial tambien surgieron algunas iniciativas, como los lenguajes troff y nroff, lenguajes utilizados para maquetacion en sistemas UNIX. Su funcionalidad era limitada porque obligaba a trabajar mediante ensayo y error, hasta que las marcas insertadas en el texto ofrecieran el resultado deseado. Estos lenguajes no llegaron a cuajar en entornos profesionales, siendo utilizados por usuarios ocasionales. La aparicion de procesadores de texto tipo WYSIWYG relego a estos sistemas al olvido.  La iniciativa que sentaria las bases de los actuales lenguajes, partiria de la empresa IBM, que buscaba nuevas soluciones para mantener grandes cantidades de documentos. El trabajo fue encomendado a Charles F. Goldfarb, que junto con Edward Mosher y Raymond Lorie, dise\u00f1o el Generalized Markup Language o GML (notese que tambien son las iniciales de sus creadores). Este lenguaje heredo del proyecto GenCode la idea de que la presentacion debe separarse del contenido. El marcado, por tanto, se centra en definir la estructura del texto y no su presentacion visual.  El lenguaje GML fue un gran exito y pronto se extendio a otros ambitos, siendo adoptado por el gobierno de Estados Unidos, con lo que surgio la necesidad de estandarizarlo. En los primeros a\u00f1os 1980 se constituyo un comite dirigido por Goldfarb. Sharon Adler, Anders Berglund y James D. Mason fueron tambien miembros de dicho comite. Se incorporaron ideas de diferentes fuentes, y participo gran cantidad de gente. Tras un largo proceso, en 1986 la Organizacion Internacional para la Estandarizacion publicaria el Standard Generalized Markup Language con rango de Estandar Internacional con el codigo ISO 8879.\u200b  El SGML especifica la sintaxis para la inclusion de marcas en los textos, asi como la sintaxis del documento que especifica que etiquetas estan permitidas y donde: el Document Type Definition o schema. Esto permitia que un autor emplease cualquier marca que quisiera, eligiendo nombres para las etiquetas que tuvieran sentido tanto por el tema del documento como por el idioma. Asi, el SGML es, estrictamente hablando, un metalenguaje, del que se derivan varios lenguajes especializados. Desde finales de los 80 han aparecido nuevos lenguajes basados en SGML, como por ejemplo el TEI o el DocBook.  El SGML tuvo una gran aceptacion y hoy dia se emplea en campos en los que se requiere documentacion a gran escala. A pesar de ello, resulto farragoso y dificil de aprender, como consecuencia de la ambicion de los objetivos previstos. Su gran potencia era a la vez una ventaja y una desventaja. Por ejemplo, ciertas etiquetas podian tener solo principio, o solo final, o incluso ser obviadas, pensando en que los textos serian redactados a mano y que asi se ahorrarian pulsaciones de teclas. Sin embargo fue un punto clave en el desarrollo de los lenguajes de marcas actuales, ya que la gran mayoria derivan de este.  En 1991, parecia que los editores WYSIWYG (que almacenan los documentos en formatos binarios propietarios) abarcarian casi la totalidad del procesamiento de textos, relegando al SGML a usos profesionales o industriales muy especificos. Sin embargo, la situacion cambio drasticamente cuando Sir Tim Berners-Lee, que habia aprendido SGML de su compa\u00f1ero en el CERN Anders Berglund, utilizo la sintaxis SGML para crear el HTML.  Este lenguaje era similar a cualquier otro creado a partir del SGML, sin embargo resulto extraordinariamente sencillo, tanto que el DTD no se desarrollo hasta mas tarde. DeRose\u200b argumenta que la flexibilidad y escalabilidad del marcado HTML fue uno de los principales factores, junto con el empleo de URLs y la distribucion libre de navegadores, del exito de la World Wide Web.  El HTML es hoy dia el tipo de documento mas empleado en el mundo. Su sencillez era tal que cualquier persona podia escribir documentos en este formato, sin apenas necesidad de conocimientos de informatica. Esta fue una de las razones de su exito, pero tambien condujo a un cierto caos. El crecimiento exponencial de la web en los a\u00f1os 90 produjo documentos en cantidades ingentes pero mal estructurados, problema agravado aun mas por la falta de respeto por los estandares, por parte de dise\u00f1adores web y fabricantes de software.  La respuesta a los problemas surgidos en torno al HTML vino de la mano del XML (eXtensible Markup Language). El XML es un metalenguaje que permite crear etiquetas adaptadas a las necesidades (de ahi lo de \u00abextensible\u00bb). El estandar define como pueden ser esas etiquetas y que se puede hacer con ellas. Es ademas especialmente estricto en cuanto a lo que esta permitido y lo que no, todo documento debe cumplir dos condiciones: ser valido y estar bien formado.  El XML fue desarrollado por el World Wide Web Consortium,\u200b mediante un comite creado y dirigido por Jon Bosak. El objetivo principal era simplificar\u200b el SGML para adaptarlo a un campo muy preciso: documentos en internet.  El nuevo lenguaje se extendio con rapidez, ya que todo documento XML es a su vez SGML. Los programas y documentos creados para y con SGML podian convertirse casi automaticamente al nuevo lenguaje. El XML simplifico radicalmente la complejidad del SGML, facilitando el aprendizaje y la implementacion del nuevo estandar. Se solucionaron ademas viejos problemas, como los surgidos de la internacionalizacion, y la imposibilidad de validar un documento sin schema. El acierto fundamental de este lenguaje es que logra un equilibrio entre simplicidad y flexibilidad.  El XML fue ideado en principio para entornos semiestructurados, como textos y publicaciones. Uno de los ejemplos mas claros es el XHTML, la redefinicion del HTML en clave XML, con las ventajas que ello supone. Sin embargo pronto se observo que sus virtudes podian ser utiles en campos bien distintos. Los lenguajes basados en XML tienen aplicaciones incontables, como en la transaccion de datos entre servidores, intercambio de informacion financiera, formulas y reacciones quimicas, y un largo etcetera.  Las nuevas tendencias han abandonado los documentos con estructura en arbol. Los textos de la literatura antigua suelen tener estructura de prosa o de poesia: versiculos, parrafos, etc. Los documentos de referencia suelen organizarse en libros, capitulos, versos y lineas. A menudo se entremezclan unos con otros, por lo que la estructura en arbol no se ajusta a sus necesidades. Los nuevos sistemas de modelado superan estos inconvenientes, como el MECS, dise\u00f1ado para la obra de Wittgenstein, o las TEI Guidelines, LMNL, y CLIX.  La Iniciativa de codificacion de textos o Text Encoding Initiative (TEI) ha publicado multitud de  guias\u200b para la codificacion de documentos de interes en humanidades y ciencias sociales, desarrollados durante a\u00f1os de trabajo colaborativo internacional. Estas directrices se han empleado en innumerables proyectos de catalogacion de documentos historicos, trabajos academicos, etc.  Los lenguajes de marcado son la herramienta fundamental en el dise\u00f1o de la web semantica, aquella que no solo permite acceder a la informacion, sino que ademas define su significado, de forma que sea mas facil su procesamiento automatico y se pueda reutilizar para distintas aplicaciones.\u200b Esto se consigue a\u00f1adiendo datos adicionales a los documentos, por medio de dos lenguajes expresamente creados: el RDF (Resource description framework-Plataforma de descripcion de recursos) y OWL (Web Ontology Language-Lenguaje de ontologias para la web), ambos basados en XML.  Una de las principales ventajas de este tipo de codificacion es que la gran mayoria puede ser interpretada directamente dado que son archivos de texto plano, quedando excluidos algunos lenguajes de presentacion que guardan la informacion en archivos binarios como '.doc' de MS Word donde solo una peque\u00f1a parte de la informacion es legible. Esto es una ventaja evidente respecto a los sistemas de archivos binarios, que requieren siempre de un programa intermediario para trabajar con ellos. Un documento escrito con lenguajes de marcado puede ser editado por un usuario con un sencillo editor de textos, sin perjuicio de que se puedan utilizar programas mas sofisticados que faciliten el trabajo.  Al tratarse solamente de texto, los documentos son independientes de la plataforma, sistema operativo o programa con el que fueron creados. Esta fue una de las premisas de los creadores de GML en los a\u00f1os 70, para no a\u00f1adir restricciones innecesarias al intercambio de informacion. Es una de las razones fundamentales de la gran aceptacion que han tenido en el pasado y del excelente futuro que se les augura.  \u200b Las instrucciones de marcado se entremezclan con el propio contenido en un unico archivo o flujo de datos. Este es un ejemplo en diferentes lenguajes de marcas:  <ul> <li>Punto 1</li> <li>Punto 2</li> <li>Punto 3</li> </ul>  \\begin{itemize} \\item Punto 1 \\item Punto 2 \\item Punto 3 \\end{itemize}  * Punto 1 * Punto 2 * Punto 3  El codigo entre parentesis angulares como <ul>, o con codigos \\section, son instrucciones de marcado, tambien llamados etiquetas. Estas etiquetas en concreto son descriptivas de la estructura del documento, pudiendo ser su presentacion visual de varias maneras. La etiqueta i (de italics, cursiva), por el contrario, especifica que el texto se debe mostrar en cursiva, sin especificar el motivo de esta diferenciacion: es una etiqueta presentacional. El texto entre estas instrucciones es el propio contenido del documento.  Las organizaciones de estandares han venido desarrollando lenguajes especializados para los tipos de documentos de comunidades o industrias concretas. Uno de los primeros fue el CALS, utilizado por las fuerzas armadas de EE.\u00a0UU. para sus manuales tecnicos. Otras industrias con necesidad de gran cantidad de documentacion, como las de aeronautica, telecomunicaciones, automocion o hardware, ha elaborado lenguajes adaptados a sus necesidades. Esto ha conducido a que sus manuales se editen unicamente en version electronica, y despues se obtenga a partir de esta las versiones impresas, en linea o en CD. Un ejemplo notable fue el caso de Sun Microsystems, empresa que opto por escribir la documentacion de sus productos en SGML, ahorrando costes considerables. El responsable de aquella decision fue Jon Bosak, que mas tarde fundaria el comite del XML.  Aunque originalmente los lenguajes de marcas se idearon para documentos de texto, se han empezado a utilizar en areas como graficos vectoriales, servicios web, sindicacion web o interfaces de usuario. Estas nuevas aplicaciones aprovechan la sencillez y potencia del lenguaje XML. Esto ha permitido que se pueda combinar varios lenguajes de marcas diferentes en un unico archivo, como en el caso de XHTML+SMIL y de XHTML+MathML+SVG.\u200b ","snippet":"Un lenguaje de marcado o lenguaje de marcas es una forma de codificar un documento que, junto con el texto, incorpora etiquetas o marcas que contienen informacion adicional acerca de la estructura del","enlaces_salientes":["Lenguaje_de_marcado","Lenguaje_de_marcado","Lenguaje_de_marcado","Standard_Generalized_Markup_Language","Oxford_English_Dictionary","HTML","Etiqueta_(lenguaje_de_marcado)","HTML","World_Wide_Web","Lenguaje_de_programaci%C3%B3n","Editorial_(empresa)","Autor","Editorial_(empresa)","Impresor","M%C3%A1quina_de_escribir","HTML","Formato_de_archivo","Texto","Maquetaci%C3%B3n","Salto_de_l%C3%ADnea","P%C3%A1gina_web","RTF","Negrita","Macro","Pila_(estructura_de_datos)","Nroff","Troff","TeX","Tip%C3%B3grafo","SGML","XML","Metadato","Atom_(formato_de_redifusi%C3%B3n)","Sindicaci%C3%B3n_Web","Hora","Hiperenlace","Buscador","P%C3%A1gina_web","Sitio_web","Idioma","%C3%81rbol","Bases_de_datos","BLOB","Base_de_datos_relacional","Generalized_Markup_Language","SGML","XML","Lenguaje_de_marcas_ligero","ASN.1","EBML","YAML","HTML","RTF","TeX","Troff","BBCode","Markdown","ReStructuredText","Textile","DocBook","LinuxDoc","HTML","XHTML","WML","Resource_Description_Framework","GladeXML","MXML","Macromedia","XAML","XForms","XUL","XBL","Atom_(formato_de_redifusi%C3%B3n)","RSS","OPML","WSDL","WSFL","XML-RPC","Webml","Scalable_Vector_Graphics","Vector_Markup_Language","VRML","X3D","ISO_10303","Matem%C3%A1tica","MathML","OpenMath","M%C3%BAsica","GNU_LilyPond","MusicXML","Taxonom%C3%ADa","DITA","Contabilidad_financiera","XBRL","Geom%C3%A1tica","Geography_Markup_Language","Aeron%C3%A1utica","Multimedia","SMIL","Mensajer%C3%ADa_instant%C3%A1nea","Extensible_Messaging_and_Presence_Protocol","Manuscrito","Imprenta","Tipo_de_letra","Tipograf%C3%ADa","Computadora_electr%C3%B3nica","Inform%C3%A1tica","1967","Stanley_Fish","A%C3%B1os_1960","1980","Carnegie_Mellon_University","Implementaci%C3%B3n","Charles_Goldfarb","IBM","Generalized_Markup_Language","SGML","A%C3%B1os_1970","A%C3%B1os_1980","1980","Tesis_doctoral","Gram%C3%A1tico","TeX","Donald_Knuth","A%C3%B1os_1970","A%C3%B1os_1980","Tipo_de_letra","Tipograf%C3%ADa","De_facto","LaTeX","Troff","Nroff","UNIX","Ensayo_y_error","Procesadores_de_texto","WYSIWYG","Generalized_Markup_Language","SGML","Estados_Unidos","Normalizaci%C3%B3n","A%C3%B1os_1980","1986","Organizaci%C3%B3n_Internacional_para_la_Estandarizaci%C3%B3n","DTD","Schema","Idioma","Metalenguaje","A%C3%B1os_1980","Text_Encoding_Initiative","DocBook","Tecla","HTML","1991","Software_propietario","Procesador_de_textos","Tim_Berners-Lee","CERN","Sintaxis","DTD","URL","Navegador_de_internet","World_Wide_Web","Caos","A%C3%B1os_1990","XML","World_Wide_Web_Consortium","Schema","XHTML","Servidor","Finanzas","F%C3%B3rmula_qu%C3%ADmica","Reacci%C3%B3n_qu%C3%ADmica","Qu%C3%ADmica","Literatura","Prosa","Poes%C3%ADa","Vers%C3%ADculo","P%C3%A1rrafo","Libro","Cap%C3%ADtulo_(libro)","Verso","Sistemas","Wittgenstein","Text_Encoding_Initiative","Humanidades","Ciencias_sociales","Web_sem%C3%A1ntica","Informaci%C3%B3n","Resource_Description_Framework","OWL","Ontolog%C3%ADa","Texto_plano","Archivo_binario",".doc","MS_Word","Editor_de_texto","Sistema_operativo","Programa_inform%C3%A1tico","A%C3%B1os_1970","Fuerzas_Armadas_de_los_Estados_Unidos","Aeron%C3%A1utica","Telecomunicaciones","Automoci%C3%B3n","Hardware","En_l%C3%ADnea","Disco_compacto","Sun_Microsystems","SGML","Coste","Gr%C3%A1fico_vectorial","Servicio_Web","Sindicaci%C3%B3n_web","Interfaz_de_usuario","Ottawa","Pittsburgh","1997","Boston","ISBN","1995","Detroit","Estados_Unidos","2006","1987","Madrid","Universidad_Complutense_de_Madrid","ISSN","2006","2002","2006","Biblioteca_digital","GFDL","1996","2006","Oxford_University_Press","ISBN","Tim_Berners-Lee","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"P%C3%A1gina_web","titulo":"Pagina web","contenido":"Una pagina web, pagina electronica, pagina digital o ciberpagina\u200b\u200b es un documento digital complejo, que puede integrar y/o contener texto, sonido, video, programas, enlaces, imagenes, hipervinculos y otros elementos, adaptado para la World Wide Web (WWW), y que puede ser accedida y visualizada mediante un navegador web. Esta informacion se encuentra generalmente en etiquetado HTML o XHTML, y puede proporcionar acceso a otras paginas web mediante enlaces de hipertexto. Frecuentemente tambien incluyen otros recursos como pueden ser hojas de estilo en cascada, scripts, imagenes digitales, etc.  Las paginas web pueden estar almacenadas en un computador o en un servidor web remoto. El servidor web puede restringir el acceso unicamente a redes privadas, por ejemplo, en una intranet corporativa, o puede publicar las paginas en la World Wide Web.Es decir que se utiliza para acceder a pagina de distintas redes  sociales para poder acceder a ella necesitas una cuenta  Una pagina web esta compuesta principalmente por informacion de un tema factible (solo texto o modulos multimedia) asi como por hiperenlaces; ademas puede contener o asociar hoja de estilo, datos de estilo para especificar como debe visualizarse, y tambien aplicaciones embebidas para asi permitir interaccion.  Las paginas web son escritas en un lenguaje de marcado que provee la capacidad de manejar e insertar hiperenlaces, generalmente HTML.  Respecto a la estructura de las paginas web, algunos organismos, en especial el World Wide Web Consortium (W3C), suelen establecer directivas con la intencion de normalizar el dise\u00f1o, y para asi facilitar y simplificar la visualizacion e interpretacion del contenido.  Una pagina web es en esencia una tarjeta de presentacion digital, ya sea para empresas, organizaciones, o personas, asi como una manera de comunicar ideas, pensamientos, conocimientos, informaciones o teorias.\u200b Asi mismo, la nueva tendencia orienta a que las paginas web no sean solo atractivas para los internautas, sino tambien optimizadas (preparadas), para los buscadores a traves del codigo fuente. Forzar esta doble funcion puede, sin embargo, crear conflictos respecto de la calidad del contenido.  Es frecuente ver a personas referirse con \"pagina web\" a un sitio web completo. Siendo rigurosos, esto es incorrecto ya que \"pagina web\" se refiere a una pagina concreta, con una URL especifica y no a un sitio completo compuesto por multiples paginas web con diferentes URL.  El contenido de una pagina web puede ser predeterminado (pagina web estatica) o generado al momento de visualizarla, o solicitarla a un servidor web (pagina web dinamica).  En el caso de las paginas estaticas, al acceder el usuario, el servidor descarga simplemente un simple fichero con un contenido codificado en HTML que se visualiza a continuacion en su navegador. Un proceso muy similar a la descarga de cualquier fichero, por ejemplo un documento PDF.  El principal problema de estas paginas es que no permiten la interaccion con el usuario, equivalente a una coleccion de documentos invariables, como un libro, en la web.  Las paginas dinamicas que se generan al momento de la visualizacion. No son un simple documento HTML, sino que estan creadas en algun lenguaje interpretado. El ejemplo mas popular es PHP, el lenguaje en el que estan programadas aplicaciones muy populares como WordPress o MediaWiki, el software en el que esta implementado la propia Wikipedia.  Aqui la web interactua con el usuario y es necesario que componga las paginas de manera dinamica. Por ejemplo: cuando un usuario busca determinados productos, la aplicacion realiza una consulta a su base de datos, obtiene los resultados y compone con ellos \"sobre la marcha\" el HTML que corresponde a la lista de los productos. Una vez compuesto dinamicamente el HTML de la pagina entera, se devuelve al navegador exactamente igual que si hubiese sido una pagina HTML estatica.  Por otra parte, existe la posibilidad de introducir dinamismo en el lado cliente a traves del lenguaje JavaScript, dise\u00f1ado especificamente para navegadores web. Habitualmente los controles de interfaz de usuario como arboles o tablas con funciones de paginacion estan creados en JavaScript.  Un navegador web puede tener una interfaz grafica de usuario, como Internet Explorer / Microsoft Edge, Mozilla Firefox, Google Chrome, Safari y Opera, o puede estar basado en texto, como Lynx.  Los usuarios web con discapacidades a menudo usan tecnologias de asistencia y estrategias adaptativas para acceder a las paginas web. Los usuarios pueden ser daltonicos, pueden o no querer usar un mouse tal vez debido a lesiones por estres repetitivo o problemas de neuronas motoras, pueden ser sordos y requerir subtitulos de audio, pueden estar ciegos y usar un lector de pantalla o pantalla braille, pueden necesitar aumento de pantalla, etc.  Los usuarios discapacitados y sin discapacidad pueden desactivar la descarga y visualizacion de imagenes y otros medios, para ahorrar tiempo, ancho de banda de la red o simplemente para simplificar su experiencia de navegacion. Los usuarios de dispositivos moviles a menudo tienen pantallas y ancho de banda restringidos. Cualquiera puede preferir no usar las fuentes, tama\u00f1os de fuente, estilos y esquemas de color seleccionados por el dise\u00f1ador de la pagina web y puede aplicar su propio estilo CSS a la pagina. El World Wide Web Consortium (W3C) y la Iniciativa de Accesibilidad Web (WAI) recomiendan que las paginas web se dise\u00f1en teniendo en cuenta todas estas opciones.  La manera mas simple de crear paginas web consiste en utilizar un simple editor de texto como, por ejemplo, Notepad++ y editar directamente el codigo HTML mas las hojas de estilo. Es la manera en la que en los inicios de Internet se creaban la mayoria de las paginas web.  Este enfoque \"artesanal\" es poco productivo por la gran cantidad de codificacion de HTML que implica y, ademas, sirve solo para webs completamente estaticas. No permite implementar cosas como, por ejemplo, una seccion de comentarios de los lectores como las que son habituales en blogs o en periodicos digitales.  Por ese motivo surgieron los sistemas CMS como, por ejemplo, Wordpress y Joomla que evitan al usuario la codificacion en HTML y ofrecen herramientas como editores visuales que convierten la tarea de la creacion de paginas web a algo parecido a la edicion de un documento en una aplicacion de ofimatica como OpenOffice o Microsoft Word.  Estas herramientas son aplicaciones web creadas con lenguajes de programacion como PHP y que usan bases de datos como MySQL que no solamente permiten una edicion mas comoda de los contenidos, sino tambien implementar webs dinamicas.  Entre estos sistemas destacan las herramientas para la creacion de blogs por ser las mas populares, lideradas por el CMS Blogger WordPress.  WordPress en particular, ademas de ser la herramienta lider para la creacion de blogs, se esta convirtiendo en la herramienta mas utilizada para la creacion de webs peque\u00f1as y medianas.\u200b   ","snippet":"Una pagina web, pagina electronica, pagina digital o ciberpagina\u200b\u200b es un documento digital complejo, que puede integrar y/o contener texto, sonido, video, programas, enlaces, imagenes, hipervinculos y","enlaces_salientes":["P%C3%A1gina_web","P%C3%A1gina_web","P%C3%A1gina_web","Documento","Sonido","V%C3%ADdeo","World_Wide_Web","Navegador_web","HTML","XHTML","Hiperv%C3%ADnculo","Hipertexto","CSS","Script","Imagen_digital","Servidor_web","Intranet","Universidad_de_Alcal%C3%A1","World_Wide_Web_Consortium","Dise%C3%B1o","Sitio_web","URL","HTML","PDF","Lenguaje_de_programaci%C3%B3n_interpretado","PHP","WordPress","MediaWiki","Base_de_datos_relacional","JavaScript","Internet_Explorer","Microsoft_Edge","Mozilla_Firefox","Google_Chrome","Safari_(navegador)","Opera_(navegador)","Lynx_(navegador)","Notepad%2B%2B","Sistema_de_gesti%C3%B3n_de_contenidos","WordPress","Joomla","Apache_OpenOffice","Microsoft_Word","PHP","MySQL","Blogger","WordPress","Sitio_web","World_Wide_Web","Internet","World_Wide_Web_Consortium","Sitios_web_m%C3%A1s_visitados","Internet_Superficial","Internet_profunda","Fund%C3%A9u","Control_de_autoridades","Gemeinsame_Normdatei","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Historia_de_los_lenguajes_de_programaci%C3%B3n","titulo":"Historia de los lenguajes de programacion","contenido":"Este articulo trata sobre la historia de los lenguajes de programacion.\u200b  Los primeros lenguajes de programacion preceden a la computadora moderna. En un inicio los lenguajes eran codigos.  La maquina del telar de Jacquard, creada en 1801, utilizaba los orificios en tarjetas perforadas para representar los movimientos de un brazo de la maquina de tejer, con el objetivo de generar patrones decorativos automaticamente.  Durante un periodo de nueve meses entre 1842 y 1843, Ada Lovelace tradujo las memorias del matematico italiano Luigi Menabrea acerca de la nueva maquina propuesta por Charles Babbage, la Maquina Analitica. Con estos escritos, ella a\u00f1adio unas notas en las cuales especificaba en detalle un metodo para calcular los numeros de Bernoulli con esta maquina.  Herman Hollerith se percato de que podia codificar la informacion en tarjetas perforadas cuando observo a los conductores de trenes que identificaban a los pasajeros segun el orificio que hacian en su respectivo ticket. En 1890 Jorge jimenez tovar codifico los datos del censo en tarjetas perforadas.  Los primeros codigos de computadora estaban especializados segun sus aplicaciones. En las primeras decadas del siglo\u00a0XX, los calculos numericos estaban basados en los numeros decimales. Con el paso del tiempo, se dieron cuenta de que la logica podia ser representada con numeros, no solo con palabras. Por ejemplo, Alonzo Church fue capaz de expresar el calculo lambda a traves de formulas. La maquina de Turing establecio las bases para almacenar programas como datos en la arquitectura de von Neuman de una computadora. Sin embargo, a diferencia del calculo lambda, el codigo de Turing no serviria satisfactoriamente como base para lenguajes de mas alto nivel- su principal uso es en el analisis riguroso en la complejidad algoritmica.  Como muchos \u201cprimeros\u201d en la historia, el primer lenguaje de programacion moderno es dificil de identificar. Desde un inicio, las restricciones de hardware definian el lenguaje. Las tarjetas perforadas permitian 80 columnas, pero algunas de estas serian utilizadas para una clasificacion de cada tarjeta. FORTRAN incluia algunas palabras reservadas provenientes del Ingles, como \u201cIF\u201d, \u201cGOTO\u201d (go to) y \u201cCONTINUE\u201d. El uso del tambor magnetico para la memoria implicaba que los programas informaticos tuvieran que estar intercalados con las rotaciones del tambor. Por lo tanto los programas eran muy dependientes del hardware.  Para algunas personas, lo que seria el primer lenguaje de programacion moderno depende de cuanto poder y legibilidad humana se requeria antes de que se concediera el estado de \"lenguaje de programacion\". Tanto el telar de Jacquard como la Maquina Diferencial de Babbage, tenian lenguajes muy simples y extremadamente limitados para describir las acciones que estas maquinas realizaran. Se puede incluso considerar los agujeros perforados en los rollos de pianola como un limitado lenguaje de dominio especifico, a pesar de no estar dise\u00f1ado para el consumo humano.    En la decada de 1940 fueron creadas las primeras computadoras modernas, con alimentacion electrica. La velocidad y capacidad de memoria limitadas forzaron a los programadores a escribir programas, en lenguaje ensamblador muy afinados. Finalmente se dieron cuenta de que la programacion en lenguaje ensamblador requeria de un gran esfuerzo intelectual y era muy propensa a errores.  En 1948, Konrad Zuse publico un articulo acerca de su lenguaje de programacion Plankalkul. Sin embargo, no fue implementado en su vida y sus contribuciones fueron aisladas de otros desarrollos.  Entre algunos lenguajes importantes que fueron desarrollados en este periodo se encuentran:  En los cincuenta, los tres primeros lenguajes de programacion modernos, cuyos descendientes aun continuan siendo utilizados, son:  Otro hito a finales de 1950 fue la publicacion, por un comite Americano y Europeo de cientificos de la computacion, de un nuevo \u201clenguaje para algoritmos\u201d; el Reporte de ALGOL 60 (\"ALGOrithmic Language\"). Este reporte consolido muchas ideas que estaban circulando en aquel entonces, y proporciono dos innovaciones importantes para los lenguajes de programacion:  Otra innovacion, relacionada con esto, fue como el lenguaje fue descrito:  Algol 60 influencio particularmente en el dise\u00f1o de lenguajes posteriores, de los cuales algunos se hicieron mas populares. Los grandes sistemas de Burroughs fueron dise\u00f1ados para ser programados en un subconjunto extendido de Algol.  Las ideas fundamentales de Algol se continuaron, produciendo Algol 68:  Las variadas pero poco usadas caracteristicas de Algol 68 (por ejemplo, bloques simultaneos y paralelos) y su complejo sistema de atajos sintacticos y coerciones automaticas de tipo lo hicieron impopular entre los ejecutores y se gano una reputacion de ser dificil. Niklaus Wirth salio del comite de dise\u00f1o para crear el sencillo lenguaje Pascal.  Algunos de los lenguajes importantes que fueron desarrollados en este periodo incluyen:  El periodo comprendido entre finales de 1960 y finales de 1970 trajo un gran florecimiento de lenguajes de programacion. La mayoria de los paradigmas de lenguajes de programacion mas importantes y actualmente en uso se inventaron en este periodo:  Cada uno de estos lenguajes genero toda una familia de descendientes, y los lenguajes mas modernos cuentan al menos uno de ellos en su ascendencia.  En los a\u00f1os 60 y 70 tambien suscito un debate considerable sobre los meritos de la \"programacion estructurada\", que esencialmente significaba programacion sin el uso de GOTO. Este debate estaba estrechamente relacionado con el dise\u00f1o del lenguaje: algunos lenguajes no incluian GOTO, lo que obligo a la programacion estructurada en el programador. Aunque el debate se recrudecia acaloradamente en ese momento, casi todos los programadores estan de acuerdo en que, incluso en lenguajes que ofrecen GOTO, es una mala practica de programacion usarlo, excepto en raras circunstancias. Como resultado de ello, las generaciones posteriores de dise\u00f1adores de lenguajes han encontrado el debate sobre programacion estructurada tedioso e incluso desconcertante.  Algunos lenguajes importantes que se desarrollaron en este periodo fueron:  La decada de 1980 fueron a\u00f1os de consolidacion relativa en los lenguajes imperativos. En vez de inventar nuevos paradigmas, se comenzo a trabajar a partir de las ideas inventadas en la decada anterior. C++ combinaba la programacion orientada a objetos y la programacion de sistemas. El gobierno de Estados Unidos estandarizo Ada, un lenguaje de programacion de sistemas destinado a ser utilizado por contratistas de defensa. En Japon y en otras partes, se gastaron enormes sumas investigando los llamados lenguajes de programacion de quinta generacion que incorporaban construcciones de la programacion logica. La comunidad de los lenguajes funcionales llevaron a cabo la estandarizacion de ML y Lisp. La investigacion en Miranda, un lenguaje funcional, con evaluacion perezosa, comenzo a tomar fuerza en esta decada.  Una nueva tendencia importante en el dise\u00f1o de lenguajes era un mayor enfoque en la programacion de sistemas a gran escala a traves del uso de modulos, una organizacion a gran escala de unidades de codigo. Modula, Ada, y ML desarrollaron sistemas de modulos notables en la decada de 1980. Los sistemas de modulos eran relacionados con frecuencia con construcciones de programacion genericas, que serian, en esencia, modulos parametrizados (vease tambien polimorfismo en programacion orientada a objetos).  Aunque no aparecian nuevos paradigmas de lenguajes de programacion imperativos, muchos investigadores expandieron las ideas de los lenguajes anteriores y las adaptaron a nuevos contextos. Por ejemplo, los lenguajes de los sistemas Argus y Emerald adaptaron la programacion orientada a objetos para sistemas distribuidos.  La decada de 1980 tambien trajo avances en la implementacion de lenguajes de programacion. El movimiento de RISC en la arquitectura de computadoras postulaba que el hardware debia estar dise\u00f1ado para los compiladores mas que para los programadores de ensamblador humanos. Con la ayuda de las mejoras en la velocidad del procesador, permitiendo tecnicas de compilacion cada vez mas agresivas, el movimiento RISC desperto un mayor interes en la tecnologia de compilacion de los lenguajes de alto nivel.  Las tecnologias de los lenguajes continuaron sobre estas lineas entrando en la decada de 1990.  Algunos lenguajes importantes que se desarrollaron en este periodo son:  El rapido crecimiento de Internet en la decada de 1990 fue el siguiente gran acontecimiento historico para los lenguajes de programacion. Con la apertura de una plataforma totalmente nueva para los sistemas informaticos, Internet creo una oportunidad adoptar nuevos lenguajes. En particular, el lenguaje de programacion JavaScript se hizo popular debido a su pronta integracion con el navegador web Netscape Navigator, y varios lenguajes de scripting alcanzaron un amplio uso en el desarrollo de aplicaciones personalizadas para servidores web. La decada de 1990 no vio ninguna novedad fundamental en los lenguajes imperativos, pero si mucha recombinacion y la maduracion de viejas ideas. Esta era comenzo la difusion de los lenguajes funcionales. Una filosofia de conduccion grande era la productividad del programador. Surgieron muchos lenguajes de \u201caplicaciones de desarrollo rapido\u201d (RAD), los cuales usualmente venian con un IDE, recolector de basura, y eran descendientes de lenguajes anteriores. Todos estos lenguajes eran orientados a objeto. Estos incluian Object Pascal, Visual Basic y Java. Java, en particular, recibio mucha atencion. Pero mas radicales e innovadores que los lenguajes de RAD eran los nuevos lenguajes de script. Estos no descendian directamente de otros lenguajes y ofrecieron nuevas sintaxis e incorporacion mas liberal de otras caracteristicas. Muchos consideran estos lenguajes de script mas productivos que los lenguajes de RAD, aunque esto se debe a menudo a que es mas dificil escribir y mantener largos programas que peque\u00f1os programas simples. Sin embargo, no es menos cierto que los programas de script llegaron para convertirse en los mas prominentes en la conexion con la Web.  Algunos lenguajes importantes que se desarrollaron en este periodo son:  La evolucion de los lenguajes de programacion continua, tanto en la industria como en investigacion. Algunas de las tendencias actuales incluyen:  Algunos lenguajes importantes desarrollados durante este periodo incluyen: ","snippet":"Este articulo trata sobre la historia de los lenguajes de programacion.\u200b  Los primeros lenguajes de programacion preceden a la computadora moderna. En un inicio los lenguajes eran codigos.  La maquina","enlaces_salientes":["Historia_de_los_lenguajes_de_programaci%C3%B3n","Historia_de_los_lenguajes_de_programaci%C3%B3n","Historia_de_los_lenguajes_de_programaci%C3%B3n","Lenguajes_de_programaci%C3%B3n","C%C3%B3digo_(comunicaci%C3%B3n)","Telar_de_Jacquard","Ada_Lovelace","Luigi_Federico_Menabrea","Charles_Babbage","M%C3%A1quina_anal%C3%ADtica","N%C3%BAmeros_de_Bernoulli","Herman_Hollerith","Alonzo_Church","C%C3%A1lculo_lambda","M%C3%A1quina_de_Turing","Arquitectura_de_von_Neumann","Complejidad_algor%C3%ADtmica","Tambor_magn%C3%A9tico","M%C3%A1quina_Diferencial","Pianola","Lenguaje_espec%C3%ADfico_del_dominio","Konrad_Zuse","Plankalk%C3%BCl","ALGOL_60","Bloque_de_c%C3%B3digo","Bloque_de_c%C3%B3digo","Backus-Naur_Form","Gram%C3%A1tica_libre_de_contexto","Grandes_sistemas_de_Burroughs","Niklaus_Wirth","Pascal_(lenguaje_de_programaci%C3%B3n)","Lenguaje_ensamblador","Autocoder","IPL","FLOW-MATIC","FORTRAN","LISP","COBOL","RPG_(lenguaje_de_programaci%C3%B3n)","APL","Simula","SNOBOL","Combined_Programming_Language","BASIC","PL/I","BCPL","Kristen_Nygaard","Ole-Johan_Dahl","Programaci%C3%B3n_orientada_a_objetos","C_(lenguaje_de_programaci%C3%B3n)","Dennis_Ritchie","Ken_Thompson","Laboratorios_Bell","Smalltalk","Prolog","Alain_Colmerauer","Programaci%C3%B3n_l%C3%B3gica","ML_(lenguaje_de_programaci%C3%B3n)","Robin_Milner","Lenguajes_funcionales","Tipado_est%C3%A1tico","Programaci%C3%B3n_estructurada","GOTO","Logo_(lenguaje_de_programaci%C3%B3n)","B_(lenguaje_de_programaci%C3%B3n)","Pascal_(lenguaje_de_programaci%C3%B3n)","Forth","C_(lenguaje_de_programaci%C3%B3n)","Smalltalk","Prolog","ML_(lenguaje_de_programaci%C3%B3n)","Scheme","SQL","Modula-2","Lenguajes_imperativos","C%2B%2B","Ada_(lenguaje_de_programaci%C3%B3n)","Miranda_(lenguaje_de_programaci%C3%B3n)","Evaluaci%C3%B3n_perezosa","Polimorfismo_(inform%C3%A1tica)","Argus_(lenguaje_de_programaci%C3%B3n)","Emerald","Computaci%C3%B3n_distribuida","RISC","Arquitectura_de_computadoras","Compiladores","C%2B%2B","Ada_(lenguaje_de_programaci%C3%B3n)","Common_Lisp","MATLAB","Eiffel_(lenguaje_de_programaci%C3%B3n)","Objective-C","Lenguaje_de_programaci%C3%B3n_Erlang","Perl","Tcl","Mathematica","Lenguajes_funcionales","RAD","Entorno_de_desarrollo_integrado","Recolector_de_basura","Object_Pascal","Visual_Basic","Java_(lenguaje_de_programaci%C3%B3n)","Script","Haskell","Python","Visual_Basic","HTML","Ruby","Lua","CLOS","Java_(lenguaje_de_programaci%C3%B3n)","Embarcadero_Delphi","JavaScript","PHP","D_(lenguaje_de_programaci%C3%B3n)","Programaci%C3%B3n_funcional","Concurrente","Computaci%C3%B3n_distribuida","Seguridad_en_hilos","Mixin","Delegaci%C3%B3n_(inform%C3%A1tica)","Programaci%C3%B3n_orientada_a_aspectos","Metaprogramaci%C3%B3n","Reflexi%C3%B3n_(inform%C3%A1tica)","%C3%81rbol_de_sintaxis_abstracta","Bases_de_datos","XML","Bases_de_datos_relacionales","Unicode","C%C3%B3digo_fuente","ASCII","XUL","XAML","C%C3%B3digo_abierto","Python","Ruby","Squeak","GPU","OpenCL","ActionScript","C_Sharp","Visual_Basic_.NET","F_Sharp","Groovy_(lenguaje_de_programaci%C3%B3n)","Scala_(lenguaje_de_programaci%C3%B3n)","Scratch_(lenguaje_de_programaci%C3%B3n)","Clojure","Go_(lenguaje_de_programaci%C3%B3n)","Dart","Swift_(lenguaje_de_programaci%C3%B3n)","Erlang","Erlang","John_Backus","Fortran","Alan_Cooper","Visual_Basic","Edsger_W._Dijkstra","James_Gosling","Java_(lenguaje_de_programaci%C3%B3n)","Anders_Hejlsberg","Turbo_Pascal","Embarcadero_Delphi","C_Sharp","Grace_Hopper","Flow-Matic","COBOL","Kenneth_E._Iverson","APL","J_(lenguaje_de_programaci%C3%B3n)","Bill_Joy","Vi","BSD","SunOS","Solaris_(sistema_operativo)","Alan_Kay","Smalltalk","Brian_Kernighan","C_(lenguaje_de_programaci%C3%B3n)","Dennis_Ritchie","AWK","Yukihiro_Matsumoto","Ruby","Mitchel_Resnick","Scratch","John_McCarthy_(cient%C3%ADfico)","LISP","Bertrand_Meyer","Eiffel_(lenguaje_de_programaci%C3%B3n)","Robin_Milner","ML_(lenguaje_de_programaci%C3%B3n)","Inferencia_de_tipos","John_von_Neumann","Sistema_operativo","Scala_(lenguaje_de_programaci%C3%B3n)","Java_(lenguaje_de_programaci%C3%B3n)","Seymour_Papert","Inteligencia_artificial","Logo_(lenguaje_de_programaci%C3%B3n)","1968","Dennis_Ritchie","C_(lenguaje_de_programaci%C3%B3n)","Guido_van_Rossum","Python","Bjarne_Stroustrup","C%2B%2B","Ken_Thompson","B_(lenguaje_de_programaci%C3%B3n)","Go_(lenguaje_de_programaci%C3%B3n)","Larry_Wall","Perl","Perl_6","Niklaus_Wirth","Pascal_(lenguaje_de_programaci%C3%B3n)","Modula","Oberon_(lenguaje_de_programaci%C3%B3n)","Stephen_Wolfram","Mathematica","Association_for_Computing_Machinery","Historia_de_la_construcci%C3%B3n_de_los_compiladores","Historia_del_hardware","Lenguaje_de_programaci%C3%B3n","Cronolog%C3%ADa_de_los_lenguajes_de_programaci%C3%B3n","Jean_E._Sammet","Academic_Press","Control_de_autoridades"]}
{"url":"Tarjeta_perforada","titulo":"Tarjeta perforada","contenido":"La tarjeta perforada o simplemente tarjeta es una lamina hecha de cartulina que contiene informacion en forma de perforaciones segun un codigo binario. Estos fueron los primeros medios utilizados para ingresar informacion e instrucciones a una computadora en los a\u00f1os 1960 y 1970. Las tarjetas perforadas fueron usadas con anterioridad por Joseph Marie Jacquard en los telares de su invencion, de donde paso a las primeras computadoras electronicas. Con la misma logica se utilizaron las cintas perforadas.  Actualmente las tarjetas perforadas han sido reemplazadas por medios magneticos y opticos de ingreso de informacion. Sin embargo, muchos de los dispositivos de almacenamiento opticos, como por ejemplo el CD-ROM, tambien se basan en un metodo similar al usado por las tarjetas perforadas, aunque por supuesto los tama\u00f1os, velocidades de acceso y capacidad de los medios actuales no admiten comparacion con los antiguos medios.  En 1725, un frances hijo de un fabricante de organos, Basile Bouchon, adapta el concepto de los mecanismos de relojeria utilizados en las cajas de musica a la tarea repetitiva de un telar operado a traves de una cinta perforada. Este invento sera perfeccionado el 1728 por su asistente, Jean-Baptiste Falcon, que utilizara una serie de tarjetas perforadas ligadas entre ellas. En 1745 el ingeniero frances e inventor de automatas mecanicos, Jacques de Vaucanson, aplica sus conocimientos y crea el primer telar automatico. Sobre la base de estos dos inventos, en 1801 Joseph Marie Jacquard crea un famoso telar mecanico de tarjetas perforadas. Estas permitian que hasta los usuarios mas inexpertos pudieran elaborar complejos dise\u00f1os en una tela.  El matematico britanico Charles Babbage, conocedor de los trabajos de maquinas calculadoras realizadas por Blaise Pascal y Gottfried Leibniz, intento entre 1833 y 1842 construir una maquina que fuese programable para hacer cualquier tipo de calculo, no solo los referentes al calculo de tablas logaritmicas o funciones polinomicas. Esta fue la maquina analitica. Su proyecto incluia dispositivos de entrada basados en las tarjetas perforadas del telar Jacquard, un procesador aritmetico, que calculaba numeros, una unidad de control que determinaba que tarea debia ser realizada, un mecanismo de salida y una memoria donde los numeros podian ser almacenados hasta ser procesados. En 1842 el ingeniero, matematico italiano Luigi Federico Menabrea escribe Nociones sobre la maquina analitica de Charles Babbage, texto inicialmente publicado en frances. Ada Lovelace, matematica y escritora britanica, hija de Lord Byron, se entero de los esfuerzos de Babbage y se intereso en su maquina. Lee y traduce al ingles el articulo de Menabrea, y en septiembre de 1843 Lovelace publica en la revista Scientific Memoirs, con el titulo de \"Sketch of the analytical engine invented by Charles Babbage\" su propio estudio sobre la maquina analitica, con la traduccion como anexo. En uno de los apartados, describe con detalle las operaciones mediante las cuales las tarjetas perforadas \"tejerian\" una secuencia de numeros en la maquina analitica. Este codigo esta considerado como el primer algoritmo especificamente dise\u00f1ado para ser ejecutado por un ordenador, aunque nunca fue probado, ya que la maquina nunca llego a construirse.  Herman Hollerith desarrollo la tecnologia de procesamiento de tarjetas perforadas de datos para el censo de los Estados Unidos de America de 1890 y fundo la compa\u00f1ia Tabulating Machine Company (1895) la cual fue una de las tres compa\u00f1ias que se unieron para formar la Computing Tabulating Recording Corporation (CTR), luego renombrada IBM. IBM manufacturo y comercializo una variedad de unidades maquinas de registro para crear, ordenar, y tabular tarjetas perforadas, aun luego de expandirse en las computadoras sobre el final de la decada del 50. IBM desarrollo la tecnologia de la tarjeta perforada como una herramienta poderosa para el procesamiento de datos empresariales y produjo una linea extensiva de unidades maquinas de registro de proposito general. Para el a\u00f1o 1950, las tarjetas IBM y las unidades maquinas de registro IBM se habian vuelto indispensables en la industria y el gobierno. Do not fold, spindle or mutilate (No doblar, enrollar o mutilar) es una version generalizada de la advertencia que aparecia en algunas tarjetas perforadas, que se convirtio en un lema en la era de la pos-Segunda Guerra Mundial (aunque mucha gente no tenia idea de lo que significaba spindle).  Desde 1905 hasta 1955, las tarjetas perforadas fueron el primer medio para el ingreso y almacenamiento de datos, y el procesamiento en computacion institucional y segun los archivos de IBM: \u00abPor 1937 [\u2026] IBM tenia 32 prensas trabajando en Endicott, N.\u202fY., imprimiendo, cortando y apilando de 5 a 10 millones de tarjetas perforadas cada dia\u00bb.\u200b Las tarjetas perforadas eran usadas incluso como billetes legales, asi como cheques y bonos de ahorro del gobierno de los Estados Unidos de America. Durante la decada del 60, las tarjetas perforadas fueron gradualmente reemplazadas como primera medida por almacenamiento de datos en cintas magneticas, mientras computadoras mejores y mas capaces se hicieron disponibles. Las tarjetas perforadas fueron todavia comunmente usadas para ingreso de datos y programacion hasta mediados de la decada de 1970, cuando la combinacion de almacenamiento de discos magneticos de mas bajo costo y terminales interactivas asequibles sobre minicomputadoras mas baratas, hicieron obsoletas a las tarjetas perforadas tambien para este rol. Sin embargo, su influencia vive a traves de muchas convenciones de estandares y formatos de archivos. Las terminales que reemplazaron a las tarjetas perforadas, por ejemplo la IBM 3270, mostraba 80 columnas de texto en modo texto, para compatibilidad con el software existente. Algunos programas todavia operan con la convencion de 80 columnas de texto, aunque cada vez menos, mientras que sistemas mas nuevos emplean una interfaz grafica de usuario con tipos de fuentes de ancho variable.  Hoy en dia, las tarjetas perforadas son mayormente obsoletas y reemplazadas por otros metodos de almacenamiento, excepto por aplicaciones especializadas.  En las primeras aplicaciones de las tarjetas perforadas, todas usaban disposiciones especificamente dise\u00f1adas y al principio se desconocia cual era su utilidad. No fue sino hasta alrededor de 1928 que las tarjetas perforadas y las maquinas se realizaron \"de proposito general\". Los bits rectangulares, circulares u ovalados de papel, se denominaban chad (recientemente, chads) o chips (en la jerga IBM). Los datos multicaracter, tales como palabras o numeros grandes, se conservaban en columnas adyacentes de la tarjeta, conocidas como campos. Al grupo de tarjetas se le llamaba mazo. Una de las esquinas superiores de la tarjeta aparecia normalmente cortada, de manera que aquellas tarjetas que no estuvieran orientadas correctamente, o las que tuvieran diferentes cortes de esquina, pudieran ser facilmente identificadas. Las tarjetas comunmente se imprimian, para que la posicion de la fila y columna de una perforacion pudiera ser identificada. Para algunas aplicaciones, la impresion podia incluir campos, nombrados y marcados con lineas verticales, logotipos y otros procedimientos.  Una de las tarjetas perforadas mas comunmente impresas fue la IBM 5081. Es mas, era tan comun que otros vendedores de tarjetas usaban el mismo numero (ver imagen a la derecha) y hasta los usuarios conocian ese numero.  La tarjeta perforada patentada por Herman Hollerith el 8 de junio de 1887 y usada en las maquinas tabuladoras mecanicas en el censo de 1890 de Estados Unidos de America, era un trozo de cartulina de alrededor de 90\u00a0mm por 215\u00a0mm, con orificios redondos y 20 columnas. Esta tarjeta puede ser vista en el sitio de Historia de la Computacion de la Universidad de Columbia.\u200b  Esta tarjeta tenia el mismo tama\u00f1o que un dolar estadounidense en aquella epoca. Las razones sugeridas para hacerla de este tama\u00f1o eran las siguientes:  Pero no hay evidencia real que pruebe que alguna de estas sugerencias sea correcta.  Las tarjetas perforadas de 45 columnas de Hollerith estan ilustradas en The application of the Hollerith Tabulating Machine to Brown's Tables of the Moon de Comrie.\u200b  El formato de la tarjeta perforada de Remington-Rand UNIVAC tenia 45 columnas y hoyos redondos, con dos juegos de 6 lugares para perforar en cada una. Las filas de cada juego se rotulaban como 0, 1/2, 3/4, 5/6, 7/8 y 9.\u200b \u200b  Este formato de tarjeta de IBM, dise\u00f1ado en 1928,\u200b tenia hoyos rectangulares, 80 columnas con 12 lugares de perforacion cada una, y un caracter para cada columna. El tama\u00f1o de la tarjeta era de exactamente 187,325\u00a0mm por 82,55\u00a0mm. Las tarjetas eran hechas de material liso, de 0,179\u00a0mm de ancho. Hay alrededor de 143 tarjetas por cada pulgada de espesor. En 1964, IBM cambio de esquinas cuadradas a redondeadas.\u200b  Las 10 posiciones inferiores representaban (de arriba abajo) los digitos del 0 al 9. Las dos posiciones superiores de una columna eran llamadas perforacion de zona 12 (superior), y perforacion de zona 11. Originalmente, solo se codificaba informacion numerica, con una perforacion por columna, indicando el digito. Podian ser agregados signos a un campo sobreperforando el bit menos significativo con una perforacion de zona: 12 para suma y 11 para resta. Las perforaciones de zona tambien tenian otros usos en el procesamiento, como indicar un registro maestro.  Mas tarde fueron introducidos codigos para letras mayusculas y caracteres especiales. Una columna con dos perforaciones (zona [12,11,0] + digito [1-9]) era una letra; 3 perforaciones (zona [12,11,0] + digito [2-4] + 8) era un caracter especial. La introduccion del EBCDIC en 1964 permitio columnas con hasta 6 perforaciones (zonas [12,11,0,8,9] + digito [1-7]). IBM y otros fabricantes usaron codificaciones muy diferentes para caracteres de tarjetas de 80 columnas.\u200b\u200b  Para algunas aplicaciones de computadora, fueron usados formatos de numeros binarios, donde cada hoyo representaba un unico digito binario (bit), cada columna (o fila) era tratada como un campo de un bit simple, y cualquier combinacion de hoyos estaba permitida. Por ejemplo, las computadoras cientificas de la serie 704/709/7090/7094 de IBM, trataban cada fila como dos palabras de 36 bit, usualmente en columnas de 1-72, ignorando las ultimas 8 columnas (las 72 columnas eran seleccionadas usando un panel de control). Otras computadoras, como la IBM 1130 o la System/360, usaban todas las columnas. Para la diversion del operador o un visitante, en modo binario, las tarjetas podian ser perforadas en todas sus posiciones perforables posibles a la vez, estas son llamadas tarjetas de encaje.  El formato de tarjeta de 80 columnas domino la industria, haciendose conocidas solo bajo el nombre de tarjetas IBM, tanto que hasta otras industrias debieron hacer tarjetas y equipamiento para procesarlas.  Las tarjetas mark sense (electrograficas), desarrolladas por Reynold B. Johnson en IBM, tenian ovalos impresos que podian ser marcados con un lapiz electrografico especial. Las tarjetas podian ser perforadas tipicamente con alguna informacion inicial, como el nombre y lugar de un objeto de inventario. La informacion a ser adherida, como la cantidad de unidades del objeto en existencia, podia ser marcada en los ovalos. Las perforaciones de tarjetas con una opcion para detectar tarjetas mark sense podian entonces perforar la informacion correspondiente en la tarjeta.  Las tarjetas de apertura tienen un hoyo rebanado en el lado derecho de tarjeta perforada. Un trozo de micropelicula de 35\u00a0mm que contiene una imagen de microforma es montado en el hoyo. Las tarjetas de apertura son usadas para diagramas de ingenieria de cualquier disciplina de la ingenieria. La informacion sobre el diagrama, por ejemplo, el numero de dibujo, tipicamente es perforado e impreso en el resto de la tarjeta. Las tarjetas de apertura tienen algunas ventajas sobre los sistemas digitales para archivar informacion.\u200b  Este formato de tarjeta perforada IBM fue una tarjeta de 80 columnas acortada. El acortamiento a veces se realizaba cortando y quitando, en el momento de la perforacion, un trozo de una tarjeta de 80 columnas. Estas tarjetas fueron usadas en algunas aplicaciones de venta minorista e inventarios.  Segun los archivos de IBM, \u00abla Division de Suministros de IBM introdujo la perforadora portatil (Port-A-Punch) en 1958 como un rapido y preciso medio para perforar hoyos en tarjetas IBM especialmente calificadas. Dise\u00f1ada para llevar en un bolsillo, la perforadora portatil hizo posible crear documentos de tarjetas perforadas en cualquier lugar\u00bb. El producto fue concebido para operaciones de registro \"en el foco\" \u2014tales como inventarios fisicos, boletas de trabajo y encuestas estadisticas\u2014, ya que eliminaba la necesidad de escrituras previas o escritura de documentos fuente.\u200b Desafortunadamente, los hoyos resultantes quedaban \"peludos\" y algunas veces causaban problemas con el equipo utilizado para leer las tarjetas. ","snippet":"La tarjeta perforada o simplemente tarjeta es una lamina hecha de cartulina que contiene informacion en forma de perforaciones segun un codigo binario. Estos fueron los primeros medios utilizados para","enlaces_salientes":["Tarjeta_perforada","Tarjeta_perforada","Tarjeta_perforada","Sistema_binario","Computadora","Joseph_Marie_Jacquard","Telar","Cinta_perforada","Memoria_(inform%C3%A1tica)","CD-ROM","Telar_de_Jacquard","1725","%C3%93rgano_(instrumento_musical)","Basile_Bouchon","Caja_de_m%C3%BAsica","Telar","Cinta_perforada","1728","Jean-Baptiste_Falcon","Aut%C3%B3mata_(mec%C3%A1nico)","Jacques_de_Vaucanson","Joseph_Marie_Jacquard","Telar_de_Jacquard","Charles_Babbage","Blaise_Pascal","Gottfried_Leibniz","1833","1842","M%C3%A1quina_anal%C3%ADtica","Luigi_Federico_Menabrea","Ada_Lovelace","Lord_Byron","Algoritmo","Herman_Hollerith","International_Business_Machines","Segunda_Guerra_Mundial","Cinta_magn%C3%A9tica","Disco_magn%C3%A9tico","Terminal_de_computadora","Minicomputadora","IBM_3270","Modo_texto","Software","Interfaz_gr%C3%A1fica_de_usuario","Bit","IBM","Herman_Hollerith","8_de_junio","1887","Tabuladora","Oficina_del_Censo_de_los_Estados_Unidos","Departamento_del_Tesoro_de_los_Estados_Unidos","UNIVAC","Fortran","IBM","Bit_menos_significativo","EBCDIC","Binario","Bit","IBM_1130","System/360","Tarjeta_de_encaje","Reynold_B._Johnson","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_Israel","National_Archives_and_Records_Administration","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings"]}
{"url":"1953","titulo":"1953","contenido":"1953 (MCMLIII) fue un a\u00f1o comun comenzado en jueves segun el calendario gregoriano.  Todas las fechas pertenecen a los estrenos oficiales de sus paises de origen, salvo que se indique lo contrario. ","snippet":"1953 (MCMLIII) fue un a\u00f1o comun comenzado en jueves segun el calendario gregoriano.  Todas las fechas pertenecen a los estrenos oficiales de sus paises de origen, salvo que se indique lo contrario. ","enlaces_salientes":["1953","1953","1953","1950","1951","1952","1954","1955","1956","D%C3%A9cada","A%C3%B1os_1920","A%C3%B1os_1930","A%C3%B1os_1940","A%C3%B1os_1950","A%C3%B1os_1960","A%C3%B1os_1970","A%C3%B1os_1980","Siglo","Siglo_XIX","Siglo_XX","Siglo_XXI","2023","Calendario_gregoriano","Ab_Urbe_condita","Calendario_armenio","Calendario_chino","Calendario_hebreo","Calendario_hind%C3%BA","Vikram_Samvat","Shaka_Samvat","Calendario_persa","Calendario_musulm%C3%A1n","Mau_Mau","Edmund_Hillary","Tenzing_Norgay","Monte_Everest","Golpe_de_Estado_en_Ir%C3%A1n_de_1953","Desastre_de_Tangiwai","Coronaci%C3%B3n_de_Isabel_II_del_Reino_Unido","T-34-85","Berl%C3%ADn_Oriental","Sublevaci%C3%B3n_de_1953_en_la_Rep%C3%BAblica_Democr%C3%A1tica_Alemana","I%C3%B3sif_Stalin","Inundaci%C3%B3n_del_Mar_del_Norte_de_1953","Numeraci%C3%B3n_romana","A%C3%B1o_com%C3%BAn_comenzado_en_jueves","Calendario_gregoriano","6_de_enero","Rang%C3%BAn","Birmania","Asia","7_de_enero","Bolivia","Derecha_(pol%C3%ADtica)","11_de_enero","Uni%C3%B3n_Sovi%C3%A9tica","Israel","20_de_enero","Dwight_D._Eisenhower","Estados_Unidos","23_de_enero","Par%C3%ADs","Esperando_a_Godot","Samuel_Becket","Roger_Blin","31_de_enero","1_de_febrero","Pa%C3%ADses_Bajos","Zelandia","Inundaci%C3%B3n_del_Mar_del_Norte_en_1953","Reino_Unido","Transbordador","Princess_Victoria","Mar_de_Irlanda","1_de_febrero","Mar_del_Norte","Inundaci%C3%B3n_de_los_Pa%C3%ADses_Bajos_en_1953","2_de_febrero","Eisenhower","Isla_de_Taiw%C3%A1n","6_de_febrero","Madrid","El_caso_de_la_se%C3%B1ora_estupenda","Miguel_Mihura","7_de_febrero","Bilbao","Estadio_de_San_Mam%C3%A9s_(1913)","10_de_febrero","Egipto","Espa%C3%B1a","1930","Egipto","Rep%C3%BAblica_Federal_de_Alemania_(1949-1990)","Rep%C3%BAblica_Democr%C3%A1tica_Alemana","11_de_febrero","Monte_San_Valent%C3%ADn","Cordillera_de_los_Andes","Patagonia","12_de_febrero","Ir%C3%A1n","13_de_febrero","Yugoslavia","16_de_febrero","Juan_Domingo_Per%C3%B3n","18_de_febrero","Bwana_Devil","Filme","3D","Lucille_Ball","Desi_Arnaz","Yo_amo_a_Lucy","1955","20_de_febrero","Londres","Francisco_de_Goya","21_de_febrero","Francis_Crick","James_Dewey_Watson","ADN","22_de_febrero","Per%C3%BA","Copa_Am%C3%A9rica","28_de_febrero","Francis_Crick","James_Dewey_Watson","1_de_marzo","Espa%C3%B1a","5_de_marzo","Mosc%C3%BA","I%C3%B3sif_Visari%C3%B3novich_Dzugasvili","17_de_marzo","Sitio_de_pruebas_de_Nevada","Bomba_at%C3%B3mica","Operaci%C3%B3n_Upshot-Knothole","Kilotones","18_de_marzo","M%C3%A1rmara","24_de_marzo","Mar%C3%ADa_de_Teck","Jorge_V","24_de_marzo","Kilotones","31_de_marzo","Kilotones","Lawrence_Livermore_National_Laboratory","1_de_abril","Lima","Selecci%C3%B3n_de_f%C3%BAtbol_de_Paraguay","Selecci%C3%B3n_de_f%C3%BAtbol_de_Brasil","2_de_abril","Julius_Raab","3_de_abril","Yma_S%C3%BAmac","6_de_abril","Sitio_de_pruebas_de_Nevada","Upshot-Knothole","Kilotones","11_de_abril","Bomba_at%C3%B3mica","Kilotones","15_de_abril","Buenos_Aires","Juan_Domingo_Per%C3%B3n","Atentado_terrorista_en_la_Plaza_de_Mayo_del_15_de_abril_de_1953","Quema_de_locales_de_opositores_del_15_de_abril_de_1953_en_Argentina","18_de_abril","Kilotones","25_de_abril","Sitio_de_pruebas_de_Nevada","GMT","Kilotones","Nature","James_D._Watson","Francis_Crick","ADN","1_de_mayo","Par%C3%ADs","Esperando_a_Godot","Samuel_Beckett","Buenos_Aires","Juan_Domingo_Per%C3%B3n","D%C3%ADa_del_Trabajador","6_de_mayo","Terremoto_de_San_Carlos_de_1953","John_Foster_Dulles","Teor%C3%ADa_del_domin%C3%B3","Indochina","Asia","8_de_mayo","Costa_Rica","Jos%C3%A9_Figueres_Ferrer","1958","Sitio_de_pruebas_de_Nevada","Bomba_at%C3%B3mica","Kilotones","17_de_mayo","Rocky_Marciano","18_de_mayo","Jacqueline_Cochran","F-86_Sabre","Barrera_del_sonido","19_de_mayo","Medell%C3%ADn_(Colombia)","Corporaci%C3%B3n_Deportiva_Club_Atl%C3%A9tico_Nacional","Sitio_de_pruebas_de_Nevada","Estados_Unidos","Bomba_at%C3%B3mica","Upshot-Knothole","Kilotones","Dirty_Harry","St._George_(Utah)","The_Conqueror","Howard_Hughes","John_Wayne","Susan_Hayward","25_de_mayo","Tiempo_universal_coordinado","Sitio_de_pruebas_de_Nevada","Bomba_at%C3%B3mica","Operaci%C3%B3n_Upshot_Knothole","29_de_mayo","Nepal","Tenzing_Norgay","Edmund_Percival_Hillary","Monte_Everest","2_de_junio","Abad%C3%ADa_de_Westminster","Reino_Unido","Isabel_II_del_Reino_Unido","4_de_junio","Sitio_de_pruebas_de_Nevada","Upshot-Knothole","Kilotones","5_de_junio","Avellaneda_(Buenos_Aires)","Juan_Domingo_Per%C3%B3n","13_de_junio","Colombia","Gustavo_Rojas_Pinilla","Laureano_G%C3%B3mez_Castro","Roberto_Urdaneta_Arbel%C3%A1ez","15_de_junio","La_Habana","Celia_Cruz","Sonora_Matancera","Bemb%C3%A9","1957","17_de_junio","Berl%C3%ADn_Oriental","26_de_junio","Costa_Rica","15_de_julio","Peronistas","Socialista","Ilustraci%C3%B3n","Biblioteca","Sudam%C3%A9rica","23_de_julio","Egipto","Faruq_I_de_Egipto","26_de_julio","Santiago_de_Cuba","Fidel_Castro","Cuartel_Moncada","Fulgencio_Batista","Gobierno_de_Estados_Unidos","27_de_julio","Corea","Estados_Unidos","Rep%C3%BAblica_Popular_China","Corea_del_Norte","Corea_del_Sur","Guerra_de_Corea","4_de_agosto","Cordillera_Blanca","Huascar%C3%A1n","11_de_agosto","Tazio_Nuvolari","12_de_agosto","Sitio_de_pruebas_at%C3%B3micas_en_Semipalatinsk","Kazajist%C3%A1n","Uni%C3%B3n_Sovi%C3%A9tica","Usilennaya","CIA","Bomba_de_hidr%C3%B3geno","1_de_noviembre","1952","Islas_J%C3%B3nicas","Grecia","19_de_agosto","Iran%C3%AD","Mohammad_Mosaddeq","Golpe_de_Estado_en_Ir%C3%A1n_de_1953","Agencia_Central_de_Inteligencia","23_de_agosto","Joe-5","RDS-4","Gran_Premio_de_Suiza","F%C3%B3rmula_1","Alberto_Ascari","27_de_agosto","Vacaciones_en_Roma","Audrey_Hepburn","29_de_agosto","Teodoro_Fern%C3%A1ndez_Meyz%C3%A1n","Alianza_Lima","Club_Universitario_de_Deportes","31_de_agosto","3_de_septiembre","Uni%C3%B3n_Sovi%C3%A9tica","Nikita_Jrushchov","Partido_Comunista_de_la_Uni%C3%B3n_Sovi%C3%A9tica","Sitio_de_pruebas_at%C3%B3micas_en_Semipalatinsk","Kazajist%C3%A1n","Uni%C3%B3n_Sovi%C3%A9tica","Joe-6","8_de_septiembre","10_de_septiembre","Chipre","14_de_septiembre","Informe_Kinsey","Best-seller","1948","Fiyi","21_de_septiembre","1.%C2%AA_Semana_Internacional_del_Cine_de_San_Sebasti%C3%A1n","Festival_Internacional_de_Cine_de_San_Sebasti%C3%A1n","27_de_septiembre","RecordTV","30_de_septiembre","Mar_Mediterr%C3%A1neo","Auguste_Piccard","Jacques_Piccard","9_de_octubre","Alemania_Occidental","Konrad_Adenauer","12_de_octubre","Hermann_Staudinger","Pl%C3%A1stico","Winston_Churchill","13_de_octubre","Venezuela","Universidad_Santa_Mar%C3%ADa","17_de_octubre","M%C3%A9xico","Voto_femenino","24_de_octubre","Venezuela","Universidad_Cat%C3%B3lica_Andr%C3%A9s_Bello","Frank_Sinatra","Ava_Gardner","9_de_noviembre","Camboya","Francia","1993","13_de_noviembre","Himno_Nacional_de_El_Salvador","San_Salvador","El_Salvador","Juan_Jos%C3%A9_Ca%C3%B1as","Juan_Aberle","15_de_noviembre","Venezuela","RCTV","27_de_mayo","2007","28_de_noviembre","Colombia","Todelar_Radio","1_de_diciembre","Radio_Panamericana","7_de_diciembre","Convenci%C3%B3n_sobre_la_Esclavitud","Ir%C3%A1n","Richard_Nixon","Teher%C3%A1n","9_de_diciembre","General_Electric","Partido_Comunista_de_los_Estados_Unidos","12_de_diciembre","Tumbes","Per%C3%BA","4_de_enero","Norberto_Alonso","5_de_enero","Pamela_Sue_Martin","6_de_enero","Malcolm_Young","2017","8_de_enero","Dami%C3%A1n_Alc%C3%A1zar","Leonor_Bravo_Vel%C3%A1squez","10_de_enero","Pat_Benatar","Blanca_Guerra","William_Millerson","15_de_enero","Hugo_Soto_(actor)","1994","18_de_enero","23_de_enero","Alister_McGrath","24_de_enero","Matthew_Wilder","Silvio_Brito","25_de_enero","The_Honky_Tonk_Man","26_de_enero","Anders_Fogh_Rasmussen","27_de_enero","Enrique_Mart%C3%ADnez_Heredia","30_de_enero","Salvador_Nasralla","3_de_febrero","Manfred_Albert_von_Richthofen","2002","8_de_febrero","Mary_Steenburgen","9_de_febrero","Juanjo_Novaira","12_de_febrero","Joanna_Kerns","15_de_febrero","Tony_Adams_(productor)","2005","Rafael_Bielsa_(pol%C3%ADtico)","16_de_febrero","Baby_Etchecopar","19_de_febrero","Cristina_Fern%C3%A1ndez_de_Kirchner","2007","2015","2019","Victoria_Vera","21_de_febrero","William_Petersen","22_de_febrero","Ren%C3%A9_Morales","Paloma_Woolrich","23_de_febrero","Satoru_Nakajima","Beto_Quevedo","25_de_febrero","Jos%C3%A9_Mar%C3%ADa_Aznar","1996","2004","26_de_febrero","Michael_Bolton","Egidio_Cuadrado","27_de_febrero","Ian_Khama","28_de_febrero","Paul_Krugman","Premio_en_Ciencias_Econ%C3%B3micas_en_memoria_de_Alfred_Nobel","2008","1_de_marzo","Carlos_Queiroz","2_de_marzo","Josema_Yuste","3_de_marzo","Zico","4_de_marzo","Ram%C3%B3n_Soto_Vargas","10_de_marzo","Paul_Haggis","12_de_marzo","Margarita_Belandria","16_de_marzo","Isabelle_Huppert","Richard_Stallman","17_de_marzo","Romualdo_Brito","2020","19_de_marzo","Lenin_Moreno","Ecuador","2017","2021","20_de_marzo","Luisa_Kuliok","22_de_marzo","Isadora_(cantante)","23_de_marzo","Baudilio_D%C3%ADaz","1990","Chaka_Khan","24_de_marzo","Louie_Anderson","2022","1_de_abril","Barry_Sonnenfeld","6_de_abril","Christopher_Franke","9_de_abril","Stephen_Paddock","Masacre_de_Las_Vegas_de_2017","11_de_abril","Andrew_Wiles","Guy_Verhofstadt","12_de_abril","%C3%81lex_Angulo","2014","16_de_abril","18_de_abril","Rick_Moranis","19_de_abril","Sara_Simeoni","Ram%C3%B3n_N%C3%BA%C3%B1ez_Armas","23_de_abril","Kim_Gordon","24_de_abril","Eric_Bogosian","27_de_abril","Arielle_Dombasle","28_de_abril","Roberto_Bola%C3%B1o","2003","30_de_abril","Joan_Massagu%C3%A9","2_de_mayo","Valeri_G%C3%A9rgiev","3_de_mayo","Luis_Alberto_Moreno","5_de_mayo","Ob%C3%BAs_(banda)","Tony_Blair","6_de_mayo","Tony_Blair","Graeme_Souness","8_de_mayo","Alex_Van_Halen","10_de_mayo","Tito_Santana","14_de_mayo","Wim_Mertens","15_de_mayo","Mike_Oldfield","16_de_mayo","Pierce_Brosnan","20_de_mayo","Carmina_Barrios","21_de_mayo","Alberto_Marcos_Mart%C3%ADn","24_de_mayo","Jorge_Casta%C3%B1eda_Gutman","Alfred_Molina","Lamberto_Leoni","25_de_mayo","Daniel_Passarella","26_de_mayo","Michael_Portillo","27_de_mayo","Susana_Olaondo","29_de_mayo","Danny_Elfman","Hiroshi_Iwasaki","1_de_junio","David_Berkowitz","3_de_junio","Loalwa_Braz","5_de_junio","Nicko_McBrain","13_de_junio","Tim_Allen","16_de_junio","Juan_Mu%C3%B1oz_(escultor)","Mar%C3%ADa_Gra%C3%B1a","21_de_junio","Benazir_Bhutto","22_de_junio","Cyndi_Lauper","Phil_Goff","Dolores_Salom%C3%B3n","23_de_junio","Russell_Mulcahy","26_de_junio","Fernando_Ribeiro_Carneiro","1_de_julio","Jes%C3%BAs_Mar%C3%ADa_Sanz_Iparraguirre","Catherine_Ferry","V%C3%ADctor_Barrueto","2_de_julio","Giuseppe_Piccioni","Antonio_Armas","3_de_julio","Pep_Munn%C3%A9","4_de_julio","Yiyi","7_de_julio","Julio_Miranda_(cantautor)","1993","10_de_julio","%C3%89douard_Guillaud","11_de_julio","Piyasvasti_Amranand","Ang%C3%A9lica_Arag%C3%B3n","Patricia_Reyes_Sp%C3%ADndola","15_de_julio","Haminah_Hamidun","Micha%C3%ABl_Dudok_de_Wit","17_de_julio","Thomas_Carter","19_de_julio","Zitto_Zegovia","1989","23_de_julio","Mar%C3%ADa_Pazos_Mor%C3%A1n","2_de_agosto","Butch_Patrick","3_de_agosto","Bruno_D%C3%ADaz","4_de_agosto","Reynaldo_Armas","6_de_agosto","Gloria_G%C3%B3mez","7_de_agosto","Vera_Holtz","8_de_agosto","Nigel_Mansell","10_de_agosto","Yolanda_Li%C3%A9vana","11_de_agosto","Hulk_Hogan","13_de_agosto","Carmen_Posadas","Arturo_Cruz_Sequeira","14_de_agosto","James_Horner","2015","15_de_agosto","Rigoberto_Cisneros","Paulo_Laserna_Phillips","Mark_Thatcher","Margaret_Thatcher","Laura_Garc%C3%ADa","16_de_agosto","17_de_agosto","Herta_M%C3%BCller","2009","Giovanni_Moretti","19_de_agosto","Giovanni_Moretti","30_de_agosto","Mar%C3%ADa_Luisa_Carcedo","31_de_agosto","Miguel_%C3%81ngel_Guerra_(piloto)","1_de_septiembre","Mem%C3%ADn_Hern%C3%A1ndez","2_de_septiembre","Keith_Allen","Dumar_Aljure_Rivas","3_de_septiembre","Jean-Pierre_Jeunet","8_de_septiembre","Elena_Reynaga","9_de_septiembre","Ryszard_Jedli%C5%84ski","2023","10_de_septiembre","Wolf_Maya","Amy_Irving","19_de_septiembre","Diana_Maff%C3%ADa","20_de_septiembre","Ricci_Martin","2016","21_de_septiembre","Bob_Huggins","22_de_septiembre","Mar%C3%ADa_Jos%C3%A9_de_Castro_Polessa","S%C3%A9gol%C3%A8ne_Royal","Francisco_de_Narv%C3%A1ez","26_de_septiembre","Xabier_Azkargorta","Guillermo_Yunge","Atentado_en_la_embajada_de_Costa_Rica","27_de_septiembre","Greg_Ham","2012","Mar%C3%ADa_Emma_Mej%C3%ADa","3_de_octubre","Edgar_Artunduaga","2019","7_de_octubre","Tico_Torres","8_de_octubre","Julia_Navarro","9_de_octubre","Tony_Shalhoub","10_de_octubre","Midge_Ure","15_de_octubre","Cilia_Flores_de_Maduro","Tito_Jackson","Larry_Miller","Enrique_Mor%C3%A1n","18_de_octubre","Silvia_Navarrete","25_de_octubre","Gonzalo_Alcalde_Crespo","27_de_octubre","Peter_Firth","30_de_octubre","%C3%81lvaro_Morales_Rodr%C3%ADguez","2011","Carlos_Antonio_V%C3%A9lez","5_de_noviembre","Aurelio_Andreazzoli","11_de_noviembre","Pecos_Kanvas","2008","13_de_noviembre","Andr%C3%A9s_Manuel_L%C3%B3pez_Obrador","Presidente_de_M%C3%A9xico","2018","15_de_noviembre","Eduardo_Darnauchans","2007","16_de_noviembre","Jes%C3%BAs_Caudevilla_Pastor","18_de_noviembre","Alan_Moore","C%C3%A9sar_Miguel_Rond%C3%B3n","Kevin_Nealon","Kath_Soucie","19_de_noviembre","Francisco_Mujika_Garmendia","23_de_noviembre","Francis_Cabrel","27_de_noviembre","Pamela_Hayden","28_de_noviembre","Alistair_Darling","Helena_Mallarino","2_de_diciembre","%C3%81lex_Lora","3_de_diciembre","%C3%81gata_Lys","2021","6_de_diciembre","Tom_Hulce","Kim_Basinger","8_de_diciembre","Kim_Basinger","Manuel_G%C3%B3mez_Pereira","Sento","9_de_diciembre","Guillermo_Garc%C3%ADa_(ajedrecista_cubano)","1990","John_Malkovich","13_de_diciembre","Ben_Bernanke","Thomas_Kurzhals","2014","17_de_diciembre","Sally_Menke","2010","24_de_diciembre","Gerardo_Solano","2000","25_de_diciembre","Mario_Santiago_Papasquiaro","26_de_diciembre","Leonel_Antonio_Fern%C3%A1ndez_Reyna","Toomas_Hendrik_Ilves","Gloria_G%C3%B3mez","29_de_diciembre","Richard_Clayderman","31_de_diciembre","Richard_P%C3%A1ez","Rafael_Araujo_(activista)","Luisito_Dom%C3%ADnguez","2008","Pilar_L%C3%B3pez_Sancho","Jorge_Emilio_Salazar","1992","Zara_Apa","2013","1_de_enero","Hank_Williams","7_de_enero","Osa_Johnson","10_de_enero","15_de_febrero","Karl_Gustaf_Staaf","24_de_febrero","Gerd_von_Rundstedt","5_de_marzo","I%C3%B3sif_Stalin","24_de_marzo","Felix-Maria_Abel","Mar%C3%ADa_de_Teck","4_de_abril","Carlos_II_de_Rumania","9_de_abril","Juan_Ram%C3%B3n_Duarte","13_de_mayo","Hermann_Jadlowker","15_de_mayo","Chet_Miller","30_de_mayo","Carl_Scarborough","20_de_julio","Jan_Struther","11_de_agosto","Tazio_Nuvolari","18_de_septiembre","Charles_de_Tornaco","24_de_septiembre","Jacobo_Fitz-James_Stuart_y_Falc%C3%B3","Berthold_Viertel","27_de_septiembre","Hans_Fritzsche","28_de_septiembre","Edwin_Hubble","8_de_octubre","Ch%C5%8Djun_Miyagi","8_de_noviembre","Ivan_Alekseyevich_Bunin","15_de_noviembre","Jorge_de_Lima","21_de_noviembre","Felice_Bonetto","27_de_noviembre","Eugene_O%27Neill","5_de_diciembre","Jorge_Negrete","Maria_Pascoli","6_de_diciembre","Konstanty_Ildefons_Ga%C5%82czy%C5%84ski","19_de_diciembre","Robert_Andrews_Millikan","23_de_diciembre","Lavrenti_Beria","31_de_diciembre","Crist%C3%B3bal_de_Castro","6_de_enero","Llu%C3%AFsa_Forrellad","Premio_Nadal","Ernest_Hemingway","Premio_Pulitzer","El_viejo_y_el_mar","Ray_Bradbury","Fahrenheit_451","Las_doradas_manzanas_del_sol","Arthur_Miller","Las_brujas_de_Salem","Juan_Rulfo","Fondo_de_Cultura_Econ%C3%B3mica","El_llano_en_llamas","Isaac_Asimov","Segunda_Fundaci%C3%B3n","Saul_Bellow","Las_aventuras_de_Augie_March","Heinrich_B%C3%B6ll","Y_no_dijo_ni_una_palabra","William_Burroughs","Yonqui_(novela)","Raymond_Chandler","El_largo_adi%C3%B3s_(novela)","Agatha_Christie","Despu%C3%A9s_del_funeral","Un_pu%C3%B1ado_de_centeno","Testigo_de_cargo_(obra_de_teatro)","Arthur_C._Clarke","El_fin_de_la_infancia","Ian_Fleming","Casino_Royale_(novela)","J._D._Salinger","Nueve_cuentos","Boris_Vian","El_arrancacorazones","C._S._Lewis","La_silla_de_plata","Frank_Sinatra","Capitol_Records","Los_%C3%81ngeles","California","Axel_Stordahl","Frank_Sinatra","Nelson_Riddle","Frank_Sinatra","Sands_Hotel","1_de_enero","Titanic_(pel%C3%ADcula_de_1953)","Jean_Negulesco","5_de_febrero","Peter_Pan_(1953)","Clyde_Geronimi","Wilfred_Jackson","Shane","George_Stevens","Reportaje_(pel%C3%ADcula)","Emilio_Fern%C3%A1ndez","Cuentos_de_Tokio","Yasujir%C5%8D_Ozu","De_aqu%C3%AD_a_la_eternidad","James_Jones_(autor)","Fred_Zinnemann","Alberto_Ascari","Lista_de_campeones_de_F%C3%B3rmula_1","F%C3%B3rmula_1","Selecci%C3%B3n_de_f%C3%BAtbol_de_Paraguay","F%C3%BAtbol_Club_Barcelona","Liga_espa%C3%B1ola_de_f%C3%BAtbol","Liga_de_B%C3%A9isbol_Profesional_de_la_Rep%C3%BAblica_Dominicana","Tigres_del_Licey","%C3%81guilas_Cibae%C3%B1as","New_York_Yankees","Serie_Mundial","Grandes_Ligas_de_B%C3%A9isbol","Brooklyn_Dodgers","Televisi%C3%B3n_en_1953","James_Dewey_Watson","Francis_Crick","Bioqu%C3%ADmico","ADN","Alfred_C._Kinsey","20_de_noviembre","Scott_Crossfield","Velocidad_del_sonido","Premio_Nobel","Frits_Zernike","Hermann_Staudinger","Premio_Nobel_de_Medicina","Hans_Adolf_Krebs","Fritz_Albert_Lipmann","Winston_Churchill","George_Catlett_Marshall","ISBN","Uni%C3%B3n_C%C3%ADvica_Radical","Roque_Carranza","Patricio_Cullen","Germ%C3%A1n_L%C3%B3pez","Miguel_%C3%81ngel_Zavala_Ortiz","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"John_Backus","titulo":"John Backus","contenido":"John Backus (Filadelfia, 3 de diciembre de 1924 - Oregon, 17 de marzo de 2007) fue un cientifico de la computacion\u200b estadounidense.  Ganador del Premio Turing en 1977 por sus trabajos en sistemas de programacion de alto nivel, en especial por su trabajo en el desarrollo de  FORTRAN.  Para evitar las dificultades de programacion de las calculadoras de su epoca, en 1954 Backus se encargo de la direccion de un proyecto de investigacion en IBM para el proyecto y realizacion de un lenguaje de programacion mas cercano a la notacion matematica normal. De ese proyecto surgio el lenguaje FORTRAN, el primero de los lenguajes de programacion de alto nivel que tuvo un gran impacto, incluso comercial, en la emergente comunidad informatica. A pesar del tiempo que ha pasado y que FORTRAN ha perdido mucha relevancia, aun es usado por muchas empresas y centros de investigacion.\u200b  Tras la realizacion de FORTRAN, Backus fue un miembro muy activo del comite internacional que se encargo del proyecto de lenguaje ALGOL. En ese contexto propuso una notacion para la representacion de las gramaticas usadas en la definicion de un lenguaje de programacion (las llamadas gramaticas libres de contexto). Tal notacion se conoce como Notacion de Backus-Naur (Backus-Naur Form o BNF) y une al nombre de Backus al de Peter Naur, un informatico europeo del comite ALGOL que contribuyo a su definicion.  En los a\u00f1os 1970, Backus se intereso sobre todo por la Programacion funcional, y proyecto el lenguaje de programacion FP, descrito en el texto que le sirvio para ganar el premio Turing, \"Can Programming be Liberated from the Von Neumann Style?\" Se trata de un lenguaje de uso fundamentalmente academico, que sin embargo animo un gran numero de investigaciones. El proyecto FP, transformado en FL, se termino cuando Backus se jubilo en IBM, en 1991.  John Backus fallecio el sabado 17 de marzo de 2007, a la edad de 82 a\u00f1os en su casa en Ashland, Oregon por causas naturales, de acuerdo a la declaracion de su familia.\u200b   ","snippet":"John Backus (Filadelfia, 3 de diciembre de 1924 - Oregon, 17 de marzo de 2007) fue un cientifico de la computacion\u200b estadounidense.  Ganador del Premio Turing en 1977 por sus trabajos en sistemas de p","enlaces_salientes":["John_Backus","John_Backus","John_Backus","Filadelfia","Estados_Unidos","Ashland_(Oreg%C3%B3n)","Universidad_de_Virginia","Qu%C3%ADmica","Universidad_de_Columbia","Maestr%C3%ADa","Matem%C3%A1ticas","Matem%C3%A1tico","Inform%C3%A1tico_te%C3%B3rico","Ciencias_de_la_computaci%C3%B3n","Ciencias_de_la_informaci%C3%B3n_(tecnolog%C3%ADa)","Ej%C3%A9rcito_de_los_Estados_Unidos","IBM","Speedcoding","Fortran","Notaci%C3%B3n_de_Backus-Naur","FP_(lenguaje_de_programaci%C3%B3n)","Segunda_Guerra_Mundial","Academia_Nacional_de_Ciencias_(Estados_Unidos)","Academia_Estadounidense_de_las_Artes_y_las_Ciencias","Filadelfia","3_de_diciembre","1924","Oreg%C3%B3n","17_de_marzo","2007","Inform%C3%A1tico_te%C3%B3rico","Estados_Unidos","Premio_Turing","1977","FORTRAN","1954","IBM","ALGOL","Gram%C3%A1tica_libre_de_contexto","Notaci%C3%B3n_de_Backus-Naur","Peter_Naur","A%C3%B1os_1970","Programaci%C3%B3n_funcional","New_York_Times","Michael_Oser_Rabin","Dana_Scott","Premio_Turing","1977","Robert_W._Floyd","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Scopus","Open_Library","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Computadora_central","titulo":"Unidad central","contenido":"Una unidad central (en ingles mainframe)\u200b es una computadora utilizada principalmente por grandes organizaciones para aplicaciones criticas, procesamiento de datos masivos (como censos y estadisticas de la industria y del consumidor, planificacion de recursos empresariales y transacciones a gran escala de procesamiento). Una computadora central es mas grande y tiene mas potencia de procesamiento que algunas otras clases de computadoras, como miniordenadores, servidores, estaciones de trabajo y computadoras personales. La mayoria de las arquitecturas de sistemas informaticos a gran escala se establecieron en la decada de 1960, pero continuan evolucionando. Las computadoras mainframe se utilizan a menudo como servidores.  El termino deriva del gabinete grande (en ingles mainframe)  que albergaba la unidad central de procesamiento y la memoria principal de las primeras computadoras.\u200b Mas tarde, el termino se utilizo para distinguir las computadoras comerciales de gama alta de las maquinas menos potentes.\u200b  La capacidad de una unidad central se define tanto por la velocidad de su CPU como por su gran memoria interna, su alta y gran capacidad de almacenamiento externo, sus resultados en los dispositivos E/S rapidos y considerables, la alta calidad de su ingenieria interna que tiene como consecuencia una alta fiabilidad y soporte tecnico costoso, pero de alta calidad. Una unidad central puede funcionar durante a\u00f1os sin problemas ni interrupciones y las reparaciones de la misma pueden ser realizadas mientras esta funcionando. Los vendedores de unidades centrales ofrecen servicios especiales; por ejemplo, si se rompe el equipo, el vendedor ejecutara las aplicaciones de su cliente en sus propias unidades sin que los usuarios lo noten mientras que duran las reparaciones. La independencia interna de estas unidad es tan grande que, por lo menos, en un caso conocido, los tecnicos pudieron cambiar las unidades centrales de sitio desmontandolas pieza a pieza y montandolas en otro lugar, dejando, mientras tanto, dichos equipos funcionando; en este ejemplo, el cambio de las unidades centrales de un sitio a otro se produjo de manera transparente.  A menudo, las unidades centrales soportan miles de usuarios de manera simultanea que se conectan mediante falsos terminales. Algunas unidades centrales pueden ejecutar o dar cobijo a muchos sistemas operativos y por lo tanto, no funcionan como una unidad sola, sino como varios equipos virtuales. En este papel, una unidad central por si sola puede reemplazar docenas o cientos de peque\u00f1as equipos personales, reduciendo los costes administrativos y de gestion al tiempo que ofrece una escalabilidad y fiabilidad mucho mejor. La fiabilidad se consigue por la independencia de sus componentes internos se\u00f1alada anteriormente, y la escalabilidad se logra porque los recursos fisicos de la unidad pueden ser redistribuidos entre los terminales virtuales segun las necesidades; esto es mucho mas dificil de hacer con las equipos personales, porque para quitar o a\u00f1adir nuevos componentes fisicos hay que desenchufar el equipo muchas veces y las limitaciones de dichos componentes son mucho mayores. Cuando una unidad central actua como el centro de operaciones de muchos terminales virtuales, puede ofrecer la potencia necesaria para que dichas unidad operen de manera eficiente, pero tambien la flexibilidad de las redes de equipos personales.  Varios fabricantes eran quienes producian unidades centrales en los a\u00f1os sesenta y setenta. En los dias de auge de estas maquinas, los fabricantes eran conocidos pues su numero no era muy grande: IBM, Burroughs, Control Data, General Electric, Honeywell, NCR, RCA, y Univac. Entre los fabricantes europeos destacaban Telefunken, Siemens, y Olivetti. Pero una demanda escasa y la gran competencia provoco un gran temblor en el mercado. RCA fue comprada por Univac, y General Electric abandono el mercado computacional. Honeywell fue adquirida por Bull, Univac se unio a Sperry para formar Sperry/Univac, que en el a\u00f1o 1986 se unio con Burroughs para formar Unisys Corporation. Por su parte y en 1991, AT&T poseyo durante un breve tiempo a NCR.  Las empresas se dieron cuenta de que los servidores basados en dise\u00f1os de microcomputadoras se podian instalar con un costo mucho menor, y ofrecer a los usuarios locales un mayor control de sus propios sistemas, y los falsos terminales empleados para conectarse a los sistemas de unidades centrales fueron reemplazados gradualmente por los equipos personales. En consecuencia, la demanda cayo en picado, y las grandes instalaciones de unidades centrales se restringieron sobre todo a las instituciones financieras con necesidades de procesamiento de grandes cantidades de datos. Durante un tiempo, existio un consenso dentro de los analistas de la industria de que el mercado de las unidades centrales estaba terminado, ya que las plataformas de unidades centrales eran en muchos casos sustituidas por redes de unidades personales.  Esta tendencia concluyo en 1990 ya que las empresas encontraron nuevos usos para sus unidades centrales, porque ahora podian ofrecer servidores web con una potencia similar a la de cientos de peque\u00f1os equipos personales, pero con mucho menos consumo de electricidad y menores costes administrativos.  Otro factor que aumento en la practica el uso de unidades centrales fue el desarrollo del sistema operativo GNU/Linux, que es capaz de ejecutarse en muchos sistemas de unidades centrales diferentes, directamente o, mas frecuentemente, a traves de una maquina virtual. Esto permite a las unidades centrales aprovecharse de la experiencia en programacion y de las comunidades del mercado de los equipos personales.  La distincion entre super computadores y unidades centrales no es muy sencilla, pero generalmente se puede decir que las super computadoras se centran en los problemas limitados por la velocidad de calculo mientras que las unidades centrales se centran en problemas limitados por los dispositivos de E/S y la fiabilidad. En consecuencia: ","snippet":"Una unidad central (en ingles mainframe)\u200b es una computadora utilizada principalmente por grandes organizaciones para aplicaciones criticas, procesamiento de datos masivos (como censos y estadisticas ","enlaces_salientes":["Unidad_central","Unidad_central","Unidad_central","Idioma_ingl%C3%A9s","Computadora","Censo_(estad%C3%ADstica)","Estad%C3%ADstica","Sistema_de_planificaci%C3%B3n_de_recursos_empresariales","Servidor","Estaci%C3%B3n_de_trabajo","Computadora_personal","CPU","Terminal_tonta","Sistema_operativo","Computadora_personal","Escalabilidad","Escalabilidad","Computadora_personal","Terminal_tonta","IBM","Burroughs_Corporation","Control_Data","General_Electric","Honeywell","NCR","RCA","Univac","Telefunken","Siemens_AG","Olivetti","Bull","1986","Unisys","1991","AT%26T","Microcomputadora","1990","GNU/Linux","Supercomputadora","Terminal_inteligente","Computadora_personal","Microcomputadora","Minicomputadora","Supercomputadora","Computadora_port%C3%A1til","Computadora_de_escritorio","Red_de_computadoras","Servidor","Cliente_(inform%C3%A1tica)","Hardware","ISBN","Control_de_autoridades","Gemeinsame_Normdatei","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Medical_Subject_Headings"]}
{"url":"IBM_704","titulo":"IBM 704","contenido":"La maquina IBM 704 fue la primera computadora producida en masa con hardware basado en aritmetica de coma flotante, introducida por IBM en abril de 1954. La 704 mejoro significativamente a la IBM 701, y en terminos de arquitectura e implementacion se puede decir que no fue compatible con su predecesora.  Los cambios con respecto a la 701 incluyen el uso de memoria de nucleos (en lugar de los tubos Williams) y la adicion de tres registros indice. Para respaldar estas nuevas caracteristicas, las instrucciones fueron expandidas para usar completamente expresiones de 36 bit. El nuevo conjunto de instrucciones se convirtio en la base para la serie IBM 700/7000 de computadoras cientificas.  IBM afirmo que el dispositivo era capaz de ejecutar mas de 40\u00a0000 instrucciones por segundo. IBM vendio 123 sistemas tipo 704 desde 1955 hasta 1960.  Fueron inicialmente desarrollados para la 704 los lenguajes de programacion FORTRAN y LISP, asi como el MUSIC 1, que se puede decir es el primer programa de musica para computadora, de Max Mathews.  En 1961 el matematico del MIT Edward O. Thorp uso la IBM 704 para descubrir primero y resolver despues, la razon por la que el Blackjack no es un juego cien por ciento de azar.\u200b Nacia el conteo de cartas. Lo que descubrio Thorp era que cuantas mas cartas bajas salgan, mas ventajas tiene el jugador y a mayor numero de cartas altas, mas ventajas tiene la banca. El libro Beat the Dealer (1966) descubria el metodo completo y provocaba el terror entre los casinos de Las Vegas y Reno en EE. UU. Curiosamente Thorp no jugaba al BlackJack; tuvo que aprender, y su experimento de campo solo duro un fin de semana en los casinos para demostrar que tenia razon. Invirtio 10\u00a0000 dolares y gano 21\u00a0000 dolares, unos 70\u00a0000 dolares de hoy.  En 1962 el fisico John Larry Kelly, Jr creo uno de los mas famosos eventos en la historia de Bell Labs al usar una IBM 704 para sintetizar el habla. El sintetizador de voz vocoder recreo la cancion \u00abDaisy Bell\u00bb, con acompa\u00f1amiento musical de Max Mathews. Arthur C. Clarke, autor de la novela y del guion de la pelicula 2001: A Space Odyssey, hizo famoso a M. Mathew y a su colega John Pierce, ya que en una visita a los edificios de los Bell Labs Murray Hill le ense\u00f1aron una aplicacion que demostraba la sintesis de voz, inspirando una de las ultimas escenas de la pelicula,\u200b donde HAL 9000, la computadora de a bordo de la nave espacial, canta la misma cancion.\u200b ","snippet":"La maquina IBM 704 fue la primera computadora producida en masa con hardware basado en aritmetica de coma flotante, introducida por IBM en abril de 1954. La 704 mejoro significativamente a la IBM 701,","enlaces_salientes":["IBM_704","IBM_704","IBM_704","Aeron%C3%A1utica","Coma_flotante","Computadora","Coma_flotante","IBM","1954","IBM_701","Memoria_de_toros","Tubos_Williams","Registro_%C3%ADndice","Conjunto_de_instrucciones","IBM_700/7000","1955","1960","Lenguaje_de_programaci%C3%B3n","Fortran","LISP","1961","Instituto_Tecnol%C3%B3gico_de_Massachusetts","Edward_O._Thorp","Blackjack","Juego","Conteo_de_cartas","Las_Vegas","Reno","Estados_Unidos_de_Am%C3%A9rica","Bell_Labs","Vocoder","Daisy_Bell","Arthur_C._Clarke","S%C3%ADntesis_de_voz","HAL_9000","Discovery_channel","MIT_Press","Wayback_Machine","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lois_Haibt","titulo":"Lois Haibt","contenido":"Lois Mitchell Haibt (Chicago, 1934) es una informatica estadounidense conocida por ser miembro del equipo de diez personas de IBM que desarrollo  FORTRAN, el primer lenguaje de programacion de alto nivel exitoso. Es conocida como una de las primeras pioneras en informatica.  Haibt estudio matematicas en Vassar College con una beca academica. Se graduo con una licenciatura en 1955. Mientras estaba en Vassar, Haibt trabajo en Bell Laboratories durante el verano.\u200b  Inmediatamente despues de graduarse de Vassar, Haibt comenzo a trabajar en IBM.\u200b  Comenzo con un salario anual de 5.100 dolares, a pesar de su falta de experiencia previa en programacion. Esta suma era casi el doble de la cantidad que habria ganado en los Laboratorios Bell. Haibt infirio que cualquier trabajo con un salario tan alto seria dificil, pero fascinante.\u200b Era parte de un equipo academico diverso de diez jovenes con diferentes grados academicos y areas de experiencia no relacionadas, como la cristalografia y la criptografia. La experiencia con las matematicas era su unica conexion comun.\u200b Haibt era la unica mujer del equipo.\u200b  Segun Haibt, el equipo trabajo bien junto: \"Nadie estaba preocupado por parecer estupido o posesivo de su codigo. Todos estabamos aprendiendo juntos\".\u200b El equipo de FORTRAN trabajo horas no tradicionales para poder tener acceso ilimitado a la computadora IBM 704.\u200b Con frecuencia alquilaban habitaciones en el cercano Hotel Langdon para dormir durante el dia y trabajar de noche.\u200b  En 1957, Haibt asistio a la Universidad de Columbia.\u200b  Haibt es miembro de la Mathematical Association of America.\u200b  El equipo de IBM paso casi tres a\u00f1os creando el lenguaje de programacion  FORTRAN, que reformo la forma en que las personas comunican las instrucciones a las computadoras.\u200b  Haibt estaba a cargo de la seccion cuatro del proyecto FORTRAN.\u200b Analizaba el flujo de programas producidos por otras secciones del compilador.\u200b Sus estimaciones de flujo en areas de alto trafico de la computadora se obtenian calculando con que frecuencia se ejecutarian los bloques basicos del programa. Haibt empleo el Metodo de Montecarlo (analisis estadistico) para estos calculos.\u200b A traves de este proceso, tambien creo el primer analizador sintactico.\u200b Haibt planeo y programo toda la seccion.\u200b Haibt tambien formo parte de un equipo de once personas para desarrollar y lanzar el primer manual de referencia para FORTRAN en 1956.\u200b  Lois Haibt se caso con Luther Haibt (4 de mayo de 1929 - 3 de diciembre de 2000), analista de sistemas de IBM en Thornwood (Nueva York).\u200b Los Haibts pasaron su vida adulta en el estado de Nueva York. La hija de Haibt, Carolyn, asistio a la Universidad de Princeton para obtener su licenciatura y luego recibio un doctorado en matematicas por el Instituto de Tecnologia de Massachusetts.\u200b Los pasatiempos de Haibt incluyen la decoracion de interiores y la lectura.\u200b ","snippet":"Lois Mitchell Haibt (Chicago, 1934) es una informatica estadounidense conocida por ser miembro del equipo de diez personas de IBM que desarrollo  FORTRAN, el primer lenguaje de programacion de alto ni","enlaces_salientes":["Lois_Haibt","Lois_Haibt","Lois_Haibt","Chicago","Estados_Unidos","Vassar_College","Inform%C3%A1tico_te%C3%B3rico","Ciencias_de_la_computaci%C3%B3n","IBM","Inform%C3%A1tica","Estadounidense","IBM","Fortran","Lenguaje_de_programaci%C3%B3n","Vassar_College","Bell_Laboratories","D%C3%B3lares","IBM_704","Universidad_de_Columbia","Mathematical_Association_of_America","Fortran","Compilador","M%C3%A9todo_de_Montecarlo","Analizador_sint%C3%A1ctico","Thornwood_(Nueva_York)","Universidad_de_Princeton","Instituto_de_Tecnolog%C3%ADa_de_Massachusetts","ISBN","ISBN","ISSN","Digital_object_identifier","ISSN","Control_de_autoridades"]}
{"url":"1956","titulo":"1956","contenido":"1956 (MCMLVI) fue un a\u00f1o bisiesto comenzado en domingo segun el calendario gregoriano. ","snippet":"1956 (MCMLVI) fue un a\u00f1o bisiesto comenzado en domingo segun el calendario gregoriano. ","enlaces_salientes":["1956","1956","1956","1953","1954","1955","1957","1958","1959","D%C3%A9cada","A%C3%B1os_1920","A%C3%B1os_1930","A%C3%B1os_1940","A%C3%B1os_1950","A%C3%B1os_1960","A%C3%B1os_1970","A%C3%B1os_1980","Siglo","Siglo_XIX","Siglo_XX","Siglo_XXI","2023","Calendario_gregoriano","Ab_Urbe_condita","Calendario_armenio","Calendario_chino","Calendario_hebreo","Calendario_hind%C3%BA","Vikram_Samvat","Shaka_Samvat","Calendario_persa","Calendario_musulm%C3%A1n","Elvis_Presley","Rock_and_roll","Colisi%C3%B3n_a%C3%A9rea_en_el_Gran_Ca%C3%B1%C3%B3n_de_1956","Masacre_de_Jan_Yunis","Guerra_del_Sina%C3%AD","Ronald_William_Clarke","Juegos_Ol%C3%ADmpicos_de_Melbourne_1956","Revoluci%C3%B3n_h%C3%BAngara_de_1956","Protestas_de_Pozna%C5%84_de_1956","Cu%C3%A1druplex","Digital_Video","Numeraci%C3%B3n_romana","Calendario_gregoriano","1_de_enero","Sud%C3%A1n","Reino_Unido","3_de_enero","Pek%C3%ADn","Mosc%C3%BA","Ferrocarril_transiberiano","Ul%C3%A1n_Bator","Irkutsk","6_de_enero","Argentina","Universidad_Nacional_del_Sur","8_de_enero","R%C3%ADo_Curaray","Misioneros","Protestantismo_evang%C3%A9lico","Estadounidenses","Ind%C3%ADgenas","Huaorani","11_de_enero","Estados_Unidos","Espa%C3%B1a","OTAN","12_de_enero","Hungr%C3%ADa","18_de_enero","Sitio_de_pruebas_nucleares_de_Nevada","Project_56","Plutonio","21_de_enero","Uruguay","1_de_febrero","Europa","Ola_de_fr%C3%ADo","Continente","6_de_febrero","Estados_Unidos","Protestas","7_de_febrero","Vuelta_a_Andaluc%C3%ADa","Pedro_Eugenio_Aramburu","10_de_febrero","Socialistas","Comunistas","Reg%C3%ADmenes_de_excepci%C3%B3n","Espa%C3%B1a","11_de_febrero","Bolivia","Voto_(elecciones)","Amerindio","Mujer","Militar","Rep%C3%BAblica_Popular_China","Europa","Castell%C3%B3n_de_la_Plana","Europea","Grados_Celsius","Colombia","Expreso_Bolivariano","13_de_febrero","15_de_febrero","Finlandia","Urho_Kekkonen","Presidente_de_Finlandia","Montevideo","Selecci%C3%B3n_de_futbol_de_Uruguay","16_de_febrero","Francisco_Franco","20_de_febrero","Grecia","Constantinos_Karamanl%C3%ADs","25_de_febrero","Mosc%C3%BA","XX_Congreso_del_PCUS","Partido_Comunista_de_la_Uni%C3%B3n_Sovi%C3%A9tica","Nikita_Jrushchov","Discurso_Secreto","Stalin","2_de_marzo","Marruecos","Francia","16_de_marzo","El_L%C3%ADbano","20_de_marzo","T%C3%BAnez","Francia","23_de_marzo","Pakist%C3%A1n","Hungr%C3%ADa","L%C3%A1szl%C3%B3_Rajk","1949","29_de_marzo","Estoril","Portugal","Alfonso_de_Borb%C3%B3n_y_Borb%C3%B3n-Dos_Sicilias","Juan_Carlos_I_de_Espa%C3%B1a","1_de_abril","Guerra_de_Marruecos","2_de_abril","Gran_cruz_de_la_Orden_de_Isabel_la_Cat%C3%B3lica","Jos%C3%A9_Mar%C3%ADa_Escriv%C3%A1_de_Balaguer","Opus_Dei","7_de_abril","Marruecos","16_de_abril","M%C3%B3naco","Grace_Kelly","Rainiero_III_de_M%C3%B3naco","19_de_abril","Albolote","Torre_Latinoamericana","30_de_abril","M%C3%A9xico","Torre_Latinoamericana","Operaci%C3%B3n_Redwing","4_de_mayo","Atol%C3%B3n_Eniwetak","Islas_Marshall","Bomba_at%C3%B3mica","Kilotones","Operaci%C3%B3n_Redwing","16_de_mayo","Club_de_Par%C3%ADs","Argentina","D%C3%B3lares_estadounidenses","20_de_mayo","Atol%C3%B3n_Bikini","Cheroqui","Kilotones","Bomba_de_hidr%C3%B3geno","24_de_mayo","Lugano","Suiza","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Suiza","Lys_Assia","27_de_mayo","Atol%C3%B3n_Bikini","Zu%C3%B1i_(etnia)","Kilotones","Bomba_de_hidr%C3%B3geno","Atol%C3%B3n_Eniwetok","Kilotones","30_de_mayo","Erie_(etnia)","Kilotones","6_de_junio","Atol%C3%B3n_Enewetak","Sem%C3%ADnole_(etnia)","Kilotones","9_de_junio","Jos%C3%A9_Le%C3%B3n_Su%C3%A1rez_(Buenos_Aires)","Gran_Buenos_Aires","Pedro_Eugenio_Aramburu","Peronistas","Fusilamientos_de_Jos%C3%A9_Le%C3%B3n_Su%C3%A1rez","1_de_junio","1970","Montoneros","11_de_junio","Atol%C3%B3n_Bikini","Kilotones","Atol%C3%B3n_Enewetak","12_de_junio","Buenos_Aires","Revoluci%C3%B3n_Libertadora_(Argentina)","Juan_Jos%C3%A9_Valle","13_de_junio","Kickapoo_(etnia)","16_de_junio","Osage_(etnia)","Kilotones","Operaci%C3%B3n_Redwing","18_de_junio","Egipto","21_de_junio","Inca_(etnia)","Kilotones","23_de_junio","Egipto","Gamal_Abdel_Nasser","25_de_junio","Atol%C3%B3n_Bikini","Dakota_(etnia)","Kilotones","28_de_junio","Polonia","Poznan","Estalinista","29_de_junio","Marilyn_Monroe","Arthur_Miller","2_de_julio","Atol%C3%B3n_Enewetak","Mohawk_(etnia)","Kilotones","8_de_julio","Atol%C3%B3n_Bikini","Apache_(etnia)","Kilotones","9_de_julio","Amorgos","Grecia","10_de_julio","Navajo_(etnia)","Kilotones","16_de_julio","Birmania","20_de_julio","Kilotones","21_de_julio","Hur%C3%B3n_(etnia)","Kilotones","Operaci%C3%B3n_Redwing","India","Anjar","25_de_julio","SS_Andrea_Doria","26_de_julio","Egipto","Gamal_Abdel_Nasser","Canal_de_Suez","28_de_julio","Per%C3%BA","Manuel_Prado_Ugarteche","7_de_agosto","Cali","Explosi%C3%B3n_de_Cali","Dinamita","6_de_septiembre","Festival_Internacional_de_Cine_de_Venecia","Calle_Mayor_(pel%C3%ADcula)","Juan_Antonio_Bardem","Betsy_Blair","Jos%C3%A9_Su%C3%A1rez_(actor)","9_de_septiembre","Elvis_Presley","Show_de_Ed_Sullivan","5_de_octubre","Producciones_PUNCH","6_de_octubre","Francisco_Franco","Espa%C3%B1a","Pueblonuevo_del_Guadiana","1948","Plan_Badajoz","19_de_octubre","Estados_Unidos","21_de_octubre","Tegucigalpa_(Honduras)","Julio_Lozano_D%C3%ADaz","23_de_octubre","Revoluci%C3%B3n_H%C3%BAngara_de_1956","24_de_octubre","Managua","Terremoto_de_Nicaragua_de_1956","26_de_octubre","Pacto_de_Varsovia","Hungr%C3%ADa","28_de_octubre","Espa%C3%B1a","Televisi%C3%B3n_Espa%C3%B1ola","29_de_octubre","Israel","Sina%C3%AD","31_de_octubre","Reino_Unido","Francia","Egipto","Canal_de_Suez","2_de_noviembre","Hungr%C3%ADa","Imre_Nagy","Asamblea_General_de_la_ONU","Israel","Sina%C3%AD","Francia","Brit%C3%A1nicos","Egipto","Caracas","Juan_Domingo_Per%C3%B3n","Resistencia_Peronista","John_William_Cooke","6_de_noviembre","Elecciones_presidenciales_de_Estados_Unidos_de_1956","Dwight_D._Eisenhower","Adlai_Stevenson","6_de_noviembre","25_de_noviembre","M%C3%A9xico","Fidel_Castro","Ra%C3%BAl_Castro","Ernesto_%22Che%22_Guevara","T%C3%BAxpam_de_Rodr%C3%ADguez_Cano","Yate_Granma","Revoluci%C3%B3n_cubana","2_de_diciembre","Fidel_Castro","Cuba","7_de_diciembre","Saeta_TV_Canal_10","12_de_diciembre","Jap%C3%B3n","ONU","Francia","Suez","Espa%C3%B1a","ONU","Pacto_de_Varsovia","Hungr%C3%ADa","Base_Amundsen-Scott","Capitol_Records_Building","Welton_Becket","3_de_enero","Eduardo_Pablo_Garc%C3%ADa_Aliverti","Mel_Gibson","4_de_enero","Bernard_Sumner","Poch","6_de_enero","7_de_enero","David_Caruso","9_de_enero","Kimberly_Beck","Imelda_Staunton","Adriana_Xenides_Cutsaimanis","10_de_enero","Antonio_Mu%C3%B1oz_Molina","11_de_enero","Vicente_Mart%C3%ADnez-Pujalte","12_de_enero","Ana_Rosa_Quintana","Nikolai_Noskov","Jaime_Gim%C3%A9nez_Arbe","13_de_enero","Janet_Hubert-Whitten","Alejandro_Carlos_Biondini","14_de_enero","Shamil_Bas%C3%A1yev","Rosina_Lippi-Green","17_de_enero","Lalo_de_los_Santos","Paul_Young","18_de_enero","Christoph_Pr%C3%A9gardien","Crist%C3%B3bal_Jim%C3%A9nez_(m%C3%BAsico)","19_de_enero","Adriana_Acosta","20_de_enero","Rodolfo_Rodr%C3%ADguez","21_de_enero","Johnny_Cecotto","Geena_Davis","23_de_enero","Patricia_Sosa","Juan_Vicente_Herrera","Diego_Ca%C3%B1amero","26_de_enero","Madeleine_Herren","Vicente_Gil_(actor)","31_de_enero","Artur_Mas","2_de_febrero","Carlos_Rubiera_Tuya","3_de_febrero","Hern%C3%A1n_Dar%C3%ADo_G%C3%B3mez","7_de_febrero","Eva_Ayll%C3%B3n","8_de_febrero","Diego_Le%C3%B3n_Hoyos","12_de_febrero","Rosa_Men%C3%A9ndez","13_de_febrero","Peter_Hook","15_de_febrero","Carlos_Totorika","16_de_febrero","Jorginho_Gularte","Eduardo_Vald%C3%A9s","18_de_febrero","Ted_G%C3%A4rdestad","Bidzina_Ivanishvili","Carlos_Rovira","19_de_febrero","Victoria_Vera","22_de_febrero","Gijs_de_Vries","28_de_febrero","Tommy_Remengesau","Bryan_Cranston","7_de_marzo","Bryan_Cranston","11_de_marzo","Rob_Paulsen","12_de_marzo","Steve_Harris","18_de_marzo","Eduardo_Alonso-Crespo","20_de_marzo","Estanislao_Rodr%C3%ADguez-Ponga","24_de_marzo","Steve_Anthony_Ballmer","Miguel_Michelagnoli","31_de_marzo","Jota_Mario_Valencia","2019","3_de_abril","Miguel_Bos%C3%A9","Eduardo_Zaplana","Ricardo_Iniesta","4_de_abril","Norma_Duval","David_E._Kelley","Carmen_Mej%C3%ADa_Ruiz","6_de_abril","Michele_Bachmann","Sebasti%C3%A1n_Spreng","12_de_abril","Andy_Garc%C3%ADa","Walter_Salles","15_de_abril","Monique_Loudieres","16_de_abril","David_McDowell_Brown","18_de_abril","Eric_Roberts","Julia_Roberts","20_de_abril","%C3%81ngel_Aguirre_Rivero","Prudencio_Norales","26_de_abril","Imanol_Arias","30_de_abril","Jorge_Chamin%C3%A9","Lars_von_Trier","4_de_mayo","Alejandro_Escudero","Victor_Pi%C5%A3urc%C4%83","10_de_mayo","Paige_O%27Hara","13_de_mayo","Roberto_%C3%81lvarez","17_de_mayo","Bob_Saget","25_de_mayo","Carlos_Lavado","28_de_mayo","Sayuri_Yamauchi","1_de_junio","Amanda_Miguel","Sa%C3%BAl_Lisazo","2_de_junio","Jan_Lammers","6_de_junio","Bj%C3%B6rn_Borg","Carlos_Gattiker","Bubbi_Morthens","9_de_junio","Joaqu%C3%ADn_Alonso","10_de_junio","Juan_Carlos_Massei","11_de_junio","Lucero_G%C3%B3mez","14_de_junio","Gianna_Nannini","18_de_junio","22_de_junio","Manuel_Saval","23_de_junio","Glenn_Danzig","Anthony_Bourdain","25_de_junio","Anthony_Bourdain","29_de_junio","Pedro_Omar_Caino","2_de_julio","Jerry_Hall","Ruben_Chauque","3_de_julio","Min_Aung_Hlaing","4_de_julio","Carlos_Ysbert","5_de_julio","Horacio_Cartes","9_de_julio","Tom_Hanks","11_de_julio","Sela_Ward","14_de_julio","Julio_Ch%C3%A1vez","15_de_julio","Ian_Curtis","Joe_Satriani","22_de_julio","Manuel_Alberto_Le%C3%B3n","2015","23_de_julio","Hansel_Camacho","31_de_julio","Adri%C3%A1n_Abonizio","Laura_Zapata","Michael_Biehn","1_de_agosto","Tom_Leykis","2_de_agosto","Isabel_Pantoja","5_de_agosto","Gregorio_Manzano","6_de_agosto","Ricardo_Jerez_Hidalgo","7_de_agosto","Sa%C3%ADn_Castro","Leticia_Perdig%C3%B3n","Cecilia_Roth","8_de_agosto","Jorge_Larra%C3%B1aga","Partido_Nacional_(Uruguay)","10_de_agosto","Alejandro_Nava","17_de_agosto","Fabio_Armiliato","20_de_agosto","Joan_Allen","21_de_agosto","Jos%C3%A9_Juli%C3%A1n_Sacramento_Garza","23_de_agosto","Cris_Morena","Fernando_Botero_Zea","25_de_agosto","Paulo_Autuori","Isaura_Espinoza","31_de_agosto","Masashi_Tashiro","Shir%C5%8D_Sait%C5%8D","5_de_septiembre","Pilar_Casta%C3%B1o","7_de_septiembre","Diana_Warren","8_de_septiembre","Stefan_Johansson","16_de_septiembre","David_Copperfield","17_de_septiembre","Max_(artista)","18_de_septiembre","Gonzalo_Navarrete","19_de_septiembre","Amparo_Grisales","20_de_septiembre","Gary_Cole","26_de_septiembre","Linda_Hamilton","27_de_septiembre","Antonio_S%C3%A1nchez_Pacheco","1_de_octubre","Theresa_May","Len_Brown","2_de_octubre","Javier_G%C3%B3mez_(actor)","4_de_octubre","Christoph_Waltz","8_de_octubre","Stephanie_Zimbalist","Carmen_Marina_Torres","2015","11_de_octubre","Nicanor_Duarte_Frutos","13_de_octubre","Chris_Carter","14_de_octubre","Carlos_Aragon%C3%A9s","15_de_octubre","Jaime_David_Fern%C3%A1ndez_Mirabal","Peter_Caruana","18_de_octubre","Craig_Bartlett","Michael_Lesch","Claudio_Ra%C3%BAl_Lozano","Martina_Navratilova","20_de_octubre","Danny_Boyle","Eduardo_Rergis","21_de_octubre","Carrie_Fisher","2016","26_de_octubre","Rita_Wilson","28_de_octubre","Mahmud_Ahmadineyad","Franky_Vercauteren","Volker_Zotz","29_de_octubre","Wilfredo_G%C3%B3mez","Bernardo_del_Rosal_Blasco","30_de_octubre","Juliet_Stevenson","7_de_noviembre","Mercedes_Chaves_Jaime","9_de_noviembre","Joaqu%C3%ADn_Mbom%C3%ADo_Bacheng","13_de_noviembre","Vinicio_Mu%C3%B1oz","21_de_noviembre","Jos%C3%A9_Ram%C3%B3n_de_la_Morena","26_de_noviembre","Luis_Fernando_Montoya_(actor)","2018","29_de_noviembre","Jorge_Telerman","1_de_diciembre","Carlos_C%C3%A1mara_Jr.","David_Ostrosky","2023","2_de_diciembre","Steven_Bauer","5_de_diciembre","Krystian_Zimerman","6_de_diciembre","Peter_Buck","7_de_diciembre","Larry_Bird","Iveta_Radi%C4%8Dov%C3%A1","8_de_diciembre","Pierre_Pincemaille","2018","9_de_diciembre","Jean-Pierre_Thiollet","17_de_diciembre","Ronald_Melzer","2013","18_de_diciembre","Vilma_Vera","19_de_diciembre","Jens_Fink-Jensen","21_de_diciembre","Walter_Oyarce_Delgado","23_de_diciembre","Dave_Murray","Jes%C3%BAs_Huerta_de_Soto","Michele_Alboreto","24_de_diciembre","Delfina_Acosta","25_de_diciembre","Francesca_Gargallo","2022","30_de_diciembre","Claudia_Di_Gir%C3%B3lamo","31_de_diciembre","Delano_Rigters","Carol_Prunhuber","Emilio_Bender","Mirtha_Rivero","Ofelia_Rey_Castelao","Ricardo_Alfonso_Cerna","M%C3%B3nica_Agudelo","3_de_enero","Alexander_Gretchaninov","1864","Joseph_Wirth","1879","5_de_enero","Mistinguett","1875","31_de_enero","A._A._Milne","1882","14_de_febrero","Jos%C3%A9_Mar%C3%ADa_Vargas_Pacheco","1874","17_de_marzo","Ir%C3%A8ne_Joliot-Curie","1935","1897","29_de_marzo","Alfonso_de_Borb%C3%B3n_y_Borb%C3%B3n-Dos_Sicilias","1941","15_de_abril","Emil_Nolde","1867","19_de_abril","Ernst_Robert_Curtius","1886","30_de_abril","Alben_W._Barkley","1877","6_de_mayo","Fergus_Anderson","1909","11_de_mayo","Eugenio_Baroffio","1877","15_de_mayo","Magdalena_Aulina_Saurina","1897","Austin_Osman_Spare","1886","7_de_junio","Julien_Benda","8_de_junio","Marie_Laurencin","17_de_junio","Bob_Sweikert","1926","8_de_julio","Giovanni_Papini","11_de_agosto","Jackson_Pollock","12_de_agosto","Giampiero_Combi","14_de_agosto","Bertolt_Brecht","Konstantin_von_Neurath","16_de_agosto","B%C3%A9la_Lugosi","21_de_agosto","Juan_Jos%C3%A9_de_Am%C3%A9zaga","1881","24_de_agosto","Kenji_Mizoguchi","19_de_septiembre","Helios_G%C3%B3mez","22_de_septiembre","Frederick_Soddy","27_de_septiembre","Gerald_Finzi","28_de_septiembre","William_E._Boeing","29_de_septiembre","Anastasio_Somoza_Garc%C3%ADa","12_de_octubre","Lorenzo_Perosi","1872","26_de_octubre","Walter_Gieseking","1895","30_de_octubre","P%C3%ADo_Baroja","1872","12_de_noviembre","Juan_Negr%C3%ADn","23_de_noviembre","Andr%C3%A9_Marty","25_de_noviembre","Alexandr_Dovzhenko","3_de_diciembre","Cow_Cow_Davenport","Alexander_Rodchenko","19_de_diciembre","Montagu_Slater","6_de_enero","Jos%C3%A9_Luis_Mart%C3%ADn_Descalzo","Premio_Nadal","Robert_A._Heinlein","Isaac_Asimov","El_sol_desnudo","Albert_Camus","La_ca%C3%ADda_(novela)","Agatha_Christie","El_templete_de_Nasse-House","Arthur_C._Clarke","La_ciudad_y_las_estrellas","Philip_K._Dick","El_informe_de_la_minor%C3%ADa","Ian_Fleming","Diamantes_para_la_eternidad_(novela)","Naguib_Mahfuz","Entre_dos_palacios","Jo%C3%A3o_Guimar%C3%A3es_Rosa","C._S._Lewis","La_%C3%BAltima_batalla","Eugene_O%27Neill","Largo_viaje_hacia_la_noche","Allen_Ginsberg","Aullido_(poema)","Gerald_Durrell","Mi_familia_y_otros_animales","Carl_Gustav_Jung","Mysterium_coniunctionis","Claudio_S%C3%A1nchez_Albornoz","Louis_Fraser","Lagenodelphis_hosei","Atraco_perfecto","Stanley_Kubrick","Gigante_(pel%C3%ADcula_de_1956)","George_Stevens","Rock_Hudson","Elizabeth_Taylor","James_Dean","La_vuelta_al_mundo_en_ochenta_d%C3%ADas_(pel%C3%ADcula_de_1956)","Michael_Anderson_(director)","David_Niven","Cantinflas","Shirley_MacLaine","Robert_Newton","Moby_Dick_(pel%C3%ADcula)","John_Huston","Gregory_Peck","Novela","Moby-Dick","Herman_Melville","Juegos_Ol%C3%ADmpicos_de_1956","Melbourne","Australia","Uni%C3%B3n_Sovi%C3%A9tica_en_los_Juegos_Ol%C3%ADmpicos_de_Melbourne_1956","Estados_Unidos_en_los_Juegos_Ol%C3%ADmpicos_de_Melbourne_1956","Australia_en_los_Juegos_Ol%C3%ADmpicos_de_Melbourne_1956","Juegos_Ol%C3%ADmpicos_de_Cortina_d%27Ampezzo_1956","Cortina_d%27Ampezzo","Italia","Uni%C3%B3n_Sovi%C3%A9tica_en_los_Juegos_Ol%C3%ADmpicos_de_Cortina_d%27Ampezzo_1956","Austria_en_los_Juegos_Ol%C3%ADmpicos_de_Cortina_d%27Ampezzo_1956","Finlandia_en_los_Juegos_Ol%C3%ADmpicos_de_Cortina_d%27Ampezzo_1956","Liga_de_B%C3%A9isbol_Profesional_de_la_Rep%C3%BAblica_Dominicana","Leones_del_Escogido","%C3%81guilas_Cibae%C3%B1as","Juan_Manuel_Fangio","Lista_de_campeones_de_F%C3%B3rmula_1","Liga_de_Campeones_de_la_UEFA","Real_Madrid_Club_de_F%C3%BAtbol","Campeonato_Uruguayo_de_F%C3%BAtbol","Club_Nacional_de_Football","F%C3%BAtbol_Profesional_Colombiano","Corporaci%C3%B3n_Deportes_Quind%C3%ADo","Primera_divisi%C3%B3n_B_chilena","Club_Deportivo_Universidad_Cat%C3%B3lica_(f%C3%BAtbol)","Primera_Divisi%C3%B3n_del_Per%C3%BA","Club_Sporting_Cristal","Pel%C3%A9","Campeonato_mundial_A_de_hockey_patines_masculino_de_1968","Oporto","Selecci%C3%B3n_de_hockey_pat%C3%ADn_masculino_de_Portugal","Selecci%C3%B3n_de_hockey_pat%C3%ADn_masculino_de_Espa%C3%B1a","Selecci%C3%B3n_de_hockey_pat%C3%ADn_masculino_de_Italia","Campeonato_Sudamericano_de_Hockey_sobre_Patines","Selecci%C3%B3n_masculina_de_hockey_pat%C3%ADn_de_Chile","Uruguay","Brasil","Campeonato_Sudamericano_de_Nataci%C3%B3n","Vi%C3%B1a_del_Mar","Chile","Argentina","Abierto_de_Australia","Frank_Sedgman","Abierto_de_Estados_Unidos","Shirley_Fry","Ken_Rosewall","Campeonato_de_Wimbledon","Shirley_Fry","Lew_Hoad","Torneo_de_Roland_Garros","Althea_Gibson","Lew_Hoad","Campeonato_Mundial_de_Voleibol_Masculino_de_1956","Checoslovaquia","Rumania","Uni%C3%B3n_Sovi%C3%A9tica","Campeonato_Sudamericano_de_Voleibol_Masculino","Uruguay","Brasil","Uruguay","Paraguay","Campeonato_Sudamericano_de_Voleibol_Femenino_de_1956","Uruguay","Brasil","Uruguay","Per%C3%BA","Elvis_Presley","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Sanremo","Aretha_Franklin","Buddy_Holly","Blue_Days,_Black_Nights","Frank_Sinatra","Songs_for_Swingin%27_Lovers!","Capitol_Records","Capitol_Records_Building","Capitol_Records","24_de_mayo","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n_1956","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Lugano","Suiza","Lys_Assia","Refrain","Suiza_en_el_Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Televisi%C3%B3n_en_1956","28_de_octubre","Televisi%C3%B3n_Espa%C3%B1ola","7_de_diciembre","Televisi%C3%B3n","Uruguay","Saeta_TV_Canal_10","Premio_Nobel","William_Bradford_Shockley","John_Bardeen","Walter_Houser_Brattain","Sir_Cyril_Norman_Hinshelwood","Nikolay_Nikolaevich_Semenov","Premio_Nobel_de_Medicina","Andr%C3%A9_Fr%C3%A9d%C3%A9ric_Cournand","Werner_Forssmann","Dickinson_W._Richards","Juan_Ram%C3%B3n_Jim%C3%A9nez","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Abril","titulo":"Abril","contenido":"En el calendario gregoriano, abril es el cuarto mes del a\u00f1o y es uno de los cuatro meses que tienen 30 dias. Era el segundo mes del a\u00f1o en el antiguo calendario romano antes de que el rey Numa Pompilio a\u00f1adiera a enero y febrero alrededor del 700\u00a0a.\u00a0C. Los antiguos romanos lo llamaban aprilis, en latin.  No se conoce exactamente el origen de la palabra \u00ababril\u00bb. Se ha querido relacionar con el verbo aperire (\u2018abrir\u2019), por la supuesta forma aperilis, asociandolo a que en este mes la primavera abre la tierra, las flores, etc. Ovidio se une a esta idea; pero no hay fundamento etimologico que lo sustente.  Tambien se ha propuesto como origen el griego aphros ('espuma') a traves de la forma aphrilis. Este nombre guarda un parecido con Aphrodite, palabra griega que lleva dentro la palabra espuma y significa Afrodita, el nombre griego de una diosa mitologica, que los romanos llamaban Venus.\u200b  Abril se inicia el mismo dia de la semana que julio todos los a\u00f1os, y que enero en los a\u00f1os bisiestos. Abril termina el mismo dia de la semana que diciembre cada a\u00f1o.  Abril, Aprilis, derivada de aperire que significa abrir, porque en este mes la tierra abre su seno para empezar a producir las flores y los frutos, esta bajo la proteccion de Venus y se ha representado en un hombre en actitud de bailar al sonido de un instrumento. Segun Ausonio, Abril hace sus honores a Venus ce\u00f1ida con mirto.  En este mes se percibe la luz mezclada con el humo que despiden los inciensos para festejar a la benefica Ceres. La antorcha colocada al lado de Abril oscila sus llamas entremezcladas con suavisimos olores. Los ambientes perfumados, los aromas exquisitos y los balsamos voluptuosos componen siempre el sequito y comitiva de la diosa Pafos. Abril segundo mes del a\u00f1o de Romulo, es el que Ovidio nombra... Venerisque secundus.\u200b ","snippet":"En el calendario gregoriano, abril es el cuarto mes del a\u00f1o y es uno de los cuatro meses que tienen 30 dias. Era el segundo mes del a\u00f1o en el antiguo calendario romano antes de que el rey Numa Pompili","enlaces_salientes":["Abril","Abril","Abril","Enero","Febrero","Marzo","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre","2023","Numeraci%C3%B3n_romana","Marzo","Mayo","Semana","Lunes","Martes","Mi%C3%A9rcoles","Jueves","Viernes","S%C3%A1bado","Domingo","27_de_marzo","28_de_marzo","29_de_marzo","30_de_marzo","31_de_marzo","1_de_abril","2_de_abril","3_de_abril","4_de_abril","5_de_abril","6_de_abril","7_de_abril","8_de_abril","9_de_abril","10_de_abril","11_de_abril","12_de_abril","13_de_abril","14_de_abril","15_de_abril","16_de_abril","17_de_abril","18_de_abril","19_de_abril","20_de_abril","21_de_abril","22_de_abril","23_de_abril","24_de_abril","25_de_abril","26_de_abril","27_de_abril","28_de_abril","29_de_abril","30_de_abril","Noviembre","Calendario_gregoriano","Mes","A%C3%B1o","D%C3%ADas","Calendario_romano","Numa_Pompilio","Enero","Febrero","Ovidio","Afrodita","Venus_(mitolog%C3%ADa)","Las_muy_ricas_horas_del_duque_de_Berry","1_de_abril","Guerra_civil_espa%C3%B1ola","2_de_abril","D%C3%ADa_Mundial_de_Concienciaci%C3%B3n_sobre_el_Autismo","2_de_abril","Argentina","Guerra_de_las_Malvinas","2_de_abril","1867","Segunda_Intervenci%C3%B3n_Francesa_en_M%C3%A9xico","Porfirio_D%C3%ADaz","Batalla_de_Puebla","2_de_abril","2005","Ciudad_del_Vaticano","Juan_Pablo_II","3_de_abril","1905","Buenos_Aires","Club_Atl%C3%A9tico_Boca_Juniors","5_de_abril","1818","Chile","Batalla_de_Maip%C3%BA","Jos%C3%A9_San_Mart%C3%ADn","7_de_abril","D%C3%ADa_Mundial_de_la_Salud","7_de_abril","1889","Gabriela_Mistral","Premio_Nobel_de_Literatura","8_de_abril","1994","Nirvana_(banda)","Kurt_Cobain","5_de_abril","8_de_abril","Club_The_Strongest","La_Paz_(Bolivia)","9_de_abril","1948","Bogot%C3%A1","Colombia","Jorge_Eli%C3%A9cer_Gait%C3%A1n","El_Bogotazo","10_de_abril","1892","Jos%C3%A9_Mart%C3%AD","Partido_Revolucionario_Cubano","10_de_abril","1919","Emiliano_Zapata","11_de_abril","1856","Batalla_de_Rivas_(11_de_abril_de_1856)","Costa_Rica","William_Walker","Juan_Santamar%C3%ADa","11_de_abril","2002","Golpe_de_Estado_en_Venezuela_de_2002","Venezuela","Golpe_de_Estado_en_Venezuela_de_2002#El_Golpe","Hugo_Ch%C3%A1vez","13_de_abril","12_de_abril","1961","Yuri_Aleks%C3%A9yevich_Gagarin","14_de_abril","1931","Segunda_Rep%C3%BAblica_Espa%C3%B1ola","14_de_abril","2003","Proyecto_Genoma_Humano","15_de_abril","1452","Leonardo_Da_Vinci","15_de_abril","1912","RMS_Titanic","Iceberg","15_de_abril","1957","Pedro_Infante","16_de_abril","1930","Jos%C3%A9_Carlos_Mari%C3%A1tegui","16_de_abril","2007","Masacre_de_Virginia_Tech","16_de_abril","2016","Escala_de_Richter","Esmeraldas","Manab%C3%AD","17_de_abril","2014","Premio_Nobel_de_Literatura","Gabriel_Garc%C3%ADa_M%C3%A1rquez","18_de_abril","1955","Albert_Einstein","19_de_abril","1810","Independencia_de_Venezuela","19_de_abril","1825","Treinta_y_Tres_Orientales","Juan_Antonio_Lavalleja","Provincia_Oriental","Uruguay","19_de_abril","1925","Club_Social_y_Deportivo_Colo-Colo","Chile","19_de_abril","D%C3%ADa_de_la_Bicicleta","20_de_abril","1889","Adolf_Hitler","20_de_abril","1999","Colorado_(estado)","Estados_Unidos","Masacre_de_la_Escuela_Secundaria_de_Columbine","21_de_abril","1792","Ouro_Preto","Brasil","Tiradentes","21_de_abril","1937","Club_Deportivo_Universidad_Cat%C3%B3lica","Chile","22_de_abril","1945","Berl%C3%ADn","Segunda_Guerra_Mundial","22_de_abril","1970","D%C3%ADa_Internacional_de_la_Madre_Tierra","23_de_abril","1521","Guerra_de_las_Comunidades_de_Castilla","Batalla_de_Villalar","Carlos_I_de_Espa%C3%B1a","24_de_abril","23_de_abril","1616","Miguel_de_Cervantes","Premio_Cervantes","1976","23_de_abril","1616","Inca_Garcilaso_de_la_Vega","23_de_abril","1616","William_Shakespeare","23_de_abril","1995","Unesco","D%C3%ADa_Internacional_del_Libro","24_de_abril","1990","Telescopio_Espacial_Hubble","25_de_abril","1707","Felipe_V_de_Borb%C3%B3n","Carlos_VI_del_Sacro_Imperio_Romano_Germ%C3%A1nico","Batalla_de_Almansa","1974","Portugal","Revoluci%C3%B3n_de_los_Claveles","Corporativismo","Ant%C3%B3nio_de_Oliveira_Salazar","A%C3%B1os_1920","Marcelo_Caetano","26_de_abril","1986","Central_nuclear_de_Chern%C3%B3bil","Ucrania","Accidente_nuclear_de_Fukushima_I","27_de_abril","1927","Chile","Carabineros_de_Chile","Carlos_Ib%C3%A1%C3%B1ez_del_Campo","27_de_abril","D%C3%ADa_Mundial_del_Dise%C3%B1o","28_de_abril","1945","Benito_Mussolini","29_de_abril","D%C3%ADa_Internacional_de_la_Danza","29_de_abril","2004","General_Motors","Oldsmobile","30_de_abril","1945","Adolf_Hitler","Eva_Braun","Berl%C3%ADn","D%C3%ADa_del_Ni%C3%B1o","M%C3%A9xico","30_de_abril","D%C3%ADa_del_Maestro","30_de_abril","1_de_mayo","Noche_de_Walpurgis","30_de_abril","D%C3%ADa_del_ni%C3%B1o","M%C3%A9xico","Iglesia_cat%C3%B3lica","Eucarist%C3%ADa","Esp%C3%ADritu_Santo","Divina_Misericordia","Venus_(mitolog%C3%ADa)","Ausonio","Ceres_(mitolog%C3%ADa)","Pafos","R%C3%B3mulo","Ovidio","Antena_3","Organizaci%C3%B3n_de_las_Naciones_Unidas","Organizaci%C3%B3n_de_las_Naciones_Unidas","FIFA","RT","Discovery_Channel","FIFA","Organizaci%C3%B3n_de_las_Naciones_Unidas","Canal_Historia","Wikcionario","Control_de_autoridades","Wikcionario","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Wikcionario"]}
{"url":"1957","titulo":"1957","contenido":"1957 (MCMLVII) fue un a\u00f1o comun comenzado en martes segun el calendario gregoriano.  Tambien la direccion de la Federacion Internacional de Voleibol tuvo ocasion en presentar un torneo en Sofia en el a\u00f1o 1957, durante la sesion del Comite Olimpico Internacional. ","snippet":"1957 (MCMLVII) fue un a\u00f1o comun comenzado en martes segun el calendario gregoriano.  Tambien la direccion de la Federacion Internacional de Voleibol tuvo ocasion en presentar un torneo en Sofia en el ","enlaces_salientes":["1957","1957","1957","1954","1955","1956","1958","1959","1960","D%C3%A9cada","A%C3%B1os_1920","A%C3%B1os_1930","A%C3%B1os_1940","A%C3%B1os_1950","A%C3%B1os_1960","A%C3%B1os_1970","A%C3%B1os_1980","Siglo","Siglo_XIX","Siglo_XX","Siglo_XXI","2023","Calendario_gregoriano","Ab_Urbe_condita","Calendario_armenio","Calendario_chino","Calendario_hebreo","Calendario_hind%C3%BA","Vikram_Samvat","Shaka_Samvat","Calendario_persa","Calendario_musulm%C3%A1n","Accidente_de_Cebu_Douglas_C-47_de_1957","Ramon_Magsaysay","Accidente_de_Kyshtym","Movimiento_antiderechista","Tratados_de_Roma","Uni%C3%B3n_Sovi%C3%A9tica","Sputnik_1","Laika","Numeraci%C3%B3n_romana","A%C3%B1o_com%C3%BAn_comenzado_en_martes","Calendario_gregoriano","1_de_enero","Saarland","Alemania_Occidental","Arturo_Toscanini","3_de_enero","6_de_enero","Uni%C3%B3n_Sovi%C3%A9tica","Ruman%C3%ADa","Checoslovaquia","Hungr%C3%ADa","Imre_Nagy","9_de_enero","Reino_Unido","Anthony_Eden","Harold_Macmillan","11_de_enero","La_Palma","Canarias","13_de_enero","Frisbee","16_de_enero","Liverpool","The_Cavern_Club","20_de_enero","Partido_Republicano_(Estados_Unidos)","Dwight_D._Eisenhower","22_de_enero","Waterbury","Connecticut","Nueva_York","29_de_enero","Buenos_Aires","Clima_de_la_Ciudad_de_Buenos_Aires","1_de_febrero","Sabadell","Francisco_Franco","Catalu%C3%B1a","2_de_febrero","Estados_Unidos","Pop_art","3_de_febrero","Paraguay","Puerto_Flor_de_Lis","6_de_febrero","IG_Farben","Campos_de_concentraci%C3%B3n","7_de_febrero","9_de_febrero","Madrid","Mohammed_V_de_Marruecos","Palacio_de_Cristal_del_Retiro","Madrid","Joaqu%C3%ADn_Sorolla","Mariano_Fortuny","15_de_febrero","Uni%C3%B3n_Sovi%C3%A9tica","Andr%C3%A9i_Gromyko","Dimitri_Shep%C3%ADlov","Ministerio_de_Relaciones_Exteriores_de_la_Uni%C3%B3n_Sovi%C3%A9tica","Mauritania","17_de_febrero","Bogot%C3%A1","Colombia","Jos%C3%A9_Celestino_Mutis","18_de_febrero","Comit%C3%A9_de_Actividades_Antiestadounidenses","Joseph_McCarthy","Budapest","21_de_febrero","Universidad_de_Barcelona","Real_Academia_Espa%C3%B1ola","Camilo_Jos%C3%A9_Cela","Ingeborg_Bachmann","Hans_Werner_Henze","Karlheinz_Stockhausen","24_de_febrero","El_Cairo","Egipto","Jordania","Siria","Arabia_Saud%C3%AD","Egipto","25_de_febrero","Francisco_Franco","1_de_marzo","Uruguay","Arturo_Lezama","3_de_marzo","Colombia","6_de_marzo","Ghana","Imperio_brit%C3%A1nico","7_de_marzo","Per%C3%BA","Copa_Am%C3%A9rica","9_de_marzo","Islas_Andreanof","Terremoto_de_las_islas_Andreanof_de_1957","15_de_marzo","Santo_Domingo_(capital)","Oficina_de_Educaci%C3%B3n_Iberoamericana","22_de_marzo","San_Francisco","25_de_marzo","Tratados_de_Roma","Comunidad_Econ%C3%B3mica_Europea","Mercado_com%C3%BAn","1_de_abril","India","Sistema_m%C3%A9trico_decimal","3_de_abril","Santiago_de_Chile","Chile","Batalla_de_Santiago_(1957)","6_de_abril","Lima","Selecci%C3%B3n_de_f%C3%BAtbol_de_Argentina","14_de_abril","Se%C3%B1or_de_los_Milagros_(Lima)","Monasterio_de_Las_Nazarenas_(Lima)","Provincia_constitucional_del_Callao","15_de_abril","Pedro_Infante","%C3%89poca_de_Oro_del_cine_mexicano","24_de_abril","Sitio_de_pruebas_de_Nevada","Proyecto_57_(prueba_at%C3%B3mica)","24_de_abril","25_de_abril","Turqu%C3%ADa","10_de_mayo","Colombia","Gustavo_Rojas_Pinilla","Rub%C3%A9n_Piedrah%C3%ADta_Arango","Deogracias_Fonseca_Espinosa","Rafael_Navas_Pardo","Luis_Ernesto_Ord%C3%B3%C3%B1ez_Castillo","Gabriel_Par%C3%ADs","12_de_mayo","Alfonso_de_Portago","Guidizzolo","Italia","Accidente_de_tr%C3%A1nsito","Mille_Miglia","26_de_mayo","Guajira_(Colombia)","Diomedes_D%C3%ADaz","Colombia","Turqu%C3%ADa","28_de_mayo","Sitio_de_pruebas_de_Nevada","Estados_Unidos","Bomba_de_hidr%C3%B3geno","Kilotones","Operaci%C3%B3n_Plumbbob","2_de_junio","Sitio_de_pruebas_de_Nevada","Estados_Unidos","Teledirigible","Bomba_de_hidr%C3%B3geno","Kilotones","5_de_junio","Frank_Sinatra","Nelson_Riddle","18_de_junio","20_de_junio","Rosario_(provincia_de_Santa_Fe)","Argentina","R%C3%ADo_Paran%C3%A1","Monumento_Hist%C3%B3rico_Nacional_a_la_Bandera","21_de_junio","24_de_junio","1_de_julio","A%C3%B1o_Geof%C3%ADsico_Internacional","2_de_julio","Ir%C3%A1n","5_de_julio","Operaci%C3%B3n_Castle","1_de_marzo","1954","Atol%C3%B3n_Bikini","6_de_julio","Liverpool","Inglaterra","Paul_McCartney","John_Lennon","The_Quarry_Men","15_de_julio","Buenos_Aires","Argentina","Organizaci%C3%B3n_Internacional_Nueva_Acr%C3%B3polis","19_de_julio","Sitio_de_pruebas_de_Nevada","Fuerza_A%C3%A9rea_de_Estados_Unidos","Misil_nuclear","Aire-aire","Metros","Operaci%C3%B3n_Plumbbob","28_de_julio","Ciudad_de_M%C3%A9xico","Terremoto_de_M%C3%A9xico_de_1957","Monumento_a_la_Independencia","Santiago_de_Chile","Partido_Dem%C3%B3crata_Cristiano_de_Chile","Argentina","Partido_Peronista","Uni%C3%B3n_C%C3%ADvica_Radical","Uni%C3%B3n_C%C3%ADvica_Radical_Intransigente","29_de_julio","Organismo_Internacional_de_Energ%C3%ADa_At%C3%B3mica","7_de_agosto","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas_(Nevada)","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","9_de_agosto","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","18_de_agosto","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","Bomba_de_Hiroshima","20_de_agosto","Piura","Per%C3%BA","23_de_agosto","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas_(Nevada)","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","26_de_agosto","Argelia","Frente_de_Liberaci%C3%B3n_Nacional_(Argelia)","Coronel_Bigeard","La_batalla_de_Argel","27_de_agosto","R%C3%ADo_de_la_Plata","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Kilotones","Sputnik","30_de_agosto","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Operaci%C3%B3n_Plumbbob","Kilotones","31_de_agosto","Malasia","Imperio_brit%C3%A1nico","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Operaci%C3%B3n_Plumbbob","Kilotones","2_de_septiembre","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Operaci%C3%B3n_Plumbbob","Kilotones","4_de_septiembre","Los_nueve_de_Little_Rock","Racismo_en_Estados_Unidos","Arkansas","Little_Rock_(Arkansas)","Ej%C3%A9rcito_de_los_EE.UU.","6_de_septiembre","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Operaci%C3%B3n_Plumbbob","Kilotones","8_de_septiembre","Zaragoza","La_Romareda","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Operaci%C3%B3n_Plumbbob","Kilotones","14_de_septiembre","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Operaci%C3%B3n_Plumbbob","Kilotones","16_de_septiembre","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Operaci%C3%B3n_Plumbbob","Kilotones","19_de_septiembre","%C3%81rea_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","23_de_septiembre","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","Bomba_de_Hiroshima","Camp_Nou","F%C3%BAtbol_Club_Barcelona","24_de_septiembre","Barcelona","Camp_Nou","F%C3%BAtbol_Club_Barcelona","27_de_septiembre","Provincia_de_C%C3%B3rdoba_(Argentina)","Revoluci%C3%B3n_%22Libertadora%22_(Argentina)","La_Falda_(provincia_de_C%C3%B3rdoba)","28_de_septiembre","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","29_de_septiembre","Planta_nuclear_de_Mayak","Cheli%C3%A1binsk","Rusia","Desastre_de_Chern%C3%B3bil","Desastre_de_Fukushima","4_de_octubre","Uni%C3%B3n_Sovi%C3%A9tica","Sat%C3%A9lite_artificial","La_hoz_y_el_martillo","La_Internacional","5_de_octubre","TV%2B","6_de_octubre","7_de_octubre","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Bomba_at%C3%B3mica","Operaci%C3%B3n_Plumbbob","Kilotones","14_de_octubre","Gran_riada_de_Valencia","Valencia_(ciudad)","R%C3%ADo_Turia","Segundo","3_de_noviembre","Uni%C3%B3n_Sovi%C3%A9tica","Sputnik","Laika","29_de_enero","1951","Lewisburg","Wilhelm_Reich","15_de_noviembre","Llipa","16_de_noviembre","Ed_Gein","23_de_noviembre","Guerra_de_Ifni","Juventud_Peronista","Gustavo_Rearte","Envar_El_Kadri","Carlos_Caride","Felipe_Vallese","Arturo_Jauretche","Qu%C3%A9!_(revista)","Rogelio_Julio_Frigerio","1_de_diciembre","Plebiscito_de_1957_en_Colombia","Frente_Nacional_(Colombia)","4_de_diciembre","Mongolia","6_de_diciembre","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Bomba_at%C3%B3mica","Proyecto_58_(bomba_at%C3%B3mica)","Kilotones","9_de_diciembre","Sitio_de_pruebas_at%C3%B3micas_de_Nevada","Las_Vegas","Bomba_at%C3%B3mica","Kilotones","13_de_diciembre","Ir%C3%A1n","India","Tripura","Frank_Sinatra","Ava_Gardner","1_de_enero","Patr%C3%ADcio_Bisso","2019","Federico_del_Barrio","Ev%C3%A1ngelos_Venizelos","2_de_enero","Laura_Canoura","Francisco_Javier_Gonz%C3%A1lez-Huix_Fern%C3%A1ndez","4_de_enero","Isidoro_Fern%C3%A1ndez","5_de_enero","Marina_Lezcano","6_de_enero","Juan_Antonio_Men%C3%A9ndez_Fern%C3%A1ndez","2019","8_de_enero","Fabio_McNamara","Miquel_Barcel%C3%B3","9_de_enero","An%C3%ADbal_Fern%C3%A1ndez","11_de_enero","Ant%C3%B3nio_Vitorino","John_Lasseter","Jane_Fellowes","13_de_enero","Daniel_Scioli","16_de_enero","Ricardo_Dar%C3%ADn","18_de_enero","Mari%C3%A1n_Flores","23_de_enero","Carolina_de_M%C3%B3naco","25_de_enero","Luis_Alfredo_Garavito","27_de_enero","Frank_Miller","29_de_enero","Elia_Barcel%C3%B3","1_de_febrero","Gustavo_Bell","4_de_febrero","Jes%C3%BAs_Leopoldo_Estrada_Moreno","9_de_febrero","Gordon_Strachan","V%C3%ADctor_Mallarino","15_de_febrero","Shahriyar_Mandanipour","18_de_febrero","Christiane_Torloni","Vanna_White","19_de_febrero","Da%C3%ADna_Chaviano","Falco_(m%C3%BAsico)","1998","Ray_Winstone","21_de_febrero","Tom%C3%A1s_Campuzano","24_de_febrero","Roxana_Ch%C3%A1vez","28_de_febrero","John_Turturro","Francisco_C%C3%A9spedes","2_de_marzo","Vlodko_Kaufman","5_de_marzo","C%C3%A9sar_Cigliutti","Lesbianas,_gais,_transexuales,_travestis,_bisexuales_e_intersexuales","2020","7_de_marzo","Maurizio_Arrivabene","8_de_marzo","Mitsuko_Horie","Helga_Schauerte-Maubouet","9_de_marzo","Geir_Ivars%C3%B8y","2006","10_de_marzo","Hans-Peter_Friedrich","Osama_bin_Laden","2011","11_de_marzo","The_Lady_Chablis","Qasem_Soleimani","2020","V%C3%ADctor_Rangel","Isabel_Ordaz","12_de_marzo","Steve_Harris","Astrid_Junguito","15_de_marzo","Joaquim_de_Almeida","19_de_marzo","Claudio_Bisio","20_de_marzo","Teresa_Russell","23_de_marzo","Nieves_Herrero","25_de_marzo","Jennifer_Edwards","28_de_marzo","Jorge_Perdomo_Polan%C3%ADa","29_de_marzo","Christopher_Lambert","4_de_abril","Joaqu%C3%ADn_Guzm%C3%A1n_Loera","5_de_abril","Anthony_Horowitz","14_de_abril","Domingo_Drummond","2002","16_de_abril","Reinaldo_Rueda","17_de_abril","Ant%C3%B3n_Reixa","24_de_abril","Sandra_Mihanovich","26_de_abril","Carlos_Ariel_S%C3%A1nchez","2_de_mayo","Jorge_Martillo","Luis_Fernando_Montoya_(entrenador)","9_de_mayo","Fulvio_Collovati","Julio_C%C3%A9sar_Uribe","10_de_mayo","Sid_Vicious","1979","14_de_mayo","Fernando_Iglesias_(periodista_argentino)","Marino_Lejarreta","15_de_mayo","Juan_Jos%C3%A9_Ibarretxe","17_de_mayo","Anna_Silvetti","Beto_Zabaleta","21_de_mayo","Rebecca_Jones","2023","23_de_mayo","Jimmy_McShane","1995","26_de_mayo","Diomedes_D%C3%ADaz","2013","Mary_Bell","27_de_mayo","I%C3%B1aki_Miram%C3%B3n","28_de_mayo","Watana_Muangsook","Antonio_L%C3%B3pez_Habas","30_de_mayo","Ram%C3%B3n_Alcoberro","31_de_mayo","Sidi_Mohamed_Ould_Boubacar","1_de_junio","Tullio_Avoledo","3_de_junio","Bolivia_Su%C3%A1rez","5_de_junio","Nacho_Canut","7_de_junio","Juan_Luis_Guerra","8_de_junio","Alejandro_Lerner","13_de_junio","Adolfo_Roitman","16_de_junio","Jordi_Hurtado","19_de_junio","Manuel_Arellano","23_de_junio","Frances_McDormand","26_de_junio","Fernando_Ar%C3%A9valo","29_de_junio","Mar%C3%ADa_Conchita_Alonso","30_de_junio","Silvio_Orlando","8_de_julio","Carlos_Cavazo","9_de_julio","Norberto_Filippo","13_de_julio","Cameron_Crowe","Tony_Vega","L%C3%ADlia_Cabral","Thierry_Boutsen","14_de_julio","Andr%C3%A9i_Belianinov","16_de_julio","W%C5%82odzimierz_Smolarek","2012","17_de_julio","Juli%C3%A1n_Infante","2000","Alan_Jara","18_de_julio","Keith_Levene","The_Clash","2022","21_de_julio","Jon_Lovitz","26_de_julio","Santi_Santamaria","2011","28_de_julio","Ra%C3%BAl_Santi","29_de_julio","Enrique_Sierra","Radio_Futura","2012","30_de_julio","Antonio_Adamo","6_de_agosto","Francesca_Gagnon","7_de_agosto","Mareta_Espinosa","9_de_agosto","Melanie_Griffith","11_de_agosto","Carlos_Trucco","14_de_agosto","Alejandro_Tommasi","Jos%C3%A9_Coronado","16_de_agosto","Koki_Ru%C3%ADz","18_de_agosto","Carole_Bouquet","24_de_agosto","Stephen_Fry","28_de_agosto","Manolo_Preciado","2012","1_de_septiembre","Gloria_Estefan","Mohammad_Ali_Jafari","4_de_septiembre","Patricia_Tallman","Khandi_Alexander","6_de_septiembre","Elia_Barcel%C3%B3","8_de_septiembre","Ricardo_Montaner","12_de_septiembre","Hans_Zimmer","Keiko_Toda","15_de_septiembre","%C5%BDeljko_Ivanek","16_de_septiembre","Assumpta_Serna","19_de_septiembre","Pepe_Carrol","2004","21_de_septiembre","Kevin_Rudd","Hermanos_Coen","22_de_septiembre","Nick_Cave","Carlos_J%C3%A1uregui","Lesbianas,_gais,_bisexuales_y_travestis","1996","26_de_septiembre","Luigi_De_Canio","30_de_septiembre","Fran_Drescher","4_de_octubre","Bill_Fagerbakke","7_de_octubre","Faruk_Had%C5%BEibegi%C4%87","Jes%C3%BAs_Candelas","8_de_octubre","Antonio_Cabrini","10_de_octubre","Rumiko_Takahashi","11_de_octubre","Paul_Sereno","13_de_octubre","Miguel_Galv%C3%A1n","2008","14_de_octubre","Luis_Eduardo_Montealegre","15_de_octubre","Omar_Varela","2022","17_de_octubre","Nelson_Barrera","20_de_octubre","Manuel_Huerga","Quimi_Portet","22_de_octubre","Daniel_Melingo","24_de_octubre","Bando_Villamil","25_de_octubre","Nancy_Cartwright_(actriz)","Jairo_Alfredo_Fern%C3%A1ndez_Quessep","29_de_octubre","Dan_Castellaneta","3_de_noviembre","Dolph_Lundgren","4_de_noviembre","Tony_Abbott","Ferni_Presas","9_de_noviembre","Magalvi_Estaba","10_de_noviembre","Ingo_Metzmacher","15_de_noviembre","Paco_Mir","19_de_noviembre","Joel_Goldsmith","2012","20_de_noviembre","Stefan_Bellof","1985","21_de_noviembre","Horacio_Castellanos_Moya","Hern%C3%A1n_Orjuela","27_de_noviembre","Callie_Khouri","Ana_Lilian_de_la_Macorra","1_de_diciembre","Deep_Roy","4_de_diciembre","Jorge_Luis_Oviedo","9_de_diciembre","Jos%C3%A9_Luis_Gil","11_de_diciembre","Peter_Bagge","Alicia_Barberi","13_de_diciembre","Steve_Buscemi","15_de_diciembre","Ch%C5%8D_(actor_de_voz)","16_de_diciembre","Antonio_Vega","2009","18_de_diciembre","El_Zurdo","Amaya_Saizar","19_de_diciembre","Jos%C3%A9_Mar%C3%ADa_Granados","Pablo_Striano","24_de_diciembre","Hamid_Karzai","25_de_diciembre","Shane_MacGowan","28_de_diciembre","Mar_Cambroll%C3%A9","Claudia_C%C3%A1rpena","Chiche_Celentano","2009","Marcelo_Lillo","Jos%C3%A9_Mar%C3%ADa_O%27Kean","William_P%C3%A9rez","2_de_enero","Paul_Peyerimhoff","7_de_enero","Jo%C5%BEe_Ple%C4%8Dnik","10_de_enero","Gabriela_Mistral","11_de_enero","Ra%C3%BAl_L%C3%B3pez_S%C3%A1nchez","14_de_enero","Humphrey_Bogart","Irene_Caba_Alba","16_de_enero","Arturo_Toscanini","8_de_marzo","Othmar_Schoeck","9_de_marzo","1891","11_de_marzo","Richard_Evelyn_Byrd","Pedro_Infante","15_de_abril","Pedro_Infante","26_de_abril","Gichin_Funakoshi","28_de_abril","Genaro_Salinas","12_de_mayo","Erich_Von_Stroheim","Alfonso_de_Portago","15_de_mayo","Keith_Andrews","30_de_mayo","Piero_Carini","31_de_mayo","Carlos_Marcuci","6_de_junio","Guadalupe_Salcedo","14_de_junio","Adalberto_de_Le%C3%B3n_Soto","21_de_junio","Johannes_Stark","22_de_junio","Atilio_Esteban_Cattaneo","26_de_junio","Malcolm_Lowry","27_de_junio","Hermann_Buhl","23_de_julio","Giuseppe_Tomasi_di_Lampedusa","24_de_julio","Sacha_Guitry","26_de_julio","Carlos_Castillo_Armas","31_de_julio","Solanus_Casey","4_de_agosto","Washington_Lu%C3%ADs_Pereira_de_Sousa","5_de_agosto","Heinrich_Otto_Wieland","16_de_agosto","Irving_Langmuir","19_de_agosto","Juli%C3%A1n_Alarc%C3%B3n_(m%C3%BAsico_paraguayo)","Carl-Gustaf_Rossby","12_de_septiembre","Jos%C3%A9_Lins_do_Rego","20_de_septiembre","Jean_Sibelius","1865","28_de_septiembre","Luis_Cluzeau_Mortet","3_de_octubre","Walter_Duranty","Holodomor","15_de_octubre","Henry_van_de_Velde","19_de_octubre","Vere_Gordon_Childe","21_de_octubre","Laur%C3%A9ane_Barrau","24_de_octubre","Christian_Dior","26_de_octubre","Nikos_Kazantzakis","29_de_octubre","Jos%C3%A9_Patricio_Guggiari","29_de_octubre","Louis_B._Mayer","3_de_noviembre","Wilhelm_Reich","24_de_noviembre","Diego_Rivera","30_de_noviembre","Beniamino_Gigli","5_de_diciembre","Evan_Gorga","12_de_diciembre","Robert_Kurka","18_de_diciembre","Juan_Alfonso_Carrizo","24_de_diciembre","Arturo_Barea","29_de_diciembre","Juan_Jos%C3%A9_Morosoli","31_de_diciembre","%C3%93scar_Dom%C3%ADnguez","Agatha_Christie","Ian_Fleming","Desde_Rusia_con_amor_(novela)","Naguib_Mahfuz","Palacio_del_deseo","La_Azucarera","Vladimir_Nabokov","Pnin","Bor%C3%ADs_Pasternak","Doctor_Zhivago","Ayn_Rand","La_rebeli%C3%B3n_de_Atlas","Evelyn_Waugh","La_odisea_de_Gilbert_Pinfold","Samuel_Beckett","Final_de_partida","Harold_Pinter","El_montaplatos","Boris_Vian","Los_forjadores_de_imperios","Octavio_Paz","Piedra_de_sol_(poema)","Fresas_salvajes","El_s%C3%A9ptimo_sello","Ingmar_Bergman","Senderos_de_gloria","Stanley_Kubrick","El_%C3%BAltimo_cupl%C3%A9","Juan_de_Ordu%C3%B1a","Testigo_de_cargo_(pel%C3%ADcula)","Billy_Wilder","Juan_Manuel_Fangio","Lista_de_campeones_de_F%C3%B3rmula_1","F%C3%B3rmula_1","Liga_Espa%C3%B1ola_de_Baloncesto_(1957-1983)","Real_Madrid_Club_de_F%C3%BAtbol","Joventut_de_Badalona","24_de_septiembre","F%C3%BAtbol_Club_Barcelona","Camp_Nou","Campeonato_Uruguayo_de_F%C3%BAtbol","Club_Nacional_de_Football","Campeonato_Peruano_de_F%C3%BAtbol","Centro_Ique%C3%B1o","F%C3%BAtbol_Profesional_Colombiano","Corporaci%C3%B3n_Deportiva_Independiente_Medell%C3%ADn","Primera_Divisi%C3%B3n_Venezolana","Venezuela","Universidad_Central_de_Venezuela_FC","Liga_de_Campeones_de_la_UEFA","Real_Madrid_Club_de_F%C3%BAtbol","ACF_Fiorentina","Estadio_Santiago_Bernab%C3%A9u","Liga_de_B%C3%A9isbol_Profesional_de_la_Rep%C3%BAblica_Dominicana","Leones_del_Escogido","Tigres_del_Licey","Televisi%C3%B3n_en_1957","Buddy_Holly","The_%22Chirping%22_Crickets","That%27ll_Be_the_Day","Peggy_Sue","Oh,_Boy!","The_Quarrymen","The_Beatles","Frank_Sinatra","Capitol_Records","Capitol_Records","Capitol_Records","Capitol_Records","3_de_marzo","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n_1957","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Fr%C3%A1ncfort_del_Meno","Alemania_Occidental","Corry_Brokken","Net_als_toen","Pa%C3%ADses_Bajos_en_el_Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Premio_Nobel","Chen_Ning_Yang","Tsung-Dao_Lee","Alexander_R._Todd","Premio_Nobel_de_Medicina","Daniel_Bovet","Albert_Camus","Lester_Bowles_Pearson","Wayback_Machine","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"COBOL","titulo":"COBOL","contenido":"El lenguaje COBOL (acronimo de COmmon Business-Oriented Language, Lenguaje Comun Orientado a Negocios) fue creado en el a\u00f1o 1959 con el objetivo de crear un lenguaje de programacion universal que pudiera ser usado en cualquier ordenador y que estuviera orientado principalmente a los negocios, es decir, a la llamada informatica de gestion. COBOL se utiliza principalmente en sistemas comerciales, financieros y administrativos para empresas y gobiernos. COBOL todavia se usa ampliamente en aplicaciones implementadas en ordenadores centrales, como trabajos de lote y procesamiento de transacciones a gran escala. Sin embargo, debido a su popularidad decreciente y al retiro de los programadores COBOL experimentados, los programas se estan migrando a nuevas plataformas, reescribiendolos en lenguajes modernos o reemplazandolos con paquetes de software.\u200b La mayor parte de la programacion en COBOL ahora es puramente para mantener las aplicaciones existentes; sin embargo, muchas instituciones financieras grandes todavia estaban desarrollando nuevos sistemas en COBOL hasta 2006.\u200b  En la creacion de este lenguaje participo la comision CODASYL, compuesta por fabricantes de ordenadores, usuarios y el Departamento de Defensa de Estados Unidos en mayo de 1959. La definicion del lenguaje se completo en poco mas de seis meses, siendo aprobada por la comision en enero de 1960. El lenguaje COBOL fue dise\u00f1ado inspirandose en el lenguaje Flow-Matic de la oficial Grace Hopper y el IBM COMTRAN de Bob Bemer, ya que ambos formaron parte de la comision.  Gracias a la ayuda de los usuarios COBOL evoluciono rapidamente y fue revisado de 1961 a 1965 para a\u00f1adirle nuevas funcionalidades. En 1968 salio la primera version ANSI del lenguaje, siendo revisada posteriormente en 1974 (COBOL ANS-74), 1985 (COBOL ANS-85, ampliado en 1989 con funciones matematicas, finalizando el estandar actual mas usado, conocido como COBOL-ANSI), y en 2002 (COBOL ANS-2002).  El ultimo estandar es el COBOL 2014 que entre otras, incluye una nueva caracteristica que permite gestion dinamica de la memoria (OCCURS DYNAMIC).  Existe una version IBM Enterprise Cobol, actualizada regularmente y lanzada en 1991, usada en sistemas Host (Mainframe) bajo z/OS.  Para Windows y Linux, hay varios compiladores e IDE-s que existen desde hace tiempo y se siguen modernizando.  Tambien actualmente existen:  Pese a esto, a comienzos de los ochenta se fue quedando anticuado respecto a los nuevos paradigmas de programacion y a los lenguajes que los implementaban. En la revision de 1985 se soluciono, incorporando a COBOL variables locales, recursividad, reserva de memoria dinamica y programacion estructurada.  En la revision de 2002 se le a\u00f1adio orientacion a objetos, aunque desde la revision de 1974 se podia crear un entorno de trabajo similar a la orientacion a objetos, y un metodo de generacion de pantallas graficas estandarizado.  Antes de la inclusion de las nuevas caracteristicas en el estandar oficial, muchos fabricantes de compiladores las a\u00f1adian de forma no estandar. En la actualidad este proceso se esta viendo con la integracion de COBOL con Internet. Existen varios compiladores que permiten emplear COBOL como lenguaje de scripting y de servicio web. Tambien existen compiladores que permiten generar codigo COBOL para la plataforma .NET y EJB.   La estructura de un Programa en Cobol se compone de 4 Divisiones.  .  Pese a que muchas personas creen que el lenguaje COBOL esta en desuso, la realidad es que casi todos los sistemas que requieren gran capacidad de procesamiento por lotes (Batch), tanto las entidades bancarias como otras grandes empresas con sistemas mainframes utilizan COBOL. Esto permite garantizar la compatibilidad de los sistemas antiguos con los mas modernos, asi como tener la seguridad de que el lenguaje es perfectamente estable y probado. Segun un informe de Gartner Group de 2005, el 75% de los datos generados por negocios son procesados por programas creados en COBOL, y en otro informe de 1997 estima que el 80% de los 300.000 millones de lineas de codigo existentes estan creados en COBOL, escribiendose 5000 millones de lineas nuevas de COBOL cada a\u00f1o. Con todo eso, hoy por hoy, la programacion en COBOL es uno de los negocios mas rentables del mundo de la informatica. En el resto de aplicaciones el COBOL ha caido en desuso, reemplazado por lenguajes mas modernos o versatiles.  En la decada de 1970, la adopcion del paradigma de programacion estructurada se estaba generalizando cada vez mas. Edsger Dijkstra, un preeminente informatico, escribio una carta al editor de Comunicaciones de la ACM, publicada en 1975 titulada \"\u00bfComo decimos verdades que podrian doler?\", en la que fue critico con COBOL y varios otros lenguajes contemporaneos; remarcando que \"el uso de COBOL paraliza la mente\".\u200b En una discrepancia publicada a los comentarios de Dijkstra, el cientifico informatico Howard E. Tompkins afirmo que el COBOL no estructurado tendia a ser \"escrito por programadores que nunca han tenido el beneficio de COBOL estructurado bien ense\u00f1ado\", argumentando que el problema era principalmente uno de entrenamiento.\u200b  Una de las causas del codigo espagueti fue la declaracion GO TO. Los intentos de eliminar GO TOs del codigo COBOL, sin embargo, resulto en programas intrincados y calidad de codigo reducida.\u200b GO TOs fueron reemplazados en gran parte por las declaraciones i procedimientos PERFORM, que promovio la programacion modular\u200b y dio facil acceso a potentes instalaciones de bucle. Sin embargo, PERFORM podria usarse solo con procedimientos para que los cuerpos de los bucles no se ubicaran donde se usaron, lo que dificultaba la comprension de los programas.\u200b  Los programas COBOL eran famosos por ser monoliticos y carecer de modularizacion.\u200b El codigo COBOL solo podia modularizarse a traves de procedimientos, que resultaron ser inadecuados para sistemas grandes. Era imposible restringir el acceso a los datos, lo que significa que un procedimiento podia acceder y modificar cualquier elemento de datos. Ademas, no habia forma de pasar parametros a un procedimiento, una omision que Jean Sammet considero como el mayor error del comite.\u200b Otra complicacion procedia de la capacidad de PERFORM THRU una secuencia especifica de procedimientos. Esto significaba que el control podia saltar y regresar de cualquier procedimiento, creando un flujo de control intrincado y permitiendo que un programador rompiera la regla entrada unica, salida unica.\u200b  Esta situacion mejoro a medida que COBOL adopto mas caracteristicas. COBOL-74 agrego subprogramas, brindando a los programadores la capacidad de controlar los datos a los que podia acceder cada parte del programa. COBOL-85 luego agrego subprogramas anidados, lo que permitio a los programadores ocultar subprogramas.\u200b Un mayor control sobre los datos y el codigo llego en 2002 cuando se incluyeron la programacion orientada a objetos, las funciones definidas por el usuario y los tipos de datos definidos por el usuario.  Sin embargo, gran parte del software COBOL heredado importante utiliza codigo no estructurado, que se ha vuelto imposible de mantener. Puede ser demasiado arriesgado y costoso modificar incluso una simple seccion de codigo, ya que puede usarse desde lugares desconocidos de formas desconocidas.\u200b  COBOL estaba destinado a ser un lenguaje \"comun\" altamente portatil. Sin embargo, para 2001, se habian creado alrededor de 300 dialectos.\u200b Una fuente de dialectos era el propio estandar: el estandar de 1974 estaba compuesto por un nucleo obligatorio y once modulos funcionales, cada uno con dos o tres niveles de soporte. Esto permitio 104 976 variantes oficiales.\u200b  COBOL-85 no era totalmente compatible con versiones anteriores y su desarrollo fue controvertido. Joseph T. Brophy, el CIO de Travellers Insurance, encabezo un esfuerzo para informar a los usuarios de COBOL sobre los altos costos de reprogramacion de implementar el nuevo estandar.\u200b Como resultado, el comite ANSI COBOL recibio mas de 2200 cartas del publico, en su mayoria negativas, que solicitaban al comite que hiciera cambios. Por otro lado, se pensaba que la conversion a COBOL-85 aumentaria la productividad en a\u00f1os futuros, justificando asi los costos de conversion.\u200b  La sintaxis de COBOL a menudo ha sido criticada por su verbosidad. Los defensores dicen que esto tenia la intencion de hacer el codigo autodocumentado, facilitando el mantenimiento del programa.\u200b COBOL tambien estaba destinado a ser facil de aprender y usar para los programadores,\u200b sin dejar de ser legible para el personal no tecnico, como los gerentes.\u200b\u200b\u200b\u200b El deseo de legibilidad condujo al uso de elementos estructurales y sintacticos similares al ingles, como sustantivos, verbos, clausulas, oraciones, secciones y divisiones. Sin embargo, en 1984, los mantenedores de los programas COBOL luchaban por lidiar con el codigo \"incomprensible\".\u200b y los principales cambios en COBOL-85 estaban alli para ayudar a facilitar el mantenimiento.\u200b  Jean Sammet, miembro del comite de corto alcance, se\u00f1alo que \"se hizo un peque\u00f1o intento por atender al programador profesional, de hecho, las personas cuyo principal interes es la programacion tienden a estar muy descontentas con COBOL\", lo que atribuyo a la sintaxis detallada de COBOL.\u200b  La comunidad COBOL siempre ha estado aislada de la comunidad informatica. Ningun informatico academico participo en el dise\u00f1o de COBOL: todos los miembros del comite procedian del comercio o el gobierno. Los informaticos de la epoca estaban mas interesados en campos como el analisis numerico, la fisica y la programacion de sistemas que en los problemas comerciales de procesamiento de archivos que abordaba el desarrollo de COBOL.\u200b Jean Sammet atribuyo la impopularidad de COBOL a una \"reaccion snob\" inicial debido a su falta de elegancia, la falta de cientificos informaticos influyentes que participaran en el proceso de dise\u00f1o y el desden por el procesamiento de datos comerciales.\u200b La especificacion COBOL uso una \"notacion\" unica, o metalenguaje, para definir su sintaxis en lugar de la nueva forma Backus-Naur que el comite no conocia. Esto resulto en criticas \"severas\".\u200b\u200b\u200b  Mas tarde, COBOL sufrio una escasez de material que lo cubriera; los libros introductorios tardaron hasta 1963 en aparecer (con Richard D. Irwin publicando un libro de texto universitario sobre COBOL en 1966).\u200b Para 1985, habia el doble de libros sobre FORTRAN y cuatro veces mas sobre BASIC que sobre COBOL en la Biblioteca del Congreso.\u200b Los profesores universitarios ense\u00f1aban lenguajes y tecnicas mas modernos y de ultima generacion en lugar de COBOL, que se decia que tenia una naturaleza de \"escuela de comercio\".\u200b Donald Nelson, presidente del comite CODASYL COBOL, dijo en 1984 que \"los academicos ... odian COBOL\" y que los graduados en informatica \"tenian 'odio COBOL' en ellos\".\u200b  A mediados de la decada de 1980, tambien hubo una condescendencia significativa hacia COBOL en la comunidad empresarial por parte de los usuarios de otros lenguajes, por ejemplo FORTRAN o ensamblador, lo que implica que COBOL podria usarse solo para problemas no-desafiantes.\u200b  En 2003, COBOL figuraba en el 80% de los planes de estudio de sistemas de informacion en los Estados Unidos, la misma proporcion que C++ y Java.\u200b Diez a\u00f1os despues, una encuesta realizada por Micro Focus encontro que el 20\u00a0% de los academicos universitarios pensaban que COBOL estaba desactualizado o muerto y que el 55\u00a0% creia que sus estudiantes pensaban que COBOL estaba desactualizado o muerto. La misma encuesta tambien encontro que solo el 25\u00a0% de los academicos tenian programacion COBOL en su plan de estudios, aunque el 60\u00a0% penso que deberian ense\u00f1arla.\u200b  Se han planteado dudas sobre la competencia del comite de normas. El miembro del comite a corto plazo, Howard Bromberg, dijo que habia \"poco control\" sobre el proceso de desarrollo y que estaba \"plagado por la discontinuidad del personal y... la falta de talento\".\u200b Jean Sammet y Jerome Garfunkel tambien se\u00f1alaron que los cambios introducidos en una revision del estandar se revertirian en la siguiente, debido tanto a los cambios en quien estaba en el comite del estandar como a la evidencia objetiva.\u200b  Los estandares COBOL han sufrido repetidamente retrasos: COBOL-85 llego cinco a\u00f1os mas tarde de lo esperado,\u200b COBOL 2002 se retraso cinco a\u00f1os,\u200b and COBOL 2014 was six years late.\u200b\u200b Para combatir los retrasos, el comite de estandares permitio la creacion de apendices opcionales que agregarian caracteristicas mas rapidamente que esperando la proxima revision del estandar. Sin embargo, algunos miembros del comite expresaron su preocupacion por las incompatibilidades entre las implementaciones y las frecuentes modificaciones del estandar.\u200b  Las estructuras de datos de COBOL influyeron en los lenguajes de programacion posteriores. Su estructura de registros y archivos influyo en PL/I y Pascal, y la clausula REDEFINES fue un predecesor de los registros variantes de Pascal. Las definiciones explicitas de estructuras de archivos precedieron al desarrollo de sistemas de administracion de bases de datos y los datos agregados fueron un avance significativo sobre las matrices de Fortran.\u200b Las declaraciones de datos de PICTURE se incorporaron a PL/I, con cambios menores.  La facilidad de COBOL con COPY, aunque se considera \"primitivo\",\u200b influyo en el desarrollo de directivas include.\u200b  El enfoque en la portabilidad y la estandarizacion significo que los programas escritos en COBOL pudieran ser portatiles y facilito la difusion del lenguaje a una amplia variedad de plataformas de hardware y sistemas operativos.\u200b Ademas, la estructura de division bien definida restringe la definicion de referencias externas a la Division de Entorno, lo que simplifica los cambios de plataforma en particular.\u200b  Migracion de Cobol MainFrame ","snippet":"El lenguaje COBOL (acronimo de COmmon Business-Oriented Language, Lenguaje Comun Orientado a Negocios) fue creado en el a\u00f1o 1959 con el objetivo de crear un lenguaje de programacion universal que pudi","enlaces_salientes":["COBOL","COBOL","COBOL","Lenguaje_de_programaci%C3%B3n","Acr%C3%B3nimo","Lenguaje_de_programaci%C3%B3n","Inform%C3%A1tica_de_gesti%C3%B3n","Ordenador_central","Procesamiento_por_lotes","Procesamiento_de_transacciones","CODASYL","Departamento_de_Defensa_de_Estados_Unidos","1959","1960","Flow-Matic","Grace_Murray_Hopper","1961","1965","1968","ANSI","1974","1985","2002","1991","GnuCOBOL","Base_diez","Paradigma_de_programaci%C3%B3n","Lenguaje_de_scripting","Servicio_web",".NET","EJB","Hola_mundo","Procesamiento_por_lotes","Mainframe","Programaci%C3%B3n_estructurada","Edsger_Dijkstra","C%C3%B3digo_espagueti","Programaci%C3%B3n_modular","Metalenguaje","Forma_Backus-Naur","Biblioteca_del_Congreso_de_Estados_Unidos","FORTRAN","Lenguaje_ensamblador","Sistemas_de_informaci%C3%B3n","C%2B%2B","Java_(lenguaje_de_programaci%C3%B3n)","Micro_Focus","PL/I","Pascal_(lenguaje_de_programaci%C3%B3n)","The_Terminator","Semantic_Scholar","Digital_object_identifier","ISBN","Digital_object_identifier","Handle_System","Digital_object_identifier","Eric_S._Raymond","ISBN","ISBN","Semantic_Scholar","Digital_object_identifier","Library_of_Congress_Control_Number","Digital_object_identifier","IBM","IBM","ISBN","Library_of_Congress_Control_Number","CRC_Press","ISBN","ISSN","CODASYL","National_Bureau_of_Standards","ISSN","Library_of_Congress_Control_Number","ISSN","John_Wiley_%26_Sons","ISBN","ISO","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","ISBN","Library_of_Congress_Control_Number","Semantic_Scholar","Digital_object_identifier","Jean_E._Sammet","Association_for_Computing_Machinery","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","OCLC","Semantic_Scholar","Digital_object_identifier","Burroughs_B2000","Grace_Murray_Hopper","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Inform%C3%A1tica_de_gesti%C3%B3n","titulo":"Informatica de gestion","contenido":"La informatica de gestion (BI) es una disciplina que combina la tecnologia de informacion (IT) o la informatica con conceptos de la gerencia. La disciplina del BI fue creada en Alemania, del concepto de \u201cWirtschaftsinformatik\u201d (en espa\u00f1ol: \"Informatica Economica\").  Es una disciplina academica establecida que se incluye en programas de bachilleratos, maestrias y carreras de grado en Alemania, Austria, Espa\u00f1a, Suiza y actualmente implantada en la mayoria de las universidades europeas. El termino informatica del negocio es hoy en dia comun en Europa central. El BI tiene efectos sinergicos fuertes de conceptos de la administracion del negocio que la integran junto con la informatica en un mismo campo.  La informatica del negocio (BI) presenta numerosas semejanzas a la disciplina de los sistemas de informacion (IS) que se puede encontrar principalmente en los lugares de habla inglesa del mundo. Sin embargo hay algunas diferencias importantes que hacen de la informatica del negocio muy atractiva para los patrones:  Por otra parte, los sistemas de informacion se centran en explicar los fenomenos empiricos del mundo real. IS a menudo se ha llamado un acercamiento \u201cexplicacion-orientado\u201d en contraste con el acercamiento \u201csolucion-orientado\u201d del BI. En IS los investigadores intentan explicar porque las cosas del mundo real son de la manera que son y conducir muchos examenes empiricos mientras que un investigador del BI intenta desarrollar las soluciones para los problemas que han observado o asumido.  El academico en BI, por ejemplo, esta a menudo encari\u00f1ado con la aplicacion de nuevas tecnologias a los problemas de negocio y hacer estudios de viabilidad construyendo prototipos del software. Ense\u00f1an los estudiantes del BI tambien este acercamiento constructivo. Su capacidad no solo de explicar la realidad, sino de formarla, esto hace a los empleados muy atractivos para las compa\u00f1ias asi como los buenos candidatos a empresarios en el negocio de IS.  Las conexiones apretadas entre la investigacion y la ense\u00f1anza son otra tradicion de la informatica del negocio. Las penetraciones recientes ganadas en proyectos de investigacion se convierten en parte de los planes de estudios absolutamente porque la mayoria de los investigadores son conferenciantes al mismo tiempo. El paso del progreso cientifico y tecnologico en BI es rapido, por lo tanto los temas ense\u00f1ados estan bajo la reconsideracion y revision permanentes.  Los programas de estudios universitarios o superiores conducen directamente al grado de un Licenciado o de Master en informatica de negocio o de gestion. Ejemplos de esto en Europa son:  Muchas universidades alemanas, austriacas, y suizas ofrecen programas equivalentes a un grado (Master/Diplomado/Licenciado) en \u201cWirtschaftsinformatik\u201d, por ejemplo:  Las universidades rusas han comenzado a ofrecer programas equivalentes en ruso desde 2002:  En Espa\u00f1a los estudios universitarios correspondientes a dichas titulaciones son:  Las universidades que ofertan dicha titulacion en Espa\u00f1a (actualmente en regulacion por el Proceso de Bolonia) son:  Objetivos formativos de las titulaciones universitarias:  Las ense\u00f1anzas conducentes a la obtencion del titulo oficial de Ingeniero Tecnico en Informatica de Gestion, maestrias, grados, o bachiller, deberan proporcionar una formacion adecuada en las bases teoricas y en las tecnicas y en la tecnologia especifica de esta ingenieria informatica. Estos profesionales se ocupan del dise\u00f1o, propiedades y mantenimiento del software de gestion, asi como la planificacion, analisis y gestion de proyectos informaticos dentro del ambito empresarial.La base formativa de estos estudios esta constituida por la interrelacion de casi todas las ramas del saber cientifico; fundamentalmente las Matematicas, Logica, Ingenieria, Linguistica, Fisica, Electronica, Estadistica, Economia, etc. Junto a ello se encuentra una serie de materias especificas sobre informatica y aplicaciones.  Salidas profesionales de la titulacion:  Las actividades que realiza un Ingeniero en Informatica de Gestion son, fundamentalmente, las siguientes: Tecnico Comercial, Tecnico de Sistemas, Analistas Programadores, Programadores de Sistemas, especialistas en Hardware y Software, Tecnicos de Sistemas especializados en Redes de Teleproceso y especialistas en Teleproceso. Los sectores empresariales que con mayor frecuencia demandan estos puestos son las entidades financieras y las empresas industriales. ","snippet":"La informatica de gestion (BI) es una disciplina que combina la tecnologia de informacion (IT) o la informatica con conceptos de la gerencia. La disciplina del BI fue creada en Alemania, del concepto ","enlaces_salientes":["Inform%C3%A1tica_de_gesti%C3%B3n","Inform%C3%A1tica_de_gesti%C3%B3n","Inform%C3%A1tica_de_gesti%C3%B3n","TIC","Inform%C3%A1tica","Alemania","Idioma_espa%C3%B1ol","Bachillerato","Alemania","Austria","Espa%C3%B1a","Suiza","Idioma_ingl%C3%A9s","Informaci%C3%B3n","Tecnolog%C3%ADa","Software","Empresario","Investigaci%C3%B3n","Ense%C3%B1anza","Licenciado","M%C3%A1ster_(grado)","Internet","Universidad_de_Rostock","Universidad_de_Utrecht","Universidad_de_Canberra","Universidad_de_Middlesex","Londres","Reino_Unido","Universidad_de_Erlangen-N%C3%BAremberg","Universidad_de_M%C3%BCnster","Universidad_de_Duisburgo-Essen","Universidad_de_Sankt_Gallen","Rusia","2002","Mosc%C3%BA","Proceso_de_Bolonia","Universidad_de_Alicante","Universidad_de_Alcal%C3%A1","Universidad_de_Almer%C3%ADa","Universidad_Antonio_de_Nebrija","Universidad_Aut%C3%B3noma_de_Barcelona","Universidad_de_Burgos","Escuela_Polit%C3%A9cnica_Superior_de_Burgos","Universidad_de_C%C3%A1diz","Universidad_Cardenal_Herrera-CEU","Universidad_Carlos_III_de_Madrid","Universidad_de_Castilla-La_Mancha","Universidad_Cat%C3%B3lica_de_%C3%81vila","Universidad_Complutense_de_Madrid","Universidad_de_La_Coru%C3%B1a","Universidad_de_Deusto","Universidad_Europea_de_Madrid","Universidad_Europea_Miguel_de_Cervantes","Universidad_del_Pa%C3%ADs_Vasco","Universidad_de_Extremadura","Universidad_Francisco_de_Vitoria","Universidad_de_Gerona","Universidad_de_Granada","Universidad_de_las_Islas_Baleares","Universidad_Internacional_de_Catalu%C3%B1a","Universidad_de_Huelva","Universidad_de_Ja%C3%A9n","Universidad_Jaime_I","Universidad_de_La_Laguna","Universidad_de_La_Rioja","Universidad_de_Las_Palmas_de_Gran_Canaria","Universidad_de_L%C3%A9rida","Universidad_de_M%C3%A1laga","Universidad_de_Murcia","Universidad_Abierta_de_Catalu%C3%B1a","Universidad_de_Oviedo","Universidad_Pablo_de_Olavide","Universidad_Polit%C3%A9cnica_de_Catalu%C3%B1a","Universidad_Polit%C3%A9cnica_de_Madrid","Universidad_Polit%C3%A9cnica_de_Valencia","Universidad_Pontificia_Comillas","Universidad_Pontificia_de_Salamanca","Universidad_P%C3%BAblica_de_Navarra","Universidad_Rey_Juan_Carlos","Universidad_Rovira_i_Virgili","Universidad_de_Salamanca","Universidad_de_Sevilla","Universidad_de_Valladolid","Universidade_de_Vigo","Universidad_de_Zaragoza","Ingenier%C3%ADa_inform%C3%A1tica","Inform%C3%A1tica_de_sistemas","Inform%C3%A1tica","Wayback_Machine","Control_de_autoridades"]}
{"url":"1980","titulo":"1980","contenido":"1980 (MCMLXXX) fue un a\u00f1o bisiesto comenzado en martes segun el calendario gregoriano. ","snippet":"1980 (MCMLXXX) fue un a\u00f1o bisiesto comenzado en martes segun el calendario gregoriano. ","enlaces_salientes":["1980","1980","1980","1977","1978","1979","1981","1982","1983","D%C3%A9cada","A%C3%B1os_1950","A%C3%B1os_1960","A%C3%B1os_1970","A%C3%B1os_1980","A%C3%B1os_1990","A%C3%B1os_2000","A%C3%B1os_2010","Siglo","Siglo_XIX","Siglo_XX","Siglo_XXI","2023","Calendario_gregoriano","Ab_Urbe_condita","Calendario_armenio","Calendario_chino","Calendario_hebreo","Calendario_hind%C3%BA","Vikram_Samvat","Shaka_Samvat","Calendario_persa","Calendario_musulm%C3%A1n","Canadian_Caper","Juegos_Ol%C3%ADmpicos_de_Mosc%C3%BA_1980","Mosc%C3%BA","Uni%C3%B3n_Sovi%C3%A9tica","Rusia","Pac-Man","Irak","Ir%C3%A1n","Guerra_Ir%C3%A1n-Irak","1988","Masacre_de_Gwangju","Corea_del_Sur","John_Lennon","Asesinato_de_John_Lennon","Mark_David_Chapman","Bolonia","Italia","Matanza_de_Bolonia","Erupci%C3%B3n_del_monte_Santa_Helena_de_1980","Numeraci%C3%B3n_romana","Calendario_gregoriano","1_de_enero","Islas_Azores","Terremoto","M%C3%A9xico","El_Chavo_del_8","Suecia","Victoria_de_Suecia","1_de_abril","Reino_Unido","3_de_enero","Portugal","Francisco_de_S%C3%A1_Carneiro","4_de_enero","Presidente_de_los_Estados_Unidos","Jimmy_Carter","Uni%C3%B3n_Sovi%C3%A9tica","Comunidad_Europea","6_de_enero","Sicilia","Piersanti_Mattarella","Mafia","7_de_enero","India","Indira_Gandhi","9_de_enero","Arabia_Saud%C3%AD","La_Meca","1979","10_de_enero","M%C3%A9xico","La_Noche_Triste","Hern%C3%A1n_Cort%C3%A9s","11_de_enero","Nigel_Short","Ajedrez","15_de_enero","M%C3%BCnich","17_de_enero","Suiza","Z%C3%BArich","Interferones","19_de_enero","Monasterio_de_El_Escorial","Alfonso_XIII","Roma","20_de_enero","Alons%C3%B3tegui","Atentado_contra_el_bar_Aldana","Nacionalistas_vascos","Grupos_Armados_Espa%C3%B1oles","Jimmy_Carter","Juegos_Ol%C3%ADmpicos_de_Mosc%C3%BA_1980","Uni%C3%B3n_Sovi%C3%A9tica","Afganist%C3%A1n","Cuba","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","22_de_enero","Mosc%C3%BA","Andrei_S%C3%A1jarov","24_de_enero","Estado_de_California","25_de_enero","Ir%C3%A1n","Abolhas%C3%A1n_Banisadr","Revoluci%C3%B3n_iran%C3%AD","26_de_enero","Israel","Egipto","27_de_enero","Teher%C3%A1n","Ir%C3%A1n","Diplomacia","Canad%C3%A1","Z%C3%BArich","Suiza","31_de_enero","Ciudad_de_Guatemala","Espa%C3%B1a","Genocidio_maya","Polic%C3%ADa_Nacional_de_Guatemala","F%C3%B3sforo_blanco","Matanza_en_la_embajada_espa%C3%B1ola_de_Guatemala","M%C3%A1ximo_Cajal_L%C3%B3pez","Gregorio_Iuj%C3%A1-Shon%C3%A1","1_de_febrero","La_Pantera_Rosa","18_de_diciembre","1964","2_de_febrero","Parlamento_italiano","3_de_febrero","Pa%C3%ADs_Vasco","4_de_febrero","Ir%C3%A1n","Ayatol%C3%A1","Ruhollah_Jomeini","Abolhassan_Banisadr","5_de_febrero","Grenoble","Klaus_von_Klitzing","Efecto_Hall","7_de_febrero","Marea_negra","Breta%C3%B1a","Francia","Madagascar","9_de_febrero","N%C3%BAremberg","Gerontolog%C3%ADa","Rep%C3%BAblica_Federal_Alemana","Erlangen","Dictadura_franquista","Movida_madrile%C3%B1a","10_de_febrero","Adolfo_Su%C3%A1rez","Irak","Jordania","13_de_febrero","Lake_Placid","Estado_de_Nueva_York","Juegos_Ol%C3%ADmpicos_de_invierno","14_de_febrero","Ir%C3%A1n","Aeroflot","15_de_febrero","Tanna","Vanuatu","Secta_de_cargo","John_Frum","Tafea","Surinam","Desi_Bouterse","Johan_Ferrier","Historia_de_Surinam","16_de_febrero","Vitoria","18_de_febrero","Surinam","Hendrick_Chin_A_Sen","Canad%C3%A1","Pierre_Trudeau","Calle_de_Atocha","19_de_febrero","Ir%C3%A1n","Bon_Scott","AC/DC","Intoxicaci%C3%B3n_et%C3%ADlica","21_de_febrero","Videojuego","HAL_Laboratory","22_de_febrero","Hockey","Uni%C3%B3n_Sovi%C3%A9tica","Juegos_Ol%C3%ADmpicos_de_invierno","Uni%C3%B3n_Sovi%C3%A9tica","Leonid_Br%C3%A9zhnev","Jimmy_Carter","Afganist%C3%A1n","23_de_febrero","Ir%C3%A1n","Ayatol%C3%A1","Ruhollah_Jomeini","25_de_febrero","Surinam","D%C3%A9si_Bouterse","Roy_Horb","Golpe_de_Estado","Henck_Arron","27_de_febrero","Colombia","M-19","Toma_de_la_embajada_de_la_Rep%C3%BAblica_Dominicana","27_de_febrero","Ir%C3%A1n","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","28_de_febrero","Espa%C3%B1a","Refer%C3%A9ndum","Andaluc%C3%ADa","Provincia_de_Almer%C3%ADa","1_de_marzo","Fiat","Peugeot","Argentina","Joint_venture","Sevel_Argentina_S._A.","Voyager_1","Jano_(luna)","Lunas_de_Saturno","3_de_marzo","Canad%C3%A1","Pierre_Trudeau","Primer_ministro_de_Canad%C3%A1","4_de_marzo","Zimbabue","Robert_Mugabe","9_de_marzo","Parlamento_Vasco","Partido_Nacionalista_Vasco","14_de_marzo","Polonia","Varsovia","Shaktoolik","Alaska","Accidente_de_aviaci%C3%B3n","F%C3%A9lix_Rodr%C3%ADguez_de_la_Fuente","18_de_marzo","Cosm%C3%B3dromo_de_Plesetsk","Uni%C3%B3n_Sovi%C3%A9tica","Cohete_Vostok","20_de_marzo","Reino_Unido","Radio_pirata","Radio_Caroline","M%C3%A9xico","Argentina","Montoneros","Sylvia_Bermann","Miguel_Bonasso","Pedro_Orgambide","Susana_Sanz","Clausewitz","21_de_marzo","Jimmy_Carter","Estados_Unidos","Juegos_Ol%C3%ADmpicos_de_Mosc%C3%BA_1980","Crucifijo","Comunista","Luis_Espinal","A%C3%B1os_1970","Evo_Morales","Papa_Francisco","La_Paz","Lu%C3%ADs_Espinal_Camps","Luis_Garc%C3%ADa_Meza","23_de_marzo","Nicaragua","Revoluci%C3%B3n_Sandinista","23_de_marzo","Espa%C3%B1a","Parlamento_de_Catalu%C3%B1a","CiU","Partido_Socialista_de_Catalu%C3%B1a","23_de_marzo","Mohammad_Reza_Pahlevi","Panam%C3%A1","Egipto","Suecia","Italia","Serie_A_(Italia)","Totonero","24_de_marzo","San_Salvador","El_Salvador","Oscar_Arnulfo_Romero","30_de_marzo","Australia","Mosc%C3%BA","Malcolm_Fraser","26_de_marzo","Sud%C3%A1frica","Vaal_Reef","27_de_marzo","Mar_del_Norte","Noruega","Plata","Jueves_de_Plata","Sierra_Leona","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","28_de_marzo","Buenos_Aires","1_de_abril","Per%C3%BA","La_Habana","Miami","%C3%89xodo_del_Mariel","2_de_abril","Bristol","7_de_abril","Estados_Unidos","Ir%C3%A1n","10_de_abril","Reino_Unido","Gibraltar","1969","12_de_abril","Liberia","Samuel_Doe","Golpe_de_Estado","14_de_abril","Heavy_Metal","Iron_Maiden","15_de_abril","Libia","Siria","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","18_de_abril","Zimbabue","Reino_Unido","Robert_Mugabe","19_de_abril","La_Haya","Johnny_Logan","Irlanda","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","20_de_abril","Honduras","24_de_abril","Estados_Unidos","Pensilvania","25_de_abril","Ir%C3%A1n","Crisis_de_los_rehenes_en_Ir%C3%A1n","Teher%C3%A1n","Buenos_Aires","Ministerio_de_Hacienda_(Argentina)","Sasetru","27_de_abril","Toma_de_la_embajada_de_la_Rep%C3%BAblica_Dominicana","Cuba","28_de_abril","Suazilandia","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","30_de_abril","Pa%C3%ADses_Bajos","Juliana_de_los_Pa%C3%ADses_Bajos","Beatriz_de_los_Pa%C3%ADses_Bajos","1_de_mayo","Argentina","3_de_mayo","El_Cerro_(barrio_de_La_Habana)","La_Habana","Comit%C3%A9s_de_Defensa_de_la_Revoluci%C3%B3n","7_de_mayo","Beacon","Estado_de_Nueva_York","1911","8_de_mayo","9_de_mayo","Florida","Liberia","Bah%C3%ADa_de_Tampa","14_de_mayo","Botsuana","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","17_de_mayo","Miami","Florida","Per%C3%BA","Sendero_Luminoso","Atentado_de_Chuschi","Departamento_de_Ayacucho","Elecciones_generales_del_Per%C3%BA_(1980)","Presidente_del_Per%C3%BA","R%C3%A9gimen_militar","18_de_mayo","Per%C3%BA","Fernando_Bela%C3%BAnde_Terry","Monte_Santa_Helena","Washington_(estado)","Gwangju","Corea_del_Sur","Masacre_de_Gwangju","20_de_mayo","Refer%C3%A9ndum","Quebec","Canad%C3%A1","Star_Wars","22_de_mayo","Toru_Iwatani","Namco","Pacman","Cordillera_de_Los_Andes","24_de_mayo","La_Haya","Corte_Internacional_de_Justicia","Teher%C3%A1n","1_de_junio","Estados_Unidos","Ted_Turner","CNN","Venezuela","3_de_junio","Estados_Unidos","Chip","Armas_nucleares","11_de_junio","Buenos_Aires","FMI","Banco_Mundial","19_de_junio","Italia","Convenio_de_Roma","Comunidad_Econ%C3%B3mica_Europea","Uni%C3%B3n_Europea","Bagdad","22_de_junio","Selecci%C3%B3n_de_f%C3%BAtbol_de_Alemania_Federal","Eurocopa_1980","23_de_junio","India","Sanjay_Gandhi","Indira_Gandhi","25_de_junio","Siria","Hafez_al-Assad","26_de_junio","El_Salvador","Junta_Revolucionaria_de_Gobierno_(El_Salvador)","Universidad_de_El_Salvador","27_de_junio","Estados_Unidos","Jimmy_Carter","Afganist%C3%A1n","N%C3%A1poles","Italia","Vuelo_870_de_Aerolinee_Itavia","Douglas_DC-9","29_de_junio","Islandia","Vigdis_Finnbogadottir","29_de_junio","Bolivia","30_de_junio","The_Game_(album)","Another_one_bites_the_dust","Crazy_little_thing_called_love","The_Game_Tour","4_de_julio","Chad","Mal%C3%AD","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","6_de_julio","Masacre_del_R%C3%ADo_Can%C3%ADmar","8_de_julio","Se%C3%BAl","Miss_Universo","9_de_julio","Brasil","Juan_Pablo_II","Zimbabue","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","16_de_julio","Detroit","M%C3%ADchigan","Ronald_Reagan","California","Estados_Unidos","17_de_julio","Golpe_de_Estado","Bolivia","18_de_julio","Brasil","Rede_Tupi","19_de_julio","Estambul","Turqu%C3%ADa","3_de_agosto","Mosc%C3%BA","Uni%C3%B3n_Sovi%C3%A9tica","Juegos_Ol%C3%ADmpicos_de_Mosc%C3%BA_1980","24_de_julio","Diputaci%C3%B3n_de_Almer%C3%ADa","Instituto_de_Estudios_Almerienses","28_de_julio","Fernando_Bela%C3%BAnde_Terry","Presidente_de_la_Rep%C3%BAblica_del_Per%C3%BA","29_de_julio","Nepal","30_de_julio","Vanuatu","Reino_Unido","Francia","1_de_agosto","Hockenheimring","Alemania","Patrick_Depailler","Espa%C3%B1a","Crimen_de_los_Marqueses_de_Urquijo","Somosaguas","Rafael_Escobedo","7_de_agosto","California","Energ%C3%ADa_solar","8_de_agosto","Honduras","12_de_agosto","Montevideo","Uruguay","Tratado_de_Montevideo_(1980)","ALADI","14_de_agosto","Polonia","Lech_Wa%C5%82%C4%99sa","Gdansk","Estados_Unidos","Jimmy_Carter","Edward_Kennedy","17_de_agosto","Uluru","Australia","Dingo","Legan%C3%A9s","Espa%C3%B1a","Bar%C3%B3n_Rojo_(banda)","Coz","Agosto","Buenos_Aires","Peronista","H%C3%A9ctor_C%C3%A1mpora","19_de_diciembre","1_de_septiembre","Buenos_Aires","Jorge_Rafael_Videla","5_de_septiembre","Suiza","T%C3%BAnel_de_carretera_de_San_Gotardo","G%C3%B6schenen","Airolo","11_de_septiembre","Nueva_York","ONU","Plebiscito_nacional_de_Chile_de_1980","Constituci%C3%B3n_Pol%C3%ADtica_de_la_Rep%C3%BAblica_de_Chile_de_1980","Dictadura_militar_(Chile)","Augusto_Pinochet","Fraude_electoral","17_de_septiembre","Polonia","Gdansk","Solidaridad_(sindicato)","Asunci%C3%B3n","Paraguay","Nicarag%C3%BCense","Anastasio_Somoza_Debayle","Alfredo_Stroessner","18_de_septiembre","Arnaldo_Tamayo","Cuba","Am%C3%A9rica_Latina","%C3%81frica","22_de_septiembre","Irak","Ir%C3%A1n","Guerra_Ir%C3%A1n-Irak","Estados_Unidos","Cuba","Mariel_(barco)","Washington_Post","Janet_Cooke","Hero%C3%ADna","25_de_septiembre","John_Bonham","Led_Zeppelin","V%C3%B3mito","27_de_septiembre","2_de_octubre","Manila","Filipinas","Organizaci%C3%B3n_Mundial_del_Turismo","Declaraci%C3%B3n_de_Manila","Bio%C3%A9tica","5_de_octubre","Alemania_Federal","Portugal","10_de_octubre","Terremoto_de_El_Asnam_de_1980","Argelia","11_de_octubre","Llamada_Dem%C3%B3crata_Cristiana","16_de_octubre","Ciudad_de_Guatemala","Irma_Flaquer","Desaparici%C3%B3n_forzada_de_personas","18_de_octubre","Malcolm_Fraser","Australia","24_de_octubre","Estado_de_Oaxaca","25_de_octubre","27_de_octubre","Irlanda_del_Norte","Ej%C3%A9rcito_Republicano_Provisional_Irland%C3%A9s","Presos_pol%C3%ADticos","30_de_octubre","Costa_Rica","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","31_de_octubre","Solidaridad_(Polonia)","Ir%C3%A1n","Reza_Pahlevi_II","Mohammad_Reza_Pahlevi","Sah","4_de_noviembre","Elecciones_presidenciales_de_Estados_Unidos_de_1980","James_Carter","Ronald_Reagan","Chile","Administradoras_de_Fondos_de_Pensiones_de_Chile","Capitalizaci%C3%B3n_individual","Puerto_Rico","8_de_noviembre","Estado_de_California","15_de_noviembre","Buenos_Aires","Rafael_Jos%C3%A9","Puerto_Rico","Festival_OTI","21_de_noviembre","Las_Vegas","Nevada","21_de_noviembre","23_de_noviembre","Terremoto_de_Irpinia_de_1980","Italia","27_de_noviembre","Vanuatu","Rep%C3%BAblica_%C3%81rabe_Saharaui_Democr%C3%A1tica","30_de_noviembre","Ciudad_del_Vaticano","Juan_Pablo_II","Enc%C3%ADclica","Dives_in_Misericordia","30_de_noviembre","Uruguay","Plebiscito_constitucional_de_1980","1_de_diciembre","Buenos_Aires","Dictadura_de_Videla","4_de_diciembre","Led_Zeppelin","John_Bonham","7_de_diciembre","Portugal","8_de_diciembre","Nueva_York","John_Lennon","Mark_David_Chapman","19_de_diciembre","M%C3%A9xico_D._F.","Peronista","H%C3%A9ctor_C%C3%A1mpora","M%C3%A9xico","Buenos_Aires","Dictadura_c%C3%ADvico-militar_argentina","21_de_diciembre","Espa%C3%B1a","Estatuto_de_Autonom%C3%ADa_de_Galicia","26_de_diciembre","Los_perros_de_Deng_Xiaoping","Lima","Per%C3%BA","Sendero_Luminoso","30_de_diciembre","Montevideo","Copa_de_Oro_de_Campeones_Mundiales","2_de_enero","Rebekah_Teasdale","3_de_enero","David_Tyree","Federico_Ins%C3%BAa","4_de_enero","Greg_Cipes","Alexandra_Jim%C3%A9nez","Chantal_Baudaux","5_de_enero","Santiago_Ventura","Sebastian_Deisler","7_de_enero","Wally_P%C3%A9rez","2014","Jackson_Meli%C3%A1n","Mari%C3%A1ngel_Ruiz","2002","Lalo_Alzueta","Campbell_Johnstone","Ad%C3%A9kambi_Olufad%C3%A9","David_Arroyo","Michael_Wright_(baloncestista)","2015","8_de_enero","Rachel_Nichols","9_de_enero","Fumie_Mizusawa","Sergio_Garc%C3%ADa_Fern%C3%A1ndez","10_de_enero","Petri_Lindroos","11_de_enero","Julio_Marchant","Damien_Wilkins","12_de_enero","Amerie","13_de_enero","Mar%C3%ADa_de_Villota","2013","14_de_enero","Carlos_Alvarado_Quesada","Presidente_de_Costa_Rica","2018","Carolina_Cerezuela","Cory_Gibbs","Y%C5%ABko_Kaida","15_de_enero","Mariana_Derderi%C3%A1n","Matt_Holliday","Albert_Pujols","16_de_enero","Michelle_Wild","Cristina_Campuzano","Albert_Pujols","Lin-Manuel_Miranda","17_de_enero","Zooey_Deschanel","18_de_enero","Jason_Segel","19_de_enero","Jenson_Button","Marbelle","20_de_enero","Matt_Tuck","21_de_enero","Nana_Mizuki","Isabel_Cristina_Estrada","La_H%C3%BAngara","22_de_enero","Jonathan_Woodgate","Christopher_Masterson","23_de_enero","Unai_Exp%C3%B3sito","24_de_enero","Wilmar_Rold%C3%A1n","Xavi_Hern%C3%A1ndez","25_de_enero","Christian_Olsson","Xavi_Hern%C3%A1ndez","Michelle_McCool","26_de_enero","Sanae_Kobayashi","Ana_Victoria_Beltr%C3%A1n","27_de_enero","Marat_Safin","28_de_enero","Yasuhito_Endo","Nick_Carter","Backstreet_Boys","29_de_enero","Ivan_Klasni%C4%87","Haylie_Johnson","30_de_enero","Wilmer_Valderrama","31_de_enero","Jurica_Vranje%C5%A1","1_de_febrero","Marcos_Patronelli","2_de_febrero","Oleguer_Presas","4_de_febrero","Kenta_Kiritani","6_de_febrero","Nicol%C3%A1s_Cabr%C3%A9","Conor_O%27Brian","Mamiko_Noto","Patricia_Coki_Ram%C3%ADrez","7_de_febrero","Gisela_Van_Lacke","Cecilia_Navia","9_de_febrero","Angelos_Charisteas","10_de_febrero","C%C3%A9sar_Izturis","Naty_Botero","Yukiko_Tamaki","11_de_febrero","Matthew_Lawrence","12_de_febrero","Juan_Carlos_Ferrero","Christina_Ricci","13_de_febrero","Sebastian_Kehl","14_de_febrero","Rossana_N%C3%A1jera","15_de_febrero","Conor_Oberst","16_de_febrero","Serhiy_Nazarenko","17_de_febrero","Al_Harrington","Jason_Ritter","18_de_febrero","Regina_Spektor","Catalina_G%C3%B3mez_(presentadora)","19_de_febrero","David_Gandy","Ma_Lin_(tenista_de_mesa)","Mike_Miller","20_de_febrero","Artur_Boruc","Sergei_Zuev","21_de_febrero","Tiziano_Ferro","Justin_Roiland","22_de_febrero","Jeanette_Biedermann","24_de_febrero","Anton_Maiden","2003","Shinsuke_Nakamura","25_de_febrero","Antonio_Burks","27_de_febrero","Don_Diablo_(DJ)","Chelsea_Clinton","Iv%C3%A1n_Hern%C3%A1ndez","Bobby_V","28_de_febrero","Piotr_Giza","Tayshaun_Prince","29_de_febrero","D%C3%A1lmata_(cantante)","Taylor_Twellman","Rub%C3%A9n_Plaza","Ivan_Goi","Fernando_Fayart","Jos%C3%A9_Almaraz","Mijalis_Murutsos","Patrick_C%C3%B4t%C3%A9","Andreas_Jakobsson_(snowboard)","Ricardo_Barroso_Agramont","Natalia_Cuello","Artem_Morozov","Omar_Bravo","1_de_marzo","Kase-O","2_de_marzo","Lance_Cade","3_de_marzo","Conchita_(cantante)","4_de_marzo","Omar_Bravo","Sebasti%C3%A1n_Bosc%C3%A1n","2021","7_de_marzo","Anthony_Oca%C3%B1a","8_de_marzo","Kazuyuki_Okitsu","8_de_marzo","Fabi%C3%A1n_Canobbio","9_de_marzo","Chingy","9_de_marzo","Matthew_Gray_Gubler","10_de_marzo","Nuria_Gago","Sara_Maldonado","12_de_marzo","Arap_Bethke","Ang%C3%A9lica_Bland%C3%B3n","Mar%C3%ADa_Gabriela_Ch%C3%A1vez","13_de_marzo","Kira_Mir%C3%B3","Caron_Butler","Nathan_Phillips","14_de_marzo","Mercedes_McNab","Aaron_Brown","Munetaka_Aoki","Jessica_Abudinen","16_de_marzo","Felipe_Reyes","17_de_marzo","Danny_Califf","19_de_marzo","Antonella_Costa","Ronaldinho","21_de_marzo","Ronaldinho","Deryck_Whibley","25_de_marzo","Javier_Ant%C3%B3n","29_de_marzo","Kim_Tae-hee","30_de_marzo","Paul_Wall","31_de_marzo","Maaya_Sakamoto","31_de_marzo","Kate_Micucci","1_de_abril","Bijou_Phillips","Randy_Orton","Karen_Castrej%C3%B3n_Trujillo","Y%C5%ABko_Takeuchi","2020","4_de_abril","Natalia_Betancurt","Bj%C3%B6rn_Wirdheim","5_de_abril","Matt_Bonner","Joris_Mathijsen","9_de_abril","Jerko_Leko","Albert_Hammond,_Jr.","10_de_abril","Charlie_Hunnam","11_de_abril","Fran_Est%C3%A9vez","Mark_Teixeira","Keiji_Tamada","12_de_abril","Brian_McFadden","13_de_abril","Jana_Cova","Kelli_Giddish","15_de_abril","Yoel_Hern%C3%A1ndez","20_de_abril","Jasmin_Wagner","21_de_abril","Hiro_Shimono","22_de_abril","Carlos_Enrique_Hern%C3%A1ndez","23_de_abril","Marjorie_de_Sousa","Michelle_Manterola","Taio_Cruz","25_de_abril","Alejandro_Valverde","Jordana_Brewster","26_de_abril","Channing_Tatum","Jordana_Brewster","29_de_abril","Kian_Egan","Mohammed_Ameen","30_de_abril","Tania_Lamarca","Ana_Karina_Soto","Ana_Claudia_Talanc%C3%B3n","1_de_mayo","Ana_Claudia_Talanc%C3%B3n","Adriana_Betancur","Zaz_(cantante)","2_de_mayo","Tim_Borowski","3_de_mayo","Andrea_Cossu","4_de_mayo","Masashi_%C5%8Cguro","8_de_mayo","Kumiko_It%C5%8D","9_de_mayo","Grant_Hackett","M%C3%B3nica_G%C3%B3mez","Est%C3%ADbaliz_Mart%C3%ADnez","10_de_mayo","Kiril_Lazarov","11_de_mayo","Francisco_Butt%C3%B3","Mar%C3%ADa_Jos%C3%A9_Mart%C3%ADnez_(actriz)","12_de_mayo","Silvestre_Dangond","Rishi_Sunak","Primer_ministro_del_Reino_Unido","14_de_mayo","Zden%C4%9Bk_Grygera","Pavel_Londak","15_de_mayo","Lina_Marulanda","2010","Juan_Arango","2012","17_de_mayo","Juan_Arango","Mikel_Alonso","Alistair_Overeem","18_de_mayo","Esperanza_G%C3%B3mez","19_de_mayo","Christian_G%C3%A1lvez_(presentador)","20_de_mayo","Cau%C3%A3_Reymond","21_de_mayo","Gotye","23_de_mayo","Miren_Ibarguren","28_de_mayo","Mark_Feehily","Estefan%C3%ADa_Borge","29_de_mayo","Adam_Brown","30_de_mayo","Steven_Gerrard","31_de_mayo","Andrew_Hurley","2_de_junio","Caio_Blat","Abby_Wambach","Fabrizio_Moretti","5_de_junio","Alejandro_Palmarola_Bejerano","7_de_junio","Berni_Rodr%C3%ADguez","9_de_junio","Kana_Ueda","10_de_junio","Sebasti%C3%A1n_Yepes","Sanalejo","Francelino_Matuzalem","Carlos_Castel","Nino_(futbolista)","Marco_Marzano","Tine_Bossuyt","Abhishek_Yadav","13_de_junio","Juan_Carlos_Navarro","Florent_Malouda","Markus_Winkelhock","14_de_junio","Mat%C3%ADas_Novoa","15_de_junio","Almudena_Cid","Christopher_Castile","16_de_junio","Mikel_Alonso_Olano","17_de_junio","Venus_Williams","19_de_junio","Lauren_Lee_Smith","22_de_junio","Luis_Maza","23_de_junio","Francesca_Schiavone","Melissa_Rauch","Erick_El%C3%ADas","24_de_junio","Cicinho","Jon_Altuna","25_de_junio","Inma_Cuesta","26_de_junio","Michael_Vick","27_de_junio","Ben_Bocquelet","El_Incre%C3%ADble_Mundo_de_Gumball","29_de_junio","Akiko_Kawase","30_de_junio","Alireza_Vahedi_Nikbakht","Rade_Prica","Seyi_Olofinjana","4_de_julio","Max_Elliott_Slade","5_de_julio","Jason_Wade","Fabi%C3%A1n_R%C3%ADos_(actor)","6_de_julio","Eva_Green","Pau_Gasol","Leandro_Rivera","8_de_julio","Robbie_Keane","9_de_julio","Udonis_Haslem","10_de_julio","Jessica_Simpson","11_de_julio","Theodore_Wilson","14_de_julio","Giuseppe_Vives","18_de_julio","Kristen_Bell","Lilo_de_la_Vega","19_de_julio","Xavier_Malisse","Giorgio_Mondini","Mark_Webber_(actor)","20_de_julio","Gisele_B%C3%BCndchen","22_de_julio","Dirk_Kuyt","Kate_Ryan","23_de_julio","Michelle_Williams_(cantante)","24_de_julio","N%C3%A9stor_Amarilla","Catalina_Londo%C3%B1o","25_de_julio","Rebeka_Dremelj","26_de_julio","Daniel_Quintero_Calle","Software","Medell%C3%ADn","2020","Jason_Statham","Jacinda_Ardern","Primer_ministro_de_Nueva_Zelanda","27_de_julio","Dolph_Ziggler","28_de_julio","Catalina_Maya","29_de_julio","Fernando_Gonz%C3%A1lez_Ciuffardi","30_de_julio","Mar%C3%ADa_Le%C3%B3n_Barrios","1_de_agosto","Isabel_Marcos_Naranjo","3_de_agosto","Jos%C3%A9_Izquierdo_Mart%C3%ADnez","5_de_agosto","Toni_Doblas","Jason_%C4%8Culina","Salvador_Caba%C3%B1as","Kaylani_Lei","Jesse_Williams","Denisse_Guerrero","6_de_agosto","Debi_Nova","8_de_agosto","Shayna_Baszler","Denisse_Guerrero","Belanova","9_de_agosto","Nuria_Cabanillas","10_de_agosto","Stuart_Bennett","13_de_agosto","%C3%81lex_Gonz%C3%A1lez_(actor)","Paula_Bevilacqua","16_de_agosto","Bob_Hardy","Vanessa_Carlton","17_de_agosto","M%C3%A1bel_Lara","Manuele_Blasi","Jan_Kromkamp","18_de_agosto","Esteban_Cambiasso","Andrea_G%C3%B3mez","26_de_agosto","Macaulay_Culkin","Chris_Pine","27_de_agosto","Servando_Primera","28_de_agosto","Y%C5%ABko_Got%C5%8D","Ryan_Madson","29_de_agosto","David_Desrosiers","William_Levy","30_de_agosto","Angel_Coulby","1_de_septiembre","Jos%C3%A9_Madero_Vizca%C3%ADno","Panda_(banda)","4_de_septiembre","Hitomi_Shimatani","Ricardo_Franco_(actor)","David_Garrett","Lucie_Silvas","5_de_septiembre","Jimena_P%C3%A9rez_de_Vaca","6_de_septiembre","Joseph_Yobo","Lina_Angarita","8_de_septiembre","Mai_Kadowaki","Slim_Thug","9_de_septiembre","Michelle_Williams_(actriz)","Jani_Liimatainen","10_de_septiembre","Mikey_Way","Alejandro_Radetic","Trevor_Rhodes","11_de_septiembre","Willy_Mckey","2021","Ant%C3%B4nio_Pizzonia","Julien_Sabl%C3%A9","Yao_Ming","12_de_septiembre","Maicer_Izturis","Yao_Ming","13_de_septiembre","Daisuke_Matsuzaka","Ben_Savage","Julio_C%C3%A9sar_Meza","14_de_septiembre","Luis_Horna","18_de_septiembre","Adriana_Louvier","21_de_septiembre","Autumn_Reeser","Robert_Hoffman","23_de_septiembre","Syu","24_de_septiembre","John_Arne_Riise","25_de_septiembre","Mat%C3%ADas_Pavoni","Olivia_Molina","Nikola_%C5%BDigi%C4%87","T.I.","26_de_septiembre","Jane_Darling","29_de_septiembre","Ana%C3%AFs_Garc%C3%ADa_Balma%C3%B1a","Emily_Lima","30_de_septiembre","Martina_Hingis","30_de_septiembre","Arisa_Ogasawara","3_de_octubre","Anquan_Boldin","4_de_octubre","Tom%C3%A1%C5%A1_Rosick%C3%BD","Motoki_Takagi","Jimmy_Workman","5_de_octubre","Paul_Thomas_(m%C3%BAsico)","6_de_octubre","Abdoulaye_M%C3%A9%C3%AFt%C3%A9","8_de_octubre","Mike_Mizanin","11_de_octubre","Tomokazu_Sugita","12_de_octubre","Soledad_Pastorutti","13_de_octubre","Ashanti_(cantante)","14_de_octubre","Andrew_Ross_(yudoca)","Pa%C3%BAl_Ambrosi","19_de_octubre","Benjamin_Salisbury","21_de_octubre","Kim_Kardashian","22_de_octubre","Kukuli_Morante","23_de_octubre","Mate_Bili%C4%87","24_de_octubre","Matthew_Amoah","Monica_(cantante)","26_de_octubre","Juan_Manuel_Mendoza","27_de_octubre","Dallyana_Passailaigue","28_de_octubre","Juan_Pablo_Espinosa","Alondra_de_la_Parra","31_de_octubre","Alondra_de_la_Parra","Samaire_Armstrong","5_de_noviembre","Luke_Hemsworth","6_de_noviembre","Pitingo","7_de_noviembre","Luciana_Salazar","9_de_noviembre","Oscar_Vallejo","12_de_noviembre","Ryan_Gosling","H%C3%A9ctor_Mancilla","Carlos_Contreras_Elvira","13_de_noviembre","Monique_Coleman","Stalin_Gonz%C3%A1lez","14_de_noviembre","Carlos_Cabezas","Pedro_Cap%C3%B3","Vanesa_Mart%C3%ADn","17_de_noviembre","Karina_Mora","Isaac_Hanson","Hanson","18_de_noviembre","19_de_noviembre","Vladimir_Radmanovi%C4%87","22_de_noviembre","Jonny_Gomes","Armando_Navarrete","24_de_noviembre","Beth_Phoenix","25_de_noviembre","Nick_Swisher","26_de_noviembre","Aruna_Dindane","30_de_noviembre","Shane_Victorino","3_de_diciembre","Anna_Chlumsky","Jenna_Dewan","4_de_diciembre","Gustavo_Chac%C3%ADn","5_de_diciembre","Shizuka_It%C5%8D","7_de_diciembre","John_George_Terry","John_Alexander_Ortiz","10_de_diciembre","Guillermo_M%C3%A9ndez_Carranza","Jaime_Jim%C3%A9nez_Merlo","12_de_diciembre","Ledley_King","15_de_diciembre","Ethel_Pozo","Christina_Aguilera","18_de_diciembre","Christina_Aguilera","Marel_Baldvinsson","19_de_diciembre","Lilly_Goodman","Jake_Gyllenhaal","Jake_Gyllenhaal","21_de_diciembre","A%C3%ADda_Merlano","22_de_diciembre","Chris_Carmack","Roy_Gal%C3%A1n","23_de_diciembre","Mar%C3%ADa_Fernanda_Yepes","Francisco_Cabrera_(actor)","24_de_diciembre","Stephen_Appiah","25_de_diciembre","Reika_Hashimoto","27_de_diciembre","Nadia_Anjuman","2005","Sof%C3%ADa_Caiche","Cesaro","30_de_diciembre","Eliza_Dushku","31_de_diciembre","Jaime_Mandros","Nerea_Barjola","1_de_enero","Pietro_Nenni","1891","3_de_enero","Joy_Adamson","Lucien_Buysse","6_de_enero","Raymond_Mays","9_de_enero","Juhayman_al-Otayb","16_de_enero","Benjam%C3%ADn_Palencia","17_de_enero","Agust%C3%ADn_Y%C3%A1%C3%B1ez","26_de_enero","Juan_Quintero_Mu%C3%B1oz","Andr%C3%A9s_Saborit_Colomer","20_de_enero","Claudio_Levrino","28_de_enero","Lloren%C3%A7_Villalonga","1_de_febrero","Gregorio_Iuj%C3%A1-Yon%C3%A1","Gastone_Nencini","8_de_febrero","Agust%C3%ADn_Millares_Carlo","19_de_febrero","Bon_Scott","AC/DC","22_de_febrero","Oskar_Kokoschka","22_de_febrero","An%C3%ADbal_de_Mar","29_de_febrero","Yigal_Allon","1_de_marzo","Wilhelmina_Cooper","5_de_marzo","John_Earle_Raven","8_de_marzo","Francisco_Gaona","14_de_marzo","F%C3%A9lix_Rodr%C3%ADguez_de_la_Fuente","22_de_marzo","Lucho_Espinal_Camps","24_de_marzo","%C3%93scar_Arnulfo_Romero","30_de_marzo","Jesse_Owens","4_de_abril","Pedro_Laza","5_de_abril","Max_Cetto","13_de_abril","Carlos_Humberto_Toledo","14_de_abril","Gianni_Rodari","Guillermo_Sautier_Casaseca","15_de_abril","Jean-Paul_Sartre","16_de_abril","Alf_Sj%C3%B6berg","21_de_abril","Aleksandr_Oparin","24_de_abril","Alejo_Carpentier","29_de_abril","Alfred_Hitchcock","30_de_abril","Luis_Mu%C3%B1oz_Mar%C3%ADn","4_de_mayo","Josip_Broz_Tito","6_de_mayo","Mar%C3%ADa_Luisa_Bombal","11_de_mayo","Fernando_Soto","12_de_mayo","Ram%C3%B3n_Baglietto","13_de_mayo","Maruxa_Fandi%C3%B1o_Ricart","18_de_mayo","Ian_Curtis","7_de_junio","Henry_Miller","18_de_junio","Terence_Fisher","Kazimierz_Kuratowski","19_de_junio","Torcuato_Fern%C3%A1ndez-Miranda","29_de_junio","Jorge_Basadre","9_de_julio","Arend_Heyting","13_de_julio","Seretse_Khama","17_de_julio","Donald_Barry_de_Acosta","24_de_julio","Peter_Sellers","25_de_julio","Vlad%C3%ADmir_Vysotski","1_de_agosto","Patrick_Depailler","14_de_agosto","Dorothy_Stratten","19_de_agosto","Otto_Heinrich_Frank","Ana_Frank","20_de_agosto","Joe_Dassin","21_de_agosto","Absal%C3%B3n_Arga%C3%B1ar%C3%A1z","22_de_agosto","Gabriel_Gonz%C3%A1lez_Videla","16_de_septiembre","Jean_Piaget","18_de_septiembre","Hugo_Irurz%C3%BAn","20_de_septiembre","Josias_Braun-Blanquet","24_de_septiembre","Jos%C3%A9_Sim%C3%B3n_Cabarga","25_de_septiembre","John_Bonham","25_de_septiembre","Lewis_Milestone","4_de_octubre","Asesinato_de_Tammy_Terrell","12_de_octubre","Alberto_Demicheli","13_de_octubre","Beto_Fern%C3%A1n","16_de_octubre","Irma_Flaquer","21_de_octubre","Hans_Asperger","S%C3%ADndrome_de_Asperger","27_de_octubre","Steve_Peregrin_Tuk","1_de_noviembre","Asesinato_de_Sherri_Ann_Jarvis","2_de_noviembre","Willie_Sutton","7_de_noviembre","Steve_McQueen","21_de_noviembre","Sara_Garc%C3%ADa","22_de_noviembre","Mae_West","23_de_noviembre","Juliette_Roche","John_Lennon","8_de_diciembre","John_Lennon","The_Beatles","Mark_David_Chapman","9_de_diciembre","Maneco_Galeano","16_de_diciembre","Harland_Sanders","Kentucky_Fried_Chicken","29_de_diciembre","Manuel_Gago_Garc%C3%ADa","31_de_diciembre","Herbert_Marshall_McLuhan","Adriana_Amalia_Lesgart","6_de_enero","Juan_Ram%C3%B3n_Zaragoza","Premio_Nadal","El_nombre_de_la_rosa","Umberto_Eco","Voyager_1","Atlantic_City_(pel%C3%ADcula_de_1980)","Louis_Malle","Cine_de_culto","Los_dioses_deben_estar_locos","Ordinary_People","Robert_Redford","Premios_%C3%93scar","La_ni%C3%B1a_de_la_mochila_azul","Pedro_Fern%C3%A1ndez_(cantante)","Superman_II","Richard_Lester","Christopher_Reeve","Gene_Hackman","Terence_Stamp","El_resplandor_(pel%C3%ADcula)","Stanley_Kubrick","Flash_Gordon","Fame_(pel%C3%ADcula_de_1980)","Alan_Parker","Friday_the_13th","Sean_S._Cunningham","Pepi,_Luci,_Bom_y_otras_chicas_del_mont%C3%B3n","Pedro_Almod%C3%B3var","Irvin_Kershner","Airplane!","Jim_Abrahams","David_Zucker","El_hombre_elefante_(pel%C3%ADcula)","David_Lynch","La_puerta_del_cielo","Michael_Cimino","The_Changeling_(pel%C3%ADcula)","Peter_Medak","The_Blue_Lagoon","Randal_Kleiser","Brooke_Shields","Toro_salvaje","Martin_Scorsese","Juegos_Ol%C3%ADmpicos_de_Mosc%C3%BA_1980","Mosc%C3%BA","Juegos_Ol%C3%ADmpicos_de_Lake_Placid_1980","Lake_Placid","F%C3%B3rmula_1","Alan_Jones","Campeonato_Mundial_de_Pilotos_de_F%C3%B3rmula_1","F%C3%B3rmula_1","WilliamsF1","Campeonato_Mundial_de_Rally","Walter_R%C3%B6hrl","Fiat_131_Abarth","Rally_Dakar","Freddy_Kottulinsky","Volkswagen_Iltis","NASCAR","Dale_Earnhardt","Chevrolet_Monte_Carlo","Championship_Auto_Racing_Teams","Johnny_Rutherford","Chaparral_Cars","Cosworth","500_Millas_de_Indian%C3%A1polis","Johnny_Rutherford","Chaparral_Cars","Cosworth","Turismo_Carretera","Francisco_Espinosa","Chevrolet_Chevy","Turismo_Competici%C3%B3n_2000","Jorge_Omar_del_R%C3%ADo","Dodge_1500","National_Basketball_Association","Los_Angeles_Lakers","Copa_de_Europa_de_Baloncesto","Real_Madrid_(baloncesto)","Liga_Espa%C3%B1ola_de_Baloncesto_(1957-1983)","Real_Madrid_(baloncesto)","Copa_del_Rey_de_Baloncesto","F%C3%BAtbol_Club_Barcelona_(baloncesto)","EHF_Copa_de_Europa","TV_Grosswallstadt","Recopa_de_Europa_de_Balonmano","CB_Calpisa","Liga_ASOBAL","F%C3%BAtbol_Club_Barcelona_(balonmano)","Tour_de_Francia","Joop_Zoetemelk","Vuelta_ciclista_a_Espa%C3%B1a","Faustino_Rup%C3%A9rez","Giro_de_Italia","Bernard_Hinault","Campeonato_del_Mundo_de_ciclismo","Bernard_Hinault","Eurocopa","Selecci%C3%B3n_de_f%C3%BAtbol_de_Alemania","Italia","Copa_Asi%C3%A1tica","Selecci%C3%B3n_de_f%C3%BAtbol_de_Kuwait","Kuwait","Copa_de_las_Naciones_de_la_OFC","Selecci%C3%B3n_de_f%C3%BAtbol_de_Australia","Nueva_Caledonia","Copa_Africana_de_Naciones","Selecci%C3%B3n_de_f%C3%BAtbol_de_Nigeria","Nigeria","Liga_de_Campeones_de_la_UEFA","Nottingham_Forest_Football_Club","Recopa_de_Europa","Valencia_Club_de_F%C3%BAtbol","Copa_de_la_UEFA","Eintracht_Fr%C3%A1ncfort","Supercopa_de_Europa","Valencia_Club_de_F%C3%BAtbol","Copa_Libertadores_de_Am%C3%A9rica","Club_Nacional_de_Football","Sport_Club_Internacional","Copa_Interamericana","Club_Olimpia","Copa_Intercontinental","Club_Nacional_de_Football","Nottingham_Forest_Football_Club","Liga_de_Campeones_de_la_CAF","Canon_de_Yaound%C3%A9","Copa_de_Campeones_de_la_CONCACAF","Pumas_de_la_UNAM","Ligas_de_f%C3%BAtbol_de_Espa%C3%B1a","Real_Madrid_Club_de_F%C3%BAtbol","Copa_del_Rey_de_F%C3%BAtbol","Real_Madrid_Club_de_F%C3%BAtbol","Premier_League","Liverpool_Football_Club","Serie_A_(Italia)","FC_Inter_de_Mil%C3%A1n","Ligue_1","Football_Club_Nantes","Fu%C3%9Fball-Bundesliga","FC_Bayern_de_M%C3%BAnich","Primera_Divisi%C3%B3n_de_M%C3%A9xico","Cruz_Azul","Primera_Divisi%C3%B3n_de_Argentina","Club_Atl%C3%A9tico_River_Plate","Club_Atl%C3%A9tico_Rosario_Central","Campeonato_Brasile%C3%B1o_de_F%C3%BAtbol","Clube_de_Regatas_do_Flamengo","Campeonatos_Nacionales_de_F%C3%BAtbol_en_Chile","Club_de_Deportes_Cobreloa","F%C3%BAtbol_Profesional_Colombiano","Corporaci%C3%B3n_Popular_Deportiva_Junior","Liga_Peruana_de_F%C3%BAtbol","Sporting_Cristal","Primera_Divisi%C3%B3n_Profesional_de_Uruguay","Club_Nacional_de_Football","Bal%C3%B3n_de_Oro","Karl-Heinz_Rummenigge","FC_Bayern_de_M%C3%BAnich","France_Football","National_Football_League","Pittsburgh_Steelers","Super_Bowl","Copa_de_Europa_de_hockey_sobre_patines","F%C3%BAtbol_Club_Barcelona_(hockey_sobre_patines)","Abierto_de_Australia","Brian_Teacher","Kim_Warwick","Hana_Mandl%C3%ADkov%C3%A1","Chris_Evert","Torneo_de_Roland_Garros","Bj%C3%B6rn_Borg","Vitas_Gerulaitis","Chris_Evert","Virginia_Ruzici","Campeonato_de_Wimbledon","Bj%C3%B6rn_Borg","John_McEnroe","Evonne_Goolagong","Chris_Evert","Abierto_de_los_Estados_Unidos","John_McEnroe","Bj%C3%B6rn_Borg","Chris_Evert","Hana_Mandl%C3%ADkov%C3%A1","Tennis_Masters_Cup","Bj%C3%B6rn_Borg","Copa_Davis","Checoslovaquia","Fed_Cup","Raza","Shar_Pei","Perro","Concierto_homenaje_a_Canito","Movida_madrile%C3%B1a","New_Order","Joy_Division","Brian_Johnson","AC/DC","Bon_Scott","Back_in_Black_(%C3%A1lbum)","Bater%C3%ADa_(instrumento_musical)","John_Bonham","Led_Zeppelin","John_Lennon","Asesinato_de_John_Lennon","Mark_David_Chapman","Edificio_Dakota","Nueva_York","Bob_Marley","Nueva_York","Pittsburgh","Peter_Criss","Eric_Carr","Kiss","The_Sisters_of_Mercy","Metallica","Depeche_Mode","ABBA","Super_Trouper","Gracias_por_la_M%C3%BAsica","AC/DC","Back_in_Black","Billy_Joel","Glass_Houses_(%C3%A1lbum_de_Billy_Joel)","Aerosmith","Greatest_Hits_(%C3%A1lbum_de_Aerosmith)","Black_Sabbath","Heaven_and_Hell_(%C3%A1lbum_de_Black_Sabbath)","Blondie","Autoamerican","Bob_Dylan","Saved","Bruce_Springsteen","The_River_(%C3%A1lbum)","Bryan_Adams","Bryan_Adams_(%C3%A1lbum)","Camilo_Sesto","Amaneciendo_(%C3%A1lbum)","Cheap_Trick","David_Bowie","Scary_Monsters_(and_Super_Creeps)","Dead_Kennedys","Fresh_Fruit_for_Rotting_Vegetables","Dire_Straits","Making_Movies","Diamond_Head","Lightning_to_the_Nations","Emmanuel_(cantante_mexicano)","%C3%8Dntimamente_(%C3%A1lbum_de_Emmanuel)","Elton_John","21_at_33","Eva_Ayll%C3%B3n","Genesis_(banda)","Duke_(%C3%A1lbum)","Georgie_Dann","Grover_Washington,_Jr.","Winelight","Iggy_Pop","Soldier_(%C3%A1lbum_de_Iggy_Pop)","Iron_Maiden","Iron_Maiden_(%C3%A1lbum)","John_Lennon","Y%C5%8Dko_Ono","Double_Fantasy","Jos%C3%A9_Jos%C3%A9","Amor,_Amor_(%C3%A1lbum_de_Jos%C3%A9_Jos%C3%A9)","Joy_Division","Closer_(%C3%A1lbum_de_Joy_Division)","Judas_Priest","British_Steel_(%C3%A1lbum)","Julio_Iglesias","Hey!","Juan_Gabriel","Ella_(%C3%A1lbum)","Killing_Joke","Killing_Joke_(%C3%A1lbum_de_1980)","Kiss","Unmasked","Le%C3%B1o_(banda)","M%C3%A1s_madera_(%C3%A1lbum)","Los_R%C3%A1pidos","Los_Tigres_del_Norte","Los_Chichos","Mazap%C3%A1n_(grupo_musical)","Miguel_Bos%C3%A9","Miguel_(%C3%A1lbum)","Mike_Oldfield","QE2_(%C3%A1lbum)","Mot%C3%B6rhead","Ace_of_Spades_(%C3%A1lbum)","Ozzy_Osbourne","Paul_McCartney","McCartney_II","Prince","Dirty_Mind","Queen_(banda)","The_Game_(%C3%A1lbum)","Richard_Clayderman","Rush_(banda)","Permanent_Waves","Scorpions","Animal_Magnetism","Simple_Minds","Stevie_Wonder","Talking_Heads","Remain_in_Light","The_Alan_Parsons_Project","The_Turn_of_a_Friendly_Card","The_Beach_Boys","Keepin%27_the_Summer_Alive","The_Buggles","The_Age_of_Plastic_(%C3%A1lbum)","The_Clash","Black_Market_Clash","The_Clash","Sandinista!","The_Cure","Seventeen_Seconds_(%C3%A1lbum_de_The_Cure)","The_Police","Zenyatta_Mondatta","The_Pretenders","Pretenders_(%C3%A1lbum)","The_Ramones","End_of_the_Century","The_Rolling_Stones","Emotional_Rescue","Trigo_Limpio","U2","Boy_(%C3%A1lbum)","UK_Subs","Crash_Course","Ultravox","Vienna_(%C3%A1lbum)","Uriah_Heep","Vainica_Doble","El_eslab%C3%B3n_perdido_(%C3%A1lbum)","Van_Halen","Women_and_Children_First","Willie_Col%C3%B3n","Ismael_Miranda","Witchfynde","X_(banda)","Los_Angeles_(%C3%A1lbum)","Yes_(banda)","Drama_(Yes)","Yola_Polastry","Yuri_(cantante)","Esperanzas","19_de_abril","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n_1980","Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","La_Haya","Pa%C3%ADses_Bajos","Johnny_Logan","What%27s_Another_Year%3F","Irlanda_en_el_Festival_de_la_Canci%C3%B3n_de_Eurovisi%C3%B3n","Televisi%C3%B3n_en_1980","Premio_Cervantes","Juan_Carlos_Onetti","Premio_Nobel","James_Watson_Cronin","Val_Logsdon_Fitch","Paul_Berg","Walter_Gilbert","Frederick_Sanger","Premio_Nobel_de_Medicina","Baruj_Benacerraf","Jean_Dausset","George_D._Snell","Czes%C5%82aw_Mi%C5%82osz","Adolfo_P%C3%A9rez_Esquivel","Premio_Nobel_de_Econom%C3%ADa","Lawrence_Klein","ISSN","ISSN","ISSN","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Arquitectura_de_computaci%C3%B3n","titulo":"Arquitectura de computadoras","contenido":"La arquitectura de computadoras, tambien llamada arquitectura de ordenadores en algunos casos, es el dise\u00f1o conceptual y la estructura operacional fundamental de un sistema de computadoras.\u200b Es decir, es un modelo y una descripcion funcional de los requerimientos y las implementaciones de dise\u00f1o para varias partes de una computadora, con especial interes en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.  Tambien la arquitectura del computador esta basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexion.  Tambien suele definirse como la forma de interconectar componentes de hardware, para crear computadoras segun los requerimientos de funcionalidad, rendimiento y costo.  La computadora recibe y envia la informacion a traves de los perifericos, por medio de los canales. La CPU es la encargada de procesar la informacion que le llega a la computadora. El intercambio de informacion se tiene que hacer con los perifericos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periferico, por lo que la computadora tiene dos partes bien definidas, que son:  \u200b La implantacion de instrucciones es similar al uso de una serie de montaje en una fabrica de manufacturacion. En las cadenas de montaje, el producto pasa a traves de muchas etapas de produccion antes de tener el producto armado. Cada etapa o segmento de la cadena esta especializada en un area especifica de la linea de produccion y lleva a cabo siempre la misma actividad. Esta tecnologia es aplicada en el dise\u00f1o de procesadores eficientes.  A estos procesadores se les conoce como pipeline processors. Estos estan compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o informacion para el uso externo.  Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:  Son las encargadas de procesar la logica de las instrucciones del sistema. Existen siete tipos basicos diferentes:  La diferencia basica esta en el almacenamiento interno de la CPU. Las principales alternativas son:  Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia. ","snippet":"La arquitectura de computadoras, tambien llamada arquitectura de ordenadores en algunos casos, es el dise\u00f1o conceptual y la estructura operacional fundamental de un sistema de computadoras.\u200b Es decir,","enlaces_salientes":["Arquitectura_de_computadoras","Arquitectura_de_computadoras","Arquitectura_de_computadoras","Computadora","Requerimiento_(sistemas)","Unidad_central_de_proceso","Memoria_(inform%C3%A1tica)","Hardware","Perif%C3%A9rico_(inform%C3%A1tica)","Memoria_principal","Unidad_aritm%C3%A9tico_l%C3%B3gica","Unidad_de_control","F%C3%A1brica","Manufactura","Cadena_de_montaje","Producci%C3%B3n_en_cadena","Tecnolog%C3%ADa","Microprocesador","Memoria_(inform%C3%A1tica)","Conjunto_de_instrucciones","NOT","AND","OR","Puerta_XOR","NAND","Puerta_NOR","XNOR","Acumulador_(inform%C3%A1tica)","Notaci%C3%B3n_polaca_inversa","OCLC","32_bits","64_bits","Arquitectura_de_CPU","Arquitectura_de_von_Neumann","Arquitectura_Harvard","Computadora","Mantenimiento_preventivo","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"V%C3%A1lvula_termoi%C3%B3nica","titulo":"Valvula termoionica","contenido":"La valvula termoionica, tambien llamada valvula electronica, valvula de vacio, tubo de vacio o bulbo, es un componente electronico utilizado para amplificar, conmutar, o modificar una se\u00f1al electrica mediante el control del movimiento de los electrones en un espacio vacio a muy baja presion, o en presencia de gases especialmente seleccionados.  La valvula originaria fue el componente critico que posibilito el desarrollo de la electronica durante la primera mitad del siglo\u00a0XX, incluyendo la expansion y comercializacion de la radiodifusion, television, radar, audio, redes telefonicas, computadoras analogicas y digitales, control industrial, etc. Algunas de estas aplicaciones son anteriores a la valvula, pero experimentaron un crecimiento explosivo gracias a ella.  A lo largo de su historia, fueron introducidos muchos tipos de valvulas, pero los principios de funcionamiento basicos son:  El ocaso de esta tecnologia comenzo con la invencion del transistor y el posterior desarrollo de componentes de estado solido que eran mucho mas peque\u00f1os, baratos y fiables que la valvula. Sin embargo hoy en dia aun sobrevive en ciertas aplicaciones especificas, donde por razones tecnicas resultan mas conveniente. Por ejemplo en transmisores de radiofrecuencia de alta potencia y sistemas de radar se utilizan magnetrones, valvulas de onda progresiva TWT, tiratrones, etc. En television y sistemas de imagen medicinal aun se utilizan tubos de rayos catodicos o tubos de captura de imagen, y en el hogar es la base de funcionamiento del horno microondas. Tambien siguen siendo ampliamente utilizadas en preamplificadores de microfonos, guitarras y bajos, asi como en equipos de sonido de alta fidelidad.  Aunque el efecto de emision termoionica fue originalmente informado por Frederick Guthrie en 1873, es la investigacion de Thomas Alva Edison el trabajo mas a menudo mencionado. Edison, al ver que con el uso el cristal de las lamparas incandescentes se iba oscureciendo, busco la forma de aminorar dicho efecto, realizando para ello diversos experimentos. Uno de ellos fue introducir en la ampolla de la lampara un electrodo en forma de placa, que se polarizaba electricamente con el fin de atraer las particulas que, al parecer, se desprendian del filamento. A pesar de que Edison no comprendia a nivel fisico el funcionamiento, y desconocia el potencial de su \u00abdescubrimiento\u00bb, en 1884 lo patento bajo el nombre de \"Efecto Edison\".  Al agregar un electrodo plano (placa), cuando el filamento se calienta se produce una agitacion de los atomos del material que lo recubre, y los electrones de las orbitas de valencia son acelerados, alcanzando velocidades de escape, con lo que se forma una nube de electrones por encima del mismo. La nube termoionica, fuertemente atraida por la placa, debido al potencial positivo aplicado en la misma, da lugar a la circulacion de una corriente electronica a traves de la valvula entre el filamento y el anodo. A este fenomeno se le denomina Efecto Edison-Richardson o termoionico.  Llegados a este punto, tenemos que la valvula termoionica mas simple esta constituida por una ampolla de vidrio, similar a la de las lamparas de incandescencia, a la que se le ha practicado el vacio y en la que se hallan encerrados dos electrodos, denominados catodo y anodo.  Fisicamente, el catodo, consiste en un filamento de wolframio, recubierto por una sustancia rica en electrones libres, que se calienta mediante el paso de una corriente. El anodo esta formado por una placa metalica que rodea al filamento a una cierta distancia y a la que se aplica un potencial positivo. Por constar de dos electrodos a la valvula antes descrita se le denomina diodo.  En tanto que la funcion de catodo es realizada directamente por el filamento, se trata de una valvula de caldeo directo.  Cuando se quieren obtener mayores corrientes a traves de la valvula y un aislamiento electrico entre la fuente de corriente de caldeo del filamento y la de anodo-catodo, se utiliza un catodo independiente constituido por un peque\u00f1o tubo metalico revestido o \"pintado\" con algun material rico en electrones libres, como el oxido de torio, que rodea el filamento, aislado electricamente, pero muy proximo a el para poder calentarlo adecuadamente. En este caso la valvula se denomina de caldeo indirecto, pudiendo entonces la corriente del caldeo ser incluso alterna. En este tipo de valvulas el filamento solo es el elemento calefactor y no se considera un electrodo activo. Al estar los filamentos aislados se pueden conectar juntos (en serie o paralelo) los filamentos de todas las valvulas del equipo, lo que no es posible con catodos de caldeo directo.  Si se agregan otros electrodos entre anodo y catodo (llamados rejillas) se puede controlar o modular el flujo de electrones que llegan al anodo, de ahi la denominacion de valvula.  Debido al hecho de que la corriente por el interior de la valvula solo puede circular en un sentido, una de las aplicaciones de las valvulas termoionicas es su utilizacion como rectificador. Asimismo, y dado que con peque\u00f1as diferencias de potencial aplicadas entre rejilla y catodo se pueden producir variaciones considerables de la corriente circulante entre catodo y anodo, otra aplicacion, posiblemente la mas importante, es como amplificador.  Aunque existe una gran diversidad de tipos de valvulas termoionicas, tanto en su aplicacion como en sus principios de funcionamiento (control de la cantidad de electrones, en triodos, tetrodos, pentodos; modulacion de su velocidad en klistrones; acoplo entre el flujo de electrones y una onda electromagnetica en tubos de onda progresiva; etc.), la mayoria comparten una serie de caracteristicas comunes que se han ido potenciando al ir avanzando su desarrollo tecnologico.  El filamento es el organo calefactor que proporciona la energia suficiente para que el catodo emita una cantidad de electrones adecuada.  En las primeras valvulas, el filamento tambien actuaba como catodo (catodo de caldeo directo). Posteriormente se separaron las funciones, quedando el filamento solo como calefactor y el catodo como electrodo separado (catodo de caldeo indirecto). Ambas formas convivieron, ya que el caldeo directo mejora la transferencia termica entre el catodo y el filamento, mientras que el caldeo indirecto simplifica grandemente el dise\u00f1o de los circuitos y permite optimizar cada uno de los electrodos.  El filamento, al estar caliente, se ve sometido al efecto de sublimacion del material de su superficie, es decir, su paso al estado gaseoso, lo que va reduciendo su seccion en ciertos puntos que ahora se calientan mas que el resto, aumentando la sublimacion en ellos hasta que el filamento se rompe. Este efecto disminuye enormemente si se trabaja a temperaturas bajas con materiales de alto punto de fusion (wolframio...). Por ello la temperatura de los filamentos ha ido descendiendo.  Efecto microfonico: este efecto consiste en la transmision al filamento de vibraciones mecanicas. Cuando el filamento vibra, transmite estas oscilaciones al catodo, variando su distancia con la rejilla, lo que produce una modulacion en la corriente de electrones. En el anodo, la se\u00f1al util aparece modulada por las vibraciones mecanicas, lo que es especialmente desagradable en el caso de amplificadores de audio, ya que las vibraciones que se acoplan provienen del propio altavoz.  Los campos magneticos tambien pueden crear oscilaciones del filamento, por ello algunas valvulas se encerraban en tubos de gran permeabilidad magnetica (mu-metal).  El catodo es el responsable de la emision de electrones, que debe ser constante a lo largo de la vida de la valvula. Desgraciadamente, esto no es asi, y los catodos se van agotando segun envejecen.  Para prolongar la vida de los filamentos, la temperatura de funcionamiento de los catodos ha ido haciendose cada vez menor, gracias al empleo de materiales con un potencial de extraccion de electrones mas bajo (aleaciones de torio, oxidos de lantanidos... ).  Los catodos tambien deben ser buenos conductores, lo que limita la aplicacion de algunos recubrimientos a aplicaciones muy particulares. Por ejemplo, el oxido de calcio suele recubrir los filamentos de las pantallas de vacio fluorescentes (VFD).  El anodo recibe el flujo de electrones que, en la mayoria de las valvulas, han sido acelerados hasta adquirir gran energia que transfieren al anodo cuando chocan contra el. Por ello, los anodos de las valvulas de potencia son grandes, muchas veces masivos y forman parte del propio cuerpo de la valvula, pudiendo refrigerarse directamente desde el exterior, por contacto con una superficie fria, aire a presion, vapor de agua, etc. Anteriormente, la refrigeracion de anodo se realizaba fundamentalmente por radiacion, por lo que las ampollas de vidrio eran grandes y separadas del anodo, para que este pudiese adquirir gran temperatura.  La emision secundaria es un efecto, normalmente indeseable, que se produce en el anodo, cuando los electrones incidentes, de gran energia, arrancan electrones del metal. Aunque en algunas valvulas este efecto se aprovecha para obtener ganancia, en la mayoria de ellas degrada la se\u00f1al y debe evitarse.  Un menor grado de vacio implica la presencia de un mayor numero de moleculas de gas en la valvula, aumentando el numero de colisiones con los electrones y disminuyendo el rendimiento del tubo. Ademas un menor vacio implica un mayor desgaste de los filamentos, por lo que historicamente se ha ido avanzando hacia las valvulas de alto vacio mediante un avance conjunto en todos los demas componentes. Sin embargo, algunas valvulas como los tiratrones basan su funcionamiento en la presencia de ciertos gases llenando el tubo.  Los metales y otros materiales tienen propiedades de absorcion y adsorcion de gases de la atmosfera, y cuando se calientan a baja presion los van liberando lentamente. Por ello, aunque se extraiga todo el aire de una valvula, con el uso, el vacio interior se reduce. Para evitarlo se utiliza el getter, que es un material (por ejemplo, magnesio) que se evapora una vez sellado el tubo. El magnesio evaporado se deposita en la superficie del vidrio formando un recubrimiento brillante. El getter adsorbe las moleculas de gas que puedan liberarse en el tubo, manteniendo la integridad del vacio. Cuando entra aire en el tubo, el getter se vuelve blanquecino.  El material mas utilizado en construccion del \"recipiente\" de la valvula es el vidrio, ya heredado de la fabricacion de bombillas. Pero el vidrio tiene bajo punto de fusion, es un buen aislante termico y es fragil, de modo que para valvulas de alta potencia y radiofrecuencia se prefiere utilizar ceramicas, que son menos fragiles, tienen buena conductividad termica y alto punto de fusion. Su talon de Aquiles ha sido el establecimiento de uniones estancas y duraderas entre la ceramica y el metal (conexiones de los electrodos, anodo, disipadores). Una vez resuelto el problema, la ceramica ha desplazado al vidrio en valvulas de potencia y de microondas.  Segun el numero de electrodos las valvulas se clasifican en: diodos, triodos, tetrodos, pentodos, y asi sucesivamente.  Otros tipos de valvulas termoionicas son:  Similares a las valvulas termoionicas, pero sin emplear el efecto Edison son:   ","snippet":"La valvula termoionica, tambien llamada valvula electronica, valvula de vacio, tubo de vacio o bulbo, es un componente electronico utilizado para amplificar, conmutar, o modificar una se\u00f1al electrica ","enlaces_salientes":["V%C3%A1lvula_termoi%C3%B3nica","V%C3%A1lvula_termoi%C3%B3nica","V%C3%A1lvula_termoi%C3%B3nica","Diodo_de_vac%C3%ADo","Emisi%C3%B3n_termoi%C3%B3nica","John_Ambrose_Fleming","1904","Lee_De_Forest","1906","Walter_H._Schottky","1919","1926","%C3%81nodo","C%C3%A1todo","Componente_electr%C3%B3nico","Se%C3%B1al_el%C3%A9ctrica","Vac%C3%ADo","Efecto_Edison","Electr%C3%B3n","Gas_ionizado","Efecto_fotoel%C3%A9ctrico","Efecto_fotoel%C3%A9ctrico","Transistor","Thomas_Alva_Edison","L%C3%A1mpara_incandescente","Electrodo","%C3%81tomo","C%C3%A1todo","%C3%81nodo","Wolframio","Diodo","Rectificador","Amplificador","Diodo_de_vac%C3%ADo","Triodo","Tetrodo","Pentodo","Triodo","Tetrodo","Pentodo","Klistr%C3%B3n","TWT","Mu-metal","VFD","Adsorci%C3%B3n","Diodo","Triodo","Tetrodo","Pentodo","Tiratr%C3%B3n","Tubo_de_rayos_cat%C3%B3dicos","Iconoscopio","Ortic%C3%B3n","Ojo_m%C3%A1gico","Klistr%C3%B3n","Magnetr%C3%B3n","TWT","Decatr%C3%B3n","Trocotr%C3%B3n","Selectr%C3%B3n","Tubo_Williams","VFD","Ignitr%C3%B3n","Tubo_Nixie","C%C3%A9lulas_fotoel%C3%A9ctricas","Detector_Geiger-M%C3%BCller","Audi%C3%B3n","Radiotr%C3%B3n","Audi%C3%B3filo","Pila_(v%C3%A1lvula_termoi%C3%B3nica)","Radio_a_v%C3%A1lvulas","Receptor_superheterodino","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Transistor","titulo":"Transistor","contenido":"El transistor es un dispositivo electronico semiconductor. Permite el paso de una se\u00f1al en respuesta a otra. Se puede configurar o \"comportar\" como amplificador, oscilador, conmutador o rectificador. El termino \u00abtransistor\u00bb proviene del acronimo transfer resistor (resistor de transferencia). El transistor se encuentra practicamente en todos los aparatos electronicos como radios, televisores y computadoras. Habitualmente dentro de los circuitos integrados.  El fisico austro-hungaro  Julius Edgar Lilienfeld solicito en Canada en el a\u00f1o 1925\u200b una patente para lo que el denomino \u00abun metodo y un aparato para controlar corrientes electricas\u00bb y que se considera el antecesor de los actuales transistores de efecto campo, ya que estaba destinado a ser un reemplazo de estado solido del triodo. Lilienfeld tambien solicito patentes en los Estados Unidos en los a\u00f1os 1926\u200b y 1928.\u200b\u200b Sin embargo, Lilienfeld no publico ningun articulo de investigacion sobre sus dispositivos, ni sus patentes citan algun ejemplo especifico de un prototipo de trabajo. Debido a que la produccion de materiales semiconductores de alta calidad no estaba disponible por entonces, las ideas de Lilienfeld sobre amplificadores de estado solido no encontraron un uso practico en los a\u00f1os 1920 y 1930, aunque acabara de construir un dispositivo de este tipo.\u200b  En 1934, el inventor aleman Oskar Heil patento en Alemania y Gran Breta\u00f1a\u200b un dispositivo similar. Cuatro a\u00f1os despues, los tambien alemanes Robert Pohl y Rudolf Hilsch efectuaron experimentos en la Universidad de Gottingen, con cristales de bromuro de potasio, usando tres electrodos, con los cuales lograron la amplificacion de se\u00f1ales de 1\u00a0Hz, pero sus investigaciones no condujeron a usos practicos.\u200b Mientras tanto, la experimentacion en los Laboratorios Bell con rectificadores a base de oxido de cobre y las explicaciones sobre rectificadores a base de semiconductores por parte del aleman Walter Schottky y del ingles Nevill Mott, llevaron a pensar en 1938 a William Shockley que era posible lograr la construccion de amplificadores a base de semiconductores, en lugar de tubos de vacio.\u200b  Desde el 17 de noviembre de 1947 hasta el 23 de diciembre de 1947, los fisicos estadounidenses John Bardeen y Walter Houser Brattain de los Laboratorios Bell\u200b llevaron a cabo diversos experimentos y observaron que cuando dos contactos puntuales de oro eran aplicados a un cristal de germanio, se produjo una se\u00f1al con una potencia de salida mayor que la de entrada.\u200b El lider del Grupo de Fisica del Estado Solido William Shockley vio el potencial de este hecho y, en los siguientes meses, trabajo para ampliar en gran medida el conocimiento de los semiconductores. El termino \u00abtransistor\u00bb fue sugerido por el ingeniero estadounidense John R. Pierce, basandose en dispositivos semiconductores ya conocidos entonces, como el termistor y el varistor y basandose en la propiedad de transrresistencia que mostraba el dispositivo.\u200b Segun una biografia de John Bardeen, Shockley habia propuesto que la primera patente para un transistor de los Laboratorios Bell debia estar basado en el efecto de campo y que el fuera nombrado como el inventor. Habiendo redescubierto las patentes de Lilienfeld que quedaron en el olvido a\u00f1os atras, los abogados de los Laboratorios Bell desaconsejaron la propuesta de Shockley porque la idea de un transistor de efecto de campo no era nueva. En su lugar, lo que Bardeen, Brattain y Shockley inventaron en 1947 fue el primer transistor de contacto de punto, cuya primera patente solicitaron los dos primeros nombrados, el 17 de junio de 1948,\u200b a la cual siguieron otras patentes acerca de aplicaciones de este dispositivo.\u200b\u200b\u200b En reconocimiento a este logro, Shockley, Bardeen y Brattain fueron galardonados conjuntamente con el Premio Nobel de Fisica de 1956 \u00abpor sus investigaciones sobre semiconductores y su descubrimiento del efecto transistor\u00bb.\u200b  En 1948, el transistor de contacto fue inventado independientemente por los fisicos alemanes Herbert Matare y Heinrich Welker, mientras trabajaban en la Compagnie des Freins et Signaux, una subsidiaria francesa de la estadounidense Westinghouse. Matare tenia experiencia previa en el desarrollo de rectificadores de cristal de silicio y de germanio mientras trabajaba con Welker en el desarrollo de un radar aleman durante la Segunda Guerra Mundial. Usando este conocimiento, el comenzo a investigar el fenomeno de la \u00abinterferencia\u00bb que habia observado en los rectificadores de germanio durante la guerra. En junio de 1948, Matare produjo resultados consistentes y reproducibles utilizando muestras de germanio producidas por Welker, similares a lo que Bardeen y Brattain habian logrado anteriormente en diciembre de 1947. Al darse cuenta de que los cientificos de Laboratorios Bell ya habian inventado el transistor antes que ellos, la empresa se apresuro a poner en produccion su dispositivo llamado \u00abtransistron\u00bb para su uso en la red telefonica de Francia.\u200b El 26 de junio de 1948, Wiliam Shockley solicito la patente del transistor bipolar de union\u200b y el 24 de agosto de 1951 solicito la primera patente de un transistor de efecto de campo,\u200b tal como se declaro en ese documento, en el que se menciono la estructura que ahora posee. Al a\u00f1o siguiente, George Clement Dacey e Ian Ross, de los Laboratorios Bell, tuvieron exito al fabricar este dispositivo,\u200b cuya nueva patente fue solicitada el 31 de octubre de 1952.\u200b Meses antes, el 9 de mayo de ese a\u00f1o, el ingeniero Sidney Darlington solicito la patente del arreglo de dos transistores conocido actualmente como transistor Darlington.\u200b  El primer transistor de alta frecuencia fue el transistor de barrera de superficie de germanio desarrollado por los estadounidenses John Tiley y Richard Williams de Philco Corporation en 1953,\u200b capaz de operar con se\u00f1ales de hasta 60\u00a0MHz.\u200b Para fabricarlo, se uso un procedimiento creado por los ya mencionados inventores mediante el cual eran grabadas depresiones en una base de germanio tipo N de ambos lados con chorros de sulfato de indio hasta que tuviera unas diez milesimas de pulgada de espesor. El Indio electroplateado en las depresiones formo el colector y el emisor.\u200b El primer receptor de radio para automoviles que fue producido en 1955 por Chrysler y Philco; uso estos transistores en sus circuitos y tambien fueron los primeros adecuados para las computadoras de alta velocidad de esa epoca.\u200b\u200b  El primer transistor de silicio operativo fue desarrollado en los Laboratorios Bell en enero de 1954 por el quimico Morris Tanenbaum.\u200b El 20 de junio de 1955, Tanenbaum y Calvin Fuller, solicitaron una patente para un procedimiento inventado por ambos para producir dispositivos semiconductores.\u200b El primer transistor de silicio comercial fue producido por Texas Instruments en 1954 gracias al trabajo del experto Gordon Teal quien habia trabajado previamente en los Laboratorios Bell en el crecimiento de cristales de alta pureza.\u200b El primer transistor MOSFET fue construido por el coreano-estadounidense Dawon Kahng y el egipcio Martin Atalla, ambos ingenieros de los Laboratorios Bell, en 1960.\u200b\u200b  El transistor consta de tres partes dopadas artificialmente (impurezas con materiales especificos en cantidades especificas) que forman dos uniones bipolares: el emisor que emite portadores, el colector que los recibe o recolecta y la tercera, que esta intercalada entre las dos primeras, modula el paso de dichos portadores (base). A diferencia de las valvulas, el transistor es un dispositivo controlado por corriente y del que se obtiene corriente amplificada. En el dise\u00f1o de circuitos a los transistores se les considera un elemento activo,\u200b a diferencia de los resistores, condensadores e inductores que son elementos pasivos.\u200b  De manera simplificada, la corriente que circula por el colector es funcion amplificada de la que se inyecta en el emisor, pero el transistor solo gradua la corriente que circula a traves de si mismo, si desde una fuente de corriente continua se alimenta la base para que circule la carga por el colector, segun el tipo de circuito que se utilice. El factor de amplificacion o ganancia logrado entre corriente de colector y corriente de base, se denomina Beta del transistor. Otros parametros a tener en cuenta y que son particulares de cada tipo de transistor son: Tensiones de ruptura de Colector Emisor, de Base Emisor, de Colector Base, Potencia Maxima, disipacion de calor, frecuencia de trabajo, y varias tablas donde se grafican los distintos parametros tales como corriente de base, tension Colector Emisor, tension Base Emisor, corriente de Emisor, etc. Los tres tipos de esquemas(configuraciones) basicos para utilizacion analogica de los transistores son emisor comun, colector comun y base comun.  Modelos posteriores al transistor descrito, el transistor bipolar (transistores FET, MOSFET, JFET, CMOS, VMOS, etc.) no utiliza la corriente que se inyecta en el terminal de base para modular la corriente de emisor o colector, sino la tension presente en el terminal de puerta y gradua la conductancia del canal entre los terminales de Fuente y Drenaje. Cuando la conductancia es nula y el canal se encuentra estrangulado, por efecto de la tension aplicada entre Compuerta y Fuente, es el campo electrico presente en el canal el responsable de impulsar los electrones desde la fuente al drenaje. De este modo, la corriente de salida en la carga conectada al Drenaje (D) sera funcion amplificada de la tension presente entre la compuerta y la fuente, de manera analoga al funcionamiento del triodo.  Los transistores de efecto de campo son los que han permitido la integracion a gran escala disponible hoy en dia; para tener una idea aproximada pueden fabricarse varios cientos de miles de transistores interconectados, por centimetro cuadrado y en varias capas superpuestas.  Llamado tambien \u00abtransistor de punta de contacto\u00bb, fue el primer transistor capaz de obtener ganancia, inventado en 1947 por John Bardeen y Walter Brattain. Consta de una base de germanio, semiconductor para entonces mejor conocido que la combinacion cobre-oxido de cobre, sobre la que se apoyan, muy juntas, dos puntas metalicas que constituyen el emisor y el colector. La corriente de base es capaz de modular la resistencia que se \u00abve\u00bb en el colector, de ahi el nombre de transfer resistor. Se basa en efectos de superficie, poco conocidos en su dia. Es dificil de fabricar (las puntas se ajustaban a mano), fragil (un golpe podia desplazar las puntas) y ruidoso. Sin embargo convivio con el transistor de union debido a su mayor ancho de banda. En la actualidad ha desaparecido.  El transistor de union bipolar (o BJT, por sus siglas del ingles bipolar junction transistor) se fabrica sobre un monocristal de material semiconductor como el germanio, el silicio o el arseniuro de galio, cuyas cualidades son intermedias entre las de un conductor electrico y las de un aislante. Sobre el sustrato de cristal se dopan en forma muy controlada tres zonas sucesivas, N-P-N o P-N-P, dando lugar a dos uniones PN.  Las zonas N (en las que abundan portadores de carga Negativa) se obtienen dopando el sustrato con atomos de elementos donantes de electrones, como el arsenico o el fosforo; mientras que las zonas P (donde se generan portadores de carga Positiva o \u00abhuecos\u00bb) se logran dopando con atomos aceptadores de electrones, como el indio, el aluminio o el galio.  Las tres zonas dopadas dan como resultado transistores PNP o NPN, donde la letra intermedia siempre corresponde a la region de la base, y las otras dos al emisor y al colector que, si bien son del mismo tipo y de signo contrario a la base, tienen diferente dopados entre ellas (por lo general, el emisor esta mucho mas dopado que el colector).  El mecanismo que representa el comportamiento semiconductor dependera de dicho dopado, de la geometria asociada y del tipo de tecnologia de dopado (difusion gaseosa, epitaxial, etc.) y del comportamiento cuantico de la union.  El transistor de efecto de campo de union (JFET), fue el primer transistor de efecto de campo en la practica. Lo forma una barra de material semiconductor de silicio de tipo N o P. En los terminales de la barra se establece un contacto ohmico, tenemos asi un transistor de efecto de campo tipo N de la forma mas basica. Si se difunden dos regiones P en una barra de material N y se conectan externamente entre si, se producira una puerta. A uno de estos contactos le llamaremos surtidor y al otro drenador. Aplicando tension positiva entre el drenador y el surtidor y conectando la puerta al surtidor, estableceremos una corriente, a la que llamaremos corriente de drenador con polarizacion cero. Con un potencial negativo de puerta al que llamamos tension de estrangulamiento, cesa la conduccion en el canal.  El transistor de efecto de campo, o FET por sus siglas en ingles, que controla la corriente en funcion de una tension; tienen alta impedancia de entrada.  Los fototransistores son sensibles a la radiacion electromagnetica en frecuencias cercanas a la de la luz visible; debido a esto su flujo de corriente puede ser regulado por medio de la luz incidente. Un fototransistor es, en esencia, lo mismo que un transistor normal, solo que puede trabajar de 2 maneras diferentes:  Con el desarrollo tecnologico y evolucion de la electronica, la capacidad de los dispositivos semiconductores para soportar cada vez mayores niveles de tension y corriente ha permitido su uso en aplicaciones de potencia. Es asi como actualmente los transistores son empleados en conversores estaticos de potencia, controles para motores y llaves de alta potencia (principalmente inversores), aunque su principal uso esta basado en la amplificacion de corriente dentro de un circuito cerrado.  Los primeros transistores bipolares de union se fabricaron con germanio (Ge). Los transistores de Silicio (Si) actualmente predominan, pero ciertas versiones avanzadas de microondas y de alto rendimiento ahora emplean el compuesto semiconductor de arseniuro de galio (GaAs) y la aleacion semiconductora de silicio-germanio (SiGe). El material semiconductor a base de un elemento (Ge y Si) se describe como elemental.  Los parametros en bruto de los materiales semiconductores mas comunes utilizados para fabricar transistores se dan en la tabla adjunta; estos parametros variaran con el aumento de la temperatura, el campo electrico, nivel de impurezas, la tension, y otros factores diversos.  La tension directa de union es la tension aplicada a la union emisor-base de un transistor bipolar de union con el fin de hacer que la base conduzca a una corriente especifica. La corriente aumenta de manera exponencial a medida que aumenta la tension en directa de la union. Los valores indicados en la tabla son las tipicos para una corriente de 1\u00a0mA (los mismos valores se aplican a los diodos semiconductores). Cuanto mas bajo es la tension de la union en directa, mejor, ya que esto significa que se requiere menos energia para colocar en conduccion al transistor. La tension de union en directa para una corriente dada disminuye con el aumento de la temperatura. Para una union de silicio tipica, el cambio es de \u20132.1\u00a0mV/\u00b0C.\u200b En algunos circuitos deben usarse elementos compensadores especiales (sensistores) para compensar tales cambios.  La densidad de los portadores moviles en el canal de un MOSFET es una funcion del campo electrico que forma el canal y de varios otros fenomenos tales como el nivel de impurezas en el canal. Algunas impurezas, llamadas dopantes, se introducen deliberadamente en la fabricacion de un MOSFET, para controlar su comportamiento electrico.  Las columnas de movilidad de electrones y movilidad de huecos de la tabla muestran la velocidad media con que los electrones y los huecos se difunden a traves del material semiconductor con un campo electrico de 1 voltio por metro, aplicado a traves del material. En general, mientras mas alta sea la movilidad electronica, el transistor puede funcionar mas rapido. La tabla indica que el germanio es un material mejor que el silicio a este respecto. Sin embargo, el germanio tiene cuatro grandes deficiencias en comparacion con el silicio y arseniuro de galio:  Debido a que la movilidad de los electrones es mas alta que la movilidad de los huecos para todos los materiales semiconductores, un transistor bipolar n-p-n dado tiende a ser mas rapido que un transistor equivalente p-n-p. El arseniuro de galio tiene el valor mas alto de movilidad de electrones de los tres semiconductores. Es por esta razon que se utiliza en aplicaciones de alta frecuencia. Un transistor FET de desarrollo relativamente reciente, el transistor de alta movilidad de electrones (HEMT), tiene una heteroestructura (union entre diferentes materiales semiconductores) de arseniuro de galio-aluminio (AlGaAs)-arseniuro de galio (GaAs), que tiene el doble de la movilidad de los electrones que una union de barrera GaAs-metal. Debido a su alta velocidad y bajo nivel de ruido, los HEMT se utilizan en los receptores de satelite que trabajan a frecuencias en torno a los 12\u00a0GHz. Los HEMT basados en nitruro de galio y nitruro de galio aluminio (AlGaN/GaN HEMT) proporcionan una movilidad de los electrones aun mayor y se estan desarrollando para diversas aplicaciones.  Los valores de la columna de Maximo valor de temperatura de la union han sido tomados a partir de las hojas de datos de varios fabricantes. Esta temperatura no debe ser excedida o el transistor puede da\u00f1arse.  Los datos de la fila Al-Si de la tabla se refieren a los diodos de barrera de metal-semiconductor de alta velocidad (de aluminio-silicio), conocidos comunmente como diodos Schottky. Esto esta incluido en la tabla, ya que algunos transistor IGFET de potencia de silicio tienen un diodo Schottky inverso \u00abparasito\u00bb formado entre la fuente y el drenaje como parte del proceso de fabricacion. Este diodo puede ser una molestia, pero a veces se utiliza en el circuito del cual forma parte.  El comportamiento del transistor se puede ver como dos diodos (Modelo de Ebers-Moll), uno entre base y emisor, polarizado en directo y otro diodo entre base y colector, polarizado en inverso. Esto quiere decir que entre base y emisor tendremos una tension igual a la tension directa de un diodo, es decir 0,6 a 0,8\u00a0V para un transistor de silicio y unos 0,4 para el germanio.  Lo interesante del dispositivo es que en el colector tendremos una corriente proporcional a la corriente de base: IC = \u03b2 IB, es decir, ganancia de corriente cuando \u03b2>1. Para transistores normales de se\u00f1al, \u03b2 varia entre 100 y 300. Existen tres configuraciones para el amplificador transistorizado: emisor comun, base comun y colector comun.  La se\u00f1al se aplica a la base del transistor y se extrae por el colector. El emisor se conecta al punto de tierra (masa) que sera comun, tanto de la se\u00f1al de entrada como para la de salida. En esta configuracion, existe ganancia tanto de tension como de corriente. Para lograr la estabilizacion de la etapa ante las variaciones de la se\u00f1al, se dispone de una resistencia de emisor, (RE) y para frecuencias bajas, la impedancia de salida se aproxima a RC. La ganancia de tension se expresa:   G V = \u2212 R C R E =-}{R_{E}}}}  El signo negativo, indica que la se\u00f1al de salida esta invertida con respecto a la se\u00f1al de entrada.  Si el emisor esta conectado directamente a masa, la ganancia queda expresada de la siguiente forma:   G V = \u2212 R C R e =-}{R_{e}}}}  Como la base esta conectada al emisor por un diodo polarizado en directo, entre ellos se puede suponer que existe una tension constante, denominada V B E } y que el valor de la ganancia (\u03b2) es constante. Del grafico adjunto, se deduce que la tension de emisor es:   V E = V B \u2212 V B E =V_{B}-V_{BE}}  Y la corriente de emisor:   I E = V E R E = V B \u2212 V B E R E =}{R_{E}}}=-V_{BE}}{R_{E}}}} .  La corriente de emisor es igual a la de colector mas la de base:   I E = I C + I B = I C + I C \u03b2 = I C ( 1 + 1 \u03b2 ) I_{E}&=I_{C}+I_{B}\\\\&=I_{C}+}}\\\\&=I_{C}\\left(1+}\\right)\\\\\\end{aligned}}}  Despejando la corriente de colector:   I C = I E 1 + 1 \u03b2 =}{1+}}}}  La tension de salida, que es la de colector se calcula asi:   V C = V C C \u2212 I C R C = V C C \u2212 R C \u2217 I E 1 + 1 \u03b2 V_{C}&=V_{CC}-I_{C}R_{C}\\\\&=V_{CC}-R_{C}*}{1+\\displaystyle }}}\\end{aligned}}}  Como \u03b2 >> 1, se puede aproximar:   1 + 1 \u03b2 = 1 }=1}  y, entonces es posible calcular la tension de colector como:   V C = V C C \u2212 R C I E = V C C \u2212 R C \u2217 ( V B \u2212 V B E R E ) = ( V C C + R C V B E R E ) \u2212 R C V B R E V_{C}&=V_{CC}-R_{C}I_{E}\\\\&=V_{CC}-R_{C}*-V_{BE}}{R_{E}}}\\\\&=V_{CC}+R_{C}}{R_{E}}}-R_{C}}{R_{E}}}\\end{aligned}}}  La parte entre parentesis es constante (no depende de la se\u00f1al de entrada), y la restante expresa la se\u00f1al de salida. El signo negativo indica que la se\u00f1al de salida esta desfasada 180\u00b0 respecto a la de entrada.  Finalmente, la ganancia es expresada como:   G V = V C V B = \u2212 R C R E G_{V}&=}{V_{B}}}\\\\&=-}{R_{E}}}\\end{aligned}}}  La corriente de entrada, I B = I E 1 + \u03b2 =}{1+\\beta }}} ,  si \u03b2 >> 1 puede expresarse como sigue:   I B = I E \u03b2 = V E R E \u03b2 = V B \u2212 V B E R E \u03b2 I_{B}&=}}\\\\&=}{R_{E}\\beta }}\\\\&=-V_{BE}}{R_{E}\\beta }}\\end{aligned}}}  Suponiendo que V B >> V B E >>V_{BE}} , podemos escribir:   I B = V B R E \u03b2 =}{R_{E}\\beta }}}  Al dividir la tension y corriente en la base, la impedancia o resistencia de entrada queda como:   Z i n = V B I B = V B V B R E \u03b2 = R E \u03b2 Z_{in}&=}{I_{B}}}\\\\&=}}{R_{E}\\beta }}}}\\\\&=R_{E}\\beta \\end{aligned}}}  Para tener en cuenta la influencia de frecuencia se deben utilizar modelos de transistor mas elaborados. Es muy frecuente usar el modelo en pi.  Recta de carga  Esta recta se traza sobre las curvas caracteristicas de un transistor que proporciona el fabricante. Los puntos para el trazado de la misma son: I c = V c c R c + R e {Rc+Re}}} y la tension de la fuente de alimentacion V c c  En los extremos de la misma, se observan las zonas de corte y de saturacion, que tienen utilidad cuando el transistor actua como interruptor. Conmutara entre ambos estados de acuerdo a la polarizacion de la base.  La eleccion del punto Q es fundamental para una correcta polarizacion. Un criterio extendido es el de adoptar V c e = V c c 2 {2}}} , si el circuito no posee R e . De contar con R e como es el caso del circuito a considerar, el valor de V c e se medira desde el colector a masa.  El punto Q, se mantiene estatico mientras la base del transistor no reciba una se\u00f1al.  Ejercicio  Procederemos a determinar los valores de R c ( R 3 ) , R e ( R 4 ) , R 1 , R 2 , Z i n , Z o y G v  Datos: V c c = 20 V , I c q = 10 m A , V c e q = 8 V , \u03b2 = 100   V E = 1 10 V C C = 1 10 20 = 2 V ={10}}V_{CC}={10}}20=2V}   R E = V E I E \u224a V E I C = 2 V 10 m A = 200 \u03a9 } _{E}=}{I_{E}}}\\approxeq }{I_{C}}}={10mA}}=200\\Omega }  Esta aproximacion se admite porque \u03b2 \u226b 10   R C = V R C I C = V C C \u2212 V C E \u2212 V E I C = 20 V \u2212 8 V \u2212 2 V 10 m A = 1 K \u03a9 } _{C}=}{I_{C}}}=-V_{CE}-V_{E}}{I_{C}}}={10mA}}=1K\\Omega }   V B = V B E + V E = 0.7 V + 2 V = 2.7 V =V_{BE}+V_{E}=0.7V+2V=2.7V}  Para que el circuito opere en una zona de eficacia, la corriente a traves del divisor de voltaje R 1 } y R 2 } , debe ser mucho mayor que la corriente de base; como minimo en una relacion 10:1   R 2 \u2264 1 10 \u03b2 R E = 1 10 ( 100 ) ( 0.2 K \u03a9 ) = 2 k \u03a9 } 2\\leq {10}}\\beta {R_{E}}={10}}(100)(0.2K\\Omega )=2k\\Omega }   V B = R 2 R 1 + R 2 V C C =}{R_{1}+R_{2}}}V_{CC}} utilizando el valor de V B } obtenido anteriormente   V B = 2.7 V = ( 2 k \u03a9 ) ( 20 V ) R 1 + 2 k \u03a9 =2.7V={R_{1}+2k\\Omega }}} \u2234 R 1 = ( 2 k \u03a9 ) ( 20 V ) 2.7 V \u2212 ( 2 k \u03a9 ) = 12.8 k \u03a9 } 1={2.7V}}-(2k\\Omega )=12.8k\\Omega }  La resistencia dinamica del diodo en la juntura del emisor r e } , se calcula tomando el valor del voltaje termico en la misma, y esta dado por: r e = V T I E \u224a V T I C = 26 m V 10 m A = 2.6 \u03a9 =}{I_{E}}}\\approxeq }{I_{C}}}={10mA}}=2.6\\Omega }  Con este valor, se procede a calcular la ganancia de voltaje de la etapa; G V = \u2212 R C r e = \u2212 1 K \u03a9 2.6 \u03a9 = \u2212 385 =-}{r_{e}}}=-{2.6\\Omega }}=-385}  No se toma en cuenta R E } ya que el emisor se encuentra a nivel de masa para la se\u00f1al por medio de C E } , que en el esquema se muestra como C 3 } ; entonces, la impedancia de salida Z O } , toma el valor de R C } si el transistor no tiene carga. Si se considera la carga R L } , Z O } se determina por Z O = 1 1 R C + 1 R L } _{O}={{R_{C}}}+{R_{L}}}}}} considerando que R L } tiene el valor 5 K \u03a9 , Z O = 1 1 1 K \u03a9 + 1 5 K \u03a9 = 830 \u03a9 } _{O}={{1K\\Omega }}+{5K\\Omega }}}}=830\\Omega }  Al considerar la R L } , la ganancia de tension se ve modificada: G V = \u2212 830 \u03a9 2.6 \u03a9 = \u2212 319 =-{2.6\\Omega }}=-319}  La impedancia de entrada en la base del transistor para el ejemplo, esta dada por Z b = r e \u03b2 = ( 2.6 ) ( 100 ) = 260 \u03a9 =r_{e}\\beta =(2.6)(100)=260\\Omega }  Mientras que la impedancia de entrada a la etapa, se determina: Z i = 1 1 R 1 + 1 R 2 + 1 Z b = 1 1 12.8 k \u03a9 + 1 2 k \u03a9 + 1 260 \u03a9 = 226 \u03a9 } _{i}={{R_{1}}}+{R_{2}}}+{Z_{b}}}}}={{12.8k\\Omega }}+{2k\\Omega }}+{260\\Omega }}}}=226\\Omega }  La reactancia de los capacitores no se ha tenido en cuenta en los calculos, porque se han elegido de una capacidad tal, que su reactancia X C \u2192 0 \\rightarrow 0} en las frecuencias de se\u00f1ales empleadas.  La se\u00f1al se aplica al emisor del transistor y se extrae por el colector. La base se conecta a las masas tanto de la se\u00f1al de entrada como a la de salida. En esta configuracion se tiene ganancia solo de tension. La impedancia de entrada es baja y la ganancia de corriente algo menor que uno, debido a que parte de la corriente de emisor sale por la base. Si a\u00f1adimos una resistencia de emisor, que puede ser la propia impedancia de salida de la fuente de se\u00f1al, un analisis similar al realizado en el caso de emisor comun, da como resultado que la ganancia aproximada es:  La base comun se suele utilizar para adaptar fuentes de se\u00f1al de baja impedancia de salida como, por ejemplo, microfonos dinamicos.  La se\u00f1al se aplica a la base del transistor y se extrae por el emisor. El colector se conecta a las masas tanto de la se\u00f1al de entrada como a la de salida. En esta configuracion se tiene ganancia de corriente, pero no de tension que es ligeramente inferior a la unidad. La impedancia de entrada es alta, aproximadamente \u03b2+1 veces la impedancia de carga. Ademas, la impedancia de salida es baja, aproximadamente \u03b2 veces menor que la de la fuente de se\u00f1al.  Antes de la aparicion del transistor, eran usadas las valvulas termoionicas. Las valvulas tienen caracteristicas electricas similares a la de los transistores de efecto campo (FET): la corriente que los atraviesa depende de la tension en el terminal llamado rejilla. Las razones por las que el transistor reemplazo a la valvula termoionica son varias:  Como ejemplo de todos estos inconvenientes se puede citar a la primera computadora digital, llamada ENIAC, la cual pesaba mas de treinta toneladas y consumia 200 kilovatios, suficientes para alimentar una peque\u00f1a ciudad, a causa de sus aproximadamente 18\u00a0000 valvulas, de las cuales algunas se quemaban cada dia, necesitando una logistica y una organizacion importantes para mantener este equipo en funcionamiento.  El transistor bipolar reemplazo progresivamente a la valvula termoionica durante la decada de 1950, pero no del todo. En efecto, durante los a\u00f1os 1960, algunos fabricantes siguieron utilizando valvulas termoionicas en equipos de radio de gama alta, como Collins y Drake; luego el transistor desplazo a la valvula de los transmisores pero no del todo en los amplificadores de radiofrecuencia. Otros fabricantes de instrumentos electricos musicales como Fender, siguieron utilizando valvulas en sus amplificadores de audio para guitarras electricas. Las razones de la supervivencia de las valvulas termoionicas son varias: ","snippet":"El transistor es un dispositivo electronico semiconductor. Permite el paso de una se\u00f1al en respuesta a otra. Se puede configurar o \"comportar\" como amplificador, oscilador, conmutador o rectificador. ","enlaces_salientes":["Transistor","Transistor","Transistor","Semiconductor","1947","Componente_electr%C3%B3nico","Semiconductor","Se%C3%B1al_el%C3%A9ctrica","Amplificador","Oscilador","Conmutador_(dispositivo)","Rectificador","Resistor","Aparato_electr%C3%B3nico","Radio_(receptor)","Televisor","Computadora","Circuito_integrado","Historia_del_transistor","Julius_Edgar_Lilienfeld","Transistor_de_efecto_campo","Electr%C3%B3nica_de_estado_s%C3%B3lido","Triodo","Laboratorios_Bell","William_Bradford_Shockley","John_Bardeen","Walter_Houser_Brattain","Laboratorios_Bell","Germanio","William_Bradford_Shockley","Termistor","Varistor","Westinghouse_Electric","Detector_de_bigotes_de_gato","Segunda_Guerra_Mundial","William_Bradford_Shockley","Transistor_Darlington","Philco","MHz","Indio_(elemento)","Chrysler","Texas_Instruments","MOSFET","Portador_de_carga","Resistor","Condensador_el%C3%A9ctrico","Inductor","Triodo","Encapsulado_(Electr%C3%B3nica)","Cobre","%C3%93xido_de_cobre_(I)","Transistor_de_uni%C3%B3n_bipolar","Semiconductor","Arseniuro_de_galio","Conductor_el%C3%A9ctrico","Uni%C3%B3n_PN","Electr%C3%B3n","Ars%C3%A9nico","F%C3%B3sforo","Indio_(elemento)","Aluminio","Galio","Transistor_de_efecto_campo","Tensi%C3%B3n_(electricidad)","Impedancia","JFET","Diel%C3%A9ctrico","MOSFET","%C3%93xido","Fototransistor","Radiaci%C3%B3n_electromagn%C3%A9tica","Luz","Electr%C3%B3nica","Conversi%C3%B3n_de_potencia","Arseniuro_de_galio","Nitruro_de_aluminio_y_galio","Diodo_Schottky","Transistor_de_uni%C3%B3n_bipolar","Voltio","Resistencia_el%C3%A9ctrica","Transistor_de_efecto_campo","Chasis","ENIAC","A%C3%B1os_1960","Psicoac%C3%BAstica","Audi%C3%B3filo","Circuito_en_paralelo","V%C3%A1lvula_termoi%C3%B3nica","Transistor_bipolar","Historia_del_transistor","Quiteron","Semiconductor","Transistor_de_aleaci%C3%B3n","Thin-film_transistor","Transistor_de_uni%C3%B3n_bipolar","Transistor_IGBT","Transistor_uniuni%C3%B3n","V%C3%A1lvula_termoi%C3%B3nica","Datasheet","Cambridge_University_Press","ISBN","Digital_object_identifier","Digital_object_identifier","Oxford_University_Press","ISBN","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Art_%26_Architecture_Thesaurus","Enciclopedia_Brit%C3%A1nica","Enciclopedia_Treccani","Medical_Subject_Headings"]}
{"url":"C%C3%B3digo_de_m%C3%A1quina","titulo":"Lenguaje de maquina","contenido":"El lenguaje de maquina o codigo maquina es el sistema de codigos directamente interpretable por un circuito microprogramable, como el microprocesador de una computadora o el microcontrolador de un automata. Este lenguaje esta compuesto por un conjunto de instrucciones que determinan acciones a ser tomadas por la maquina. Un programa consiste en una cadena de estas instrucciones mas un conjunto  cual se trabaja. Estas instrucciones son normalmente ejecutadas en secuencia, con eventuales cambios de flujo causados por el propio programa o eventos externos. El lenguaje de maquina es especifico de la arquitectura de la maquina, aunque el conjunto de instrucciones disponibles pueda ser similar entre arquitecturas distintas.  Los circuitos microprogramables son digitales, lo que significa que trabajan con dos unicos niveles de tension. Dichos niveles, por abstraccion, se simbolizan con los numeros 0 y 1, por eso el lenguaje de maquina solo utiliza dichos signos. Esto permite el empleo de las teorias del algebra booleana y del sistema binario en el dise\u00f1o de este tipo de circuitos y en su programacion.  Claude Elwood Shannon, en su libro Analysis of Relay and Switching Circuits, y con sus experiencias en redes de conmutacion, sento las bases para la aplicacion del algebra de Boole a las redes de conmutacion. Una red de conmutacion es un circuito de interruptores electricos que al cumplir ciertas combinaciones booleanas con las variables de entrada, define el estado de la salida. Este concepto es el nucleo de las puertas logicas, las cuales son, por su parte, los ladrillos con que se construyen sistemas logicos cada vez mas complejos. Shannon utilizaba el rele como dispositivo fisico de conmutacion en sus redes, dado que el rele, a igual que una lampara electrica, posee dos estados: activado (encendido) o (apagado).  El desarrollo tecnologico ha permitido evolucionar desde las redes de reles electromagneticos a circuitos con tubos de vacio, luego a redes transistorizadas, hasta llegar a los modernos circuitos integrados, en cuya cuspide se encuentran los circuitos microprogramados.  El llamado codigo maquina consistia en introducir la programacion de la maquina mediante unos y ceros. cualquier programa de ordenador debe, finalmente, ser convertido a este codigo para que un ordenador pueda ejecutar las instrucciones de dicho programa.  Los ordenadores solo leen este tipo de lenguaje, en donde la combinacion de numeros logra convertirse en acciones. Dada su complejidad existen los lenguajes de programacion como JavaScript para programar paginas web o C++ para programar videojuegos entre muchos otros.\u200b ","snippet":"El lenguaje de maquina o codigo maquina es el sistema de codigos directamente interpretable por un circuito microprogramable, como el microprocesador de una computadora o el microcontrolador de un aut","enlaces_salientes":["Lenguaje_de_m%C3%A1quina","Lenguaje_de_m%C3%A1quina","Lenguaje_de_m%C3%A1quina","Intel_8086_y_8088","Sistema_hexadecimal","Lenguaje_ensamblador","ASCII","Microprocesador","Computadora_electr%C3%B3nica","Microcontrolador","Aut%C3%B3mata_programable","Conjunto_de_instrucciones","Programa_inform%C3%A1tico","Arquitectura_de_computadoras","Sistema_digital","%C3%81lgebra_de_Boole","Sistema_binario","Claude_Elwood_Shannon","Puerta_l%C3%B3gica","Sistema_digital","Rel%C3%A9","V%C3%A1lvula_termoi%C3%B3nica","Transistor","Circuito_integrado","JavaScript","C%2B%2B","L%C3%B3gica_binaria","Lenguaje_ensamblador","Lenguaje_de_bajo_nivel","Lenguaje_de_alto_nivel","Control_de_autoridades","Gemeinsame_Normdatei"]}
{"url":"Lenguajes_de_bajo_nivel","titulo":"Lenguaje de bajo nivel","contenido":"Un lenguaje de programacion de caracteristicas de bajo nivel o de primera generacion es aquel en el que sus instrucciones ejercen un control directo sobre el hardware y estan condicionados por la estructura fisica de las computadoras que lo soportan. El uso de la palabra bajo en su denominacion no implica que el lenguaje sea menos potente que un lenguaje de alto nivel, sino que se refiere a la reducida abstraccion entre el lenguaje y el hardware  Los lenguajes de bajo nivel tales como el lenguaje ensamblador pueden ser mas dificiles de programar que los lenguajes de alto nivel debido a que estan mas intimamente relacionados con las caracteristicas tecnicas del hardware. Ademas estos suelen carecer de abstracciones de mayor nivel. No es posible una abstraccion fuera de lo estipulado para el conjunto del microcodigos del microprocesador de un ordenador. Por otro lado, es mas facilmente traducible a lenguaje de maquina, tarea que realiza esencialmente un compilador.  De menor a mayor nivel de abstraccion respecto del hardware es posible clasificar los lenguajes de programacion de la siguiente manera:  En este tipo de lenguajes se trabaja a nivel de instrucciones, es decir, su programacion es al mas fino detalle, ademas, esta completamente orientado a la maquina.  El lenguaje de programacion de primera generacion (por sus siglas en ingles: 1GL), es el lenguaje de codigo maquina. Es el unico lenguaje que un microprocesador entiende de forma nativa. El lenguaje maquina al constar de unos y ceros, es de dificil lectura y gran probabilidad de equivocacion al ingresarlo, por lo tanto es raro que una persona lo use directamente.  Las instrucciones en lenguaje maquina, constan de una o dos memorias de instruccion, y otras memorias con datos (ver articulo modos de direccionamiento)  El lenguaje de programacion de segunda generacion (por sus siglas en ingles: 2GL), es el lenguaje ensamblador. El avance respecto al anterior, es que en vez de llanos unos y ceros, se tienen mnemonicos ya escritos como un texto, y datos visibles a un lado del mnemonico. En este se requiere de un programa que traduzca los mnemonicos a lenguaje maquina.  Un programador de lenguaje ensamblador debe conocer la arquitectura del procesador (como por ejemplo las particularidades de sus registros o su conjunto de instrucciones). ","snippet":"Un lenguaje de programacion de caracteristicas de bajo nivel o de primera generacion es aquel en el que sus instrucciones ejercen un control directo sobre el hardware y estan condicionados por la estr","enlaces_salientes":["Lenguaje_de_bajo_nivel","Lenguaje_de_bajo_nivel","Lenguaje_de_bajo_nivel","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_alto_nivel","Abstracci%C3%B3n_(inform%C3%A1tica)","Microc%C3%B3digo","Microprocesador","Lenguaje_de_m%C3%A1quina","Compilador","Lenguaje_de_m%C3%A1quina","Lenguaje_ensamblador","Compilador","Complex_instruction_set_computing","Reduced_instruction_set_computing","Lenguaje_ensamblador_x86","C%2B%2B","Rust_(lenguaje_de_programaci%C3%B3n)","Fortran","Cobol","Lisp","Go_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_m%C3%A1quina","Modo_de_direccionamiento","Lenguaje_ensamblador","Lenguaje_ensamblador","Ensamblador","Control_de_autoridades","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa"]}
{"url":"Abstracci%C3%B3n_(inform%C3%A1tica)","titulo":"Abstraccion (informatica)","contenido":"La abstraccion consiste en aislar un elemento de su contexto o del resto de los elementos que lo acompa\u00f1an. En programacion, el termino se refiere al enfasis en el \"\u00bfque hace?\" mas que en el \"\u00bfcomo lo hace?\" (caracteristica de caja negra). El comun denominador en la evolucion de los lenguajes de programacion, desde los clasicos o imperativos hasta los orientados a objetos, ha sido el nivel de abstraccion del que cada uno de ellos hace uso.  La abstraccion tambien se puede entender como el metodo que se usa al momento de analizar un elemento particular, despreciando los aspectos no relevantes para el estudio especifico, y considerando solo las propiedades esenciales para dicho analisis, facilitando con ello la mejor comprension de dicho elemento y disminuyendo de esta manera el esfuerzo que se debe invertir en su comprension.  Los lenguajes de programacion son las herramientas mediante las cuales los dise\u00f1adores de lenguajes pueden implementar los modelos abstractos. La abstraccion ofrecida por los lenguajes de programacion se puede dividir en dos categorias: abstraccion de datos (pertenecientes a los datos) y abstraccion de control (perteneciente a las estructuras de control).  Los diferentes paradigmas de programacion han aumentado su nivel de abstraccion, comenzando desde los lenguajes de maquina, lo mas proximo al ordenador y mas lejano a la comprension humana; pasando por los lenguajes de comandos, los imperativos, la orientacion a objetos (POO), la Programacion Orientada a Aspectos (POA); u otros paradigmas como la programacion declarativa, etc.  La abstraccion encarada desde el punto de vista de la programacion orientada a objetos expresa las caracteristicas esenciales de un objeto, las cuales distinguen al objeto de los demas. Ademas de distinguir entre los objetos provee limites conceptuales. Entonces se puede decir que la encapsulacion separa las caracteristicas esenciales de las no esenciales dentro de un objeto. Si un objeto tiene mas caracteristicas de las necesarias los mismos resultaran dificiles de usar, modificar, construir y comprender sobre todo cuando es un metodo de numero entero con terminacion fraccionaria.  La misma genera una ilusion de simplicidad dado que minimiza la cantidad de caracteristicas que definen a un objeto.  Durante a\u00f1os, los programadores se han dedicado a construir aplicaciones muy parecidas que resolvian una y otra vez los mismos problemas. Para conseguir que sus esfuerzos pudiesen ser utilizados por otras personas se creo la POO que consiste en una serie de normas para garantizar la interoperabilidad entre usuarios de manera que el codigo se pueda reutilizar.  Pensar en terminos de objetos es muy parecido a como lo hariamos en la vida real. Una analogia seria  modelizar un auto en un esquema de POO. Diriamos que el auto es el elemento principal que tiene una serie de caracteristicas, como podrian ser el color, el modelo o la marca.  Por poner otro ejemplo vamos a ver como modernizariamos en un esquema POO una fraccion, es decir, esa estructura matematica que tiene un numerador y un denominador que divide al numerador, por ejemplo 3/2. La fraccion sera el objeto y tendra dos propiedades, el numerador y el denominador. Luego podria tener varios metodos como simplificarse, sumarse con otra fraccion o numero, restarse con otra fraccion, etc.  Estos objetos son utilizables en los programas, por ejemplo en un programa de matematicas se puede hacer uso de objetos fraccion y en un programa que gestione un taller de autos, objetos auto. Los programas orientados a objetos utilizan muchos objetos para realizar las acciones que se desean realizar y ellos mismos tambien son objetos. Es decir, el taller de autos sera un objeto que utilizara objetos auto, herramienta, mecanico, recambio.   ","snippet":"La abstraccion consiste en aislar un elemento de su contexto o del resto de los elementos que lo acompa\u00f1an. En programacion, el termino se refiere al enfasis en el \"\u00bfque hace?\" mas que en el \"\u00bfcomo lo","enlaces_salientes":["Abstracci%C3%B3n_(inform%C3%A1tica)","Abstracci%C3%B3n_(inform%C3%A1tica)","Abstracci%C3%B3n_(inform%C3%A1tica)","Programaci%C3%B3n","Caja_negra_(sistemas)","Lenguaje_de_programaci%C3%B3n","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_orientada_a_objetos","Lenguaje_de_programaci%C3%B3n","Estructuras_de_control","Paradigma_de_programaci%C3%B3n","Lenguaje_de_m%C3%A1quina","Computadora","Programaci%C3%B3n_Orientada_a_Aspectos","Programaci%C3%B3n_declarativa","Programaci%C3%B3n_orientada_a_objetos","Objeto_(programaci%C3%B3n)","Encapsulaci%C3%B3n","Programador","Aplicaci%C3%B3n_inform%C3%A1tica","Programaci%C3%B3n_orientada_a_objetos","C%C3%B3digo_fuente","Fracci%C3%B3n","Matem%C3%A1tica","Programaci%C3%B3n_orientada_a_objetos","Arquitectura_software","Ingenier%C3%ADa_de_Software","Caja_negra_(sistemas)","Control_de_autoridades"]}
{"url":"Controlador_de_dispositivo","titulo":"Controlador de dispositivo","contenido":"Un controlador de dispositivo o manejador de dispositivo (en ingles: device driver, o simplemente driver)[nota 1]\u200b es un programa informatico que permite al sistema operativo interactuar con un periferico, haciendo una abstraccion del hardware y proporcionando una interfaz (posiblemente estandarizada) para utilizar el dispositivo.\u200b  Es una pieza esencial del software, y en particular, del nucleo de un sistema operativo, sin la cual el hardware seria inutilizable.\u200b ","snippet":"Un controlador de dispositivo o manejador de dispositivo (en ingles: device driver, o simplemente driver)[nota 1]\u200b es un programa informatico que permite al sistema operativo interactuar con un perife","enlaces_salientes":["Controlador_de_dispositivo","Controlador_de_dispositivo","Controlador_de_dispositivo","Controladora_de_perif%C3%A9rico","Programa_inform%C3%A1tico","Sistema_operativo","Perif%C3%A9rico_(inform%C3%A1tica)","Hardware","Interfaz","Software","N%C3%BAcleo_(inform%C3%A1tica)","Sistema_operativo","Hardware","Controlador_de_impresora","Controladora_de_perif%C3%A9rico","Envoltura_de_manejador","Interrupci%C3%B3n","Puerto_(computaci%C3%B3n)","Registro_(hardware)","ISBN","OCLC","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_Israel"]}
{"url":"Lenguaje_simb%C3%B3lico","titulo":"Evolucion humana","contenido":"Primeros Hominidos  Australopithecus  Paranthropus  Kenyanthropus  La evolucion humana u hominizacion es el proceso de evolucion biologica de la especie humana desde sus ancestros hasta la actualidad.\u200b El estudio de dicho proceso requiere de un analisis interdisciplinario en el que se complementen conocimientos desde ciencias como la genetica, la antropologia fisica, la paleontologia, la estratigrafia, la geocronologia, la arqueologia y la linguistica.  El termino humano, en el contexto de su evolucion, se refiere a los individuos del genero Homo. Sin embargo, los estudios de la evolucion humana incluyen otros homininos, como Ardipithecus, Australopithecus, etc.  De esta manera, el estudio especifico de la evolucion humana es el estudio del linaje, o clado, que incorpora a todas las especies mas cercanas al humano moderno que al chimpance, el pariente vivo mas proximo.\u200b\u200b Las evidencias moleculares\u200b y paleontologicas\u200b han permitido estimar que el ancestro comun entre Homo sapiens y Pan troglodytes, vivio en Africa hace entre cinco y siete millones de a\u00f1os. A partir de esta divergencia, dentro del linaje hominino continuaron emergiendo nuevas especies, todas ellas extintas actualmente a excepcion de Homo sapiens.  Al analizar el genoma humano actual se ha descubierto que en su proceso evolutivo hay varios hechos que destacar. Asi, se observa por ejemplo que el Homo sapiens comparte casi el 99\u00a0% de los genes con el chimpance y con el bonobo. Para mayor precision, el genoma de cualquier individuo de nuestra especie tiene una diferencia de solo el 1,24\u00a0% respecto al genoma de Pan troglodytes (chimpances) y de 1,62\u00a0% respecto al genoma de los gorilas.\u200b  El analisis genomico ha establecido el siguiente parentesco:\u200b  \u00a0Gorila  \u00a0Chimpance  \u00a0Bonobo  \u00a0Neandertal  \u00a0Denisovano  \u00a0Homo sapiens  Partiendo del analisis genetico de la evolucion humana, se postula que dentro de su genealogia se habria producido introgresion en varias ocasiones. Ejemplo de ello es el cromosoma Y actual mas antiguo (cromosoma-Y A00), que se remontaria hasta los humanos arcaicos (hace unos 340\u00a0000 a\u00f1os aprox.).\u200b  Tambien destaca el descubrimiento de la existencia de hibridacion con otras especies hominidas mas antiguas, tales como el Homo neanderthalensis (de un 1\u00a0% a un 4\u00a0% de genes neandertales por persona, principalmente en Europa),\u200b y con el hominido de Denisova (la poblacion local que vive actualmente en Papua Nueva Guinea, en el Sudeste Asiatico, le debe al menos el 3\u00a0% de su genoma por persona a los hominidos de Denisova).\u200b\u200b Sin embargo, destaca que al analizar el porcentaje total de ADN del Homo neanderthalensis dentro de la poblacion humana actual no africana, este porcentaje aumenta significativamente a un 20\u00a0%; estando este genoma neandertal relacionado con genes que produjeron una \"heterosis\" a adaptaciones ambientales (como fenotipos de la piel), pero tambien implicado en enfermedades como la diabetes tipo 2, la enfermedad de Crohn, el lupus y la cirrosis biliar.\u200b  Igualmente, destaca que los retrovirus endogenos humanos (HERV) (Secuencia de ADN derivado de virus pertenecientes al grupo de los retrovirus) comprenden una parte significativa del genoma humano. Con aproximadamente 98\u00a0000 fragmentos y elementos ERV, estos componen casi el 8\u00a0% del genoma actual del ser humano, los cuales ha adquirido el ser humano en diferentes periodos temporales de su evolucion.\u200b  Los primeros posibles hominidos bipedos (homininos) son Sahelanthropus tchadiensis (con una antiguedad de 7 millones de a\u00f1os y encontrado en el Chad, pero que genera dudas acerca de su adscripcion a nuestra linea evolutiva),\u200b Orrorin tugenensis (con unos 6 millones de a\u00f1os y hallado en Africa Oriental) y Ardipithecus (entre 5,5-4,5 millones de a\u00f1os y encontrado en la misma region). Los fosiles de estos hominidos son escasos y fragmentarios y no hay acuerdo general sobre si eran totalmente bipedos. No obstante, tras el descubrimiento del esqueleto casi completo de un individuo de Ardipithecus ramidus apodado Ardi, se han podido resolver algunas dudas al respecto; asi, la forma de la parte superior de la pelvis indica que era bipedo y que caminaba con la espalda recta, pero la forma del pie, con el dedo gordo dirigido hacia adentro (como en las manos) en vez de ser paralelo a los demas, indica que debia caminar apoyandose sobre la parte externa de los pies y que no podia recorrer grandes distancias.\u200b  Los primeros hominidos de los que se tiene la seguridad de que fueron completamente bipedos son los miembros del genero Australopithecus, de los que se han conservado esqueletos muy completos (como el de la famosa Lucy).  Este tipo de homininos prospero en las sabanas arboladas del este de Africa entre 4 y 2,5 millones de a\u00f1os atras con notable exito ecologico, como lo demuestra la radiacion que experimento, con al menos cinco especies diferentes esparcidas desde Etiopia y el Chad hasta Sudafrica.  Su desaparicion se ha atribuido a la crisis climatica que se inicio hace unos 2,8 millones de a\u00f1os y que condujo a una desertificacion de la sabana con la consiguiente expansion de los ecosistemas abiertos, esteparios. Como resultado de esta presion evolutiva, algunos Australopithecus se especializaron en la explotacion de productos vegetales duros y de escaso valor nutritivo, desarrollando un impresionante aparato masticador, originando al Paranthropus; otros Australopithecus se hicieron paulatinamente mas carnivoros, originando a los primeros Homo.  No se sabe con certeza de que especie proceden los primeros miembros del genero Homo; se han propuesto Australopithecus africanus, A. afarensis y A. garhi, pero no hay un acuerdo general. Tambien se ha sugerido que Kenyanthropus platyops pudo ser el antepasado de los primeros Homo.\u200b  Clasicamente se consideran como pertenecientes al genero Homo los hominidos capaces de elaborar herramientas de piedra. No obstante, esta vision ha sido puesta en duda; por ejemplo, se ha sugerido que Australopithecus ghari fue capaz de fabricar herramientas hace 2,5 millones de a\u00f1os.\u200b Las primeras herramientas eran muy simples y se encuadran en la industria litica conocida como Olduvayense o Modo 1. Las mas antiguas proceden de la region de Afar (Etiopia) y su antiguedad se estima en unos 2,6 millones de a\u00f1os,\u200b pero no existen fosiles de hominidos asociados a ellas.  De esta fase se han descrito dos especies, Homo rudolfensis y Homo habilis, que habitaron Africa Oriental entre 2,5 y 1,8 millones de a\u00f1os atras, que a veces se reunen en una sola. El volumen craneal de estas especies oscila entre 650 y 800\u00a0cm\u00b3.  Esta es sin duda la etapa mas confusa y compleja de la evolucion humana. El sucesor cronologico de los citados Homo rudolfensis y Homo habilis es Homo ergaster, cuyos fosiles mas antiguos datan de hace aproximadamente 1,8 millones de a\u00f1os, y su volumen craneal oscila entre 850 y 880\u00a0cm\u00b3. Morfologicamente es muy similar a Homo erectus y en ocasiones se alude a el como \u00abHomo erectus africano\u00bb. Se supone que fue el primero de nuestros antepasados en abandonar Africa; se han hallado fosiles asimilables a H. ergaster (o tal vez a Homo habilis) en Dmanisi (Georgia), datados en 1,8 millones de a\u00f1os de antiguedad y que se han denominado Homo georgicus que prueban la temprana salida de Africa de nuestros antepasados remotos.\u200b  Esta primera migracion humana condujo a la diferenciacion de dos linajes descendientes de Homo ergaster: Homo erectus en Extremo Oriente (China, Java) y Homo antecessor/Homo cepranensis en Europa (Espa\u00f1a, Italia). Por su parte, los miembros de H. ergaster que permanecieron en Africa inventaron un modo nuevo de tallar la piedra, mas elaborado, denominado Achelense o Modo 2 (hace 1,6 o 1,7 millones de a\u00f1os). Se ha especulado que los clanes poseedores de la nueva tecnologia habrian ocupado los entornos mas favorables desplazando a los tecnologicamente menos avanzados, que se vieron obligados a emigrar. Ciertamente sorprende el hecho que H. antecessor y H. erectus siguieran utilizando el primitivo Modo 1 (Olduvayense), cientos de miles de a\u00f1os despues del descubrimiento del Achelense. Una explicacion alternativa es que la migracion se produjera antes de la aparicion del Achelense.\u200b  Despues del hallazgo de restos del hombre de Denisova se ha detectado que hace un millon a 700\u00a0000 a\u00f1os se produjo un flujo genetico de las poblaciones africanas a las asiaticas y europeas.\u200b\u200b De los milenios posteriores, ademas de los emblematicos fosiles de Homo erectus encontrados en Java y en Pekin, China, se han hallado otros restos de homininos, cuyas caracteristicas morfologicas presentan claras diferencias, asi como coincidencias, tanto con H. erectus como con H. sapiens: los de Hathnora, valle del Narmada (India), de hace unos 250\u00a0000\u00a0a\u00f1os;\u200b\u200b\u200b el craneo de Dali (China), que data de hace 200\u00a0000\u00a0a\u00f1os; la mujer de Jinniushan; la mandibula de Zhirendong de hace 106\u00a0000\u00a0a\u00f1os, el craneo de Xuchang de 100\u00a0000\u00a0a\u00f1os; el hombre de Orsang (India), que data de hace 50\u00a0000\u00a0a\u00f1os;\u200b del Hombres de la cueva de los ciervos de China, que vivio hasta hace 11\u00a0500 a\u00f1os;\u200b y del hombre de Solo (Java).\u200b  En condiciones de aislamiento, evolucionaron especies independientes, como el caso del Homo luzonensis;\u200b y del Homo floresiensis de la Isla de Flores (Indonesia), especies desaparecidas hace 60\u00a0000 a\u00f1os. Aunque podrian haber evolucionado desde poblaciones tempranas de H. erectus, las proporciones de las extremidades inferiores, los huesos de los pies y la anatomia funcional de la mu\u00f1eca y el hombro, mas parecidas a Homo Habilis e incluso a los Australopithecus, sugieren que sus ancestros salieron de Africa antes de la evolucion de H. erectus.\u200b\u200b  Por su parte, en Europa se tiene constancia de la presencia humana desde hace mas de 1 millon de a\u00f1os (Homo antecessor), pero se han hallado herramientas de piedra mas antiguas no asociadas a restos fosiles en diversos lugares. La posicion central de H. antecessor como antepasado comun de Homo neanderthalensis y Homo sapiens ha sido descartada por los propios descubridores de los restos (Eudald Carbonell y Juan Luis Arsuaga).  Los ultimos representantes de esta fase de nuestra evolucion son Homo heidelbergensis en Europa, que supuestamente esta en la linea evolutiva de los neandertales, y Homo rhodesiensis en Africa que seria el antepasado del hombre moderno.\u200b\u200b\u200b  Una vision mas conservadora de esta etapa de la evolucion humana reduce todas las especies mencionadas a una, Homo erectus, que es considerada como una especie politipica de amplia dispersion con numerosas subespecies y poblaciones interfertiles geneticamente interconectadas.  La fase final de la evolucion de la especie humana esta presidida por tres especies humanas inteligentes, que durante un largo periodo convivieron y compitieron por los mismos recursos. Se trata del Hombre de Neanderthal (Homo neanderthalensis), la especie del hominido de Denisova y el hombre moderno (Homo sapiens). Son en realidad historias paralelas que, en un momento determinado, se cruzan.  El Hombre de Neanderthal surgio y evoluciono en Europa y Oriente Medio hace unos 230\u00a0000 a\u00f1os,\u200b presentando claras adaptaciones al clima frio de la epoca (complexion baja y fuerte, nariz ancha).  El hominido de Denisova vivio hace 40\u00a0000 a\u00f1os en los montes Altai y probablemente en otras areas en las cuales tambien vivieron neandertales y sapiens. El analisis del ADN mitocondrial indica un ancestro femenino comun con las otras dos especies hace aproximadamente un millon de a\u00f1os.\u200b La secuencia de su genoma ha revelado que habria compartido con los neandertales un ancestro hace unos 650\u00a0000 a\u00f1os y con los humanos modernos hace 800\u00a0000 a\u00f1os. Un molar descubierto presenta caracteristicas morfologicas claramente diferentes a las de los neandertales y los humanos modernos.\u200b  Los fosiles de Djebel Irhoud (Marruecos) que datan de hace 300\u00a0000 a\u00f1os\u200b y el craneo de Florisbad (Homo helmei), de Bloemfontein (Sudafrica), datado en 259\u00a0000 a\u00f1os antes del presente, apuntan al Homo sapiens.\u200b  En las excavaciones de la cuenca de Olorgesailie, en el sur de Kenia, de hace 295\u00a0000 a 320\u00a0000 a\u00f1os, datados mediante metodos de series de argon-40/argon-39 y uranio, se encontraron restos de actividad de homininos, que en estos sitios hicieron nucleos preparados y puntas, explotaron rocas ricas en hierro para obtener pigmento rojo y adquirieron materiales para herramientas de piedra desde distancias de 25 a 50 kilometros. Estos hallazgos sugieren que desde entonces ya se registraban complejos comportamientos que caracterizan al Homo sapiens.\u200b  Los Hombres de Kibish, especialmente Omo I, son considerados los fosiles mas antiguos de Homo sapiens datan de hace unos 200\u00a0000 a\u00f1os (Etiopia).\u200b Hace unos 90\u00a0000 a\u00f1os llego al Proximo Oriente donde se encontro con el Hombre de Neanderthal que huia hacia el sur de la glaciacion que se abatia sobre Europa. Homo sapiens siguio su expansion y hace unos 45\u00a0000 a\u00f1os llego a Europa Occidental (Francia); paralelamente, el Hombre de Neanderthal se fue retirando, empujado por H. sapiens, a la periferia de su area de distribucion (Peninsula iberica, mesetas altas de Croacia), donde desaparecio hace unos 28\u00a0000 a\u00f1os.  Aunque H. neanderthalensis ha sido considerado con frecuencia como subespecie de Homo sapiens (H. sapiens neanderthalensis), el analisis del genoma mitocondrial completo de fosiles de H. neanderthalensis sugieren que la diferencia existente es suficiente para considerarlos como dos especies diferentes, separadas desde hace 660\u00a0000 (\u00b1 140\u00a0000) a\u00f1os.\u200b (ver el apartado \"Clasificacion\" en Homo neanderthalensis).  Se tiene la casi plena certeza de que el hombre de Neandertal no es ancestro directo del ser humano actual, sino perteneciente a una linea evolutiva paralela derivada tambien de Homo erectus/Homo ergaster a traves del eslabon conocido como Homo heidelbergensis. El neandertal coexistio con Homo sapiens y quiza termino extinguido por la competencia con nuestra especie. Sin embargo, el analisis del genoma nuclear apunta a un aporte neandertal al acervo genetico de los humanos modernos. Los euroasiaticos poseen entre el 1 y el 5\u00a0% de genes arcaicos por persona que se pueden atribuir a la hibridacion de Homo sapiens con H.\u00a0neanderthalensis.\u200b  En cuanto al llamado hombre de Cro-Magnon corresponde a las poblaciones de Europa Occidental de la actual especie Homo sapiens.  Los parientes vivos mas cercanos a nuestra especie son los grandes simios: el gorila, el chimpance, el bonobo y el orangutan. Los fosiles mas antiguos de Homo sapiens tienen una antiguedad de casi  doscientos mil a\u00f1os\u200b y proceden del sur de Etiopia (formacion Kibish del rio Omo), considerada como la cuna de la humanidad (vease Hombres de Kibish). A estos restos fosiles siguen en antiguedad los de Homo sapiens idaltu, con unos ciento sesenta mil a\u00f1os.  Algunos datos de genetica molecular concordantes con hallazgos paleontologicos, sostienen que todos los seres humanos descienden de una misma Eva mitocondrial o E.M., esto quiere decir que, segun los rastreos del ADNmt - que solo se transmite a traves de las madres-, toda la humanidad actual tiene una antecesora comun que habria vivido en el noreste de Africa, probablemente en Tanzania (dada la mayor diversidad genetica alli) hace entre ciento cincuenta mil y doscientos treinta mil a\u00f1os\u200b (ver haplogrupos de ADN mitocondrial humano).  Estudios de los haplogrupos del cromosoma Y humano, concluyen que por linea paterna hay una ascendencia que llega hasta el Adan cromosomico, el cual habria vivido en el Africa subsahariana entre hace sesenta mil y noventa mil a\u00f1os.\u200b  Otros indicios derivados de muy recientes investigaciones sugieren que la de por si exigua poblacion de Homo sapiens hace unos setenta y cuatro mil a\u00f1os se redujo al borde de la extincion al producirse el estallido del volcan Toba, segun la Teoria de la catastrofe de Toba, volcan ubicado en la isla de Sumatra, cuyo estallido ha dejado como rastro el lago Toba. Tal erupcion-estallido tuvo una fuerza 3000 veces superior a la erupcion del Monte Santa Helena en 1980. Esto significo que gran parte del planeta se vio cubierto por nubes de ceniza volcanica que afectaron negativamente a las poblaciones de diversas especies incluidas la humana. Segun esta hipotesis llamada entre la comunidad cientifica Catastrofe de Toba, la poblacion de Homo sapiens (entonces toda en Africa; la primera migracion fuera de Africa fue en torno al a\u00f1o 70\u00a0000\u00a0a.\u00a0C.) se habria reducido a solo alrededor de mil individuos. Si esto es cierto, significaria que el 'pool' genetico de la especie se habria restringido de tal modo que se habria potenciado la unidad genetica de la especie humana.[cita\u00a0requerida] No todos estan de acuerdo con esa datacion. Despues de analizar el ADN de personas de todas las regiones del mundo, el genetista Spencer Wells sostiene que todos los humanos que viven hoy descienden de un solo individuo que vivio en Africa hace unos sesenta mil a\u00f1os.\u200b Por todo lo antedicho queda demostrado el monogenismo de la especie humana y, consecuentemente, descartado el poligenismo, que servia de \"argumento\" a teorias racistas.  En 2021 fue descubierta una posible nueva especie de humano arcaico a partir de un craneo datado de unos ciento cuarenta y seis mil a\u00f1os descubierto en Harbin, al noreste de China, en 1933 que data de al menos unos ciento cuarenta y seis mil a\u00f1os durante el Pleistoceno medio. Se le bautizo como Homo longi (en chino tradicional, \u9f8d\u4eba; en chino simplificado, \u9f99\u4eba; traducido como Hombre dragon). Su analisis sugiere que el Homo sapiens esta mas relacionado con el que con el Homo neanderthalensis.\u200b  Junto a los hallazgos arqueologicos, los principales indicadores de la expansion del ser humano por el planeta son el ADN mitocondrial y el cromosoma Y, que son caracteristicos de la descendencia por linea materna y paterna respectivamente.  Los humanos ya habrian comenzado a salir de Africa unos noventa mil a\u00f1os antes del presente; colonizando para esas fechas el Levante mediterraneo (estos restos fosiles han sido atribuibles a tempranos Homo sapiens, pero su relacion real con los humanos modernos es muy discutible).\u200b  Australia y Nueva Guinea: la Linea de Wallace no significo para los Homo sapiens un limite insuperable para acceder a esta region. La llegada de humanos a Australia se data hace unos cincuenta mil a\u00f1os cuando pudieron fabricar rusticas almadias o balsas de juncos para atravesar el estrecho que separaba a Sahul de la region de la Sonda.  Europa: comenzo a ser colonizada hace solo unos cuarenta mil a\u00f1os, se supone que durante milenios el desierto de Siria resultaba una barrera infranqueable desde Africa hacia Europa, por lo que habria resultado mas practicable una migracion costera desde las costas de Eritrea a las costas yemenies y de alli al subcontinente indio. La expansion por Europa coincide con la extincion de su coetaneo de entonces, el hombre de Neandertal.  Oceania: la colonizacion de estas islas mas proximas a Eurasia se habria iniciado hace unos cincuenta mil a\u00f1os, pero la expansion por esta MUG (macro-unidad geografica) fue muy lenta y gradual, y hace unos cinco mil a\u00f1os pueblos austronesios comenzaron una efectiva expansion por Oceania, aunque archipielagos como el de Hawai y Nueva Zelanda no estaban aun poblados por seres humanos hace dos mil o mil quinientos a\u00f1os (esto requirio el desarrollo de una apropiada tecnica naval y conocimientos suficientes de nautica).  America: la llegada del hombre a America, se habria iniciado hace unos veinte mil o, al menos, quince mil a\u00f1os, aunque no hay consenso al respecto. Durante las glaciaciones el nivel de los oceanos desciende al grado que el \"Viejo Mundo\" y el \"Nuevo Mundo\" forman un megacontinente unido por el Puente de Beringia.  Cuando los ancestros del Homo sapiens y otros muchos primates vivian en selvas comiendo frutos, bayas y hojas, abundantes en vitamina C, pudieron perder la capacidad genetica, que tiene la mayoria de los animales, de sintetizar en su propio organismo tal vitamina. Tales perdidas durante la evolucion han implicado sutiles pero importantes determinaciones: cuando las selvas originales se redujeron o, por crecimiento demografico, resultaron superpobladas, los primitivos homininos (y luego los humanos) se vieron forzados a recorrer importantes distancias, migrar, para obtener nuevas fuentes de nutrientes (por ejemplo de la citada vitamina C).  Todos los cambios rese\u00f1ados han sucedido en un periodo relativamente breve (aunque se mida en millones de a\u00f1os), esto explica la susceptibilidad de nuestra especie a afecciones en la columna vertebral y en la circulacion sanguinea y linfatica.  La cerebracion tanto como la corticalizacion son fenomenos biologicos muy anteriores a la aparicion de los hominidos. Sin embargo, en estos y en especial en Homo sapiens, la cerebracion y la corticalizacion adquieren un grado superlativo.  El cerebro de Homo sapiens, en relacion con la masa corporal, es uno de los mas grandes. Mas llamativo es el consumo de energia metabolica (por ejemplo, la producida por la \"combustion\" de la glucosa) que requiere el cerebro: un 20% de toda la energia corporal, y aun cuando la longitud de los intestinos humanos evidencian los problemas que se le presentan.  En Homo sapiens el volumen oscila entre los 1200 a 1400 cm\u00b3, el promedio global actual es de 1350 cm\u00b3; sin embargo no basta un incremento del volumen, sino como se dispone; esto es: como esta dispuesta la \"estructura\" del sistema nervioso central y del cerebro en particular. Por termino medio, los Homo neanderthalensis pudieron haber tenido un cerebro de mayor tama\u00f1o que el de nuestra especie, pero la morfologia de su craneo demuestra que la estructura cerebral era muy diferente: con escasa frente, los neandertalenses tenian poco desarrollados los lobulos frontales y, en especial, muy poco desarrollada la corteza prefrontal. El craneo de Homo sapiens no solo tiene una frente prominente sino que es tambien mas alto en el occipucio (craneo muy abovedado), esto permite el desarrollo de los lobulos frontales. De todos los mamiferos, Homo sapiens es el unico que tiene la faz ubicada bajo los lobulos frontales.  Sin embargo, aun mas importante para la evolucion del encefalo parecen haber sido las mutaciones en el posicionamiento del esfenoides.  Se ha hecho mencion en el apartado dedicado a la aparicion del lenguaje articulado de la importancia del gen FOXP2; dicho gen es el encargado del desarrollo de las areas del lenguaje y de las areas de sintesis (las areas de sintesis se encuentran en la corteza cerebral de los lobulos frontales). El aumento del cerebro y su especializacion permitio la aparicion de la llamada lateralizacion, o sea, una diferencia muy importante entre el hemisferio izquierdo y el hemisferio derecho del cerebro. El hemisferio izquierdo tiene desarrollado en su corteza areas especificas que posibilitan el lenguaje simbolico basado en significantes acusticos: el area de Wernicke y el area de Broca.  Es casi seguro que ya hace 200\u00a0000 a\u00f1os los sujetos de la especie Homo sapiens tenian un potencial intelectual equivalente al de la actualidad, pero para que se activara tal potencial tardaron milenios: el primer registro de conducta artistica conocido se data hace solo unos 75\u00a0000 a\u00f1os, los primeros grafismos y expresiones netamente simbolicas fuera del lenguaje hablado se datan hace solo entre 40\u00a0000 y 35\u00a0000 a\u00f1os. Las primeras escrituras (\"memoria segunda\" como bien les llamara Roland Barthes) datan de hace entre 5500 o 5000 a\u00f1os, en el Valle del Nilo o en la Mesopotamia asiatica.  Se ha dicho, tambien lineas antes, que Homo sapiens mantiene caracteristicas de estructura craneal \"primitivas\" ya que recuerdan a las de un chimpance infantil; en efecto, tal morfologia es la que permite tener la frente sobre el rostro y los lobulos frontales desarrollados.  La cabeza de Homo sapiens, para contener tal cerebro, es muy grande; aun en el feto y en el neonato, razon principal por la cual los partos son dificiles, sumada a la disposicion de la pelvis.  Una solucion parcial a esto es la heterocronia: el neonato humano esta muy incompletamente desarrollado en el momento del parto; puede decirse (con algo de metafora) que la gestacion en el ser humano no se restringe a los ya de por si prolongados nueve meses intrauterinos, sino que se prolonga extrauterinamente hasta, al menos, los cuatro primeros a\u00f1os; en efecto, el infante esta completamente desvalido durante a\u00f1os, tan es asi que, que entre los 2 a 4 a\u00f1os es cuando tiene lo suficientemente desarrolladas las areas visuales del cerebro como para tener una percepcion visual de su propio ser (Estadio del espejo descubierto por Jacques Lacan en la decada de 1930). Ahora bien, si Homo sapiens tarda mucho en poder tener una percepcion plena de su imagen corporal es interesante saber que es uno de los pocos animales que se percibe al ver su imagen reflejada (solo se nota esta capacidad en bonobos, chimpances, y si acaso en gorilas, orangutanes, delfines y elefantes).  Tal es la prematuracion de Homo sapiens, que mientras un chimpance neonato tiene una capacidad cerebral de un 65% de la de un chimpance adulto, o la capacidad de Australopithecus afarensis era en el parto de un 50% respecto a la de su edad adulta, en Homo sapiens 'bebe' tal capacidad no supera al 25% de la capacidad que tendra a los 45 a\u00f1os[cita\u00a0requerida] (a los 45 a\u00f1os aproximadamente es cuando se desarrolla totalmente el cerebro humano[cita\u00a0requerida]).  Pero no basta el desarrollo cronologico. Para que el cerebro humano se \"despliegue\" -por asi decirlo- o desarrolle requiere de estimulacion y afecto; de otro modo la organizacion de algunas de las areas del cerebro puede quedar atrofiada.  Los homininos, primates bipedos, habrian surgido hace unos 6 o 7 millones de a\u00f1os en Africa, cuando dicho continente se encontro afectado por una progresiva desecacion que redujo las areas de bosques y selvas. A partir de ello la primera teoria y mas aceptada, es que como adaptacion al bioma de sabana aparecieron primates capaces de caminar facilmente de modo bipedo y mantenerse erguidos (East Side Story;\u200b\u200b). Mas aun, en un medio calido y con fuerte radiacion ultravioleta e infrarroja algunas de las mejores soluciones adaptativas son la marcha bipeda y la progresiva reduccion de la capa pilosa, lo que evita el excesivo recalentamiento del cuerpo. Hace 150\u00a0000 a\u00f1os el norte de Africa volvio a sufrir una intensa desertizacion lo cual significo otra gran presion evolutiva como para que se fijaran los rasgos principales de la especie Homo sapiens.  Sin embargo, existen actualmente discrepancia respecto a la teoria de la aparicion del bipedismo producto de la adaptacion a la vida en la Sabana. La existencia de restos fosiles tales como los del genero Ardipithecus, con una forma de los dedos de los pies y una estructura pelvica que sugieren que andaban erguidos, y el posterior descubrimiento de los restos fosiles de Danuvius guggenmosi, plantea un problema con esta teoria; y  lleva a plantear la teoria de que el bipedismo podria haberse originado en los antepasados del ser humano mientras se movian aun sobre los arboles.  Para lograr la postura y la marcha erecta han tenido que aparecer importantes modificaciones:  Es evidente que la gran cantidad de modificaciones anatomicas que condujeron del cuadrupedismo al bipedismo requirio una fuerte presion selectiva. Se ha discutido mucho sobre la eficacia e ineficacia de la marcha bipeda comparada con la cuadrupeda. Tambien se ha notado que ningun otro animal de los que se adaptaron a la sabana al final de Mioceno desarrollo una marcha bipeda.  Si tomamos en cuenta la teoria de que partimos de hominidos con un tipo de desplazamiento cuadrupedo poco eficaz para largos desplazamientos en terreno abierto, como el que presentan los chimpances. El modo en que se desplazan los chimpances, apoyando la segunda falange de los dedos de las manos, no puede compararse a la marcha cuadrupeda de ningun otro mamifero; en cambio la existencia de un desplazamiento bipedo anterior a habitar la sabana habria sido una ventaja para lograr habitar en este medio ambiente.  Como los primeros hominidos de sabana probablemente se vieron obligados a desplazarse distancias considerables en campo abierto para alcanzar grupos de arboles situados a distancia; la marcha bipeda pudo ser una ventaja muy eficaz en estas condiciones ya que:\u200b  Hace a\u00f1os se argumento que la liberacion de las manos por parte de los primeros hominidos bipedos les permitio elaborar armas de piedra para cazar; lo cual habria sido el principal motor de nuestra evolucion. Hoy esta claro que la liberacion de las manos (que se produjo hace mas de 4 millones de a\u00f1os) no esta ligada a la fabricacion de herramientas, que acontecio unos 2 millones de a\u00f1os despues, y que los primeros homininos no eran cazadores y que a lo sumo comian carro\u00f1a esporadicamente.[cita\u00a0requerida]  Pero la bipedestacion trajo una desventaja en la reproduccion, ya que el hecho de pasar del cuadrupedismo al bipedismo conllevo un cambio anatomico de las caderas, con gran reduccion del canal del parto que hacia mas dificil y doloroso el alumbramiento, tal como se demuestra cuando se compara la cadera de un chimpance promedio con la de un Australopithecus como Lucy, quienes ademas presentan un tama\u00f1o de cerebro similar.\u200b  La postura bipeda dejo libres los miembros superiores que ya no tienen que cumplir la funcion de patas (excepto en los ni\u00f1os muy peque\u00f1os) ni la de braquiacion, es decir, el desplazamiento de rama en rama con los brazos, aun cuando la actual especie humana, de la cintura hacia arriba mantenga una complexion de tipo arboricola.  Esta liberacion de los miembros superiores fue, en su inicio, una adaptacion optima al bioma de sabana; al marchar bipedamente y con los brazos libres, los ancestros del hombre podian recoger mas facilmente su comida; raices, frutos, hojas, insectos, huevos, reptiles peque\u00f1os, roedores y carro\u00f1a; en efecto, muchos indicios hacen suponer como probable que nuestros ancestros fueran en gran medida carro\u00f1eros y, dentro del carro\u00f1eo, practicaran la modalidad llamada cleptoparasitismo, esto es, robaban las presas recien cazadas por especies netamente carnivoras; para tal practica, nuestros ancestros debian haber actuado en bandas, organizadamente.  Los miembros superiores, siempre en relacion con otras especies, se han acortado. Estos miembros superiores al quedar liberados de funciones locomotoras, se han podido especializar en funciones netamente humanas. El pulgar oponible es una caracteristica heredada de los primates mas antiguos, pero si en estos la funcion principal ha sido la de aferrarse a las ramas y en segundo lugar aprehender las frutas o insectos que servian de alimento, en la linea evolutiva que desemboca en nuestra especie la motilidad de la mano, y en particular de los dedos de esta, se ha hecho gradualmente mas precisa y delicada lo que ha facilitado la elaboracion de artefactos; aun (junio de 2005) no se tiene conocimiento respecto al momento en que la linea evolutiva comenzo a crear artefactos, es seguro que hace ya mas de 2 millones de a\u00f1os Homo habilis/Homo rudolfensis realizaba toscos instrumentos que utilizaba asiduamente (en todo caso, los chimpances, en estado silvestre, confeccionan \"herramientas\" de piedra, madera y hueso muy rudimentarias). El desarrollo de la capacidad de pronacion en la articulacion de la mu\u00f1eca tambien ha sido importantisimo para la capacidad de elaborar artefactos.  El humano hereda de los prosimios la vision estereoscopica y pancromatica (la capacidad de ver una amplia tonalidad de los colores del espectro visible); los ojos en la parte delantera de la cabeza posibilitan la vision estereoscopica (en tres dimensiones), pero si esa caracteristica surge en los prosimios como una adaptacion para moverse mejor durante la noche o en ambientes umbrios como los de las junglas, en Homo sapiens tal funcion cobra otro valor; facilita la mirada a lontananza, el otear horizontes, en este aspecto la vision es bastante mas aguda en los humanos que en los otros primates y en los prosimios. Esto facilitara el hecho por el cual Homo sapiens sea un ser altamente visual (por ejemplo las comunicaciones mediante la mimica), y facilitara asimismo lo imaginario.  Pese al conjunto de modificaciones morfologicas antes rese\u00f1adas, desde el punto de vista de la anatomia comparada, llama la atencion una cuestion: Homo sapiens es un animal relativamente poco especializado. En efecto, gran parte de las especies animales ha logrado algun tipo de especializacion anatomica (por ejemplo los artiodactilos poseen pezu\u00f1as que les permiten correr en las llanuras despejadas), pero las especializaciones, si suelen ser una optima adaptacion a un determinado bioma, conllevan el riesgo de la desaparicion de la especie especializada y asociada a tal bioma si este se modifica.  La ausencia de tales especializaciones anatomicas ha facilitado a los humanos una adaptabilidad inusitada entre las demas especies de vertebrados para adecuarse a muy diversas condiciones ambientales.  Mas aun, aunque parezca paradojico, Homo sapiens tiene caracteristicas neotenicas. En efecto, la estructura craneal de un Homo sapiens adulto se aproxima mas a la de la cria de un chimpance que a la de un chimpance adulto: el rostro es achatado (\"ortognato\" o de \"bajo indice facial\") y es casi inexistente el torus supraorbitario (en la humanidad actual apenas se encuentran vestigios de torus en las poblaciones llamadas australoides). De otro modo se puede decir que los arcos superciliares de Homo sapiens son \"infantiles\", delicados, el rostro aplanado o ligeramente prognato.  Homo sapiens es, por su anatomia, un animal muy vulnerable si se encuentra en condiciones naturales.  Asociado al hecho por el cual morfologicamente el ser humano tenga caracteristicas que le aproximan a las de un chimpance \"ni\u00f1o\" se encuentra el 'ortognatismo' y esto quiere decir, entre otras cuestiones, que los dientes de Homo sapiens son relativamente peque\u00f1os y poco especializados, las mandibulas, por esto, se ha abreviado y hecho mas delicadas, falta ademas el diastema o espacio en donde encajan los colmillos. La debilidad de las mandibulas humanas las hace casi totalmente inutiles para la defensa a mordiscos ante un predador y, asimismo, son muy deficientes para poder consumir gran parte del alimento en su estado natural, lo que es uno de los muchos deficits corporales que llevan al humano a vivir en una sociedad organizada.  Hablar de la aparicion del lenguaje humano, lenguaje simbolico, por logica pareceria implicar que hay que hablar previamente de la cerebracion, y eso es bastante cierto, pero el lenguaje humano simbolico tiene sus antecedentes en momentos y cambios morfologicos que son previos a cambios importantes en la estructura del sistema nervioso central. Por ejemplo, los chimpances pueden realizar un esbozo primario de lenguaje simbolico basandose en la mimica (de un modo semejante a un sistema muy simple de comunicacion para mudos).  Ahora bien, el lenguaje simbolico por excelencia es el basado en los significantes acusticos, y para que una especie tenga la capacidad de articular sonidos discretos, se requieren mas innovaciones morfologicas, algunas de ellas muy probablemente anteriores al desarrollo de un cerebro lo suficientemente complejo como para pensar de modo simbolico. En efecto, observemos la orofaringe y la laringe: en los mamiferos, a excepcion del humano, la laringe se encuentra en la parte alta de la garganta, de modo que la epiglotis cierra la traquea de un modo estanco al beber e ingerir comida. En cambio, en Homo sapiens, la laringe se ubica mas abajo, lo que permite a las cuerdas vocales la produccion de sonidos mas claramente diferenciados y variados, pero al no poder ocluir completamente la epiglotis, la respiracion y la ingesta deben alternarse para que el sujeto no se ahogue. El acortamiento del prognatismo que se compensa con una elevacion de la boveda palatina facilitan el lenguaje oral. Otro elemento de relevante importancia es la posicion y estructura del hioides, su gracilidad y motilidad permitiran un lenguaje oral lo suficientemente articulado.  Estudios realizados en la Sierra de Atapuerca (Espa\u00f1a) evidencian que Homo antecessor, hace unos 800\u00a0000 a\u00f1os, ya tenia la capacidad, al menos en su aparato fonador, para emitir un lenguaje oral lo suficientemente articulado como para ser considerado simbolico, aunque la consuetudinaria fabricacion de utensilios (por toscos que fueran) por parte del Homo habilis hace unos dos millones de a\u00f1os, sugiere que en estos ya existia un lenguaje oral articulado muy rudimentario pero lo suficientemente eficaz como para transmitir la suficiente informacion o ense\u00f1anza para la confeccion de los toscos artefactos.  Ademas de todas las condiciones recien mencionadas, imprescindibles para la aparicion de un lenguaje simbolico, se debe hacer mencion de la aparicion del gen FOXP2 que resulta basico para la posibilidad de tal lenguaje y del pensamiento simbolico, como se vera a continuacion.  Se han hipotetizado diferentes posibilidades respecto a la evolucion futura del ser humano, entre ellos:  Una linea del pensamiento que asegura que la especie humana ha dejado de evolucionar de la misma forma que el resto de los seres vivos, por diferentes motivos.  Sin embargo, existen tambien otras posturas que consideran que son precisamente los adelantos tecnologicos los que impulsan actualmente la evolucion humana, aunque de manera artificial no darwiniana. Por una parte, se ha propuesto que el entorno actual favorece la reproduccion de las personas inteligentes, independientemente de su fuerza fisica o su estado de salud.\u200b Ademas, es posible que la ingenieria genetica humana permita seleccionar las caracteristicas geneticas de la descendencia.\u200b  Por otra parte, tambien se ha propuesto que en el futuro la tecnologia posibilite a las personas vivir como cyborg o incluso como seres digitales dentro de cuerpos o estructuras completamente artificiales.\u200b  La taxonomia se encarga de la clasificacion de los organismos. Por ende, la definicion de especie es un aspecto fundamental para clasificar especimenes como pertenecientes a distintas o mismas especies. En organismos vivos es posible definir especies bajo el criterio de la capacidad que tienen distintos individuos de reproducirse y tener descendencia fertil (definicion de especie biologica). Sin embargo, el registro fosil plantea mas problemas, ya que es imposible ver el potencial reproductivo entre organismos extintos. Esto hace que el definir especies en paleontologia sea extremadamente complejo. Un supuesto para definir y nombrar especies basadas en el registro fosil es a partir de la morfologia; bajo esta premisa se espera que exista mayor variacion morfologica entre especies que entre individuos de la misma especie.[cita\u00a0requerida]  En el estudio de la evolucion humana, definir y nombrar especies es, como en toda disciplina paleontologica, no solo un fenomeno cientifico sino tambien psicologico. En ese sentido, podemos dividir a los paleontologos en dos extremos de acuerdo a la forma de distinguir y definir especies en el registro fosil: los agrupadores (lumpers) trataran de definir unas pocas especies, con mayor variacion inter-especifica (es decir, dentro de la especie), mientras que los divisores (splitters) definiran nuevas especies cuando existe una peque\u00f1a diferencia morfologica entre especimenes.\u200b Obviamente estos son dos extremos de un fenomeno y la mayoria de los paleontologos se ubicaran en algun punto medio. ","snippet":"Primeros Hominidos  Australopithecus  Paranthropus  Kenyanthropus  La evolucion humana u hominizacion es el proceso de evolucion biologica de la especie humana desde sus ancestros hasta la actualidad.","enlaces_salientes":["Evoluci%C3%B3n_humana","Evoluci%C3%B3n_humana","Evoluci%C3%B3n_humana","La_marcha_del_progreso","Hominina","Sahelanthropus_tchadensis","Orrorin_tugenensis","Ardipithecus_kadabba","Ardipithecus_ramidus","Australopithecus","Australopithecus_anamensis","Australopithecus_bahrelghazali","Australopithecus_afarensis","Australopithecus_africanus","Australopithecus_garhi","Australopithecus_sediba","Paranthropus","Paranthropus_aethiopicus","Paranthropus_boisei","Paranthropus_robustus","Kenyanthropus","Kenyanthropus_platyops","Homo_gautengensis","Homo_habilis","Homo_rudolfensis","Homo_ergaster","Homo_georgicus","Homo_erectus","Homo_erectus_erectus","Homo_erectus_pekinensis","Homo_erectus_soloensis","Homo_erectus_lantianensis","Hombre_de_Nank%C3%ADn","Homo_erectus_yuanmouensis","Homo_cepranensis","Homo_antecessor","Homo_heidelbergensis","Homo_naledi","Homo_luzonensis","Homo_floresiensis","Homo_rhodesiensis","Cr%C3%A1neo_de_Florisbad","Homo_Nesher_Ramla","Homo_longi","Homo_neanderthalensis","Homo_sapiens","Homo_sapiens_idaltu","Homo_sapiens_sapiens","Evoluci%C3%B3n_biol%C3%B3gica","Homo_sapiens","Gen%C3%A9tica","Antropolog%C3%ADa_f%C3%ADsica","Paleontolog%C3%ADa","Estratigraf%C3%ADa","Dataci%C3%B3n_radiom%C3%A9trica","Arqueolog%C3%ADa","Ling%C3%BC%C3%ADstica","Homo","Hominina","Ardipithecus","Australopithecus","Clado","Homo_sapiens","Pan_troglodytes","Ma_(unidad_de_tiempo)","Hominina","Homo_sapiens","Genoma","Gen","Pan_paniscus","Genoma","Pan_troglodytes","Gorilas","Gorilla","Chimpanc%C3%A9_com%C3%BAn","Pan_paniscus","Neandertal","Denisovano","Homo_sapiens","Genealog%C3%ADa","Introgresi%C3%B3n","Cromosoma_Y","Humanos_arcaicos","H%C3%ADbrido_(biolog%C3%ADa)","Homo_neanderthalensis","Hom%C3%ADnido_de_Denisova","Pap%C3%BAa_Nueva_Guinea","Sudeste_Asi%C3%A1tico","Heterosis","Fenotipo","Diabetes","Enfermedad_de_Crohn","Lupus","Cirrosis","Retrovirus_end%C3%B3geno","Virus","Retrovirus","Hominidae","Hominina","Sahelanthropus_tchadiensis","Chad","Orrorin_tugenensis","%C3%81frica_Oriental","Ardipithecus","Ardipithecus_ramidus","Ardi","Pelvis","Pie","Hallux","Australopithecus","Lucy","Homininos","Sabana","%C3%81frica","Especie","Etiop%C3%ADa","Chad","Sud%C3%A1frica","Desertificaci%C3%B3n","Presi%C3%B3n_evolutiva","Paranthropus","Homo","Australopithecus_africanus","Australopithecus_afarensis","Australopithecus_garhi","Kenyanthropus_platyops","Industria_l%C3%ADtica","Olduvayense","Afar","Etiop%C3%ADa","Homo_rudolfensis","Homo_habilis","%C3%81frica_Oriental","Sierra_de_Atapuerca","Provincia_de_Burgos","Homo_rudolfensis","Homo_habilis","Homo_ergaster","Homo_erectus","Dmanisi","Georgia","Homo_georgicus","Extremo_Oriente","China_continental","Java_(isla)","Homo_antecessor","Homo_cepranensis","Europa","Espa%C3%B1a","Italia","Achelense","Olduvayense","Hombre_de_Denisova","Flujo_gen%C3%A9tico","Homo_erectus","Homo_erectus_erectus","Homo_erectus_pekinensis","China","Narmada","India","Cr%C3%A1neo_de_Dali","Mujer_de_Jinniushan","Zhirendong","Hombre_de_Xuchang","Hombres_de_la_cueva_de_los_ciervos","Hombre_de_Solo","Homo_luzonensis","Homo_floresiensis","Homo_antecessor","Homo_neanderthalensis","Homo_sapiens","Eudald_Carbonell","Juan_Luis_Arsuaga","Homo_heidelbergensis","Homo_rhodesiensis","Homo_erectus","Especie","Homo_neanderthalensis","Hom%C3%ADnido_de_Denisova","Homo_sapiens","Europa","Oriente_Medio","Montes_Alt%C3%A1i","ADN_mitocondrial","Genoma","Molar","Djebel_Irhoud","Marruecos","Cr%C3%A1neo_de_Florisbad","Bloemfontein","Sud%C3%A1frica","Kenia","Hombres_de_Kibish","Etiop%C3%ADa","Pr%C3%B3ximo_Oriente","Europa_Occidental","Francia","Pen%C3%ADnsula_ib%C3%A9rica","Croacia","Genoma","Homo_neanderthalensis#Clasificaci\u00f3n","Homo_neanderthalensis","Homo_erectus","Homo_ergaster","Homo_heidelbergensis","Acervo_gen%C3%A9tico","Homo_neanderthalensis#Hibridaci\u00f3n_con_Homo_sapiens","Hombre_de_Cro-Magnon","Origen_de_los_humanos_modernos","Grandes_simios","Gorilla","Chimpanc%C3%A9","Pan_paniscus","Orangut%C3%A1n","Etiop%C3%ADa","Valle_bajo_del_Omo","Hombres_de_Kibish","Homo_sapiens_idaltu","Biocronolog%C3%ADa","Hominina","Gen%C3%A9tica_molecular","Eva_mitocondrial","Homo_sapiens","Tanzania","Haplogrupos_de_ADN_mitocondrial_humano","Haplogrupos_del_cromosoma_Y_humano","Ad%C3%A1n_cromos%C3%B3mico","%C3%81frica_subsahariana","Teor%C3%ADa_de_la_cat%C3%A1strofe_de_Toba","Sumatra","Lago_Toba","Erupci%C3%B3n_del_Monte_Saint_Helens_en_1980","Teor%C3%ADa_de_la_cat%C3%A1strofe_de_Toba","%C3%81frica","Monogenismo_(antropolog%C3%ADa)","Poligenismo","Humanos_arcaicos","Harbin","China_del_Noreste","Chibaniense","Homo_longi","Caracteres_chinos_tradicionales","Caracteres_chinos_simplificados","Migraciones_humanas_prehist%C3%B3ricas","ADN_mitocondrial","Cromosoma_Y","Levante_mediterr%C3%A1neo","ADN_mitocondrial","Tundra","Glaciaci%C3%B3n","Australia","Nueva_Guinea","L%C3%ADnea_de_Wallace","Sahul","Regi%C3%B3n_de_la_Sonda","Europa","Siria","Hombre_de_Neandertal","Ocean%C3%ADa","MUG","Austronesios","Ocean%C3%ADa","Haw%C3%A1i","Nueva_Zelanda","T%C3%A9cnica","Am%C3%A9rica","Llegada_del_hombre_a_Am%C3%A9rica","Puente_de_Beringia","%C3%9Altimo_ancestro_com%C3%BAn_chimpanc%C3%A9-humano","Vitamina_C","Hombre_de_Vitruvio","Leonardo_da_Vinci","Encefalizaci%C3%B3n","Consumo","Energ%C3%ADa","Sistema_nervioso_central","Cerebro","L%C3%B3bulo_frontal","Corteza_prefrontal","Hueso_occipital","Enc%C3%A9falo","Mutaci%C3%B3n","Esfenoides","Gen","FOXP2","Corteza_cerebral","Hemisferio_izquierdo","Hemisferio_derecho","%C3%81rea_de_Wernicke","%C3%81rea_de_Broca","Grafismo","Escritura_(ling%C3%BC%C3%ADstica)","Roland_Barthes","Nilo","Mesopotamia","Feto","Neonato","Parto","Heterocron%C3%ADa","Met%C3%A1fora","Gestaci%C3%B3n","Estadio_del_espejo","Jacques_Lacan","A%C3%B1os_1930","Pan_paniscus","Chimpanc%C3%A9","Gorilla","Orangut%C3%A1n","Delphinidae","Elephantidae","Australopithecus_afarensis","Hominino","%C3%81frica","Continente","Bosque","Selva","Bioma","Sabana","Primate","B%C3%ADpedo","East_Side_Story","Ultravioleta","Infrarrojo","Homo_sapiens","Ardipithecus","Danuvius_guggenmosi","Thomas_Henry_Huxley","Foramen_magnum","M%C3%A9dula_espinal","Cr%C3%A1neo","Columna_vertebral","Simio","Pelvis","Chimpanc%C3%A9","V%C3%A9rtebra","Pelvis","Vagina","Mam%C3%ADferos","Parto","Articulaci%C3%B3n_(anatom%C3%ADa)","Pierna","F%C3%A9mur_(anatom%C3%ADa_humana)","Chimpanc%C3%A9","Rodilla","%C3%81rbol","Pie_(anatom%C3%ADa)","Tal%C3%B3n","Pulgar_(dedo)","Pie","Hominino","Hueso","Sabana","Mioceno","Mano","Mam%C3%ADfero","Reproducci%C3%B3n","Caderas","Alumbramiento","Chimpanc%C3%A9","Australopithecus","Lucy","Braquiaci%C3%B3n","Cleptoparasitismo","Homo_habilis","Homo_rudolfensis","Pronaci%C3%B3n","Articulaci%C3%B3n_(anatom%C3%ADa)","Prosimio","Ojo_humano","Jungla","Visi%C3%B3n","Artiod%C3%A1ctilos","Pezu%C3%B1a","Bioma","Vertebrados","Neotenia_en_humanos","Diente","Mand%C3%ADbula","Diastema","Colmillo","Evoluci%C3%B3n_del_lenguaje","Lenguaje","Sistema_nervioso_central","Chimpanc%C3%A9","M%C3%ADmica","Mudo","Significantes","Orofaringe","Laringe","Mam%C3%ADferos","Garganta","Epiglotis","Tr%C3%A1quea","Cuerda_vocal","Prognatismo","B%C3%B3veda_palatina","Hioides","Sierra_de_Atapuerca","Espa%C3%B1a","Homo_antecessor","Homo_habilis","Informaci%C3%B3n","Gen","FOXP2","Cron_(geolog%C3%ADa)","Homo_habilis","Homo_rudolfensis","Homo_georgicus","Homo_ergaster","Homo_erectus","Homo_cepranensis","Homo_antecessor","Homo_heidelbergensis","Homo_rhodesiensis","Homo_neanderthalensis","Homo_sapiens","Homo_sapiens_idaltu","Homo_floresiensis","Homo_luzonensis","Holoceno","Homo_sapiens","Neol%C3%ADtico","Pleistoceno","Tarantiense","Homo_sapiens","Homo_neanderthalensis","Homo_floresiensis","Homo_erectus_soloensis","Paleol%C3%ADtico_Superior","Musteriense","Chibaniense","Homo_sapiens_idaltu","Homo_rhodesiensis","Homo_heidelbergensis","Homo_erectus","Achelense","Calabriense","Paranthropus_robustus","Paranthropus_boisei","Australopithecus_sediba","Homo_ergaster","Homo_habilis","Homo_antecessor","Homo_cepranensis","Sierra_de_Atapuerca","Homo_georgicus","Olduvayense","Gelasiense","Paranthropus_aethiopicus","Australopithecus_garhi","Australopithecus_africanus","Homo_rudolfensis","Plioceno","Piacenziense","Kenyanthropus_platyops","Australopithecus_bahrelghazali","Australopithecus_afarensis","Zancliense","Australopithecus_anamensis","Ciencia","Selecci%C3%B3n_natural","Deriva_gen%C3%A9tica","Universidad_de_California_en_Los_%C3%81ngeles","Selecci%C3%B3n_natural#Selecci\u00f3n_sexual","Ingenier%C3%ADa_gen%C3%A9tica_humana","Cyborg","Taxonom%C3%ADa","Especie","F%C3%B3sil","Paleontolog%C3%ADa","Psicolog%C3%ADa","Agrupamiento_y_desglose","Agrupamiento_y_desglose","Autodomesticaci%C3%B3n","East_Side_Story","Evoluci%C3%B3n_biol%C3%B3gica","%C3%9Altimo_ancestro_com%C3%BAn_chimpanc%C3%A9-humano","Haplogrupos_de_ADN_mitocondrial_humano","Hip%C3%B3tesis_del_simio_acu%C3%A1tico","Historia_de_la_paleoantropolog%C3%ADa","Homo","Anthropopithecus","El_origen_del_hombre","Origen_del_hombre","Paleoantropolog%C3%ADa","Paleontolog%C3%ADa","Prehistoria","Antropolog%C3%ADa","Neotenia_en_humanos","La_odisea_de_la_especie","ISSN","PubMed_Central","PubMed_Identifier","Digital_object_identifier","Digital_object_identifier","ISSN","PubMed_Central","PubMed_Identifier","Digital_object_identifier","PubMed_Central","PubMed_Identifier","Digital_object_identifier","ISSN","Digital_object_identifier","Identificador_de_objeto_digital","Washington_Post","Nature_(journal)","Digital_object_identifier","Internet_Archive","PubMed_Central","PubMed_Identifier","Digital_object_identifier","ISBN","Digital_object_identifier","Identificador_de_objeto_digital","Identificador_de_objeto_digital","Nature_(journal)","Digital_object_identifier","Nature","Digital_object_identifier","Digital_object_identifier","Nature","ISSN","Digital_object_identifier","Internet_Archive","Cuaternario","La_Jornada_(peri%C3%B3dico_de_M%C3%A9xico)","Internet_Archive","Michio_Kaku","ISBN","ISBN","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Ensamblador","titulo":"Ensamblador","contenido":"El termino ensamblador (del ingles assembler) se refiere a un tipo de programa informatico que se encarga de traducir un fichero fuente escrito en un lenguaje ensamblador, a un fichero objeto que contiene codigo maquina, ejecutable directamente por el microprocesador.  El programa lee el fichero escrito en lenguaje ensamblador y sustituye cada uno de los codigos nemotecnicos que aparecen por su codigo de operacion correspondiente en sistema binario para la plataforma que se eligio como destino en las opciones especificas del ensamblador.  Se puede distinguir entre dos tipos de ensambladores: ","snippet":"El termino ensamblador (del ingles assembler) se refiere a un tipo de programa informatico que se encarga de traducir un fichero fuente escrito en un lenguaje ensamblador, a un fichero objeto que cont","enlaces_salientes":["Ensamblador","Ensamblador","Ensamblador","Ensamblador_(desambiguaci%C3%B3n)","Lenguaje_ensamblador","Programa_(computaci%C3%B3n)","Fichero_fuente","Lenguaje_ensamblador","Fichero_objeto","C%C3%B3digo_m%C3%A1quina","Microprocesador","C%C3%B3digo_nemot%C3%A9cnico","C%C3%B3digo_de_operaci%C3%B3n","Ensamblador_de_alto_nivel","Instrucci%C3%B3n_de_m%C3%A1quina","Lenguaje_ensamblador","Lenguaje_ensamblador_x86","Flat_assembler","GNU_Assembler","Microsoft_Macro_Assembler","RosASM","A86_y_A386_assemblers","Turbo_Assembler","GNU_toolchain","Control_de_autoridades","Gemeinsame_Normdatei"]}
{"url":"Lenguajes_de_alto_nivel","titulo":"Lenguaje de alto nivel","contenido":"Un lenguaje de programacion de alto nivel se caracteriza por expresar los algoritmos de una manera adecuada a la capacidad cognitiva humana, en lugar de la capacidad con que las maquinas lo ejecutan. Estos lenguajes permiten una maxima flexibilidad al programador a la hora de abstraerse o de ser literal. Permiten un camino bidireccional entre el lenguaje maquina y una expresion casi oral entre la escritura del programa y su posterior compilacion. Por lo general suelen estar orientados a objetos, a eventos o a funciones, pudiendo estos combinarse. Asimismo, pueden ser compilados o interpretados. Algunos ejemplos son: Java, PHP, Python, Javascript, C#.  En los primeros lenguajes, la limitacion era que se orientaban a un area especifica y sus instrucciones requerian de una sintaxis predefinida. Se clasifican como lenguajes procedimentales o lenguajes de bajo nivel. Otra limitacion de estos es que se requiere de ciertos conocimientos de programacion para realizar las secuencias de instrucciones logicas. Los lenguajes de alto nivel se crearon para que el usuario comun pudiese solucionar un problema de procesamiento de datos de una manera mas facil y rapida.  Por esta razon, a finales de los a\u00f1os 1950 surgio un nuevo tipo de lenguajes de programacion que evitaba estos inconvenientes, a costa de ceder un poco en las ventajas. Estos lenguajes se llaman de tercera generacion o de nivel alto, en contraposicion a los de bajo nivel o de nivel proximo a la maquina.  Lenguaje de alto nivel se refiere al nivel mas alto de abstraccion de lenguaje de maquina. En lugar de tratar con registros, direcciones de memoria y las pilas de llamadas, lenguajes de alto nivel se refieren a las variables, matrices, objetos, aritmetica compleja o expresiones booleanas, subrutinas y funciones, bucles, hilos, cierres y otros conceptos de informatica abstracta, con un enfoque en la facilidad de uso sobre la eficiencia optima del programa.    (Debido a que permite programar en nivel bajo) ","snippet":"Un lenguaje de programacion de alto nivel se caracteriza por expresar los algoritmos de una manera adecuada a la capacidad cognitiva humana, en lugar de la capacidad con que las maquinas lo ejecutan. ","enlaces_salientes":["Lenguaje_de_alto_nivel","Lenguaje_de_alto_nivel","Lenguaje_de_alto_nivel","Lenguaje_de_programaci%C3%B3n","Algoritmo","Cognici%C3%B3n","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_dirigida_por_eventos","Programaci%C3%B3n_funcional","Lenguaje_de_programaci%C3%B3n_compilado","Int%C3%A9rprete_(inform%C3%A1tica)","Java_(lenguaje_de_programaci%C3%B3n)","PHP","Python","JavaScript","C_Sharp","Lenguaje_de_bajo_nivel","A%C3%B1os_1950","Paradigma_de_programaci%C3%B3n","Python","VB.NET","Erlang","Ada_(lenguaje_de_programaci%C3%B3n)","ALGOL","BASIC","C_Sharp","FORTRAN","C%2B%2B","C_(lenguaje_de_programaci%C3%B3n)","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Abstracci%C3%B3n_(inform%C3%A1tica)","Compilador","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lenguaje_de_programaci%C3%B3n_Ada","titulo":"Ada (lenguaje de programacion)","contenido":"Ada es un lenguaje de programacion orientado a objetos y fuertemente tipado de forma estatica que fue dise\u00f1ado por Jean Ichbiah de CII Honeywell Bull por encargo del Departamento de Defensa de los Estados Unidos. Es un lenguaje multiproposito, orientado a objetos y concurrente, pudiendo llegar desde la facilidad de Pascal hasta la flexibilidad de C++.  Fue dise\u00f1ado con la seguridad en mente y con una filosofia orientada a la reduccion de errores comunes y dificiles de descubrir. Para ello se basa en un tipado muy fuerte y en chequeos en tiempo de ejecucion (desactivables en beneficio del rendimiento). La sincronizacion de tareas se realiza mediante la primitiva rendezvous.  Ada se usa principalmente en entornos en los que se necesita una gran seguridad y fiabilidad, como la defensa, la aeronautica (Boeing y Airbus), la gestion del trafico aereo (como Indra en Espa\u00f1a) y la industria aeroespacial entre otros.  El lenguaje fue dise\u00f1ado bajo encargo del Departamento de Defensa de los Estados Unidos (DoD). Durante los a\u00f1os 1970, este departamento tenia proyectos en una infinidad de lenguajes y estaba gastando mucho dinero en software. Para solucionarlo se busco un lenguaje unico que cumpliese unas ciertas normas recogidas en el documento Steelman. Despues de un estudio de los lenguajes existentes en la epoca se decidio que ninguno las cumplia totalmente, por lo que se hizo un concurso publico al que se presentaron cuatro equipos, cuyas propuestas se nombraron con un color: rojo (Intermetrics), verde (CII Honeywell Bull), azul (SofTEch)\u200b y amarillo (SRI International). Finalmente, en mayo de 1979 se selecciono la propuesta verde dise\u00f1ada por Jean Ichbiah de CII Honeywell Bull, y se le dio el nombre de Ada. Esta propuesta era un sucesor de un lenguaje anterior de este equipo llamado LIS y desarrollado durante los a\u00f1os 1970. El manual de referencia preliminar de Ada se publico en ACM SIGPLAN Notices en junio de 1979. El manual de referencia de Military Standard se aprobo el 10 de diciembre de 1980 (cumplea\u00f1os de Ada Lovelace) y recibio el numero MIL-STD-1815 en honor del a\u00f1o de nacimiento de Ada Lovelace. En 1981, C. A. R. Hoare aprovecho su Premio Turing para criticar a Ada por ser demasiado complejo y, por lo tanto, poco fiable.\u200b pero posteriormente parecio retractarse en el prologo que escribio para un libro de texto de Ada.\u200b  Ada atrajo mucha atencion de la comunidad de programacion en su conjunto durante sus primeros dias. Sus patrocinadores y otros predijeron que podria convertirse en un lenguaje dominante para la programacion de proposito general y no solo para el trabajo relacionado con la defensa.\u200b Ichbiah declaro publicamente que dentro de diez a\u00f1os, solo quedarian dos lenguajes de programacion: Ada y Lisp.\u200b  Los primeros compiladores de Ada lucharon por implementar este lenguaje grande y complejo, y tanto el rendimiento en tiempo de compilacion como en tiempo de ejecucion tendia a ser lento y las herramientas primitivas.\u200b   Los proveedores de compiladores dedicaron la mayor parte de sus esfuerzos a aprobar el paquete de validacion Capacidad de validacion del compilador de Ada (ACVC) requerido por el gobierno, con pruebas de conformidad de lenguaje masivas, que se requeria en otra caracteristica novedosa del esfuerzo de lenguaje de Ada.\u200b The Jargon File, un diccionario de jerga de piratas informaticos que se origino entre 1975 y 1983, se\u00f1ala en una entrada sobre Ada que \"es precisamente lo que uno podria esperar dado ese tipo de respaldo por decreto; dise\u00f1ado por el comite ... dificil para usar, y en general un desastroso despilfarro de miles de millones de dolares... Ada Lovelace... casi con certeza palideceria ante el uso que se le ha dado a su nombre ultimamente; lo mas amable que se ha dicho al respecto es que hay probablemente una buena lengua peque\u00f1a que grita para salir del interior de su enorme masa elefantiana\".\u200b  El nombre se eligio en conmemoracion de lady Augusta Ada Byron (1815-1852), condesa de Lovelace, hija del poeta Lord George Byron y la matematica, activista y aristocrata Anne Isabella Noel Byron, considerada la primera programadora de la Historia por su colaboracion y relacion con Charles Babbage, creador de la maquina analitica.  El lenguaje se convirtio en un estandar de ANSI en 1983 (ANSI/MIL-STD 1815) y un estandar ISO en 1987 (ISO-8652:1987). Los requisitos del lenguaje de Steelman eran los que un lenguaje de programacion de alto nivel para propositos generales deberia cumplir, creado por el Departamento de Defensa de los Estados Unidos en el programa de Lenguaje de Orden Superior Comun del Departamento de Defensa en 1978. Los antecesores de este documento fueron llamados, en orden, \"Strawman\", \"Woodenman\", \"Tinman\" y \"Ironman\".  Los requisitos se centraron en las necesidades de las aplicaciones informaticas integradas y enfatizaron la confiabilidad, la capacidad de mantenimiento y la eficiencia. En particular, incluyeron facilidades de manejo de excepciones, verificacion en tiempo de ejecucion y computacion paralela.  Se concluyo que ningun lenguaje existente cumplia con estos criterios en la medida suficiente, por lo que se convoco un concurso para crear un lenguaje que estuviera mas cerca de cumplirlos. El dise\u00f1o que gano este concurso se convirtio en el lenguaje de programacion Ada.  El lenguaje resultante siguio de cerca los requisitos de Steelman, aunque no exactamente.  La primera implementacion validada de Ada fue el traductor NYU Ada/Ed,\u200b certificado el 11 de abril de 1983. NYU Ada/Ed se implementa en el lenguaje establecido de alto nivel SETL.\u200b Varias empresas comerciales comenzaron a ofrecer compiladores Ada y herramientas de desarrollo asociadas, incluidas Alsys, TeleSoft, DDC-I, Advanced Computer Techniques, Tartan Laboratories, Irvine Compiler, TLD Systems y Verdix.\u200b Los fabricantes de ordenadores que tenian un negocio importante en las industrias de defensa, aeroespacial o relacionadas, tambien ofrecian compiladores y herramientas Ada en sus plataformas; estos incluyeron Concurrent Computer Corporation, Cray Research, Inc., Harris Computer Systems, y Siemens Nixdorf Informationssysteme AG.\u200b  En 1991, el Departamento de Defensa de EE. UU. comenzo a exigir el uso de Ada (el \"mandato de Ada\") para todo el software,\u200b aunque a menudo se concedieron excepciones a esta regla.\u200b  El mandato Ada del Departamento de Defensa se elimino efectivamente en 1997, cuando el Departamento de Defensa comenzo a adoptar la tecnologia comercial lista para usar (COTS).\u200b Existian requisitos similares en otros paises de la OTAN: se requeria Ada para los sistemas de la OTAN que involucran comando y control y otras funciones, y Ada era el idioma obligatorio o preferido para aplicaciones relacionadas con la defensa en paises como Suecia, Alemania y Canada.\u200b  A finales de la decada de 1980 y principios de la de 1990, los compiladores de Ada habian mejorado en rendimiento, pero aun habia barreras para explotar completamente las habilidades de Ada, incluido un modelo de tareas que era diferente al que estaban acostumbrados la mayoria de los programadores en tiempo real.\u200b  Debido a las caracteristicas de soporte de seguridad critica de Ada, ahora se usa no solo para aplicaciones militares, sino tambien en proyectos comerciales donde un error de software puede tener graves consecuencias, por ejemplo, avionica y control de trafico aereo, cohetes comerciales como el Ariane 4 y el Ariane 5, satelites y otros sistemas espaciales, transporte ferroviario y banca.\u200b Por ejemplo, el sistema de gestion de informacion del avion, el software del sistema fly-by-wire en el Boeing 777, fue escrito en Ada.\u200b\u200b  Desarrollado por Honeywell Air Transport Systems en colaboracion con consultores de DDC-I, se convirtio posiblemente en el mas conocido de todos los proyectos de Ada, civiles o militares.\u200b\u200b El sistema de trafico aereo automatizado canadiense se escribio en 1 millon de lineas de Ada (recuento de SLOC). Presentaba procesamiento distribuido avanzado, una base de datos Ada distribuida y un dise\u00f1o orientado a objetos. Ada tambien se utiliza en otros sistemas de trafico aereo, por ejemplo, el soporte de herramientas de control de area futuro provisional de proxima generacion del sistema de control de trafico aereo del Reino Unido (iFACTS) esta dise\u00f1ado e implementado usando SPARK Ada.\u200b Tambien se utiliza en el sistema de se\u00f1alizacion de cabina frances de TVM en el sistema ferroviario de alta velocidad TGV y en los trenes suburbanos del metro en Paris, Londres, Hong Kong y Nueva York.\u200b\u200b  El Ada preliminar se puede encontrar en ACM Sigplan Notices Vol 14, No 6, junio de 1979.  Ada se publico por primera vez en 1980 como estandar ANSI ANSI/MIL-STD 1815. Como esta primera version contenia muchos errores e inconsistencias (vease Resumen de los cambios de lenguaje de Ada), la edicion revisada se publico en 1983 como ANSI/MIL-STD 1815A. Sin mas cambios, se convirtio en norma ISO en 1987, ISO 8652:1987. Esta version del lenguaje se conoce comunmente como Ada\u00a083, desde la fecha de su adopcion por parte de ANSI, pero a veces tambien se la denomina Ada\u00a087, desde la fecha de su adopcion por ISO. Este es el Manual de referencia de Ada 83. Tambien hay una traduccion al frances; DIN lo tradujo al aleman como DIN 66268 en 1988.  Ada\u00a095, el estandar conjunto ISO/IEC/ANSI ISO/IEC 8652:1995 (vease Ada 95 RM) fue publicado en febrero de 1995, convirtiendolo en el primer lenguaje de programacion orientado a objetos estandar ISO. Para ayudar con la revision estandar y la futura aceptacion, la Fuerza Aerea de los Estados Unidos financio el desarrollo del compilador GNAT. Actualmente, el compilador GNAT es parte de la GNU Compiler Collection.  Se ha continuado trabajando en la mejora y actualizacion de los contenidos tecnicos del lenguaje Ada. En octubre de 2001 se publico un correccion tecnica de Ada\u00a095, ISO/IEC 8652:1995/Corr 1:2001 (vease Ada 95 RM con TC 1), y una enmienda importante, ISO/IEC 8652:1995/Amd 1:2007 (vease Ada 2005 RM) fue publicado el 9 de marzo de 2007, comunmente conocido como Ada\u00a02005 porque el trabajo en el nuevo estandar finalizo ese a\u00f1o.  En la conferencia Ada-Europa 2012 en Estocolmo, Ada Resource Association (ARA) y Ada-Europa anunciaron la finalizacion del dise\u00f1o de la ultima version del lenguaje Ada y la presentacion del manual de referencia al ISO/IEC JTC 1/SC 22/WG 9 de la Organizacion Internacional de Normalizacion (ISO) y la Comision Electrotecnica Internacional (IEC) para su aprobacion. ISO/IEC 8652:2012 (vease Ada 2012 RM) fue publicado en diciembre de 2012, conocido como Ada\u00a02012. Se publico un corrigendum tecnico ISO/IEC 8652:2012/COR 1:2016 (vease RM 2012 con TC 1).  A pesar de los nombres Ada 83, 95, etc., legalmente solo existe un estandar Ada, el del ultimo estandar ISO/IEC: con la aceptacion de una nueva version del estandar, el anterior se retira. Los otros nombres son solo informales que hacen referencia a una determinada edicion.  Otros estandares relacionados incluyen ISO/IEC 8651-3:1988 Sistemas de procesamiento de informacion\u2014Graficos por ordenador\u2014Enlaces de lenguaje del Sistema de Kernel Grafico (GKS)\u2014Parte 3: Ada.  Un compilador de Ada muy usado es GNAT, originalmente desarrollado por la Universidad de Nueva York bajo patrocinio del DoD. Esta basado en la tecnologia de GCC y es software libre. Actualmente esta mantenido por AdaCore (antes llamada Ada Core Technologies), empresa que ofrece soporte y servicios sobre el compilador.  Existen otros compiladores comerciales.  Un ejemplo comun sobre la sintaxis de los lenguajes de programacion es el \"Hola mundo\". En Ada, se realizaria asi:  Ejemplo de uso de array:  type T_vector is array(1..10) of integer; -- estamos definiendo la variable T_vector como un tipo de dato que almacenara 10 elementos de tipo entero.  Vector1:T_vector; -- Estamos declarando una variable llamada \"Vector1\" del tipo \"T_vector\" previamente definido.  Para acceder a cada uno de los huecos se accederia de la siguiente manera:  Vector1(4):= 5; --El hueco 4 de la variable Vector1 tiene el valor de 5. ","snippet":"Ada es un lenguaje de programacion orientado a objetos y fuertemente tipado de forma estatica que fue dise\u00f1ado por Jean Ichbiah de CII Honeywell Bull por encargo del Departamento de Defensa de los Est","enlaces_salientes":["Ada_(lenguaje_de_programaci%C3%B3n)","Ada_(lenguaje_de_programaci%C3%B3n)","Ada_(lenguaje_de_programaci%C3%B3n)","Jean_Ichbiah","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_imperativa","1980","Jean_Ichbiah","Sistema_de_tipos","GNAT","SPARK","Perfil_de_Ravenscar","ALGOL_68","Pascal_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Smalltalk","Java_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Eiffel_(lenguaje_de_programaci%C3%B3n)","PL/SQL","VHDL","Ruby","Java_(lenguaje_de_programaci%C3%B3n)","Sistema_operativo","Multiplataforma","Lenguaje_de_programaci%C3%B3n","Programaci%C3%B3n_orientada_a_objetos","Fuertemente_tipado","Jean_Ichbiah","CII_Honeywell_Bull","Departamento_de_Defensa_de_los_Estados_Unidos","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_concurrente","Pascal_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Primitiva_de_sincronizaci%C3%B3n_rendezvous","Aeron%C3%A1utica","Gesti%C3%B3n_del_tr%C3%A1fico_a%C3%A9reo","Indra_Sistemas","Aeroespacial","Departamento_de_Defensa_de_los_Estados_Unidos","A%C3%B1os_1970","Lenguajes_de_programaci%C3%B3n","Software","Requisitos_de_lenguaje_Steelman","1979","Jean_Ichbiah","A%C3%B1os_1970","Ada_Lovelace","C._A._R._Hoare","Premio_Turing","Ada_Augusta_Byron","George_Byron","Anna_Isabella_Noel_Byron","Charles_Babbage","M%C3%A1quina_anal%C3%ADtica","ANSI","1983","ISO","1987","Commercial_off-the-shelf","Organizaci%C3%B3n_del_Tratado_del_Atl%C3%A1ntico_Norte","Avi%C3%B3nica","Control_de_tr%C3%A1fico_a%C3%A9reo","Ariane_4","Ariane_5","Sat%C3%A9lite_artificial","Fly-by-wire","Boeing_777","Honeywell_Aerospace","Francia","TGV","American_National_Standards_Institute","Fuerza_A%C3%A9rea_de_los_Estados_Unidos","Compilador","GNAT","GNU_Compiler_Collection","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Comisi%C3%B3n_Electrot%C3%A9cnica_Internacional","GNAT","Universidad_de_Nueva_York","Departamento_de_Defensa_de_los_Estados_Unidos","GCC","Software_libre","Lenguaje_de_programaci%C3%B3n_Pascal","Subprograma","Lenguaje_de_programaci%C3%B3n_C","Lenguaje_de_programaci%C3%B3n_Pascal","OOP","Hola_mundo","SPARK","Perfil_de_Ravenscar","ALGOL_68","Pascal_(lenguaje_de_programaci%C3%B3n)","Smalltalk","Ada_(moneda_digital)","Tony_Hoare","Association_for_Computing_Machinery","Semantic_Scholar","Digital_object_identifier","Digital_object_identifier","Semantic_Scholar","Digital_object_identifier","ISBN","Semantic_Scholar","Digital_object_identifier","ACM_Queue","Digital_object_identifier","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"C_sharp","titulo":"C Sharp","contenido":"\"C#\" (pronunciado cii sharp en ingles) es un lenguaje de programacion multiparadigma desarrollado y estandarizado por la empresa Microsoft como parte de su plataforma .NET, que despues fue aprobado como un estandar por la ECMA (ECMA-334) e ISO (ISO/IEC 23270). C# es uno de los lenguajes de programacion dise\u00f1ados para la infraestructura de lenguaje comun.  Su sintaxis basica deriva de C/C++ y utiliza el modelo de objetos de la plataforma .NET, similar al de Java, aunque incluye mejoras derivadas de otros lenguajes.  El nombre C Sharp fue inspirado por el signo \u266f, el cual se lee como sharp en ingles para notacion musical. Es un juego de palabras, pues '\"C#\" significa, musicalmente hablando, \"do sostenido\", donde el simbolo # indica que una nota (en este caso do, representada por C) debe ser un semitono mas alta. Esto es una metafora de la superioridad de C# sobre su antecesor C++ y a su vez hace alusion a la misma metafora que se ideo para dar nombre a C++.\u200b Ademas, el simbolo # puede ser imaginado como la union de cuatro simbolos +, continuando asi con el sentido de progresion de los lenguajes C.  Aunque C# forma parte de la plataforma .NET, esta es una API, mientras que C# es un lenguaje de programacion independiente dise\u00f1ado para generar programas sobre dicha plataforma. Ya existe un compilador implementado que provee el marco Mono - DotGNU, el cual genera programas para distintas plataformas como Microsoft Windows, Unix, Android, iOS, Windows Phone, Mac OS y GNU/Linux.  Durante el desarrollo de la plataforma .NET, las bibliotecas de clases fueron escritas originalmente usando un sistema de codigo gestionado llamado Simple Managed C (SMC). En abril de 1999, Anders Hejlsberg formo un equipo con la mision de desarrollar un nuevo lenguaje orientado a objetos. Este nombre tuvo que ser cambiado debido a problemas de marca, pasando a llamarse C#.\u200b La biblioteca de clases de la plataforma .NET fue migrada entonces al nuevo lenguaje, y este despues fue modificado por Joseth M.  Hejlsberg lidero el proyecto de desarrollo de C#. Anteriormente ya habia participado en el desarrollo de otros lenguajes como Turbo Pascal, Delphi y J++.  C# contiene veinte categorias generales de tipos de datos integrados: tipos de valor y tipos de referencia. El termino tipo de valor indica que esos tipos contienen directamente sus valores. Tipos para definir numeros enteros:  Los tipos de coma flotante pueden representar numeros con componentes fraccionales. Existen dos clases de tipos de coma flotante: float y double. El tipo double es el mas utilizado porque muchas funciones matematicas de la biblioteca de clases de C# usan valores double. Quiza, el tipo de coma flotante mas interesante de C# es decimal, dirigido al uso de calculos monetarios. La aritmetica de coma flotante normal esta sujeta a una variedad de errores de redondeo cuando se aplica a valores decimales. El tipo decimal elimina estos errores y puede representar hasta 28 lugares decimales.  Los caracteres en C# no tienen un tama\u00f1o de 8 bits como en muchos otros lenguajes de programacion, sino que usan un tama\u00f1o de 16 bits. Este tipo de dato se llama char y utiliza la codificacion Unicode. No existen conversiones automaticas de tipo entero a char.  Para los tipos de datos logicos no existen conversiones automaticas de tipo entero a bool.  En ocasiones, resulta mas sencillo usar un sistema numerico en base 16 en lugar de 10, para tal caso C# permite especificar numeros enteros en formato hexadecimal, y se define anteponiendo 0x, por ejemplo: 0xFF, que equivale a 255 en decimal. Asimismo, tambien permite poner estos en formato binario anteponiendo 0b.  C# tiene caracteres denominados secuencias de escape para facilitar la escritura con el teclado de simbolos que carecen de representacion visual.  C#, al igual que C++, define un tipo de cadena de caracteres. Dentro de la cadena de caracteres se pueden usar secuencias de escape. Una cadena de caracteres puede iniciarse con el simbolo @ seguido por una cadena entre comillas (\"), en tal caso, las secuencias de escape no tienen efecto, y ademas la cadena puede ocupar dos o mas lineas.  Las variables son identificadores asociados a valores. Se declaran indicando el tipo de dato que almacenara y su identificador.  Un identificador puede:  Un identificador no puede:  Declarar una variable:  Para asignar un valor a una variable, se indica el identificador de la misma, seguido del simbolo igual (=) y el valor que queremos que almacene:  Se puede declarar y asignar un valor al mismo tiempo:  Tambien puedes declarar una variable sin especificar el tipo de dato, utilizando el mecanismo de inferencia mediante la palabra clave var donde el compilador determina el tipo de dato que se le asignara a la variable y solamente es permitida para variables locales, no para parametros o datos miembro.  Las conversiones de tipo de variables en C# se representan en la siguiente tabla en donde la fila es el origen y la columna el destino.  Ademas de realizarse dentro de una asignacion, las conversiones de tipos tambien tienen lugar dentro de una expresion, pues en cada operacion ambos operandos deben de ser del mismo tipo. Si la conversion es del tipo implicito se efectua el siguiente algoritmo en dicho orden:  Las constantes son valores inmutables, y por tanto no se pueden cambiar.  const  Cuando se declara una constante con la palabra clave const, tambien se debe asignar el valor. Tras esto, la constante queda bloqueada y no se puede cambiar. Son implicitamente estaticas (static).  readonly  A diferencia de const, no requiere que se asigne el valor al mismo tiempo que se declara. Pueden ser miembros de la instancia o miembros estaticos de la clase (static).  if-else  switch  for  while  do-while  foreach  ref  out  params  Sobrecarga de metodos  Main  Declarar una matriz:  Declarar e inicializar una matriz (el tama\u00f1o de la matriz se puede omitir):  Acceder a un elemento:  Declarar una matriz multidimensional:  Declarar e inicializar una matriz multidimensional (el tama\u00f1o de la matriz se puede omitir):  Acceder a un elemento de una matriz multidimensional:  Mas informacion en: Tutorial de matrices (C#) (en ingles).  Declarar una clase:  Iniciar una clase (tambien llamado crear un objeto de la clase o instanciar una clase):  Constructor (como si fuera un metodo, pero con el nombre de su clase):  Destructor (como si fuera un metodo, precedido del simbolo '~'):  this:  static:  operator:  Comparacion de objetos:  Declarar una cadena de caracteres (como si fuera una variable de un tipo de dato como int o double):  Longitud de una cadena:  Comparar dos cadenas:  Concatenar cadenas:  La clase System.String, y una instancia de la misma, string, poseen algunos metodos para trabajar con cadenas, como:  static string Copy(string str): devuelve una copia de str.  int CompareTo(string str): devuelve menor que cero si la cadena que llama es menor que str, mayor que cero si la cadena que llama es mayor que str, y cero si las cadenas son iguales.  int IndexOf(string str): devuelve el indice de la primera coincidencia de la subcadena especificada en str, o -1 en caso de error.  int LastIndexOf(string str): devuelve el indice de la ultima coincidencia de la subcadena especificada en str, o -1 en caso de error.  string ToLower: devuelve una copia de la cadena en minusculas.  string ToUpper: devuelve una copia de la cadena en mayusculas.  string Substring: devuelve una subcadena, indicando la posicion de inicio y la longitud que se desea.  Mas informacion en: String (Clase) (System) (en ingles).  Language-Integrated Query (LINQ) es el nombre de un conjunto de tecnologias que consiste en la integracion directa de funciones de consulta en el lenguaje C# (tambien en Visual Basic y potencialmente en cualquier otro lenguaje de .NET). Con LINQ, ahora una consulta es una construccion de lenguaje de primera clase, igual que las clases, los metodos, los eventos, etc.  Para un programador que escribe consultas, la parte integrada en el lenguaje mas visible de LINQ es la expresion de consulta. Las expresiones de consulta se escriben en la sintaxis de consulta declarativa que se introdujo en C# 3.0. Al usar sintaxis de consulta, se pueden realizar incluso operaciones complejas de filtrado, ordenacion y agrupamiento en origenes de datos con codigo minimo. Los mismos patrones de expresion de consulta basicos se usan para consultar y transformar datos de bases de datos SQL, conjuntos de datos de ADO.NET, secuencias y documentos XML, y colecciones de .NET.  En el siguiente ejemplo se muestra la operacion de consulta completa. La operacion completa incluye la creacion de un origen de datos, la definicion de la expresion de consulta y la ejecucion de la consulta en una instruccion foreach.  https://msdn.microsoft.com/es-es/library/bb397676(v=vs.120).aspx  Ejemplo basico \"Hola mundo\":  Suma y concatenacion:  Uso de clases, metodos, propiedades y sobrecarga:  Ejemplo de Vectores o Arreglos paralelos:  Problema 1:  Desarrollar un programa que permita cargar 5 nombres de personas y sus edades respectivas. Luego de realizar la carga por teclado de todos los datos imprimir los nombres de las personas mayores de edad (mayores o iguales a 18 a\u00f1os).  Programa:  Cabe destacar que los controles comunes que ofrece la plataforma .NET se pueden personalizar y/o editar para satisfacer las diferentes necesidades de los desarrolladores. El tomar la decision de crear un control personalizado llega cuando se desea hacer una componente en donde se tiene el control total sobre su aspecto funcional y visual; con la posibilidad de no cargar las funcionalidades innecesarias para el desarrollo.  Los casos comunes en donde se suelen usar estas caracteristicas son:  En la actualidad existen los siguientes compiladores o IDE para el lenguaje C#:  El estandar ECMA-334 lista las siguientes metas en el dise\u00f1o para C#: ","snippet":"\"C#\" (pronunciado cii sharp en ingles) es un lenguaje de programacion multiparadigma desarrollado y estandarizado por la empresa Microsoft como parte de su plataforma .NET, que despues fue aprobado co","enlaces_salientes":["C_Sharp","C_Sharp","C_Sharp","Microsoft","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_estructurada","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_dirigida_por_eventos","Programaci%C3%B3n_funcional","Programaci%C3%B3n_gen%C3%A9rica","Reflexi%C3%B3n_(inform%C3%A1tica)","Microsoft","Sistema_de_tipos","Sistema_de_tipos#Tipado_est\u00e1tico","Sistema_de_tipos#Tipado_din\u00e1mico","Tipado_fuerte","Microsoft_.NET",".NET_Core","Proyecto_Mono","DotGNU","C%CF%89","Java_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Eiffel_(lenguaje_de_programaci%C3%B3n)","Modula-3","Pascal_(lenguaje_de_programaci%C3%B3n)","D_(lenguaje_de_programaci%C3%B3n)","F_Sharp","Java_(lenguaje_de_programaci%C3%B3n)","Vala_(lenguaje_de_programaci%C3%B3n)","Sistema_operativo","Multiplataforma","Lenguaje_de_programaci%C3%B3n","Empresa","Microsoft","Microsoft_.NET","Ecma_International","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Infraestructura_de_lenguaje_com%C3%BAn","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Java_(lenguaje_de_programaci%C3%B3n)","Met%C3%A1fora","Interfaz_de_programaci%C3%B3n_de_aplicaciones","Compilador","Proyecto_Mono","DotGNU","Microsoft_Windows","Unix","Android","IOS_(sistema_operativo)","Windows_Phone","Mac_OS","GNU/Linux","Clase_(inform%C3%A1tica)","C%C3%B3digo_gestionado","Anders_Hejlsberg","Lenguaje_orientado_a_objetos","Turbo_Pascal","Embarcadero_Delphi","J%2B%2B","Unidades_de_informaci%C3%B3n#N\u00fameros_enteros","Coma_flotante","Car%C3%A1cter_(tipo_de_dato)","16_bits","Tipo_de_dato","Unicode","Tipo_de_dato_l%C3%B3gico","Sistema_hexadecimal","Sistema_de_numeraci%C3%B3n_decimal","Sistema_binario","Cadena_de_caracteres","Nueva_l%C3%ADnea","Retorno_de_carro","Barra_inversa","Case_sensitive","Inferencia","Truncamiento","Redondeo","Recolector_de_basura","Hola_mundo","Controles_comunes_personalizados_CSharp","Compilador","Entorno_de_desarrollo_integrado","Entorno_de_desarrollo_integrado","Microsoft_Visual_Studio","SharpDevelop","Software_libre","GNU_Lesser_General_Public_License","Proyecto_Mono","GNU_General_Public_License","Microsoft_.NET","Novell","DotGNU","Portable.NET","Free_Software_Foundation","Ingenier%C3%ADa_de_software","Componente_de_software","Internacionalizaci%C3%B3n_y_localizaci%C3%B3n","Sistema_operativo","Idioma_%C3%81rabe","Internet_Archive","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Cobol","titulo":"COBOL","contenido":"El lenguaje COBOL (acronimo de COmmon Business-Oriented Language, Lenguaje Comun Orientado a Negocios) fue creado en el a\u00f1o 1959 con el objetivo de crear un lenguaje de programacion universal que pudiera ser usado en cualquier ordenador y que estuviera orientado principalmente a los negocios, es decir, a la llamada informatica de gestion. COBOL se utiliza principalmente en sistemas comerciales, financieros y administrativos para empresas y gobiernos. COBOL todavia se usa ampliamente en aplicaciones implementadas en ordenadores centrales, como trabajos de lote y procesamiento de transacciones a gran escala. Sin embargo, debido a su popularidad decreciente y al retiro de los programadores COBOL experimentados, los programas se estan migrando a nuevas plataformas, reescribiendolos en lenguajes modernos o reemplazandolos con paquetes de software.\u200b La mayor parte de la programacion en COBOL ahora es puramente para mantener las aplicaciones existentes; sin embargo, muchas instituciones financieras grandes todavia estaban desarrollando nuevos sistemas en COBOL hasta 2006.\u200b  En la creacion de este lenguaje participo la comision CODASYL, compuesta por fabricantes de ordenadores, usuarios y el Departamento de Defensa de Estados Unidos en mayo de 1959. La definicion del lenguaje se completo en poco mas de seis meses, siendo aprobada por la comision en enero de 1960. El lenguaje COBOL fue dise\u00f1ado inspirandose en el lenguaje Flow-Matic de la oficial Grace Hopper y el IBM COMTRAN de Bob Bemer, ya que ambos formaron parte de la comision.  Gracias a la ayuda de los usuarios COBOL evoluciono rapidamente y fue revisado de 1961 a 1965 para a\u00f1adirle nuevas funcionalidades. En 1968 salio la primera version ANSI del lenguaje, siendo revisada posteriormente en 1974 (COBOL ANS-74), 1985 (COBOL ANS-85, ampliado en 1989 con funciones matematicas, finalizando el estandar actual mas usado, conocido como COBOL-ANSI), y en 2002 (COBOL ANS-2002).  El ultimo estandar es el COBOL 2014 que entre otras, incluye una nueva caracteristica que permite gestion dinamica de la memoria (OCCURS DYNAMIC).  Existe una version IBM Enterprise Cobol, actualizada regularmente y lanzada en 1991, usada en sistemas Host (Mainframe) bajo z/OS.  Para Windows y Linux, hay varios compiladores e IDE-s que existen desde hace tiempo y se siguen modernizando.  Tambien actualmente existen:  Pese a esto, a comienzos de los ochenta se fue quedando anticuado respecto a los nuevos paradigmas de programacion y a los lenguajes que los implementaban. En la revision de 1985 se soluciono, incorporando a COBOL variables locales, recursividad, reserva de memoria dinamica y programacion estructurada.  En la revision de 2002 se le a\u00f1adio orientacion a objetos, aunque desde la revision de 1974 se podia crear un entorno de trabajo similar a la orientacion a objetos, y un metodo de generacion de pantallas graficas estandarizado.  Antes de la inclusion de las nuevas caracteristicas en el estandar oficial, muchos fabricantes de compiladores las a\u00f1adian de forma no estandar. En la actualidad este proceso se esta viendo con la integracion de COBOL con Internet. Existen varios compiladores que permiten emplear COBOL como lenguaje de scripting y de servicio web. Tambien existen compiladores que permiten generar codigo COBOL para la plataforma .NET y EJB.   La estructura de un Programa en Cobol se compone de 4 Divisiones.  .  Pese a que muchas personas creen que el lenguaje COBOL esta en desuso, la realidad es que casi todos los sistemas que requieren gran capacidad de procesamiento por lotes (Batch), tanto las entidades bancarias como otras grandes empresas con sistemas mainframes utilizan COBOL. Esto permite garantizar la compatibilidad de los sistemas antiguos con los mas modernos, asi como tener la seguridad de que el lenguaje es perfectamente estable y probado. Segun un informe de Gartner Group de 2005, el 75% de los datos generados por negocios son procesados por programas creados en COBOL, y en otro informe de 1997 estima que el 80% de los 300.000 millones de lineas de codigo existentes estan creados en COBOL, escribiendose 5000 millones de lineas nuevas de COBOL cada a\u00f1o. Con todo eso, hoy por hoy, la programacion en COBOL es uno de los negocios mas rentables del mundo de la informatica. En el resto de aplicaciones el COBOL ha caido en desuso, reemplazado por lenguajes mas modernos o versatiles.  En la decada de 1970, la adopcion del paradigma de programacion estructurada se estaba generalizando cada vez mas. Edsger Dijkstra, un preeminente informatico, escribio una carta al editor de Comunicaciones de la ACM, publicada en 1975 titulada \"\u00bfComo decimos verdades que podrian doler?\", en la que fue critico con COBOL y varios otros lenguajes contemporaneos; remarcando que \"el uso de COBOL paraliza la mente\".\u200b En una discrepancia publicada a los comentarios de Dijkstra, el cientifico informatico Howard E. Tompkins afirmo que el COBOL no estructurado tendia a ser \"escrito por programadores que nunca han tenido el beneficio de COBOL estructurado bien ense\u00f1ado\", argumentando que el problema era principalmente uno de entrenamiento.\u200b  Una de las causas del codigo espagueti fue la declaracion GO TO. Los intentos de eliminar GO TOs del codigo COBOL, sin embargo, resulto en programas intrincados y calidad de codigo reducida.\u200b GO TOs fueron reemplazados en gran parte por las declaraciones i procedimientos PERFORM, que promovio la programacion modular\u200b y dio facil acceso a potentes instalaciones de bucle. Sin embargo, PERFORM podria usarse solo con procedimientos para que los cuerpos de los bucles no se ubicaran donde se usaron, lo que dificultaba la comprension de los programas.\u200b  Los programas COBOL eran famosos por ser monoliticos y carecer de modularizacion.\u200b El codigo COBOL solo podia modularizarse a traves de procedimientos, que resultaron ser inadecuados para sistemas grandes. Era imposible restringir el acceso a los datos, lo que significa que un procedimiento podia acceder y modificar cualquier elemento de datos. Ademas, no habia forma de pasar parametros a un procedimiento, una omision que Jean Sammet considero como el mayor error del comite.\u200b Otra complicacion procedia de la capacidad de PERFORM THRU una secuencia especifica de procedimientos. Esto significaba que el control podia saltar y regresar de cualquier procedimiento, creando un flujo de control intrincado y permitiendo que un programador rompiera la regla entrada unica, salida unica.\u200b  Esta situacion mejoro a medida que COBOL adopto mas caracteristicas. COBOL-74 agrego subprogramas, brindando a los programadores la capacidad de controlar los datos a los que podia acceder cada parte del programa. COBOL-85 luego agrego subprogramas anidados, lo que permitio a los programadores ocultar subprogramas.\u200b Un mayor control sobre los datos y el codigo llego en 2002 cuando se incluyeron la programacion orientada a objetos, las funciones definidas por el usuario y los tipos de datos definidos por el usuario.  Sin embargo, gran parte del software COBOL heredado importante utiliza codigo no estructurado, que se ha vuelto imposible de mantener. Puede ser demasiado arriesgado y costoso modificar incluso una simple seccion de codigo, ya que puede usarse desde lugares desconocidos de formas desconocidas.\u200b  COBOL estaba destinado a ser un lenguaje \"comun\" altamente portatil. Sin embargo, para 2001, se habian creado alrededor de 300 dialectos.\u200b Una fuente de dialectos era el propio estandar: el estandar de 1974 estaba compuesto por un nucleo obligatorio y once modulos funcionales, cada uno con dos o tres niveles de soporte. Esto permitio 104 976 variantes oficiales.\u200b  COBOL-85 no era totalmente compatible con versiones anteriores y su desarrollo fue controvertido. Joseph T. Brophy, el CIO de Travellers Insurance, encabezo un esfuerzo para informar a los usuarios de COBOL sobre los altos costos de reprogramacion de implementar el nuevo estandar.\u200b Como resultado, el comite ANSI COBOL recibio mas de 2200 cartas del publico, en su mayoria negativas, que solicitaban al comite que hiciera cambios. Por otro lado, se pensaba que la conversion a COBOL-85 aumentaria la productividad en a\u00f1os futuros, justificando asi los costos de conversion.\u200b  La sintaxis de COBOL a menudo ha sido criticada por su verbosidad. Los defensores dicen que esto tenia la intencion de hacer el codigo autodocumentado, facilitando el mantenimiento del programa.\u200b COBOL tambien estaba destinado a ser facil de aprender y usar para los programadores,\u200b sin dejar de ser legible para el personal no tecnico, como los gerentes.\u200b\u200b\u200b\u200b El deseo de legibilidad condujo al uso de elementos estructurales y sintacticos similares al ingles, como sustantivos, verbos, clausulas, oraciones, secciones y divisiones. Sin embargo, en 1984, los mantenedores de los programas COBOL luchaban por lidiar con el codigo \"incomprensible\".\u200b y los principales cambios en COBOL-85 estaban alli para ayudar a facilitar el mantenimiento.\u200b  Jean Sammet, miembro del comite de corto alcance, se\u00f1alo que \"se hizo un peque\u00f1o intento por atender al programador profesional, de hecho, las personas cuyo principal interes es la programacion tienden a estar muy descontentas con COBOL\", lo que atribuyo a la sintaxis detallada de COBOL.\u200b  La comunidad COBOL siempre ha estado aislada de la comunidad informatica. Ningun informatico academico participo en el dise\u00f1o de COBOL: todos los miembros del comite procedian del comercio o el gobierno. Los informaticos de la epoca estaban mas interesados en campos como el analisis numerico, la fisica y la programacion de sistemas que en los problemas comerciales de procesamiento de archivos que abordaba el desarrollo de COBOL.\u200b Jean Sammet atribuyo la impopularidad de COBOL a una \"reaccion snob\" inicial debido a su falta de elegancia, la falta de cientificos informaticos influyentes que participaran en el proceso de dise\u00f1o y el desden por el procesamiento de datos comerciales.\u200b La especificacion COBOL uso una \"notacion\" unica, o metalenguaje, para definir su sintaxis en lugar de la nueva forma Backus-Naur que el comite no conocia. Esto resulto en criticas \"severas\".\u200b\u200b\u200b  Mas tarde, COBOL sufrio una escasez de material que lo cubriera; los libros introductorios tardaron hasta 1963 en aparecer (con Richard D. Irwin publicando un libro de texto universitario sobre COBOL en 1966).\u200b Para 1985, habia el doble de libros sobre FORTRAN y cuatro veces mas sobre BASIC que sobre COBOL en la Biblioteca del Congreso.\u200b Los profesores universitarios ense\u00f1aban lenguajes y tecnicas mas modernos y de ultima generacion en lugar de COBOL, que se decia que tenia una naturaleza de \"escuela de comercio\".\u200b Donald Nelson, presidente del comite CODASYL COBOL, dijo en 1984 que \"los academicos ... odian COBOL\" y que los graduados en informatica \"tenian 'odio COBOL' en ellos\".\u200b  A mediados de la decada de 1980, tambien hubo una condescendencia significativa hacia COBOL en la comunidad empresarial por parte de los usuarios de otros lenguajes, por ejemplo FORTRAN o ensamblador, lo que implica que COBOL podria usarse solo para problemas no-desafiantes.\u200b  En 2003, COBOL figuraba en el 80% de los planes de estudio de sistemas de informacion en los Estados Unidos, la misma proporcion que C++ y Java.\u200b Diez a\u00f1os despues, una encuesta realizada por Micro Focus encontro que el 20\u00a0% de los academicos universitarios pensaban que COBOL estaba desactualizado o muerto y que el 55\u00a0% creia que sus estudiantes pensaban que COBOL estaba desactualizado o muerto. La misma encuesta tambien encontro que solo el 25\u00a0% de los academicos tenian programacion COBOL en su plan de estudios, aunque el 60\u00a0% penso que deberian ense\u00f1arla.\u200b  Se han planteado dudas sobre la competencia del comite de normas. El miembro del comite a corto plazo, Howard Bromberg, dijo que habia \"poco control\" sobre el proceso de desarrollo y que estaba \"plagado por la discontinuidad del personal y... la falta de talento\".\u200b Jean Sammet y Jerome Garfunkel tambien se\u00f1alaron que los cambios introducidos en una revision del estandar se revertirian en la siguiente, debido tanto a los cambios en quien estaba en el comite del estandar como a la evidencia objetiva.\u200b  Los estandares COBOL han sufrido repetidamente retrasos: COBOL-85 llego cinco a\u00f1os mas tarde de lo esperado,\u200b COBOL 2002 se retraso cinco a\u00f1os,\u200b and COBOL 2014 was six years late.\u200b\u200b Para combatir los retrasos, el comite de estandares permitio la creacion de apendices opcionales que agregarian caracteristicas mas rapidamente que esperando la proxima revision del estandar. Sin embargo, algunos miembros del comite expresaron su preocupacion por las incompatibilidades entre las implementaciones y las frecuentes modificaciones del estandar.\u200b  Las estructuras de datos de COBOL influyeron en los lenguajes de programacion posteriores. Su estructura de registros y archivos influyo en PL/I y Pascal, y la clausula REDEFINES fue un predecesor de los registros variantes de Pascal. Las definiciones explicitas de estructuras de archivos precedieron al desarrollo de sistemas de administracion de bases de datos y los datos agregados fueron un avance significativo sobre las matrices de Fortran.\u200b Las declaraciones de datos de PICTURE se incorporaron a PL/I, con cambios menores.  La facilidad de COBOL con COPY, aunque se considera \"primitivo\",\u200b influyo en el desarrollo de directivas include.\u200b  El enfoque en la portabilidad y la estandarizacion significo que los programas escritos en COBOL pudieran ser portatiles y facilito la difusion del lenguaje a una amplia variedad de plataformas de hardware y sistemas operativos.\u200b Ademas, la estructura de division bien definida restringe la definicion de referencias externas a la Division de Entorno, lo que simplifica los cambios de plataforma en particular.\u200b  Migracion de Cobol MainFrame ","snippet":"El lenguaje COBOL (acronimo de COmmon Business-Oriented Language, Lenguaje Comun Orientado a Negocios) fue creado en el a\u00f1o 1959 con el objetivo de crear un lenguaje de programacion universal que pudi","enlaces_salientes":["COBOL","COBOL","COBOL","Lenguaje_de_programaci%C3%B3n","Acr%C3%B3nimo","Lenguaje_de_programaci%C3%B3n","Inform%C3%A1tica_de_gesti%C3%B3n","Ordenador_central","Procesamiento_por_lotes","Procesamiento_de_transacciones","CODASYL","Departamento_de_Defensa_de_Estados_Unidos","1959","1960","Flow-Matic","Grace_Murray_Hopper","1961","1965","1968","ANSI","1974","1985","2002","1991","GnuCOBOL","Base_diez","Paradigma_de_programaci%C3%B3n","Lenguaje_de_scripting","Servicio_web",".NET","EJB","Hola_mundo","Procesamiento_por_lotes","Mainframe","Programaci%C3%B3n_estructurada","Edsger_Dijkstra","C%C3%B3digo_espagueti","Programaci%C3%B3n_modular","Metalenguaje","Forma_Backus-Naur","Biblioteca_del_Congreso_de_Estados_Unidos","FORTRAN","Lenguaje_ensamblador","Sistemas_de_informaci%C3%B3n","C%2B%2B","Java_(lenguaje_de_programaci%C3%B3n)","Micro_Focus","PL/I","Pascal_(lenguaje_de_programaci%C3%B3n)","The_Terminator","Semantic_Scholar","Digital_object_identifier","ISBN","Digital_object_identifier","Handle_System","Digital_object_identifier","Eric_S._Raymond","ISBN","ISBN","Semantic_Scholar","Digital_object_identifier","Library_of_Congress_Control_Number","Digital_object_identifier","IBM","IBM","ISBN","Library_of_Congress_Control_Number","CRC_Press","ISBN","ISSN","CODASYL","National_Bureau_of_Standards","ISSN","Library_of_Congress_Control_Number","ISSN","John_Wiley_%26_Sons","ISBN","ISO","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","ISBN","Library_of_Congress_Control_Number","Semantic_Scholar","Digital_object_identifier","Jean_E._Sammet","Association_for_Computing_Machinery","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","OCLC","Semantic_Scholar","Digital_object_identifier","Burroughs_B2000","Grace_Murray_Hopper","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Embarcadero_Delphi","titulo":"Embarcadero Delphi","contenido":"Embarcadero Delphi, antes conocido como CodeGear Delphi, Inprise Delphi y Borland Delphi, es un entorno de desarrollo de software dise\u00f1ado para la programacion de aplicaciones multiplataforma con enfasis en la programacion visual. En Delphi se utiliza como lenguaje de programacion una version moderna de Pascal llamada Object Pascal. Es producido comercialmente por la empresa Embarcadero Technologies desde mayo de 2008, tras adquirir CodeGear (antes lo desarrollaba Borland). En sus diferentes variantes, permite producir archivos ejecutables para Windows, MacOS X, iOS, Android, GNU/Linux y la plataforma .NET.  Delphi fue originalmente desarrollado por Borland como sucesor de Turbo Pascal y la primera herramienta que implementaba la filosofia de desarrollo rapido de aplicaciones para Windows.  Durante unos pocos a\u00f1os CodeGear se ocupo del Desarrollo de Delphi.  CodeGear fue escindida de la empresa Borland, donde Delphi se creo originalmente, tras un proceso que pretendia en principio la venta del departamento de herramientas para desarrollo . CodeGear fue adquirida por Embarcadero Technologies, que es la empres que se ocupa desde 2008 hasta el presente de su desarrollo creando las nuevas versiones.  Un uso habitual de Delphi, aunque no el unico, es el desarrollo de aplicaciones visuales y de bases de datos cliente-servidor y multicapas. Debido a que es una herramienta de proposito multiple, se usa tambien para proyectos de casi cualquier tipo, incluyendo aplicaciones de consola, aplicaciones de web (por ejemplo servicios web, CGI, ISAPI, NSAPI, modulos para Apache), servicios COM y DCOM, y servicios del sistema operativo. Entre las aplicaciones mas populares actualmente destaca Skype, un programa de telefonia por IP.  Delphi inicialmente solo producia ejecutables binarios para Windows: Delphi 1 para Win16 y con Delphi 2 se introdujo Win32.  Delphi esta basado en una version de Pascal denominada Object Pascal. Borland en los ultimos a\u00f1os defendia que el nombre correcto del lenguaje es tambien Delphi, posiblemente debido a pretensiones de marca, aunque en sus mismos manuales el nombre del lenguaje aparecia como Object Pascal, por lo que la comunidad de programadores no ha adoptado mayoritariamente este cambio (supuesta aclaracion, segun Borland). Object Pascal expande las funcionalidades del Pascal estandar:  La potencia del lenguaje de programacion Delphi, se basa principalmente en la gestion y administracion de base de datos, concepto mediante el cual se repotencio para constituirse en una herramienta importante para desarrolladores, que requerian velocidad y manejo de grandes cantidades de datos, basada en un lenguaje de programacion extensamente variado Object Pascal.  Esto permitio a los desarrolladores noveles (principiantes) y avanzados contar con una herramienta clara y de facil manejo, moderna, capaz de ejecutar con gran velocidad, procedimentos intrinsecos, que permiten obtener resultados inmediatos y a bajo costo. Entre sus caracteristicas principales, destaca lo atractivo del producto final, debido al apoyo de su  interfaz grafica de desarrollo, por lo que se situa en la categoria de lenguajes visuales, pero no todo es bondad, una desventaja con los programas no visuales, es la gran cantidad de memoria que emplea y que su ejecutable resulta demasiado grande en comparacion con uno hecho en  lenguaje C, pero esta desventaja se compensa con el tiempo de desarrollo de una aplicacion; se sacrifica espacio, pero se gana velocidad.  Esta herramienta de desarrollo, permite emular las caracteristicas de los lenguajes denominados de bajo nivel. Trabaja tanto en modo consola, como en ambiente grafico windows, actualmente existe una version para Linux.  Delphi dio una implementacion muy buena a la idea del uso de componentes, que son piezas reutilizables de codigo (clases) que pueden interactuar con el IDE en tiempo de dise\u00f1o y desempe\u00f1ar una funcion especifica en tiempo de ejecucion. Desde un enfoque mas especifico de la herramienta, se catalogan como componentes todos aquellos objetos que heredan de la clase TComponent, donde se implementa la funcionalidad necesaria para interactuar con el entorno de desarrollo, la carga dinamica desde streams y la liberacion de memoria mediante una jerarquia. Una gran parte de los componentes disponibles para Delphi son controles (derivados de TControl), que encapsulan los elementos de interaccion con el usuario como botones, menus, barras de desplazamiento, etcetera.  Delphi incluye una biblioteca de clases bien dise\u00f1ada denominada VCL (Visual Component Library, Biblioteca de Componentes Visuales) y, en sus versiones 6 y 7, una jerarquia multiplataforma paralela denominada CLX. Esta tambien se incluye en Kylix. Estas jerarquias de objetos incluyen componentes visuales y no visuales, tales como los pertenecientes a la categoria de acceso a datos, con los que puede establecerse conexiones de forma nativa o mediante capas intermedias (como ADO, BDE u ODBC) a la mayoria de las bases de datos relacionales existentes en el mercado. La VCL tambien esta disponible para el desarrollo en .NET.  Ademas de poder utilizar en un programa estos componentes estandar (botones, grillas, conjuntos de datos, etc.), es posible crear nuevos componentes o mejorar los ya existentes, extendiendo la funcionalidad de la herramienta. En Internet existe un gran numero de componentes, tanto gratuitos como comerciales, disponibles para los proyectos a los que no les basten los que vienen ya con la herramienta.  Delphi permite de manera sencilla ejecutar trozos de codigo en respuesta a acciones o eventos (sucesos) que ocurren durante el tiempo que un programa se ejecuta. Por ejemplo, cuando se presiona un boton, la VCL captura la notificacion estandar de Windows, y detecta si hay algun metodo asociado al evento OnClick del boton. Si lo hay, manda ejecutar dicho metodo.  Los eventos pueden generarse debido a la recepcion de se\u00f1ales desde elementos de hardware como el raton o el teclado, o pueden producirse al realizar alguna operacion sobre un elemento de la propia aplicacion (como abrir un conjunto de datos, que genera los eventos BeforeOpen/AfterOpen). La VCL ha demostrado estar bien dise\u00f1ada y el control que se tiene a traves de los eventos de la misma es suficiente para la gran mayoria de aplicaciones.  Una de las principales caracteristicas y ventajas de Delphi es su capacidad para desarrollar aplicaciones con conectividad a bases de datos de diferentes fabricantes. El programador de Delphi cuenta con una gran cantidad de componentes para realizar la conexion, manipulacion, presentacion y captura de los datos, algunos de ellos liberados bajo licencias de codigo abierto o gratuitos. Estos componentes de acceso a datos pueden enlazarse a una gran variedad de controles visuales, aprovechando las caracteristicas del lenguaje orientado a objetos, gracias al polimorfismo.  En la paleta de componentes pueden encontrarse varias pesta\u00f1as para realizar una conexion a bases de datos usando diferentes capas o motores de conexion.  Hay motores que permiten conectarse a bases de datos de diferentes fabricantes tales como BDE, DBExpress o ADO, que cuentan con manejadores para los formatos mas extendidos.  Tambien hay componentes de conexion directa para un buen numero de bases de datos especificas: Firebird, Interbase, Oracle, etcetera.  A continuacion un breve resumen (aun recopilandose) de las capas de conexion disponibles para las bases de datos mas populares:  Es un motor de conexion a bases de datos de uso bastante amplio y que permite manejar bases de datos de escritorio como dBase, Foxpro y Paradox, ademas de ofrecer la capacidad para conectarse a servidores SQL locales y remotos.  Su uso, va siendo cada vez menor, debido a la pobre gestion de memoria que realiza, sustituyendolo por componentes mas actualizados y especializados como DOAC (Direct Oracle Access Components), DBExpress o ZEOS, esto sumado a la fiabilidad que estan presentando los nuevos gestores de Datos en especial tecnologias como RDO y ADO; los cuales son mantenidos por sus fabricantes, forzando la compatibilidad con las versiones preliminares; liberando al programador de actualizaciones en cuanto a gestion de datos. Actualmente ya no es desarrollado por Codegear.  Como entorno visual, la programacion en Delphi consiste en dise\u00f1ar los formularios que componen al programa colocando todos sus controles (botones, etiquetas, campos de texto, etc.) en las posiciones deseadas, normalmente usando un raton. Luego se asocia codigo a los eventos de dichos controles y tambien se pueden crear modulos de datos, que regularmente contienen los componentes de acceso a datos y las reglas de negocio de una aplicacion.  Entorno de desarrollo integrado (EDI) o  IDE en ingles (Integrated Development Environment), es el ambiente de desarrollo de programas de Delphi. Se trata de un editor de formularios (que permite el desarrollo visual), un potente editor de textos que resalta la sintaxis del codigo fuente, la paleta de componentes y el depurador integrado, ademas de una barra de botones y un menu que nos permite la configuracion de la herramienta y la gestion de proyectos. En las ediciones Client/Server y Enterprise el EID tambien ofrece integracion con una herramienta de control de versiones (PVCS).  Es una potente caracteristica que nos permite establecer puntos de ruptura (breakpoints), la ejecucion paso a paso de un programa, el seguimiento de los valores de las variables y de la pila de ejecucion, asi como la evaluacion de expresiones con datos de la ejecucion del programa. Con su uso, un programador experimentado puede detectar y resolver errores logicos en el funcionamiento de un aplicativo desarrollado con Delphi. En las ediciones Client/Server y Enterprise se a\u00f1ade la opcion de depuracion de programas corriendo en equipos remotos (remote debugging), lo que posibilita el uso de todas las caracteristicas del depurador con un programa ejecutandose en su entorno normal de trabajo y no en el ordenador del programador (en donde muchas veces no ocurren los errores).  Existen desarrollos de la comunidad del software libre que intentan producir una version multiplataforma y completamente independiente de Delphi. La mas desarrollada es el llamado Lazarus.  El nombre Delphi hace referencia al oraculo de Delfos. Borland eligio ese nombre para resaltar su principal mejora con respecto a su antecesor (Turbo Pascal), que seria su conectividad con bases de datos Oracle (oraculo, en ingles). El nombre se suele pronunciar delfi en Europa, incluida Gran Breta\u00f1a. En cambio, en Estados Unidos se usa la pronunciacion delfai puesto que existe una ciudad llamada Delphi con esa pronunciacion. Esta ultima, delfai, es la preferida por Borland.  En septiembre de 2006 Borland lanzo TurboDelphi como una version reducida de Delphi. Hay dos versiones: Turbo Delphi for Windows (Win32) y Turbo Delphi for .NET, ambas disponibles en dos ediciones Professional y Explorer, esta ultima era gratuita. ","snippet":"Embarcadero Delphi, antes conocido como CodeGear Delphi, Inprise Delphi y Borland Delphi, es un entorno de desarrollo de software dise\u00f1ado para la programacion de aplicaciones multiplataforma con enfa","enlaces_salientes":["Embarcadero_Delphi","Embarcadero_Delphi","Embarcadero_Delphi","Entorno_de_desarrollo_integrado","Desarrollador_de_software","Embarcadero_Technologies","Licencia_de_software","Software_propietario","Idioma","Lenguaje_de_programaci%C3%B3n","Pascal_(lenguaje_de_programaci%C3%B3n)","Plataforma_(inform%C3%A1tica)","Multiplataforma","Ciclo_de_vida_del_lanzamiento_de_software","Desarrollo_de_software","Programaci%C3%B3n","Programaci%C3%B3n_visual","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n_Pascal","Object_Pascal","CodeGear","Borland","Ejecutable","Windows","MacOS_X","IOS","Android","GNU/Linux",".NET","Borland","Aplicaci%C3%B3n_(inform%C3%A1tica)","Base_de_datos","Cliente-servidor","Common_Gateway_Interface","Sistema_operativo","Win16","Win32","Lenguaje_de_programaci%C3%B3n_Pascal","Object_Pascal","Programaci%C3%B3n_orientada_a_objetos","Turbo_Pascal","Encapsulaci%C3%B3n_en_programaci%C3%B3n_orientada_a_objetos","Manejo_de_excepciones","Niklaus_Wirth","Herencia_(inform%C3%A1tica)","Base_de_datos","Object_Pascal","Lenguaje_C","Windows","Distribuci%C3%B3n_Linux","Kylix_(entorno_de_desarrollo)","ODBC","Internet","Programaci%C3%B3n_orientada_a_objetos","DBExpress","ActiveX_Data_Objects","Interbase","Firebird","Oracle","DBase","FoxPro","Paradox_(base_de_datos)","Microsoft_SQL_Server","MySQL","PostgreSQL","DBase","Foxpro","Paradox_(base_de_datos)","Entorno_de_desarrollo_integrado","Editor_de_texto","Sintaxis","C%C3%B3digo_fuente","Depurador","Control_de_versiones","Variable_(programaci%C3%B3n)","Pila_de_ejecuci%C3%B3n","Depuraci%C3%B3n_de_programas","Lazarus_(entorno_de_desarrollo)","Or%C3%A1culo","Delfos","Turbo_Pascal","Oracle","Delphi_(Indiana)","C%2B%2BBuilder","Visual_Component_Library","Lazarus_(entorno_de_desarrollo)","Control_de_autoridades","Biblioteca_de_Catalu%C3%B1a","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa"]}
{"url":"PHP","titulo":"PHP","contenido":"PHP es un lenguaje de programacion interpretado\u200b del lado del servidor y de uso general que se adapta especialmente al desarrollo web.\u200b Fue creado inicialmente por el programador danes-canadiense Rasmus Lerdorf en 1994.\u200b En la actualidad, la implementacion de referencia de PHP es producida por The PHP Group.\u200b PHP originalmente significaba Personal Home Page (Pagina personal), pero ahora significa el inicialismo[n 1]\u200b recursivo PHP: Hypertext Preprocessor.\u200b  El codigo PHP suele ser procesado en un servidor web por un interprete PHP implementado como un modulo, un daemon o como un ejecutable de interfaz de entrada comun (CGI). En un servidor web, el resultado del codigo PHP interpretado y ejecutado \u2014que puede ser cualquier tipo de datos, como el HTML generado o datos de imagenes binarias\u2014 formaria la totalidad o parte de una respuesta HTTP. Existen diversos sistemas de plantillas, sistemas de gestion de contenidos y frameworks que pueden emplearse para organizar o facilitar la generacion de esa respuesta. Por otra parte, PHP puede utilizarse para muchas tareas de programacion fuera del contexto de la web, como aplicaciones graficas autonomas\u200b y el control de drones.\u200b Tambien se puede interpretar y ejecutar un codigo PHP cualquiera a traves de una interfaz de linea de comandos (CLI).  El interprete estandar de PHP, impulsado por Motor Zend, es un software libre publicado bajo Licencia PHP. PHP ha sido ampliamente portado y puede ser desplegado en la mayoria de los servidores web en casi todos los sistemas operativos y plataformas, de forma gratuita.  El lenguaje PHP evoluciono sin una especificacion formal escrita o un estandar hasta 2014, con la implementacion original actuando como el estandar de facto que otras implementaciones intentaban seguir. Desde 2014, se ha trabajado para crear una especificacion formal de PHP.\u200b  PHP puede ser desplegado en la mayoria de los servidores web y en todos los sistemas operativos y plataformas sin costo alguno. El lenguaje PHP se encuentra instalado en mas de 20 millones de sitios web y en un millon de servidores. Migrar los servicios basados en PHP hacia las nuevas tecnologias que aparecen, supone un costo a justificar monetariamente (sobre todo, en terminos de hardware y rendimiento), por ello, hablar si el numero de sitios basados en PHP se ha visto reducido progresivamente en los ultimos a\u00f1os, con la aparicion de nuevas tecnologias como Node.js, Golang, ASP.NET, etc.  Poderse hacer una vision general de como PHP esta evolucionando a dia de hoy, es hablar sobre las nuevas librerias disponibles, el uso de matrices,\u200b manejo de numeros enteros, tratamiento de la criptografia cuando se usa una Base64,\u200b\u200b\u200b Web scraping, indexacion de webs, precocinado de datos, Macrodatos, set de datos, supervision de datos, set de proposiciones dimensionales. Como vemos, una vision general de este lenguaje, es mucho mas compleja que afirmar que es un lenguaje para desarrollo web. Dicha realidad, subyace en la aparicion de dominios xyz, cuya finalidad y especialidad es el cacheado de los servicios PHP para servir contenido con una orientacion al desempe\u00f1o vinculada a servicios para consumo de otros servicios que necesitan datos, tales como I.A.s. donde PHP esta viendo una acogida con un sentimiento de confianza en los resultados a obtener (sin pretender servir de lenguaje en si mismo orientado a la I.A., dado que no fue su conceptualizacion origen). Aunque el marketing que esta recibiendo este tipo de dominios, esta relacionado con las nuevas generaciones de personas educadas en las nuevas tecnologias\u200b Como parte de la vision general, habria que incluir un ultimo aspecto, y es la capacidad de generar capas de seguridad autodependientes, en un paradigma solo emergente gracias a las librerias de las que dispone PHP (En proceso de desarrollo).  El sitio web de Wikipedia esta desarrollado en PHP.\u200b Es tambien el modulo Apache mas popular entre las computadoras que utilizan Apache como servidor web.  El gran parecido que posee PHP con los lenguajes mas comunes de programacion estructurada, como C y Perl, permiten a la mayoria de los programadores crear aplicaciones complejas con una curva de aprendizaje muy corta. Tambien les permite involucrarse con aplicaciones de contenido dinamico sin tener que aprender todo un nuevo grupo de funciones.  Aunque todo en su dise\u00f1o esta orientado a facilitar la creacion de sitios webs, es posible crear aplicaciones con una interfaz grafica de usuario, utilizando alguna extension como puede ser PHP-Qt, PHP-GTK,\u200b WxPHP, WinBinder, Roadsend PHP, Phalanger, Phc o HiP Hop VM. Tambien puede ser usado desde la linea de comandos, de la misma manera como Perl o Python pueden hacerlo; a esta version de PHP se la llama PHP-CLI (Command Line Interface).\u200b  Cuando el cliente hace una peticion al servidor para que le envie una pagina web, el servidor ejecuta el interprete de PHP. Este procesa el script solicitado que generara el contenido de manera dinamica (por ejemplo obteniendo informacion de una base de datos). El resultado es enviado por el interprete al servidor, quien a su vez se lo envia al cliente.  Mediante extensiones es tambien posible la generacion de archivos PDF,\u200b Flash, asi como imagenes en diferentes formatos.  Permite la conexion a diferentes tipos de servidores de bases de datos tanto SQL como NoSQL tales como MySQL, PostgreSQL, Oracle, ODBC, DB2, Microsoft SQL Server, Firebird, SQLite o MongoDB.\u200b  PHP tambien tiene la capacidad de ser ejecutado en la mayoria de los sistemas operativos, tales como Unix (y de ese tipo, como Linux o Mac OS X) y Microsoft Windows, y puede interactuar con los servidores de web mas populares ya que existe en version CGI, modulo para Apache, e ISAPI.  PHP es una alternativa a las tecnologias de Microsoft ASP y ASP.NET (que utiliza C# y Visual Basic .NET como lenguajes), a ColdFusion de la empresa Adobe, a JSP/Java, CGI/Perl y a Node.js/Javascript. Aunque su creacion y desarrollo se da en el ambito de los sistemas libres, bajo la licencia GNU, existe ademas un entorno de desarrollo integrado comercial llamado Zend Studio. CodeGear (la division de lenguajes de programacion de Borland) ha sacado al mercado un entorno de desarrollo integrado para PHP, denominado 'Delphi for PHP. Tambien existen al menos un par de modulos para Eclipse, uno de los entornos mas populares.\u200b  Fue originalmente dise\u00f1ado en Perl, con base en la escritura de un grupo de CGI binarios escritos en el lenguaje C por el programador danes-canadiense Rasmus Lerdorf en el a\u00f1o 1994 para mostrar su curriculum vitae y guardar ciertos datos, como la cantidad de trafico que su pagina web recibia. El 8 de junio de 1995 fue publicado \"Personal Home Page Tools\" despues de que Lerdorf lo combinara con su propio Form Interpreter para crear PHP/FI.  Dos programadores israelies del Technion, Zeev Suraski y Andi Gutmans, reescribieron el analizador sintactico (parser, en ingles) en 1997 y crearon la base del PHP3, y cambiaron el nombre del lenguaje por PHP: Hypertext Preprocessor. Inmediatamente comenzaron experimentaciones publicas de PHP3, y se publico oficialmente en junio de 1998. Para 1999, Suraski y Gutmans reescribieron el codigo de PHP, y produjeron lo que hoy se conoce como motor Zend. Tambien fundaron Zend Technologies en Ramat Gan, Israel.  En mayo del 2000, PHP 4 se lanzo bajo el poder del motor Zend 1.0. El 13 de julio de 2007 se anuncio la suspension del soporte y desarrollo de la version 4 de PHP,\u200b y, a pesar de lo anunciado, se ha liberado una nueva version con mejoras de seguridad, la 4.4.8, publicada el 13 de enero del 2008, y posteriormente la version 4.4.9, publicada el 7 de agosto del 2008.\u200b Segun esta noticia,\u200b se le dio soporte a fallos criticos hasta el 9 de agosto del 2008.  El 13 de julio de 2004, se lanzo PHP 5, utilizando el motor Zend Engine 2.0 (o Zend Engine 2). Incluye todas las ventajas que provee el nuevo Zend Engine 2, como:  En abril de 2020, mas de la mitad de los sitios en la web que usaban PHP seguian en la version descontinuada\u200b 5.6 o anterior.\u200b y con la version 7.0 y 7.1 mas del 68%, que no estan oficialmente soportadas por The PHP Development Team,\u200b mientras que el soporte de seguridad es proporcionado por terceros, como Debian (hasta junio de 2020 para PHP 5).\u200b Adicionalmente, la version 7.2, la version con soporte mas popular, dejo de recibir actualizaciones de seguridad el 30 de noviembre de 2020.\u200b  El 26 noviembre del 2020 se presenta la actualizacion del lenguaje PHP a su version 8.0 que mas recursos y optimizaciones incluyendo argumentos nombrados, tipos de uniones, atributos, promocion de propiedades constructivas, expresiones match, operador nullsafe, JIT (traduccion dinamica) y tambien mejoras en el sistema de tipos, manejo de errores y consistencia en general.\u200b, esta la cual llegara a su fin en noviembre del 2023, tambien considerando que a partir de lanzamiento de php 8.2 el 8 de noviembre del a\u00f1o 2022, Wordpress que ha logrado ser compatible al dia siguiente el 9 de diciembre del 2022.\u200b seguido del Framework CodeIgniter que actualmente ha expulsado a php7.4 de sus compatibilidades en sus nuevas actualizaciones.\u200b  En enero de 2023, segun W3Techs \"PHP es utilizado por el 77,8% de todos los sitios web que se ejecutan en el lado del servidor\". Tambien informa de que solo el 8% de los usuarios de PHP utilizan las versiones 8.x actualmente soportadas.\u200b La ultima version publicada de PHP es PHP 8.2. y se preve que hasta noviembre de 2023 no habra ningun otro lanzamiento.  Se abandono la version 6 de PHP siendo la siguiente version la 7.\u200b  La sintaxis de PHP, se fundamenta en los principios de programacion de C.  El interprete de PHP solo ejecuta el codigo que se encuentra entre sus delimitadores. Los delimitadores mas comunes son <?php para abrir una seccion PHP y ?> para cerrarla. El proposito de estos delimitadores es separar el codigo PHP del resto de codigo, como por ejemplo el HTML.\u200b En los archivos que contienen solo codigo PHP, el delimitador ?> se puede omitir. De hecho, PHP-FIG a traves de sus recomendaciones estandar para PHP recomienda omitir el delimitador ?>, ya que asi no se envia contenido HTML de manera accidental. Por ejemplo, si se envia un caracter \"no PHP\" (que no es procesado por el interprete de PHP), no se podran ejecutar ciertas acciones como enviar encabezados HTTP a traves de la funcion header(), ya que el proceso de respuesta ya ha comenzado.  Las variables se prefijan con el simbolo del dolar ($) y no es necesario indicar su tipo. Las variables, a diferencia de las funciones, distinguen entre mayusculas y minusculas. Las cadenas de caracteres pueden ser encapsuladas tanto en dobles comillas como en comillas simples, aunque en el caso de las primeras, se pueden insertar variables en la cadena directamente, sin necesidad de concatenacion.  Los comentarios se pueden escribir bien con dos barras (//) al principio de la linea, o con una almohadilla (#). Tambien permite comentarios multi-linea encapsulados en /* */.  En cuanto a las palabras clave, PHP comparte con la mayoria de otros lenguajes con sintaxis C las condiciones con if, los bucles con for y while y los retornos de funciones. Habitualmente en este tipo de lenguajes, las sentencias deben acabar con punto y coma (;).  Programa Hola mundo con PHP inmerso dentro de codigo HTML:  Programa Hola mundo con PHP en forma de app monolitica:  Programa Hola mundo con PHP respondiendo en formato JSON:  El lado del cliente que realizara peticion al archivo PHP:  PHP puede combinarse con MySQL para trabajar con bases de datos, aunque tambien se pueden utilizar otros motores de base de datos como Microsoft SQL Server, PostgreSQL, MongoDB, entre otros.  El siguiente ejemplo se muestra el inicio de sesion con usuario y contrase\u00f1a utilizando MySQL y PHP con el estilo orientado a objetos:  El siguiente ejemplo hace lo mismo que el anterior, pero con la seguridad de que sea cual sea el estado medio del servicio, si no hay forma de conectar, se destruira la clase y se cerrara lo adjunto a sus hilos.   Borrese  Los servicios REST se fundamentan en tres conceptos fundamentales:  Una de las dificultades que enfrentan las empresas para actualizar a las versiones mas altas actuales de los lenguajes de programacion es la compatibilidad con el codigo existente contrastado las mejoras. Muchas veces, el codigo antiguo utiliza funciones o sintaxis que han sido modificadas o eliminadas en las nuevas versiones, lo que genera errores o incompatibilidades.\u200b Ademas, las empresas deben invertir tiempo y recursos en capacitar a sus programadores para que se adapten a los cambios y puedan aprovechar las nuevas caracteristicas y ventajas de los lenguajes actualizados.\u200b El desafio de cambiar las versiones de PHP tambien puede ser que algunas bibliotecas, complementos y extensiones utilizados en la aplicacion tambien necesiten actualizarse. Si estos no se actualizan, pueden generar conflictos o errores en la aplicacion.  XAMPP es un servidor independiente de plataforma, software libre, que consiste principalmente en la base de datos MySQL, el servidor Web Apache y los interpretes para lenguajes de script: PHP y Perl. El nombre proviene del acronimo de X (para cualquiera de los diferentes sistemas operativos), Apache, MySQL, PHP, Perl. El programa esta liberado bajo la licencia GNU y actua como un servidor Web libre, facil de usar y capaz de interpretar paginas dinamicas. Actualmente XAMPP esta disponible para Microsoft Windows, GNU/Linux, Solaris, y MacOS X.  Es un software \"liviano\" que se puede utilizar en cualquier PC. No necesita muchos recursos.  LAMP presenta una funcionalidad parecida a XAMPP, pero enfocada en Linux, WAMP lo hace enfocado en Windows, y MAMP para MacOS X. UwAmp es muy identico a WAMP y se destaca en que se puede ejecutar desde una memoria USB.  Se utiliza PHP en millones de sitios; entre los mas destacados se encuentran: ","snippet":"PHP es un lenguaje de programacion interpretado\u200b del lado del servidor y de uso general que se adapta especialmente al desarrollo web.\u200b Fue creado inicialmente por el programador danes-canadiense Rasm","enlaces_salientes":["PHP","PHP","PHP","PHP_(desambiguaci%C3%B3n)","PHP_Group","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_funcional","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_por_procedimientos","Reflexi%C3%B3n_(inform%C3%A1tica)","Rasmus_Lerdorf","Sistema_de_tipos","Sistema_de_tipos#Tipado_din\u00e1mico","Tipado_fuerte#Lenguajes_no_tipados","Motor_Zend","HHVM","Phalanger_(Compilador)","M%C3%A1quina_virtual_Parrot","Perl","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Java_(lenguaje_de_programaci%C3%B3n)","Tcl","Falcon_(lenguaje_de_programaci%C3%B3n)","Hack_(lenguaje_de_programaci%C3%B3n)","Sistema_operativo","Unix-like","Microsoft_Windows","Licencia_de_software","Licencia_PHP","Lenguaje_de_programaci%C3%B3n","Desarrollo_web","Programador","Dinamarca","Canad%C3%A1","Rasmus_Lerdorf","Implementaci%C3%B3n_de_referencia","Servidor_web","Int%C3%A9rprete_(inform%C3%A1tica)","Complemento_(inform%C3%A1tica)","Daemon_(inform%C3%A1tica)","Ejecutable","Interfaz_de_entrada_com%C3%BAn","HTML","Protocolo_de_transferencia_de_hipertexto","Sistema_de_gesti%C3%B3n_de_contenidos","Framework_para_aplicaciones_web","Interfaz_gr%C3%A1fica_de_usuario","Dron","Interfaz_de_l%C3%ADnea_de_comandos","Motor_Zend","Software_libre","Licencia_PHP","Sistema_operativo","Plataforma_(inform%C3%A1tica)","Especificaci%C3%B3n_formal","De_facto","Servidor_web","Sitio_web","Node.js","ASP.NET","Base64","Web_scraping","Teorema_de_Taylor","Macrodatos","Matriz_de_rotaci%C3%B3n","Transformada_Z","Servidor_HTTP_Apache","Servidor_HTTP_Apache","Programaci%C3%B3n_estructurada","C_(lenguaje_de_programaci%C3%B3n)","Perl","Programador","Curva_de_aprendizaje","Interfaz_gr%C3%A1fica_de_usuario","PHP-Qt","PHP-GTK","L%C3%ADnea_de_comandos","Perl","Python","P%C3%A1gina_web","Int%C3%A9rprete_(inform%C3%A1tica)","Script","PDF","Adobe_Flash","SQL","NoSQL","MySQL","PostgreSQL","Oracle_Database","Open_Database_Connectivity","DB2","Microsoft_SQL_Server","Firebird","SQLite","MongoDB","Sistema_operativo","Unix","N%C3%BAcleo_Linux","OS_X","Microsoft_Windows","Servidor_web","Interfaz_de_entrada_com%C3%BAn","Servidor_HTTP_Apache","ISAPI","Microsoft","Active_Server_Pages","ASP.NET","C_Sharp","Visual_Basic_.NET","ColdFusion","Adobe","JavaServer_Pages","Java_(lenguaje_de_programaci%C3%B3n)","Interfaz_de_entrada_com%C3%BAn","Perl","Node.js","Javascript","GNU","Zend_Studio","CodeGear","Borland","Eclipse_(software)","Perl","Interfaz_de_entrada_com%C3%BAn","C_(lenguaje_de_programaci%C3%B3n)","Programador","Rasmus_Lerdorf","Curr%C3%ADculum_v%C3%ADtae","Israel","Technion","Zeev_Suraski","Andi_Gutmans","Analizador_sint%C3%A1ctico","Idioma_ingl%C3%A9s","Motor_Zend","Zend_Technologies","Ramat_Gan","Israel","Motor_Zend","Programaci%C3%B3n_orientada_a_objetos","MySQL","Extensible_Markup_Language","SQLite","Simple_Object_Access_Protocol","Iterador_(patr%C3%B3n_de_dise%C3%B1o)","Manejo_de_excepciones","Oracle_Database","Debian_GNU/Linux","2020","Wordpress","Framework","Interfaz_de_l%C3%ADnea_de_comandos","Interfaz_de_entrada_com%C3%BAn","JSON","GOTO","Clausura_(inform%C3%A1tica)","Microsoft_Windows","MySQL","Multipurpose_Internet_Mail_Extensions","Trait","Sintaxis","Programaci%C3%B3n","C","HTML","Barra_(tipograf%C3%ADa)","Almohadilla","Hola_mundo","HTML","Hola_mundo","Hola_mundo","MySQL","Microsoft_SQL_Server","PostgreSQL","MongoDB","Transferencia_de_Estado_Representacional","API","Aplicaci%C3%B3n_web","Base_de_datos","Ejecutable","Php_arrays","Navegador_web","MySQL","PostgreSQL","Software_libre","Programaci%C3%B3n_orientada_a_objetos","Tiempo_de_ejecuci%C3%B3n","Manejo_de_excepciones","Patr%C3%B3n_de_dise%C3%B1o","Modelo_Vista_Controlador","L%C3%B3gica_de_control","Interfaz_de_usuario","Ofuscaci%C3%B3n","Cach%C3%A9_(inform%C3%A1tica)","LAMP","Squid_(programa)","XAMPP","Servidor_HTTP_Apache","LAMP","WAMP","MAMP","Digg","Facebook","Flickr","Mailchimp","Tumblr","WordPress","Yahoo!","P%C3%A1gina_web","P%C3%A1gina_web_din%C3%A1mica","MySQL","Active_Server_Pages","ASP.NET","GNU/Linux","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Open_Hub"]}
{"url":"Programaci%C3%B3n_orientada_a_objetos","titulo":"Programacion orientada a objetos","contenido":"La programacion orientada a objetos (POO, en espa\u00f1ol); es un paradigma de programacion que parte del concepto de \"objetos\" como base, los cuales contienen informacion en forma de campos (a veces tambien referidos como atributos o propiedades) y codigo en forma de metodos.  Los objetos son capaces de interactuar y modificar los valores contenidos en sus campos o atributos (estado) a traves de sus metodos (comportamiento).\u200b  Muchos de los objetos predise\u00f1ados de los lenguajes de programacion actuales permiten la agrupacion en bibliotecas o librerias, sin embargo, muchos de estos lenguajes permiten al usuario la creacion de sus propias bibliotecas.  Algunas caracteristicas clave de la programacion orientada a objetos son herencia, cohesion, abstraccion, polimorfismo, acoplamiento y encapsulamiento.  Su uso se popularizo a principios de la decada de 1990. En la actualidad, existe una gran variedad de lenguajes de programacion que soportan la orientacion a objetos, estando la mayoria de estos basados en el concepto de clases e instancias.  Los objetos son entidades que tienen un determinado estado, comportamiento e identidad:  La programacion orientada a objetos difiere de la programacion estructurada tradicional, en la que los datos y los procedimientos estan separados y sin relacion, ya que lo unico que se busca es el procesamiento de unos datos de entrada para obtener otros de salida. La programacion estructurada prima el concepto de procedimientos o funciones sobre el de estructuras (se emplean principalmente funciones que procesan datos). La programacion orientada a objetos, en cambio, primero se definen los objetos o estructuras para posteriormente solicitar la ejecucion de sus metodos.  Los conceptos de la POO tienen origen en Simula 67, un lenguaje dise\u00f1ado para hacer simulaciones, creado por Ole-Johan Dahl y Kristen Nygaard, del Centro de Computo Noruego en Oslo. En este centro se trabajaba en simulaciones de naves, que fueron confundidas por la explosion combinatoria de como las diversas cualidades de diferentes naves podian afectar unas a las otras. La idea surgio al agrupar los diversos tipos de naves en diversas clases de objetos, siendo responsable cada clase de objetos de definir sus \"propios\" datos y comportamientos. Fueron refinados mas tarde en Smalltalk, desarrollado en Simula en Xerox PARC (cuya primera version fue escrita sobre Basic) pero dise\u00f1ado para ser un sistema completamente dinamico en el cual los objetos se podrian crear y modificar \"sobre la marcha\" (en tiempo de ejecucion) en lugar de tener un sistema basado en programas estaticos.  La POO se fue convirtiendo en el estilo de programacion dominante a mediados de los a\u00f1os 1980, en gran parte debido a la influencia de C++, una extension del lenguaje de programacion C. Su dominacion fue consolidada gracias al auge de las interfaces graficas de usuario, para las cuales la POO esta particularmente bien adaptada. En este caso, se habla tambien de programacion dirigida por eventos.  Las caracteristicas de orientacion a objetos fueron agregadas a muchos lenguajes existentes durante ese tiempo, incluyendo Ada, BASIC, Lisp mas Pascal, entre otros. La adicion de estas caracteristicas a los lenguajes que no fueron dise\u00f1ados inicialmente para ellas condujo a menudo a problemas de compatibilidad y en la capacidad de mantenimiento del codigo. Los lenguajes orientados a objetos \"puros\", por su parte, carecian de las caracteristicas de las cuales muchos programadores habian venido a depender. Para saltar este obstaculo, se hicieron muchas tentativas para crear nuevos lenguajes basados en metodos orientados a objetos, pero permitiendo algunas caracteristicas imperativas de maneras \"seguras\". El lenguaje de programacion Eiffel de Bertrand Meyer fue un temprano y moderadamente acertado lenguaje con esos objetivos, pero ahora ha sido esencialmente reemplazado por Java, en gran parte debido a la aparicion de Internet y a la implementacion de la maquina virtual Java en la mayoria de navegadores web. PHP en su version 5 se ha modificado; soporta una orientacion completa a objetos, cumpliendo todas las caracteristicas propias de la orientacion a objetos.  La terminologia \"objetos\" y \"orientada\" en el sentido moderno de la programacion orientada a objetos hizo su primer aparicion en el MIT a finales del 1950s y principio de 1960s. Ya en 1960 en el entorno del grupo de inteligencia artificial, el termino \"objeto\" era usado para referirse a elementos (LISP atomos) con propiedades (atributos);\u200b\u200b  Otro ejemplo temprano de programacion orientada en el MIT fue Sketchpad creado por Ivan Sutherland en 1960\u20131961; en el glosario del informe tecnico de 1963, Sutherland define la nocion de \"objeto\" y de \"instancia\".  Simula introdujo conceptos importantes que hoy en dia son una parte esencial de la programacion orientada a objetos, como clases, objetos, herencia y dynamic binding.\u200b  Mas recientemente ha surgido una serie de lenguajes que estan principalmente orientados a objetos pero que tambien son compatibles con la programacion procedural. Dos ejemplos de estos lenguajes son Python y Ruby. Probablemente los lenguajes orientados a objetos recientes con mas importancia comercialmente son Java, desarrollado por Sun Microsystems y C# junto a Visual Basic.NET (VB.NET), dise\u00f1ado por Microsoft's.  La POO es una forma de programar que trata de encontrar una solucion a estos problemas. Introduce nuevos conceptos, que superan y amplian conceptos antiguos ya conocidos. Entre ellos destacan los siguientes:  En comparacion con un lenguaje imperativo, una \"variable\" no es mas que un contenedor interno del atributo del objeto o de un estado interno, asi como la \"funcion\" es un procedimiento interno del metodo del objeto.  Existe un acuerdo acerca de que caracteristicas contempla la \"orientacion a objetos\". Las caracteristicas siguientes son las mas importantes:\u200b  Cabe destacar que para que un lenguaje se pueda tratar como orientado a objetos, debe cumplir que:  El paradigma POO ha sido criticado por varias razones, incluyendo no cumplir con las metas de reusabilidad y modularidad,\u200b\u200b y por sobreenfatizar un aspecto de dise\u00f1o y modelacion de software (datos/objetos) a expensas de otros aspectos importantes (computacion/algoritmos).\u200b\u200b  La POO es un paradigma surgido en los a\u00f1os 1970, que utiliza objetos como elementos fundamentales en la construccion de la solucion. Un objeto es una abstraccion de algun hecho o ente del mundo real, con atributos que representan sus caracteristicas o propiedades, y metodos que emulan su comportamiento o actividad. Todas las propiedades y metodos comunes a los objetos se encapsulan o agrupan en clases. Una clase es una plantilla, un prototipo para crear objetos; en general, se dice que cada objeto es una instancia o ejemplar de una clase.  Para realizar programacion orientada a objetos existen 3 corrientes principales:\u200b\u200b  Simula (1967) es aceptado como el primer lenguaje que posee las caracteristicas principales de un lenguaje orientado a objetos. Fue creado para hacer programas de simulacion, en donde los \"objetos\" son la representacion de la informacion mas importante.  Smalltalk (1972 a 1980) es posiblemente el ejemplo canonico, y con el que gran parte de la teoria de la programacion orientada a objetos se ha desarrollado.  Entre los lenguajes orientados a objetos se destacan los siguientes:    Muchos de estos lenguajes de programacion no son puramente orientados a objetos, sino que son hibridos que combinan la POO con otros paradigmas.  Al igual que C++, otros lenguajes, como OOCOBOL, OOLisp, OOProlog y Object REXX, han sido creados a\u00f1adiendo extensiones orientadas a objetos a un lenguaje de programacion clasico.  Un nuevo paso en la abstraccion de paradigmas de programacion es la Programacion Orientada a Aspectos (POA). Aunque es todavia una metodologia en estado de maduracion, cada vez atrae a mas investigadores e incluso proyectos comerciales en todo el mundo. ","snippet":"La programacion orientada a objetos (POO, en espa\u00f1ol); es un paradigma de programacion que parte del concepto de \"objetos\" como base, los cuales contienen informacion en forma de campos (a veces tambi","enlaces_salientes":["Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_orientada_a_objetos","Idioma_espa%C3%B1ol","Paradigma_de_programaci%C3%B3n","Objeto_(programaci%C3%B3n)","Campo_(inform%C3%A1tica)","M%C3%A9todo_(programacion_orientada_a_objetos)","Lenguajes_de_programaci%C3%B3n","Herencia_(inform%C3%A1tica)","Cohesi%C3%B3n_(inform%C3%A1tica)","Abstracci%C3%B3n_(inform%C3%A1tica)","Polimorfismo_(inform%C3%A1tica)","Acoplamiento_(inform%C3%A1tica)","Encapsulamiento_(inform%C3%A1tica)","D%C3%A9cada_de_1990","Lenguajes_de_programaci%C3%B3n","Clase_(programacion_orientada_a_objetos)","Instancia_(programacion)","Variable_(programaci%C3%B3n)","Constante_(programaci%C3%B3n)","Programaci%C3%B3n_estructurada","Simula","Ole-Johan_Dahl","Kristen_Nygaard","Oslo","Smalltalk","Xerox_PARC","Basic","A%C3%B1os_1980","C%2B%2B","Lenguaje_de_programaci%C3%B3n_C","Interfaz_gr%C3%A1fica_de_usuario","Programaci%C3%B3n_dirigida_por_eventos","Lenguaje_de_programaci%C3%B3n_Ada","BASIC","Lisp","Lenguaje_de_programaci%C3%B3n_Pascal","Lenguaje_de_programaci%C3%B3n_Eiffel","Java_(lenguaje_de_programaci%C3%B3n)","Internet","M%C3%A1quina_virtual_Java","Navegadores_web","PHP","Unified_Modeling_Language","MIT","Inteligencia_artificial","Sketchpad","Ivan_Sutherland","Simula","Clase_(inform%C3%A1tica)","Objeto_(programaci%C3%B3n)","Herencia_(inform%C3%A1tica)","Python","Ruby","Java_(programming_language)","Sun_Microsystems","C_Sharp","Visual_Basic.NET","Clase_(inform%C3%A1tica)","Herencia_(inform%C3%A1tica)","Objeto_(programaci%C3%B3n)","M%C3%A9todo_(programaci%C3%B3n_orientada_a_objetos)","Abstracci%C3%B3n_(programaci%C3%B3n_orientada_a_objetos)","Encapsulamiento_(programaci%C3%B3n_orientada_a_objetos)","Dise%C3%B1o_estructurado","Polimorfismo_(programaci%C3%B3n_orientada_a_objetos)","Sobrecarga","Herencia_(programaci%C3%B3n_orientada_a_objetos)","Herencia_m%C3%BAltiple","Modularidad_(programaci%C3%B3n_orientada_a_objetos)","Principio_de_ocultaci%C3%B3n","Rompecabezas","Recolecci%C3%B3n_de_basura_(programaci%C3%B3n_orientada_a_objetos)","Object_Pascal","A%C3%B1os_1970","Programaci%C3%B3n_basada_en_prototipos","Simula","Smalltalk","ABAP","ActionScript","ActionScript_3","C_Sharp","Clarion_(lenguaje_de_programaci%C3%B3n)","Clipper_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n_D","Object_Pascal","Embarcadero_Delphi","Gambas","GObject","Genie_(lenguaje_de_programaci%C3%B3n)","Compilador_Harbour","Lenguaje_de_programaci%C3%B3n_Eiffel","Fortran","Lenguaje_de_programaci%C3%B3n_Java","JavaScript","L%C3%A9xico","Objective-C","Lenguaje_de_programaci%C3%B3n_Oz","Lenguaje_de_programaci%C3%B3n_R","Pauscal","Perl","Perl_6","PHP","Processing","Python","Ruby","Self_(lenguaje_de_programaci%C3%B3n)","Smalltalk","Swift_(lenguaje_de_programaci%C3%B3n)","Magik_(lenguaje_de_programaci%C3%B3n)","Vala_(lenguaje_de_programaci%C3%B3n)","VB.NET","Visual_FoxPro","Visual_Basic","XBase%2B%2B","Lenguaje_de_programaci%C3%B3n_Scala","Object_REXX","Programaci%C3%B3n_Orientada_a_Aspectos","Base_de_datos_orientada_a_objetos","Ingenier%C3%ADa_de_software_basada_en_componentes","ISBN","Phyllis_Fox","Boston","Massachusetts","MIT_Press","ISBN","Semantic_Scholar","Digital_object_identifier","ISBN","Luca_Cardelli","ISSN","Digital_object_identifier","SAP_Business_Suite","SAP_AG","Programaci%C3%B3n_basada_en_prototipos","%C3%81rbol_(estructura_de_datos)","CPAN","Lenguaje_de_programaci%C3%B3n","Twitter","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"SQL","titulo":"SQL","contenido":"SQL (por sus siglas en ingles Structured Query Language; en espa\u00f1ol lenguaje de consulta estructurada) es un lenguaje especifico de dominio, dise\u00f1ado para administrar, y recuperar informacion de sistemas de gestion de bases de datos relacionales.\u200b Una de sus principales caracteristicas es el manejo del algebra y el calculo relacional para efectuar consultas con el fin de recuperar, de forma sencilla, informacion de bases de datos, asi como realizar cambios en ellas.  Originalmente basado en el algebra relacional y en el calculo relacional, SQL consiste en un lenguaje de definicion de datos, un lenguaje de manipulacion de datos y un lenguaje de control de datos. El alcance de SQL incluye la insercion de datos, consultas, actualizaciones y borrado, la creacion y modificacion de esquemas y el control de acceso a los datos. Tambien el SQL a veces se describe como un lenguaje declarativo, tambien incluye elementos procesales.  SQL fue uno de los primeros lenguajes comerciales para el modelo relacional de Edgar Frank Codd como se describio en su articulo de investigacion de 1970 El modelo relacional de datos para grandes bancos de datos compartidos. A pesar de no adherirse totalmente al modelo relacional descrito por Codd, paso a ser el lenguaje de base de datos mas usado.  SQL paso a ser el estandar del Instituto Nacional Estadounidense de Estandares (ANSI) en 1986 y de la Organizacion Internacional de Normalizacion (ISO) en 1987. Desde entonces, el estandar ha sido revisado para incluir mas caracteristicas. A pesar de la existencia de ambos estandares, la mayoria de los codigos SQL no son completamente portables entre sistemas de bases de datos diferentes sin otros ajustes.  Los origenes de SQL estan ligados a las bases de datos relacionales, especificamente las que residian en maquinas IBM bajo el sistema de gestion System R, desarrollado por un grupo de la IBM en San Jose, California.  Al principio fue IBM, e IBM creo SQL. SQL, originalmente un acronimo de \"Lenguaje de consulta estructurado\" (\"Structured Query Language\u201d), es un lenguaje unificado para definir, consultar, modificar y controlar los datos en una base de datos relacional. Su nombre se pronuncia oficialmente \"ess-cue-ell\" (segun el American National Standards Institute).  El modelo relacional de gestion de bases de datos fue propuesto en 1970 por el Dr. E. F. Codd en el Laboratorio de Investigacion de IBM en San Jose, California, y se desarrollo durante la decada siguiente en universidades y laboratorios de investigacion. SQL, uno de varios lenguajes que surgieron de este trabajo inicial, ahora se ha apoderado casi por completo del mundo de los lenguajes de bases de datos relacionales. Los proveedores de sistemas de administracion de bases de datos relacionales que inicialmente eligieron otros lenguajes han acudido en masa a SQL; Las organizaciones de normalizacion nacionales e internacionales han propuesto una version codificada del lenguaje.  En 1970, E. F. Codd propone el modelo relacional y asociado a este un sublenguaje de acceso a los datos basado en el calculo de predicados.\u200b Basandose en estas ideas, los laboratorios de IBM definieron el lenguaje SEQUEL (Structured English Query Language) que mas tarde fue ampliamente implementado por el sistema de gestion de bases de datos (SGBD) experimental System R, desarrollado en 1977 tambien por IBM. Sin embargo, fue Oracle quien lo introdujo por primera vez en 1979 en un producto comercial.  El SEQUEL termino siendo el predecesor de SQL, que es una version evolucionada del primero. SQL pasa a ser el lenguaje por excelencia de los diversos sistemas de gestion de bases de datos relacionales surgidos en los a\u00f1os siguientes y fue por fin estandarizado en 1986 por el ANSI, dando lugar a la primera version estandar de este lenguaje, \"SQL-86\" o \"SQL1\". Al a\u00f1o siguiente este estandar es tambien adoptado por ISO.  Sin embargo, este primer estandar no cubria todas las necesidades de los desarrolladores e incluia funcionalidades de definicion de almacenamiento que se considero suprimirlas. Asi que, en 1992, se lanzo un nuevo estandar ampliado y revisado de SQL llamado \"SQL-92\" o \"SQL2\".  En la actualidad SQL es el estandar de facto de la inmensa mayoria de los SGBD comerciales. Y, aunque la diversidad de a\u00f1adidos particulares que incluyen las distintas implementaciones comerciales del lenguaje es amplia, el soporte al estandar SQL-92 es general y muy amplio.  El ANSI SQL sufrio varias revisiones y agregados a lo largo del tiempo:  SQL es un lenguaje de acceso a bases de datos que explota la flexibilidad y potencia de los sistemas relacionales y permite asi gran variedad de operaciones.\u200b  Es un lenguaje declarativo de \"alto nivel\" o \"de no procedimiento\" que, gracias a su fuerte base teorica y su orientacion al manejo de conjuntos de registros \u2014y no a registros individuales\u2014 permite una alta productividad en codificacion y la orientacion a objetos. De esta forma, una sola sentencia puede equivaler a uno o mas programas que se utilizarian en un lenguaje de bajo nivel orientado a registros. SQL tambien tiene las siguientes caracteristicas:  Algunos de los tipos de datos basicos de SQL son:  Numeros enteros:  Numeros en punto flotante:  Fechas y tiempos  Cadena de caracteres:  Enum y set:  Binarios:  Como ya se dijo antes, y suele ser comun en los lenguajes de acceso a bases de datos de alto nivel, SQL es un lenguaje declarativo. O sea, que especifica que es lo que se quiere y no como conseguirlo, por lo que una sentencia no establece explicitamente un orden de ejecucion.  El orden de ejecucion interno de una sentencia puede afectar seriamente a la eficiencia del SGBD, por lo que se hace necesario que este lleve a cabo una optimizacion antes de su ejecucion. Muchas veces, el uso de indices acelera una instruccion de consulta, pero ralentiza la actualizacion de los datos. Dependiendo del uso de la aplicacion, se priorizara el acceso indexado o una rapida actualizacion de la informacion. La optimizacion difiere sensiblemente en cada motor de base de datos y depende de muchos factores.  Los sistemas de bases de datos modernos poseen un componente llamado optimizador de consultas. Este realiza un detallado analisis de los posibles planes de ejecucion de una consulta SQL y elige aquel que sea mas eficiente para llevar adelante la misma.  Existe una ampliacion de SQL conocida como FSQL (Fuzzy SQL, SQL difuso) que permite el acceso a bases de datos difusas, usando la logica difusa. Este lenguaje ha sido implementado a nivel experimental y esta evolucionando rapidamente.  El lenguaje de definicion de datos (en ingles Data Definition Language, o DDL), es el que se encarga de la modificacion de la estructura de los objetos de la base de datos. Incluye ordenes para modificar, borrar o definir las tablas en las que se almacenan los datos de la base de datos. Existen cuatro operaciones basicas: CREATE, ALTER, DROP y TRUNCATE.\u200b  Este comando permite crear objetos de datos, como nuevas bases de datos, tablas, vistas y procedimientos almacenados.  Este comando permite modificar la estructura de una tabla u objeto. Se pueden agregar/quitar campos a una tabla, modificar el tipo de un campo, agregar/quitar indices a una tabla, modificar un trigger, etc.  Este comando elimina un objeto de la base de datos. Puede ser una tabla, vista, indice, trigger, funcion, procedimiento o cualquier objeto que el motor de la base de datos soporte. Se puede combinar con la sentencia ALTER.  Este comando solo aplica a tablas y su funcion es borrar el contenido completo de la tabla especificada. La ventaja sobre el comando DELETE, es que si se quiere borrar todo el contenido de la tabla, es mucho mas rapido, especialmente si la tabla es muy grande. La desventaja es que TRUNCATE solo sirve cuando se quiere eliminar absolutamente todos los registros, ya que no se permite la clausula WHERE. Si bien, en un principio, esta sentencia pareceria ser DML (Lenguaje de Manipulacion de Datos), es en realidad una DDL, ya que internamente, el comando TRUNCATE borra la tabla y la vuelve a crear y no ejecuta ninguna transaccion.  El lenguaje de manipulacion de datos (Data Manipulation Language, o DML en ingles) es el que permite a los usuarios llevar a cabo las tareas de consulta o manipulacion de los datos, organizados por el modelo de datos adecuado.\u200b En SQL incluye ordenes para seleccionar, insertar, actualizar y borrar los datos. Existen cuatro operaciones basicas: SELECT, INSERT, UPDATE y DELETE.  La sentencia SELECT nos permite consultar los datos almacenados en una tabla de la base de datos.    Cuando se pone la palabra clave ALL Indica que queremos seleccionar todos los valores, es decir que genere un multiconjunto o bolsa en lugar de un conjunto. Es el valor por defecto y no suele especificarse casi nunca. Cuando se pone la palabra clave DISTINCT Indica que queremos seleccionar solo los valores distintos. El resultado es un conjunto en lugar de un multiconjunto o bolsa.  Ejemplo:  Para formular una consulta a la tabla coches y recuperar los campos matricula, marca, modelo, color, numero_kilometros, num_plazas debemos ejecutar la siguiente consulta. Los datos seran devueltos ordenados por marca y por modelo en orden ascendente, de menor a mayor. La palabra clave FROM indica que los datos seran recuperados de la tabla Coches.  Ejemplo de consulta simplificada a traves de un comodin de campos (*):  El uso del asterisco indica que queremos que la consulta devuelva todos los campos que existen en la tabla y los datos seran devueltos ordenados por marca y por modelo.  La clausula WHERE es la instruccion que nos permite filtrar el resultado de una sentencia SELECT. Habitualmente no deseamos obtener toda la informacion existente en la tabla, sino que queremos obtener solo la informacion que nos resulte util en ese momento. La clausula WHERE filtra los datos antes de ser devueltos por la consulta. Cuando en la Clausula WHERE queremos incluir un tipo texto, debemos incluir el valor entre comillas simples.  Ejemplos:  En nuestro ejemplo, se desea consultar un coche en concreto, para esto se agrego una clausula WHERE. Esta clausula especifica una o varias condiciones que deben cumplirse para que la sentencia SELECT devuelva los datos. En este caso la consulta devolvera solo los datos del coche con matricula para que la consulta devuelva solo los datos del coche con matricula MF-234-ZD o bien la matricula FK-938-ZL . Se puede utilizar la clausula WHERE solamente, o en combinacion con tantas condiciones como queramos.  Una condicion WHERE puede ser negada a traves del Operador Logico NOT. La Siguiente consulta devolvera todos los datos de la tabla Coches, menos el que tenga la Matricula MF-234-ZD.  La siguiente consulta utiliza la condicional DISTINCT, la cual nos devolvera la tabla generada al seleccionar unicamente los campos marca y modelo de cada registro, eliminando los renglones repetidos. Dicho de otra manera, el conjunto de modelos de cada marca que hay en coches.  Si se omitese DISTINCT o se usase ALL la tabla generada tendria renglones repetidos porque pueden haber vaios coches de la misma marca y modelo pero con distinta matricula. En ese caso el resultado seria un multiconjunto donde cada renglon con los campos marca y modelo en la respuesta corresponde a alguna matricula de la tabla coches que no se muestra en la respuesta.    La clausula ORDER BY es la instruccion que nos permite especificar el orden en el que seran devueltos los datos. Podemos especificar el orden de forma ascendente o descendente a traves de las palabras clave ASC y DESC. El orden depende del tipo de datos que esten definidos en la columna, de forma que un campo numerico sera ordenado como tal, y un alfanumerico se ordenara de la A a la Z, aunque su contenido sea numerico. El valor predeterminado es ASC si no se especifica al hacer la consulta.  Ejemplos:   Este ejemplo, selecciona todos los campos matricula, marca, modelo, color, numero_kilometros y num_plazas de la tabla coches, ordenandolos por los campos marca y modelo, marca en forma ascendente y modelo en forma descendente. Este ejemplo, selecciona todos los campos matricula, marca, modelo, color, numero_kilometros y num_plazas de la tabla coches, ordenandolos por el campo marca, ya que aparece en segundo lugar dentro de la lista de campos que componen la SELECT.  Una subconsulta es una sentencia SELECT que esta embebida en una clausula de otra sentencia SQL. Tambien pueden utilizarse subconsultas en los comandos INSERT, UPDATE, DELETE y en la clausula FROM.\u200b  Las subconsultas pueden resultar utiles si necesitas seleccionar filas de una tabla con una condicion que depende de los datos de la propia tabla o de otra tabla.  La subconsulta (consulta interna), se ejecuta antes de la consulta principal; el resultado de la subconsulta es utilizado por la consulta principal (consulta externa).  En este ejemplo, se seleccionan las matriculas y los modelos de los coches cuyas multas superan los u$s 100.  Una sentencia INSERT de SQL agrega uno o mas registros a una (y solo una) tabla en una base de datos relacional.  Las cantidades de columnas y valores deben ser iguales. Si una columna no se especifica, le sera asignado el valor por omision. Los valores especificados (o implicitos) por la sentencia INSERT deberan satisfacer todas las restricciones aplicables. Si ocurre un error de sintaxis o si alguna de las restricciones es violada, no se agrega la fila y se devuelve un error.  Cuando se especifican todos los valores de una tabla, se puede utilizar la sentencia acortada:  Ejemplo (asumiendo que 'nombre' y 'numero' son las unicas columnas de la tabla 'agenda_telefonica'):  Una caracteristica de SQL (desde SQL-92) es el uso de constructores de filas para insertar multiples filas a la vez, con una sola sentencia SQL:  Esta caracteristica es soportada por DB2, PostgreSQL (desde la version 8.2), MySQL, y H2.  Ejemplo (asumiendo que nombre y numero son las unicas columnas en la tabla agenda_telefonica):  Que podia haber sido realizado por las sentencias  Notar que las sentencias separadas pueden tener semantica diferente (especialmente con respecto a los triggers), y puede tener diferente rendimiento que la sentencia de insercion multiple.  Para insertar varias filas en MS SQL puede utilizar esa construccion:  Tenga en cuenta que no se trata de una sentencia SQL valida de acuerdo con el estandar SQL (SQL: 2003), debido a la clausula subselect incompleta.  Para hacer lo mismo en Oracle se usa la Tabla DUAL, siempre que se trate de solo una simple fila:  Una implementacion conforme al estandar de esta logica se muestra el siguiente ejemplo, o como se muestra arriba (no aplica en Oracle):  Un INSERT tambien puede utilizarse para recuperar datos de otros, modificarla si es necesario e insertarla directamente en la tabla. Todo esto se hace en una sola sentencia SQL que no implica ningun procesamiento intermedio en la aplicacion cliente. Un SUBSELECT se utiliza en lugar de la clausula VALUES. El SUBSELECT puede contener la sentencia JOIN, llamadas a funciones, y puede incluso consultar en la misma TABLA los datos que se inserta. Logicamente, el SELECT se evalua antes que la operacion INSERT este iniciada. Un ejemplo se da a continuacion.  Una variacion es necesaria cuando algunos de los datos de la tabla fuente se esta insertando en la nueva tabla, pero no todo el registro. (O cuando los esquemas de las tablas no son iguales.)  El SELECT produce una tabla (temporal), y el esquema de la tabla temporal debe coincidir con el esquema de la tabla donde los datos son insertados.  Una sentencia UPDATE de SQL es utilizada para modificar los valores de un conjunto de registros existentes en una tabla.  Una sentencia DELETE de SQL borra uno o mas registros existentes en una tabla.  Los dise\u00f1adores de base de datos que usan una clave suplente como la clave principal para cada tabla, se ejecutara en el ocasional escenario en el que es necesario recuperar automaticamente la base de datos, generando una clave primaria de una sentencia SQL INSERT para su uso en otras sentencias SQL. La mayoria de los sistemas no permiten sentencias SQL INSERT para retornar fila de datos. Por lo tanto, se hace necesario aplicar una solucion en tales escenarios.  Implementaciones comunes incluyen:  Los disparadores, tambien conocidos como desencadenantes (triggers en ingles) son definidos sobre la tabla en la que opera la sentencia INSERT, y son evaluados en el contexto de la operacion. Los desencadenantes BEFORE INSERT permiten la modificacion de los valores que se insertaran en la tabla. Los desencadenantes AFTER INSERT no puede modificar los datos de ahora en adelante, pero se puede utilizar para iniciar acciones en otras tablas, por ejemplo para aplicar mecanismos de auditoria Excel.  Los sistemas de gestion de base de datos con soporte SQL mas utilizados son, por orden alfabetico:  El lenguaje de consultas de los diferentes sistemas de gestion de bases de datos son incompatibles entre ellos y no necesariamente siguen completamente el estandar. En particular, la sintaxis de fecha y tiempo, la concatenacion de cadenas, nulas, y la comparacion de textos en cuanto al tratamiento de mayusculas y minusculas varian de un proveedor a otro. Una excepcion particular es PostgreSQL, que se esfuerza por lograr el cumplimiento del estandar.\u200b  Las implementaciones populares de SQL omiten comunmente soporte para funciones basicas de SQL estandar, como la de los tipos de dato DATE o TIME. Es el caso del manejador de bases de datos de Oracle (cuyo tipo DATE se comporta como DATETIME, y carece de un tipo TIME)\u200b y MS SQL Server (antes de la version de 2008). Como resultado, el codigo SQL rara vez puede ser portado entre los sistemas de base de datos sin modificaciones.  Hay varias razones para esta falta de portabilidad entre sistemas de bases de datos:  El estandar ODBC (Open Database Connectivity) permite acceder a la informacion desde cualquier aplicacion independientemente del sistema de gestion de base de datos (DBMS) en el que este almacenada la informacion, desacoplando asi la aplicacion de la base de datos.   ","snippet":"SQL (por sus siglas en ingles Structured Query Language; en espa\u00f1ol lenguaje de consulta estructurada) es un lenguaje especifico de dominio, dise\u00f1ado para administrar, y recuperar informacion de siste","enlaces_salientes":["SQL","SQL","SQL","IBM","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Sistema_de_tipos","Tipado_est%C3%A1tico","Tipado_fuerte","Language_Integrated_Query","Windows_PowerShell","Sistema_operativo","Multiplataforma","IBM","Extensi%C3%B3n_de_archivo","Multipurpose_Internet_Mail_Extensions","Fases_del_desarrollo_de_software","L%C3%B3gica_de_primer_orden","Est%C3%A1ndar_internacional","Formato_abierto","Idioma_ingl%C3%A9s","Idioma_espa%C3%B1ol","Lenguaje_espec%C3%ADfico_de_dominio","Sistema_de_gesti%C3%B3n_de_bases_de_datos_relacionales","%C3%81lgebra_relacional","C%C3%A1lculo_relacional","Informaci%C3%B3n","Base_de_datos","%C3%81lgebra_relacional","C%C3%A1lculo_relacional","Lenguaje_de_definici%C3%B3n_de_datos","Lenguaje_de_manipulaci%C3%B3n_de_datos","Lenguaje_de_control_de_datos","Control_de_acceso_inform%C3%A1tico","Lenguaje_declarativo","Modelo_relacional","Edgar_Frank_Codd","Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","IBM","System_R","San_Jos%C3%A9_(California)","California","IBM","IBM","IBM","San_Jos%C3%A9_(California)","California","Edgar_Frank_Codd","Modelo_relacional","Dato","IBM","SEQUEL","Sistema_de_gesti%C3%B3n_de_bases_de_datos","System_R","Oracle_Corporation","Sistema_de_gesti%C3%B3n_de_bases_de_datos","Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","Normalizaci%C3%B3n","1986","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","1989","1992","SQL-92","1999","Expresi%C3%B3n_regular","2003","Extensible_Markup_Language","2006","2008","Lenguaje_de_alto_nivel","Registro_(base_de_datos)","Lenguaje_de_programaci%C3%B3n","C%2B%2B","C_(lenguaje_de_programaci%C3%B3n)","Java_(lenguaje_de_programaci%C3%B3n)","PHP","COBOL","Pascal_(lenguaje_de_programaci%C3%B3n)","Fortran","Optimizador_de_consultas","FSQL","Base_de_datos","L%C3%B3gica_difusa","Procedimiento_almacenado","Campo_(base_de_datos)","Trigger_(base_de_datos)","Vista_(base_de_datos)","%C3%8Dndice_(base_de_datos)","Trigger_(base_de_datos)","Multiconjunto","Multiconjunto","Conjunto","Multiconjunto","Fila_(base_de_datos)","Tabla_DUAL","Sentencia_JOIN_en_SQL","Identificador_%C3%BAnico_global","PHP","MySQL","Oracle_Corporation","PL/SQL","PostgreSQL","Trigger_(base_de_datos)","Sistema_de_gesti%C3%B3n_de_bases_de_datos","DB2","Firebird","HSQL","Informix","InterBase","MariaDB","Microsoft_SQL_Server","MySQL","Oracle","PostgreSQL","PervasiveSQL","SQLite","Adaptive_Server_Enterprise","Sistema_de_gesti%C3%B3n_de_bases_de_datos","PostgreSQL","Oracle_Database","%C3%8Dndice_(base_de_datos)","Retrocompatibilidad","Open_Database_Connectivity","Sistema_de_gesti%C3%B3n_de_bases_de_datos","AQL","FSQL","Lenguaje_de_definici%C3%B3n_de_datos","Modelo_de_base_de_datos","Inyecci%C3%B3n_SQL","ISBN","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"ISO","titulo":"Organizacion Internacional de Normalizacion","contenido":"La Organizacion Internacional de Normalizacion (llamada en ocasiones: Organizacion Internacional de Estandarizacion; conocida por el acronimo ISO) es una organizacion para la creacion de estandares internacionales compuesta por diversas organizaciones nacionales de normalizacion.  Fundada el 23 de febrero de 1947, la organizacion promueve el uso de estandares privativos, industriales y comerciales a nivel mundial. Su sede esta en Ginebra (Suiza)\u200b y hasta 2015 trabajaba en 196 paises.\u200b  La Organizacion Internacional de Normalizacion (ISO) es una organizacion independiente y no-gubernamental formada por las organizaciones de normalizacion de sus 167 paises miembros. Es el mayor desarrollador mundial de estandares internacionales voluntarios y facilita el comercio mundial al proporcionar estandares comunes entre paises. Se han establecido cerca de veinte mil estandares cubriendo desde productos manufacturados y tecnologia a seguridad alimenticia, agricultura y sanidad.\u200b  El uso de estandares facilita la creacion de productos y servicios que sean seguros, fiables y de calidad. Los estandares ayudan a los negocios a aumentar la productividad a la vez que minimizan los errores y el gasto. Al permitir comparar directamente productos de diferentes fabricantes, facilita que nuevas compa\u00f1ias puedan entrar en nuevos mercados y ayudar en el desarrollo de un comercio global con bases justas. Los estandares tambien sirven para proteger a los consumidores y usuarios finales de productos y servicios, asegurando que los productos certificados se ajusten a los minimos normalizados internacionalmente.\u200b  Los tres idiomas oficiales de ISO son ingles, frances y ruso.\u200b El nombre de la organizacion en frances es Organisation internationale de normalisation, International Organization for Standardization en ingles y \u041c\u0435\u0436\u0434\u0443\u043d\u0430\u0440\u043e\u0434\u043d\u0430\u044f \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u0438\u0437\u0430\u0446\u0438\u0438 en ruso. Segun ISO, debido a que su nombre en diferentes idiomas tendria diferentes siglas (\"IOS\" en ingles, \"OIN\" en frances, etc.), la organizacion adopto \"ISO\" como sus siglas en referencia a la palabra griega isos (\u03c3\u03bf\u03c2, traducido como igual)\u200b Sin embargo, durante las reuniones fundacionales de la nueva organizacion, esta palabra nunca fue mencionada, asi que esta explicacion podria haber sido imaginada posteriormente.\u200b  Tanto el nombre \"ISO\" como el logo son marcas registradas, y su uso esta restringido.\u200b  La organizacion conocida hoy en dia como ISO nacio en 1926  como la Federacion Internacional de Asociaciones de Estandarizacion Nacionales (ISA). Fue suspendida en 1942\u200b durante la Segunda Guerra Mundial, pero tras la guerra se le propuso por parte del Comite Coordinador de Estandares de las Naciones Unidas (UNSCC) formar un nuevo cuerpo de estandares globales.\u200b En octubre de 1946, delegados de ISA y de UNSCC de 25 paises se reunieron en Londres y decidieron unir fuerzas para crear la nueva Organizacion Internacional de Normalizacion; la nueva organizacion comenzaria oficialmente a operar en febrero de 1947.\u200b  ISO es una organizacion voluntaria cuyos miembros son autoridades reconocidas en normalizacion, cada uno representando a un pais. Los miembros se reunen anualmente en la Asamblea General para discutir los objetivos estrategicos de ISO. La organizacion esta coordinada por un Secretariado Central con sede en Ginebra.\u200b  Un Consejo rotativo de 20 miembros proporcionan guia y gobierno, incluyendo el establecimiento de los presupuestos anuales del Secretariado Central.\u200b\u200b  La Junta de Administracion Tecnica es la responsable de cerca de 250 comites tecnicos, quienes desarrollan los estandares ISO.\u200b\u200b\u200b\u200b  ISO ha formado varios comites conjuntos con la Comision Electrotecnica Internacional (IEC) para desarrollar estandares y la terminologia relacionados con areas de tecnologia electrica y electronica.  El Comite Conjunto Tecnico ISO/IEC 1 (JTC 1) fue creado en 1987 para \"desarrollar, mantener, promover y facilitar los estandares relacionados con la Tecnologia de la Informacion\".\u200b  El Comite Conjunto Tecnico ISO/IEC 2 (JTC 2) se creo en 2009 con el proposito de \u00abnormalizar el campo de la eficiencia energetica y las fuentes de energias renovables\u00bb.\u200b  ISO tiene 167 paises miembros,\u200b de un total de 206 paises en el mundo.  ISO tiene tres categorias de miembros:\u200b  Los miembros participantes son llamados miembros \"P\", en contraposicion a los miembros observadores, que son llamados miembros \"O\".  ISO esta financiada por una combinacion de:\u200b  Los principales productos de ISO son sus estandares internacionales. ISO tambien publica informes tecnicos, especificaciones tecnicas, especificaciones disponibles publicamente, erratas tecnicas, y guias.\u200b\u200b  Son metaestandares que cubren \u00abmaterias relacionadas con la normalizacion internacional\u00bb.\u200b Son nombradas utilizando el formato \"ISO[/IEC]Guide N:yyyy: Titulo\"Por ejemplo:  Un estandar publicado por ISO/IEC es la ultima etapa en un largo proceso que normalmente comienza con la propuesta de un nuevo trabajo en un comite. Aqui se presentan algunas abreviaturas usadas para marcar un estandar cuando esta en este estado:\u200b\u200b\u200b\u200b\u200b\u200b\u200b  Abreviaturas usadas para enmiendas:\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b  Otras abreviaturas:\u200b\u200b\u200b\u200b  Los Estandares Internacionales son desarrollados por los comites tecnicos de ISO (TC) y subcomites (SC) por un proceso con seis etapas:\u200b\u200b  Los TC y SC pueden establecer grupos de trabajo (WG) de expertos para la preparacion de borradores de trabajo. Los Subcomites pueden tener varios grupos de trabajo, los cuales a su vez pueden tener varios Subgrupos (SG).\u200b  Es posible omitir ciertas etapas, si hay algun documento con un cierto grado de madurez al principio del proyecto de normalizacion, por ejemplo un estandar desarrollado por otra organizacion. Las directrices de ISO/IEC tambien permiten el llamado \"Procedimiento abreviado\". En este procedimiento el documento es enviado directamente para aprobacion como un Borrador de Estandar Internacional (DIS) a los cuerpos miembros de ISO o como un Borrador Final de Estandar Internacional (FDIS) si el documento fue desarrollado por un cuerpo internacional de normalizacion reconocido por el Consejo de ISO.\u200b  El primer paso -una propuesta de trabajo (Nueva Proposicion)- es aprobado el subcomite o comite tecnico relevante (por ejemplo, SC29 y JTC1 respectivamente en el caso de Moving Picture Experts Group - ISO/IEC JTC1/SC29/WG11). Un grupo de trabajo (WG) de expertos es establecido por el TC/SC para la preparacion de un borrador de trabajo. Cuando el objetivo de un nuevo trabajo esta lo suficientemente claro, alguno de los grupos de trabajo (por ejemplo, MPEG) normalmente hace una peticion abierta de proposiciones -conocido como \"peticion de propuestas\". El primer documento que es producido por ejemplo para los estandares de codificacion de audio y video es llamado un modelo de verificacion (VM) (anteriormente tambien llamado un \"modelo de simulacion y prueba\"). Cuando se alcanza la suficiente confianza en la estabilidad del estandar en desarrollo, se produce un borrador de trabajo (WD). Tiene la forma de un estandar, pero se mantiene internamente para ser revisado por el grupo de trabajo. Cuando un borrador de trabajo es lo suficientemente solido y el grupo de trabajo esta seguro que de ha desarrollado la mejor solucion tecnica para el problema tratado, este se convierte en un borrador de comite (CD). Si es necesario, es entonces cuando es enviado a los miembros P del TC/SE (los cuerpos nacionales) para votacion.  El CD pasa a ser un borrador final de comite (FCD) si el numero de votos positivos esta por encima del quorum. Varios borradores de comite pueden ser evaluados hasta que se alcance un consenso en su contenido tecnico. Cuando se alcanza, el texto es finalizado para ser enviado como un borrador de Estandar Internacional (DIS). El texto es entonces enviado a los cuerpos nacionales para votacion y ser comentado en un periodo de cinco meses. Es aprobado como un borrador final de Estandar Internacional (FDIS) si un las dos terceras partes de los miembros P del TC/SC estan a favor y no mas de un cuarto del total de votos emitidos son negativos. ISO celebrara entonces una votacion con los Cuerpos Nacionales donde no se podran proponer cambios tecnicos al texto (una votacion se si/no), en un periodo de dos meses. Es aprobado como un Estandar Internacional (IS) si las dos terceras partes de los miembros P del TC/SC estan a favor y no mas de un cuarto de los votos emitidos son negativos. Tras la aprobacion, solo se introduciran cambios menores editoriales en el texto. El texto final se envia al Secretariado Central de ISO, el cual lo publica como un Estandar Internacional.\u200b\u200b  El hecho de que muchos de los estandares creados por ISO son ubicuos ha llevado, en ocasiones, al uso de \"ISO\" para llamar al producto en si que se adecua a un estandar. Algunos ejemplos de ello son:  A excepcion de un peque\u00f1o numero de estandares aislados,\u200b los estandares ISO no estan disponibles gratuitamente,\u200b cuyo coste ha sido visto por algunos sectores como demasiado elevado para proyectos peque\u00f1os software de codigo abierto.\u200b  Los procedimientos abreviados del ISO/IEC JTC1 (usado por Office Open XML y OpenDocument) han cosechado criticas con relacion a la estandarizacion de Office Open XML. Martin Bryan, convocante del ISO/IEC JTC1/SC34 WG1, dijo al respecto:  El empresario en seguridad e inversor de Ubuntu, Mark Shuttleworth, comento en el proceso de estandarizacion de Office Open XML que \"cree que devalua la confianza de la gente en el procedimiento de creacion de estandares\" y alego que ISO no estaba llevando a cabo sus responsabilidades. Tambien se\u00f1alo que Microsoft ha presionado activamente a muchos paises que tradicionalmente no han participado en ISO y formado comites con empleados de Microsoft, proveedores de soluciones y distribuidores afines a Office Open XLM.  ISO 45001 de Seguridad y salud en el trabajo ","snippet":"La Organizacion Internacional de Normalizacion (llamada en ocasiones: Organizacion Internacional de Estandarizacion; conocida por el acronimo ISO) es una organizacion para la creacion de estandares in","enlaces_salientes":["Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","ISO_(desambiguaci%C3%B3n)","Ginebra","Suiza","Organizaci%C3%B3n_no_gubernamental","Sitio_web","Est%C3%A1ndares","Normalizaci%C3%B3n#Organismos_Nacionales_de_Normalizaci.C3.B3n","Ginebra","Suiza","Idioma_ingl%C3%A9s","Idioma_franc%C3%A9s","Idioma_ruso","Idioma_griego","Praga","Segunda_Guerra_Mundial","Londres","Ginebra","Comisi%C3%B3n_Electrot%C3%A9cnica_Internacional","ISO_3166-1","Producto_interior_bruto","Errata","Comisi%C3%B3n_Electrot%C3%A9cnica_Internacional","Moving_Picture_Experts_Group","Imagen_de_disco_%C3%B3ptico","Extensi%C3%B3n_de_archivo","Imagen_ISO","ISO_9660","CD-ROM","Disco_Compacto","DVD-ROM","Escala_de_sensibilidad_fotogr%C3%A1fica","Flash_(fotograf%C3%ADa)","Software_de_c%C3%B3digo_abierto","Office_Open_XML","OpenDocument","Ubuntu_(sistema_operativo)","Mark_Shuttleworth","Microsoft","Cabildeo","Instituto_Argentino_de_Normalizaci%C3%B3n_y_Certificaci%C3%B3n","Instituto_Nacional_de_Normalizaci%C3%B3n_(Chile)","Asociaci%C3%B3n_Espa%C3%B1ola_de_Normalizaci%C3%B3n_y_Certificaci%C3%B3n","Instituto_Nacional_de_Calidad","Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","Associa%C3%A7%C3%A3o_Brasileira_de_Normas_T%C3%A9cnicas","Deutsches_Institut_f%C3%BCr_Normung","British_Standards_Institution","Comit%C3%A9_Europeo_de_Normalizaci%C3%B3n","GOST","International_Electrotechnical_Commission","IEEE_Standards_Association","International_Telecommunication_Union","Normalizaci%C3%B3n","Grupo_de_trabajo_de_ingenier%C3%ADa_de_internet","Ente_Nazionale_Italiano_di_Unificazione","Universidad_Purdue","ISBN","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Biblioteca_de_Catalu%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Australia","Biblioteca_Nacional_de_Israel","CiNii","Syst%C3%A8me_universitaire_de_documentation","BIBSYS","Historical_Dictionary_of_Switzerland","Enciclopedia_Brit%C3%A1nica"]}
{"url":"ANSI","titulo":"Instituto Nacional Estadounidense de Estandares","contenido":"El Instituto Nacional Estadounidense de Estandares, mas conocido como ANSI (por sus siglas en ingles: American National Standards Institute), es una organizacion sin fines de lucro que supervisa el desarrollo de estandares para productos, servicios, procesos y sistemas en los Estados Unidos.  ANSI es miembro de la Organizacion Internacional para la Estandarizacion (International Organization for Standardization, ISO) y de la Comision Electrotecnica Internacional (International Electrotechnical Commission, IEC).  La organizacion tambien coordina estandares del pais estadounidense con estandares internacionales, de tal modo que los productos de dicho pais puedan usarse en todo el mundo. Por ejemplo, los estandares aseguran que la fabricacion de objetos cotidianos, como pueden ser las camaras fotograficas, se realice de tal forma que dichos objetos puedan usar complementos fabricados en cualquier parte del mundo por empresas ajenas al fabricante original. De este modo, y siguiendo con el ejemplo de la camara fotografica, la gente puede comprar carretes para la misma independientemente del pais donde se encuentre y el proveedor del mismo.  Por otro lado, el sistema de exposicion fotografico ASA se convirtio en la base para el sistema ISO de \"velocidad de pelicula\" (en ingles: film speed), el cual es ampliamente utilizado actualmente en todo el mundo.  Esta organizacion aprueba estandares que se obtienen como fruto del desarrollo de tentativas de estandares por parte de otras organizaciones, agencias gubernamentales, compa\u00f1ias y otras entidades. Estos estandares aseguran que las caracteristicas y las prestaciones de los productos son consistentes, es decir, que la gente use dichos productos en los mismos terminos y que esta categoria de productos se vea afectada por las mismas pruebas de validez y calidad.  ANSI acredita a organizaciones que realizan certificaciones de productos o de personal de acuerdo con los requisitos definidos en los estandares internacionales. Los programas de acreditacion ANSI se rigen de acuerdo a directrices internacionales en cuanto a la verificacion gubernamental y a la revision de las validaciones.  En la ciudad de Washington D.\u00a0C. esta ubicada la sede de la organizacion.  Aunque el propio ANSI no elabora normas, el Instituto supervisa el desarrollo y el uso de las normas mediante la acreditacion de los procedimientos de las organizaciones de elaboracion de normas. La acreditacion de ANSI significa que los procedimientos utilizados por las organizaciones de desarrollo de normas cumplen con los requisitos del instituto en cuanto a apertura, equilibrio, consenso y debido proceso.  El ANSI tambien designa normas especificas como Normas Nacionales Americanas, o ANS, cuando el Instituto determina que las normas se desarrollaron en un entorno equitativo, accesible y que responde a los requisitos de las distintas partes interesadas.\u200b  Las normas de consenso voluntario aceleran la aceptacion de los productos en el mercado, al tiempo que dejan claro como mejorar la seguridad de esos productos para proteger a los consumidores. Hay aproximadamente 9.500 normas nacionales americanas que llevan la designacion ANSI.  El proceso de las Normas Nacionales Americanas (American National Standards) implica:  La membresia ANSI comprende organismos gubernamentales, organizaciones, corporaciones, entidades academicas, internacionales e individuos. En total, el Instituto representa los intereses de mas de 125.000 empresas y 3,5 millones de profesionales.  Ademas de facilitar la formacion de normas en Estados Unidos, el ANSI promueve el uso de las normas estadounidenses a nivel internacional, defiende la politica y las posiciones tecnicas de Estados Unidos en las organizaciones internacionales y regionales de normalizacion, y fomenta la adopcion de normas internacionales como normas nacionales cuando procede.  El instituto es el representante oficial de Estados Unidos en las dos principales organizaciones internacionales de normalizacion, la Organizacion Internacional de Normalizacion (ISO), como miembro fundador,\u200b y la Comision Electrotecnica Internacional (CEI), a traves del Comite Nacional de Estados Unidos (USNC). El ANSI participa en casi todo el programa tecnico tanto de la ISO como de la CEI, y administra muchos comites y subgrupos clave. En muchos casos, las normas estadounidenses se transmiten a la ISO y la CEI, a traves del ANSI o el USNC, donde se adoptan total o parcialmente como normas internacionales.  La adopcion de normas ISO e CEI como normas estadounidenses aumento del 0,2% en 1986 al 15,5% en mayo de 2012.\u200b  En Microsoft Windows, la palabra \"ANSI\" hace referencia a las paginas de codigo ANSI de Windows. La mayoria de estos codigos tienen la mision de arreglar la anchura aunque existen algunas anchuras variables para lenguajes ideograficos. Algunos de estos codigos se acercan bastante a las series ISO_8859-1 provocando que muchos asuman de una forma equivocada que son identicos.  El Arte ASCII, el cual es coloreado o animado a partir de unos codigos de control denominados secuencias X3.64 que se reciben en un terminal ANSI, esta relacionado comunmente con el arte ANSI. Este fue muy popular en los foros a lo largo de las decadas de 1980 y 1990. ","snippet":"El Instituto Nacional Estadounidense de Estandares, mas conocido como ANSI (por sus siglas en ingles: American National Standards Institute), es una organizacion sin fines de lucro que supervisa el de","enlaces_salientes":["Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","Estados_Unidos","Estados_Unidos","Washington_D._C.","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Comisi%C3%B3n_Panamericana_de_Normas_T%C3%A9cnicas","Comisi%C3%B3n_Electrot%C3%A9cnica_Internacional","1918","Estados_Unidos","Organizaci%C3%B3n_Internacional_para_la_Estandarizaci%C3%B3n","Comisi%C3%B3n_Electrot%C3%A9cnica_Internacional","Escala_de_sensibilidad_fotogr%C3%A1fica#ASA","Sensibilidad_de_la_pel%C3%ADcula_fotogr%C3%A1fica#ISO","Washington_D._C.","1918","1928","1966","1969","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Comisi%C3%B3n_Electrot%C3%A9cnica_Internacional","Microsoft_Windows","ISO_8859-1","Arte_ASCII","Foro_(Internet)","D%C3%A9cada_de_1980","D%C3%A9cada_de_1990","Digital_object_identifier","Arte_ASCII","ANSI.SYS","Manejador_de_dispositivo","MS-DOS","C%C3%B3digo_escape_ANSI","ANSI_C","Instituto_Nacional_de_Est%C3%A1ndares_y_Tecnolog%C3%ADa","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Est%C3%A1ndar_abierto","Wayback_Machine","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_Francia","Biblioteca_de_Catalu%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Australia","Biblioteca_Nacional_de_Israel","CiNii","Syst%C3%A8me_universitaire_de_documentation","Union_List_of_Artist_Names","BIBSYS","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Natural_(lenguaje_de_programaci%C3%B3n)","titulo":"Natural (lenguaje de programacion)","contenido":"NATURAL es un lenguaje de cuarta generacion de Software AG.  Codigo del programa \u00a1Hola Mundo! en NATURAL:  Tiene la sentencia de control de flujo \"ESCAPE TOP\", la cual es similar a \"continue\" en C, o \"Continue For\" en \"Visual Basic.NET 2005\", excepto que tambien funciona dentro de una subrutina para retornar desde la misma y continuar con la siguiente iteracion del bucle de proceso.  Como \"continue\", evita gran numero de identaciones cuando se usan bloques anidados de instrucciones dentro de cualquier sentencia de tipo bucle.  Ejemplo con ESCAPE TOP:  Los niveles de sangria pueden ser ajustados automaticamente con el comando STRUCT dentro del Editor de NATURAL.  El mismo ejemplo, sin ESCAPE TOP:   ","snippet":"NATURAL es un lenguaje de cuarta generacion de Software AG.  Codigo del programa \u00a1Hola Mundo! en NATURAL:  Tiene la sentencia de control de flujo \"ESCAPE TOP\", la cual es similar a \"continue\" en C, o ","enlaces_salientes":["Natural_(lenguaje_de_programaci%C3%B3n)","Natural_(lenguaje_de_programaci%C3%B3n)","Natural_(lenguaje_de_programaci%C3%B3n)","Hola_mundo","Idioma_ingl%C3%A9s","Idioma_ingl%C3%A9s","Idioma_ingl%C3%A9s","Idioma_espa%C3%B1ol","Idioma_ingl%C3%A9s","Control_de_autoridades"]}
{"url":"PL/SQL","titulo":"PL/SQL","contenido":"PL/SQL (Procedural Language/Structured Query Language) es un lenguaje de programacion incrustado en Oracle.\u200b  PL/SQL soportara todas las consultas, ya que la manipulacion de datos que se usa es la misma que en SQL, incluyendo nuevas caracteristicas:  El lenguaje PL/SQL esta incorporado en:  En un entorno de base de datos los programadores pueden construir bloques PL/SQL para utilizarlos como procedimientos o funciones, o bien pueden escribir estos bloques como parte de scripts SQL*Plus.  Los programas o paquetes de PL/SQL se pueden almacenar en la base de datos como otro objeto, y todos los usuarios que esten autorizados tienen acceso a estos paquetes. Los programas se ejecutan en el servidor para ahorrar recursos a los clientes.  A continuacion se muestra un listado de los tipos de datos disponibles en Oracle / PLSQL. Hemos tratado de diferenciar los tipos de datos entre las versiones de Oracle 8i y Oracle 9i.  dec(p, e)  Por ejemplo: decimal(3,1) es un numero de 3 digitos y solo uno es decimal.  number(p, e)  Por ejemplo: numeric(5,2) es un numero que tiene 5 digitos antes del decimal y 2 digitos despues del decimal.  Hasta 2000 bytes en Oracle 8i/9i.  Hasta 4000 bytes en Oracle 8i/9.i  Hasta 2000 bytes en Oracle 8i/9i.  Por ejemplo: timestamp(6)  Por ejemplo: timestamp(5) with time zone  Por ejemplo: timestamp(4) with local time zone  Por ejemplo: interval year(4) to month  RRRR es la fila del bloque; FFFFF es el fichero de la base de datos.  Un identificador es un nombre que se le pone a un objeto que interviene en un programa, que puede ser variable, constante, procedimientos, excepciones, cursores... Debe tener un maximo de 30 caracteres que empiece siempre por una letra, y puede contener letras, numeros, los simbolos $, #, _, y mayusculas y minusculas indiferentemente. Los identificadores no pueden ser palabras reservadas (SELECT, INSERT, DELETE, UPDATE, DROP).  - (resta)  * (multiplicacion)  / (division)  ** (exponente)  <>,\u00a0!= (distinto de)  < (menor que)  > (mayor que)  >= (mayor o igual a)  <= (menor o igual a)  -- comentario de una linea  Las variables son nombres para procesar los elementos de los datos. Declaracion:  Ejemplos:  Tambien se puede definir una variable a partir de un campo mediante los atributos %TYPE y %ROWTYPE, con esto damos el tipo y longitud a la variable de otra variable u objeto ya definido.  %TYPE es la que se utiliza normalmente, %ROWTYPE es para claves de registro. El NOT NULL y el valor inicial no se heredan, solo el tipo de dato y longitud de ese dato.  Por ejemplo:  Las constantes son como las variables pero no puede modificarse su valor. Se declaran de la siguiente manera:  Por ejemplo, el IVA es un valor fijo, y para declararlo lo hariamos de la siguiente manera: por ejemplo,  Bloque es la unidad de estructura basica en los programas PL/SQL. Supone una mejora en el rendimiento, pues se envian los bloques completos al servidor para ser procesados en lugar de enviar cada secuencia SQL.  Partes de un bloque:  Forma de crear un bloque:  La barra \"/\" que va al final del bloque es opcional y se utiliza para verificar la sintaxis del bloque antes de que este sea ejecutado.  La sintaxis es la siguiente  Para borrar un procedimiento almacenado de la base de datos  Para utilizar un procedimiento almacenado de la base de datos  Una funcion es un bloque de codigo PL/SQL que tiene las mismas caracteristicas que un procedimiento almacenado. La diferencia estriba que una funcion devuelve un valor al retornar. Al devolver un valor puede ser llamada como parte de una expresion.  La sintaxis seria  Para borrar una funcion de la base de datos  Los procedimientos y funciones se pueden agrupar en unas estructuras llamadas Paquetes.  Se usan para agrupar procedimientos y funciones. Facilitan la descomposicion modular y el mantenimiento.  Constan de dos partes: la especificacion o prototipo y el cuerpo.  Un trigger o disparador se ejecuta ante un determinado evento de manera automatica. Generalmente se utilizan para garantizar que una determinada accion siempre se realiza despues de realizar una tarea determinada. Se debe tener cuidado con este tipo de estructuras puesto que un uso excesivo puede dar lugar a dependencias dificiles de mantener. Ademas se deben tener muy claros las restricciones de integridad para evitar problemas.  La sintaxis seria  A nivel de sentencia:  A nivel de registro:  Para eliminar un trigger: ","snippet":"PL/SQL (Procedural Language/Structured Query Language) es un lenguaje de programacion incrustado en Oracle.\u200b  PL/SQL soportara todas las consultas, ya que la manipulacion de datos que se usa es la mis","enlaces_salientes":["PL/SQL","PL/SQL","PL/SQL","Lenguaje_de_programaci%C3%B3n","1992","Lenguaje_de_programaci%C3%B3n","Oracle","SQL","Variable_(programaci%C3%B3n)","Oracle","Variable_(programaci%C3%B3n)","Constante_(programaci%C3%B3n)","Paquetes_en_PLSQL","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Desarrollador_de_software","titulo":"Desarrollador de software","contenido":"Un desarrollador es un programador o una compa\u00f1ia comercial que se dedica a uno o mas aspectos del proceso de desarrollo de software. Se trata de un ambito mas amplio de la programacion algoritmica.  En informatica, un desarrollador\u200b (al que con frecuencia tambien se conoce como analista-programador), es un especialista en informatica que es capaz de concebir y elaborar sistemas informaticos (paquetes de software), asi como de implementarlos y ponerlos a punto, utilizando uno o varios lenguajes de programacion.  El desarrollador puede contribuir a la vision general del proyecto mas a nivel de aplicacion que a nivel de componentes, asi como en las tareas de programacion individuales.  Conforme pasa el tiempo, la separacion entre el dise\u00f1o de sistemas informaticos, el desarrollo de software, y la programacion, se van haciendo mas claras y diferenciadas. En el mercado laboral suele encontrarse una diferenciacion entre programadores y desarrolladores, siendo estos ultimos los que dise\u00f1an la estructura o jerarquia de clases. Incluso esos desarrolladores se convierten en arquitectos de sistemas informaticos, o sea, aquellos que dise\u00f1an la arquitectura a varios niveles o las interacciones entre componentes de un proyecto de software grande.  El concepto de desarrollo de software incluye:  Nota: para que un programador se convierta en desarrollador, debe poseer experiencia y saber el manejo y la aplicacion de metodologias de desarrollo; es sobre todo la experiencia y el conocimiento tecnico, lo que ha impulsado la evolucion del termino 'programador' hacia el termino 'desarrollador'.  Segun el diccionario de la lengua francesa 'Larousse'\u200b y la 'Office quebecois de la langue francaise' (en espa\u00f1ol: 'Oficina quebecuense de la lengua francesa'), y aunque esto no es reconocido por el Centre national de ressources textuelles et lexicales), el termino \u00abdeveloppeur\u00bb\u200b (en espa\u00f1ol: \u00abdesarrollador\u00bb) se aplica (en el dominio de la informatica), a una persona que concibe y desarrolla aplicaciones informaticas, o una empresa organizada y orientada a desarrollar ese tipo de aplicaciones y su asociado software. Sin embargo, en el caso de las personas, es posible distinguir a los desarrolladores por especialidad y formacion, o sea, diferenciar entre los expertos en el arte del manejo, uso, y creacion de software, y los especializados particularmente en todo lo relativo a Internet y al manejo de ordenadores (sistemas operativos, programas utilitarios, etc),\u200b asi como los especializados en el sector de las Tecnologias de la informacion y la comunicacion (TICS), grupos todos estos en los que se encuentran desarrolladores con las caracteristicas que se indican seguidamente:  Para responder adecuadamente y en la mejor forma a las necesidades del cliente, conviene que en una primera etapa el desarrollador establezca un pliego de condiciones, a efectos de determinar y especificar las necesidades del cliente en materia de automatizacion, informatizacion, y control, asunto por asunto. En esta etapa, conviene que se aclaren las siguientes cuestiones:  Esta es una fase crucial puesto que no solo se debe responder a las necesidades actuales del cliente, sino tambien dise\u00f1ar un sistema informatico que acompa\u00f1ara al cliente en la evolucion de sus actividades.  En una segunda etapa se desarrolla una solucion tecnica (hardware) y se crea un modelo (analisis organico) del futuro programa (software) que gestionara el futuro sistema informatico (si no existe).  Luego se deben escribir las lineas de codigo necesarias para el correcto funcionamiento (programacion), participar en las fases de pruebas, confeccionar la documentacion tecnica, y hacer el seguimiento y el mantenimiento del producto.  El desarrollador puede tambien capacitar a los usuarios. ","snippet":"Un desarrollador es un programador o una compa\u00f1ia comercial que se dedica a uno o mas aspectos del proceso de desarrollo de software. Se trata de un ambito mas amplio de la programacion algoritmica.  ","enlaces_salientes":["Desarrollador_de_software","Desarrollador_de_software","Desarrollador_de_software","Desarrollador","Programador","Empresa","Desarrollo_de_software","Programaci%C3%B3n","Inform%C3%A1tica","Inform%C3%A1tico_te%C3%B3rico","Sistema_inform%C3%A1tico","Software","Lenguaje_de_programaci%C3%B3n","Sistemas_inform%C3%A1ticos","Metodolog%C3%ADa_de_desarrollo_de_software","Programaci%C3%B3n","Clase_(inform%C3%A1tica)","Desarrollo_de_software","Trabajo_en_equipo","Ergonom%C3%ADa","Pliego_de_condiciones","Pruebas_de_software","Error_de_software","Mantenimiento_de_software","Centre_national_de_ressources_textuelles_et_lexicales","Software","Internet","Computadora","Tecnolog%C3%ADas_de_la_informaci%C3%B3n_y_la_comunicaci%C3%B3n","Desarrollo_web","Lenguaje_de_marcado","HTML","Hoja_de_estilos_en_cascada","Extensible_Markup_Language","Pliego_de_condiciones","Ambiente_de_desarrollo_integrado","Desarrollador_de_videojuegos","Ingenier%C3%ADa_del_software","Interfaz_de_programaci%C3%B3n_de_aplicaciones","Programaci%C3%B3n","Software","Programador","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Gemeinsame_Normdatei","Art_%26_Architecture_Thesaurus"]}
{"url":"Paradigma","titulo":"Paradigma","contenido":"El concepto de paradigma es utilizado comunmente como sinonimo de \u201cejemplo\u201d o para hacer referencia a algo que se toma como \u201cmodelo\". En principio se tenia en cuenta en el campo, tema, ambito, entre dos personalidades u otros..., gramatical (para definir su uso en un cierto contexto) y se valoraba desde la retorica (para hacer mencion a una parabola o fabula). A partir de la decada de 1960, los alcances de la nocion se ampliaron y paradigma comenzo a ser un termino comun en el vocabulario cientifico y en expresiones etimologicas cuando se hacia necesario hablar de modelos de conocimiento aceptados por las comunidades cientificas.\u200b  El termino paradigma\u200b se origina en la palabra griega \u03c0\u03b1\u03c1\u03b1\u03b4\u03b5\u03b3\u03bc\u03b1 [paradeigma] que en griego antiguo significa \"modelo\" o \"ejemplo\". A su vez se divide en dos vocablos \u03c0\u03b1\u03c1\u03b1 [para] (\"junto\") y \u03b4\u03b5\u03b3\u03bc\u03b1 [deigma] (\"ejemplo\", \"patron\").\u200b Originariamente, significaba patron, modelo.  El sentido del concepto paradigma, del griego antiguo \u03c0\u03b1\u03c1\u03b1\u03b4\u03b5\u03b3\u03bc\u03b1, paradeigma (\"modelo\", \"ejemplo\"), deriva de \u03c0\u03b1\u03c1\u03b1\u03b4\u03b5\u03ba\u03bd\u03c5\u03bd\u03b1, paradeiknunai (\"demostrar\", \"probar\", \"comparar\" ), de \u03c0\u03b1\u03c1\u03b1-, para'- (\"junto\", \"alrededor\") y \u03b4\u03b5\u03ba\u03bd\u03c5\u03bc, deiknumi (\"se\u00f1alar\", \"indicar\", \"mostrar\",\u00a0\"ense\u00f1ar\").  Para Platon, los paradigmas son los modelos divinos a partir de los cuales las cosas terrestres estan hechas.\u200b A su vez tiene las mismas raices que \u00abdemostrar\u00bb.  Michel Foucault uso los terminos epistemologico, discursivo, matesis y taxinomial, para aspectos del paradigma en el sentido original dado por Kuhn.  En linguistica, Ferdinand de Saussure ha usado paradigma para referirse a una clase de elementos con similitudes.  En arquitectura, \u00abmodelo\u00bb (maqueta) o \u00abplano\u00bb de un edificio y tambien es utilizado por escultores y pintores de manera semejante.\u200b  Dentro de la enfermeria se emplea tambien el concepto paradigma aunque con cierta imprecision, ya que se establece dentro de esta disciplina la existencia de tres paradigmas de enfermeria (categorizacion, integracion y transformacion) y un metaparadigma constituido por cuatro conceptos esenciales para la enfermeria (persona, salud, entorno y cuidado).  Este concepto fue de uso especifico en la gramatica. En 1992 el diccionario Merriam\u2013Webster's Collegiate Dictionary definia su uso solamente en tal contexto, o desde la retorica para referirse a una parabola o a una fabula.  En ciencias sociales y en teoria de sistemas, el paradigma es equiparable al concepto de pensamiento de grupo\u200b -Groupthink- o su casi equivalente Mindset -mentalidad-, como cuerpos de ideas, metodos y asunciones teoricas sostenidos y validados por una persona o grupo de personas, que incluye una serie de comportamientos, actitudes y creencias.  La palabra paradigma tambien se utiliza para indicar un patron o modelo, un ejemplo fuera de toda duda, un arquetipo. En este sentido se la utiliza frecuentemente en las profesiones del dise\u00f1o. Los paradigmas de dise\u00f1o \u2014arquetipos\u2014 representan los antecedentes funcionales para las soluciones de dise\u00f1o.\u200b  Tambien se usa en cibernetica en donde \u2014en un sentido muy amplio\u2014 refiere a un preprograma conceptual para el ordenamiento de unos datos aun mas caoticos en terminos relativos.  El concepto es de amplio uso en la vida cotidiana, ya que se refiere a ideas, pensamientos, opiniones, creencias, puntos de vista, percepciones, etcetera, que se asumen como verdaderos o falsos. Incluso, el concepto de paradigma puede referirse, de manera cotidiana, a una creencia u opinion compartida colectivamente. Sin embargo, este uso del concepto puede generar diversos errores e imprecisiones, al presentarse en ambitos teoricos y cientificos, ya que se refiere practicamente a cualquier idea o creencia que tenga un sujeto o grupo de sujetos. Es recomendable no emplear este concepto en usos de la vida cotidiana, y dejarlo para discusiones de caracter epistemologico. En su lugar, cotidianamente se pueden usar cualesquiera de los conceptos arriba mencionados.  Es necesario acotar el significado del concepto paradigma siempre que este se emplee en la teorizacion epistemologica, ya que en general su significado contemporaneo dentro de la filosofia de la ciencia o epistemologia alude al conjunto de practicas y teorias que definen una disciplina cientifica en una epoca historica dada.  El filosofo e historiador de la ciencia, Thomas S. Kuhn dio a paradigma su significado contemporaneo cuando lo adopto para referirse al conjunto de practicas y saberes que definen una disciplina cientifica durante un periodo especifico. El mismo Kuhn preferia los terminos ejemplar o ciencia normal, que tienen un significado filosofico mas exacto. Sin embargo, en su libro La estructura de las revoluciones cientificas\u200b define a un paradigma de la siguiente manera:  El paradigma, de esta manera constituye el desarrollo de lo que Kuhn llama ciencia normal, y como tal se manifiesta a traves de los libros de texto propios de una ciencia o disciplina, al presentar las teorias aceptadas por las comunidades cientificas de cada disciplina, explicandolas y comparandolas, mostrandolas a traves de experimentos y observaciones. El paradigma define los metodos, los problemas que legitimamente debe abordar una disciplina o campo de investigacion, para ser legado a generaciones futuras de cientificos. De esta forma, el paradigma incluye en el plano de la investigacion cientifica lo siguiente:  En realidad este concepto de paradigma es muy amplio y se puede equiparar al concepto de matriz disciplinar o disciplina, ya que dicho concepto alude a la posesion comun por parte de los que practican una disciplina concreta (disciplinar) y matriz porque se compone de los elementos estructurados que dan sentido a las explicaciones cientificas. El paradigma es el conjunto de realizaciones de una ciencia y es compartido por los miembros de la comunidad cientifica. El papel de la comunidad cientifica de cada disciplina en el desarrollo del paradigma es clave, ya que Kuhn asume que la ciencia es una empresa humana colectiva y como tal las discusiones cientificas son producto de la comunicacion y la tarea coordinada y conjunta de los cientificos que trabajan en el desarrollo de un paradigma o disciplina a traves de sus diversas teorias y experimentos.  El paradigma en un sentido amplio, incluye aspectos ontologicos y epistemologicos fundamentales, que proporcionan el horizonte desde el cual se construyen los diferentes modelos teoricos y teorias de un nivel inferior, presentando las directrices generales de agrupamiento de las diferentes teorias en los campos disciplinares de cada ciencia.  De esta forma, dentro de la ciencia normal, un paradigma incluye el conjunto de experimentos modelicos capaces de ser copiados o emulados; siendo la base para crear un consenso cientifico. El paradigma aceptado en el consenso cientifico imperante en una epoca historica dada, establece formas de ver e interpretar la realidad, tambien abre lineas para la creacion de propuestas para la investigacion futura, las teorias y practicas derivadas del uso de un metodo cientifico y sus aplicaciones metodologicas concretas.  Un ejemplo de paradigma comunmente aceptado seria el modelo estandar de la fisica. Los metodos cientificos permitirian a los cientificos ortodoxos investigar muchos fenomenos que pueden resultar contradictorios o contrastantes con el modelo estandar. Sin embargo es mucho mas dificil obtener consenso para los mismos, en proporcion a la divergencia de los principios aceptados del modelo estandar que tales experimentos examinarian. Asi, en particular, un experimento para investigar la masa del neutrino o la descomposicion de neutrones recibiria mas fondos que un experimento que buscara violaciones a la conservacion de momentos, o pretendiera estudiar la ingenieria de los viajes en el tiempo.  Kuhn define al paradigma como \"una completa constelacion de creencias, valores y tecnicas, etc. compartidas por los miembros de una determinada comunidad\".\u200b Esta definicion aparece en 1969 como agregado a su libro original denominado La estructura de las revoluciones cientificas, porque inicialmente el uso del termino en dicha obra presentaba significados diversos. Bajo esta definicion de Kuhn subyace otro sentido en el uso del termino: \"...un paradigma tambien denota una suerte de elemento en esa constelacion, la solucion concreta del rompecabezas que, empleado como ejemplo o modelo, puede reemplazar a las reglas explicitas como base para la solucion de los rompecabezas remanentes de la ciencia normal\".\u200b El termino permanece impreciso debido a los diferentes usos que el mismo Kuhn le da a lo largo de La estructura de las revoluciones cientificas, y si bien intento precisarlo en el a\u00f1adido a la obra, continua teniendo un grado de polisemia. Sin embargo, el termino de paradigma no debe confundirse con los de teoria, marco teorico, corriente teorica, ya que el paradigma es mucho mas amplio, porque incluye la cosmovision propia de la totalidad de realizaciones de la disciplina cientifica en cada caso. Podria por lo mismo, hacerse equivalente el concepto de paradigma y disciplina o matriz disciplinar, para evitar las confusiones.  El cambio de paradigma tiende a ser drastico en las ciencias, ya que estas parecen ser estables y maduras, como la fisica a fines del siglo\u00a0XIX. En aquel tiempo la fisica aparentaba ser una disciplina que completaba los ultimos detalles de un sistema muy trabajado. Es famosa la frase de Lord Kelvin en 1900, cuando dijo: \"No queda nada por ser descubierto en el campo de la fisica actualmente. Todo lo que falta son mas medidas y mas precisas\".  Cinco a\u00f1os despues de esta aseveracion, Albert Einstein publico su trabajo relatividad especial que fijo un sencillo conjunto de reglas superando a la mecanica de Newton, que habia sido utilizada para describir la fuerza y el movimiento por mas de doscientos a\u00f1os. En este ejemplo, el nuevo paradigma reduce al viejo a un caso especial, ya que la mecanica de Newton sigue siendo una excelente aproximacion en el contexto de velocidades lentas en comparacion con la velocidad de la luz.  En La estructura de las revoluciones cientificas, Kuhn escribio que \"...las sucesivas transiciones de un paradigma a otro via alguna revolucion, es el patron de desarrollo usual de la ciencia madura\".  La idea de Kuhn era revolucionaria en su tiempo,  ya que establecio la necesidad de mirar con perspectiva historica a los desarrollos cientificos, y asumio que la ciencia es una empresa humana y como tal historica, por ende, transformable. La observacion kuhniana sobre la necesidad de mirar desde la perspectiva historica el desarrollo de la ciencia, fue en si misma un \"cambio paradigmatico\" en la historia, la sociologia y la filosofia de la ciencia.  En las ultimas tres o cuatro decadas, ademas del uso del concepto de paradigma realizado por Kuhn, otros autores como Imre Lakatos y otros han empleado dicho concepto con un sentido distinto. Cabe destacar el uso que de el ha hecho Fritjof Capra, en su obra El punto crucial Archivado el 18 de noviembre de 2016 en Wayback Machine. (The turning point). En esta obra, Capra plantea una vision amplia sobre paradigma, vinculada con los procesos historicos y civilizatorios, y su relacion con la naturaleza. Para Capra, las limitaciones civilizatorias actuales estan generando un \"cambio de paradigma\", entendiendo por paradigma la mentalidad, conceptos y sistemas de valores que forman parte de una vision particular de la realidad. Establece y describe dos grandes paradigmas: el existente o mecanicista y el que esta en formacion. El paradigma existente o mecanicista dia se ha gestado desde la antiguedad, e incluye fenomenos historicos como: la Revolucion cientifica, el Siglo de las luces, la Revolucion industrial. Incluye a nivel conceptual o cultural la idea del metodo cientifico como unico enfoque para llegar al conocimiento legitimo;  la concepcion del universo como sistema mecanico compuesto de partes elementales; la fragmentacion de la realidad y sus fenomenos; la vida social comprendida como lucha competitiva por la existencia; el crecimiento tecnologico y economico para la obtencion de progreso material ilimitado; la idea de que el crecimiento y el progreso es constante e ilimitado; la idea del modelo causa-efecto como base para las explicaciones de los fenomenos. A tal paradigma existente, contrapone otro paradigma en proceso de formacion, con caracteristicas opuestas: la posibilidad de llegar al conocimiento no solamente a traves del metodo cientifico; una vision holistica, amplia e integral de la realidad y sus fenomenos, que no fragmenta los fenomenos para conocerlos; la idea de que la civilizacion privilegia la cooperacion; la limitacion del crecimiento material y tecnologico dada la finitud de la naturaleza; una vision del mundo entendiendo a este como amalgama de sistemas complejos interdependientes e interrelacionados.  Probablemente el uso mas comun de paradigma, implique el concepto de \"cosmovision\".\u200b Por ejemplo, en ciencias sociales, el termino se usa para describir el conjunto de experiencias, creencias y valores que afectan la forma en que un individuo percibe la realidad y la forma en que responde a esa percepcion. Debe tenerse en cuenta que el mundo tambien es comprendido por el paradigma, por ello es necesario que el significado de paradigma es la forma por la cual es entendido el mundo, el hombre y por supuesto las realidades cercanas al conocimiento. Los investigadores sociales han adoptado el concepto de Kuhn \"cambio de paradigma\"\u200b para remarcar un cambio en la forma en que una determinada sociedad organiza e interpreta la realidad. Un \"paradigma dominante\" se refiere a los valores o sistemas de pensamiento hegemonicos o dominantes en una sociedad, en un momento determinado. Los paradigmas dominantes son compartidos por el trasfondo cultural de la comunidad y por el contexto historico del momento. Las siguientes son condiciones que facilitan que un sistema de pensamiento pueda convertirse en un paradigma dominante:  Al equiparar el paradigma con modelo, hablando de Ciencias Sociales, se tiene que el mismo comprende a un conjunto de caracteristicas aplicables al estudio de determinada sociedad.  Los paradigmas pueden ser descritos desde una perspectiva estructural. Operan en diferentes niveles: macro, meso y micro de la estructura paradigmatica. Los niveles direccionan mejor la estructura fundamental de los paradigmas, y no tanto su categorizacion cronologica o historica, ni su uso etimologico; como sucede en la mayoria de las disciplinas. Los niveles paradigmaticos estan siempre presentes y no se encuentran limitados por tales categorias. Permiten ademas ayudar a comprender el funcionamiento de un paradigma.\u200b  Asi, un paradigma es una vision de la realidad que conforma una Gestalt resultante de las tres ramas de la filosofia: metafisica, epistemologia y etica, de la siguiente manera:  Resulta obvio que las tres ramas de la filosofia describen la estructura de un paradigma. Ninguna de las ramas de la filosofia puede por separado completar su conocimiento, pero juntas describen la Gestalt semejante a un movimiento en espiral \u2014no un mero circulo\u2014 que constituye el conocimiento hermeneutico.  La Paralisis Paradigmatica se puede presentar en cualquier nivel de la sociedad, pero sus consecuencias son peores cuando ataca a personas que toman decisiones. No es una enfermedad fisica, mas bien es de la mente,  pero cuando se presenta suele ser muy da\u00f1ina sobre todo en personas y organizaciones expuestas a un entorno dinamico. En general, es una enfermedad facil de adquirir y a menudo fatal cuando se trata de convertir el paradigma en el paradigma unico.  Pero. \u00bfDe donde proviene esta enfermedad, muchas veces rayana en la paranoia? La palabra griega \"paradeigma\" significa \"modelo\" o patron\" y en la practica se convierte en un conjunto de reglas y disposiciones, escritas o no, que establecen o definen los limites y las formas de comportarse dentro de ellos. Se crean estructuras mentales, mitos, creencias, modelos, patrones, estereotipos que al asumirse como ciertos, resultan faciles de adoptar, y por ende influyen en el comportamiento, actitudes y percepciones de las personas.  Algunos paradigmas podran ser triviales, pero grandes o peque\u00f1os, sirven para proporcionar una vision, una comprension y metodos particulares para resolver problemas especificos. Es muy saludable tener ciertas formas de comportarse o de poseer ciertos modelos, pero en el extremo, la \"paralisis paradigmatica\", pasa a constituirse en una de las enfermedades organizacionales mas graves, la cual no permite pensar ni dudar respecto de la validez o vigencia del paradigma y podria volverse cronica.  Existen variados ejemplos de esta enfermedad entre empresarios, educadores, gobiernos, profesionales, comerciantes, politicos, cientificos, en las familias, en paises, en las religiones, etc., y eso debido a que la historia humana siempre ha estado en proceso de cambio y por ende siempre han existido paradigmas, con la unica diferencia que de anta\u00f1o ocurria un cambio cada veinticinco a\u00f1os y en la actualidad ocurren en cosa de minutos, por lo que se debe disponer de una adecuada dosis de predisposicion, entre otras, para no ser victima de esta \"paralisis paradigmatica\".  En 1492, hace mas de quinientos a\u00f1os, Cristobal Colon inicio un viaje para buscar una nueva ruta a Oriente. Basado en su creencia de que la Tierra era redonda, Colon habia notado que al observar un barco alejandose del puerto, el casco era lo primero en desaparecer en el horizonte, despues lo hacia el velamen. Los demas obviamente veian lo mismo, sin embargo como el paradigma de la epoca, era el de que la Tierra era plana, no trataron de explicarse el porque de la situacion, ya que al ser plana, el barco alejandose solo se veria mas peque\u00f1o. Unos a\u00f1os mas tarde, Hernando de Magallanes comenzo y Juan Sebastian El Cano completo la primera vuelta en barco alrededor del mundo. Se habia roto el paradigma y la correspondiente paralisis.[cita\u00a0requerida] ","snippet":"El concepto de paradigma es utilizado comunmente como sinonimo de \u201cejemplo\u201d o para hacer referencia a algo que se toma como \u201cmodelo\". En principio se tenia en cuenta en el campo, tema, ambito, entre d","enlaces_salientes":["Paradigma","Paradigma","Paradigma","Sin%C3%B3nimo","Antigua_Grecia","Griego_antiguo","Plat%C3%B3n","Arquetipo","Michel_Foucault","Ling%C3%BC%C3%ADstica","Ferdinand_de_Saussure","Arquitectura","Enfermer%C3%ADa","Filosof%C3%ADa_de_la_enfermer%C3%ADa","Metaparadigma_de_la_enfermer%C3%ADa","Gram%C3%A1tica","1992","Ret%C3%B3rica","Par%C3%A1bola_(literatura)","F%C3%A1bula","Ciencias_sociales","Teor%C3%ADa_de_sistemas","Pensamiento_de_grupo","Arquetipo","Dise%C3%B1o","Cibern%C3%A9tica","Filosof%C3%ADa_de_la_ciencia","Epistemolog%C3%ADa","Thomas_Kuhn","Disciplina_cient%C3%ADfica","La_estructura_de_las_revoluciones_cient%C3%ADficas","Experimento","Comunidad_cient%C3%ADfica","Consenso_cient%C3%ADfico","M%C3%A9todo_cient%C3%ADfico","1969","Albert_Einstein","Cambio_de_paradigma","F%C3%ADsica","Sistema","William_Thomson_Kelvin","1900","Albert_Einstein","Relatividad_especial","Velocidad_de_la_luz","Fritjof_Capra","Wayback_Machine","Revoluci%C3%B3n_de_Cop%C3%A9rnico","Ilustraci%C3%B3n","Revoluci%C3%B3n_industrial","Cosmovisi%C3%B3n","Ciencias_sociales","Creencias","Ciencias_Sociales","Plat%C3%B3n","Arist%C3%B3teles","Ontolog%C3%ADa","Heidegger","S%C3%B3crates","%C3%89tica","Psicolog%C3%ADa_de_la_Gestalt","Metaf%C3%ADsica","Epistemolog%C3%ADa","%C3%89tica","Gestaltico","Consenso_cient%C3%ADfico","Comunidad_cient%C3%ADfica","Epistemolog%C3%ADa","Cosmovisi%C3%B3n","Episteme","Innovaci%C3%B3n","Thomas_Kuhn","Revoluci%C3%B3n_cient%C3%ADfica","Timeo_(di%C3%A1logo)","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Orientaci%C3%B3n_a_objetos","titulo":"Programacion orientada a objetos","contenido":"La programacion orientada a objetos (POO, en espa\u00f1ol); es un paradigma de programacion que parte del concepto de \"objetos\" como base, los cuales contienen informacion en forma de campos (a veces tambien referidos como atributos o propiedades) y codigo en forma de metodos.  Los objetos son capaces de interactuar y modificar los valores contenidos en sus campos o atributos (estado) a traves de sus metodos (comportamiento).\u200b  Muchos de los objetos predise\u00f1ados de los lenguajes de programacion actuales permiten la agrupacion en bibliotecas o librerias, sin embargo, muchos de estos lenguajes permiten al usuario la creacion de sus propias bibliotecas.  Algunas caracteristicas clave de la programacion orientada a objetos son herencia, cohesion, abstraccion, polimorfismo, acoplamiento y encapsulamiento.  Su uso se popularizo a principios de la decada de 1990. En la actualidad, existe una gran variedad de lenguajes de programacion que soportan la orientacion a objetos, estando la mayoria de estos basados en el concepto de clases e instancias.  Los objetos son entidades que tienen un determinado estado, comportamiento e identidad:  La programacion orientada a objetos difiere de la programacion estructurada tradicional, en la que los datos y los procedimientos estan separados y sin relacion, ya que lo unico que se busca es el procesamiento de unos datos de entrada para obtener otros de salida. La programacion estructurada prima el concepto de procedimientos o funciones sobre el de estructuras (se emplean principalmente funciones que procesan datos). La programacion orientada a objetos, en cambio, primero se definen los objetos o estructuras para posteriormente solicitar la ejecucion de sus metodos.  Los conceptos de la POO tienen origen en Simula 67, un lenguaje dise\u00f1ado para hacer simulaciones, creado por Ole-Johan Dahl y Kristen Nygaard, del Centro de Computo Noruego en Oslo. En este centro se trabajaba en simulaciones de naves, que fueron confundidas por la explosion combinatoria de como las diversas cualidades de diferentes naves podian afectar unas a las otras. La idea surgio al agrupar los diversos tipos de naves en diversas clases de objetos, siendo responsable cada clase de objetos de definir sus \"propios\" datos y comportamientos. Fueron refinados mas tarde en Smalltalk, desarrollado en Simula en Xerox PARC (cuya primera version fue escrita sobre Basic) pero dise\u00f1ado para ser un sistema completamente dinamico en el cual los objetos se podrian crear y modificar \"sobre la marcha\" (en tiempo de ejecucion) en lugar de tener un sistema basado en programas estaticos.  La POO se fue convirtiendo en el estilo de programacion dominante a mediados de los a\u00f1os 1980, en gran parte debido a la influencia de C++, una extension del lenguaje de programacion C. Su dominacion fue consolidada gracias al auge de las interfaces graficas de usuario, para las cuales la POO esta particularmente bien adaptada. En este caso, se habla tambien de programacion dirigida por eventos.  Las caracteristicas de orientacion a objetos fueron agregadas a muchos lenguajes existentes durante ese tiempo, incluyendo Ada, BASIC, Lisp mas Pascal, entre otros. La adicion de estas caracteristicas a los lenguajes que no fueron dise\u00f1ados inicialmente para ellas condujo a menudo a problemas de compatibilidad y en la capacidad de mantenimiento del codigo. Los lenguajes orientados a objetos \"puros\", por su parte, carecian de las caracteristicas de las cuales muchos programadores habian venido a depender. Para saltar este obstaculo, se hicieron muchas tentativas para crear nuevos lenguajes basados en metodos orientados a objetos, pero permitiendo algunas caracteristicas imperativas de maneras \"seguras\". El lenguaje de programacion Eiffel de Bertrand Meyer fue un temprano y moderadamente acertado lenguaje con esos objetivos, pero ahora ha sido esencialmente reemplazado por Java, en gran parte debido a la aparicion de Internet y a la implementacion de la maquina virtual Java en la mayoria de navegadores web. PHP en su version 5 se ha modificado; soporta una orientacion completa a objetos, cumpliendo todas las caracteristicas propias de la orientacion a objetos.  La terminologia \"objetos\" y \"orientada\" en el sentido moderno de la programacion orientada a objetos hizo su primer aparicion en el MIT a finales del 1950s y principio de 1960s. Ya en 1960 en el entorno del grupo de inteligencia artificial, el termino \"objeto\" era usado para referirse a elementos (LISP atomos) con propiedades (atributos);\u200b\u200b  Otro ejemplo temprano de programacion orientada en el MIT fue Sketchpad creado por Ivan Sutherland en 1960\u20131961; en el glosario del informe tecnico de 1963, Sutherland define la nocion de \"objeto\" y de \"instancia\".  Simula introdujo conceptos importantes que hoy en dia son una parte esencial de la programacion orientada a objetos, como clases, objetos, herencia y dynamic binding.\u200b  Mas recientemente ha surgido una serie de lenguajes que estan principalmente orientados a objetos pero que tambien son compatibles con la programacion procedural. Dos ejemplos de estos lenguajes son Python y Ruby. Probablemente los lenguajes orientados a objetos recientes con mas importancia comercialmente son Java, desarrollado por Sun Microsystems y C# junto a Visual Basic.NET (VB.NET), dise\u00f1ado por Microsoft's.  La POO es una forma de programar que trata de encontrar una solucion a estos problemas. Introduce nuevos conceptos, que superan y amplian conceptos antiguos ya conocidos. Entre ellos destacan los siguientes:  En comparacion con un lenguaje imperativo, una \"variable\" no es mas que un contenedor interno del atributo del objeto o de un estado interno, asi como la \"funcion\" es un procedimiento interno del metodo del objeto.  Existe un acuerdo acerca de que caracteristicas contempla la \"orientacion a objetos\". Las caracteristicas siguientes son las mas importantes:\u200b  Cabe destacar que para que un lenguaje se pueda tratar como orientado a objetos, debe cumplir que:  El paradigma POO ha sido criticado por varias razones, incluyendo no cumplir con las metas de reusabilidad y modularidad,\u200b\u200b y por sobreenfatizar un aspecto de dise\u00f1o y modelacion de software (datos/objetos) a expensas de otros aspectos importantes (computacion/algoritmos).\u200b\u200b  La POO es un paradigma surgido en los a\u00f1os 1970, que utiliza objetos como elementos fundamentales en la construccion de la solucion. Un objeto es una abstraccion de algun hecho o ente del mundo real, con atributos que representan sus caracteristicas o propiedades, y metodos que emulan su comportamiento o actividad. Todas las propiedades y metodos comunes a los objetos se encapsulan o agrupan en clases. Una clase es una plantilla, un prototipo para crear objetos; en general, se dice que cada objeto es una instancia o ejemplar de una clase.  Para realizar programacion orientada a objetos existen 3 corrientes principales:\u200b\u200b  Simula (1967) es aceptado como el primer lenguaje que posee las caracteristicas principales de un lenguaje orientado a objetos. Fue creado para hacer programas de simulacion, en donde los \"objetos\" son la representacion de la informacion mas importante.  Smalltalk (1972 a 1980) es posiblemente el ejemplo canonico, y con el que gran parte de la teoria de la programacion orientada a objetos se ha desarrollado.  Entre los lenguajes orientados a objetos se destacan los siguientes:    Muchos de estos lenguajes de programacion no son puramente orientados a objetos, sino que son hibridos que combinan la POO con otros paradigmas.  Al igual que C++, otros lenguajes, como OOCOBOL, OOLisp, OOProlog y Object REXX, han sido creados a\u00f1adiendo extensiones orientadas a objetos a un lenguaje de programacion clasico.  Un nuevo paso en la abstraccion de paradigmas de programacion es la Programacion Orientada a Aspectos (POA). Aunque es todavia una metodologia en estado de maduracion, cada vez atrae a mas investigadores e incluso proyectos comerciales en todo el mundo. ","snippet":"La programacion orientada a objetos (POO, en espa\u00f1ol); es un paradigma de programacion que parte del concepto de \"objetos\" como base, los cuales contienen informacion en forma de campos (a veces tambi","enlaces_salientes":["Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_orientada_a_objetos","Idioma_espa%C3%B1ol","Paradigma_de_programaci%C3%B3n","Objeto_(programaci%C3%B3n)","Campo_(inform%C3%A1tica)","M%C3%A9todo_(programacion_orientada_a_objetos)","Lenguajes_de_programaci%C3%B3n","Herencia_(inform%C3%A1tica)","Cohesi%C3%B3n_(inform%C3%A1tica)","Abstracci%C3%B3n_(inform%C3%A1tica)","Polimorfismo_(inform%C3%A1tica)","Acoplamiento_(inform%C3%A1tica)","Encapsulamiento_(inform%C3%A1tica)","D%C3%A9cada_de_1990","Lenguajes_de_programaci%C3%B3n","Clase_(programacion_orientada_a_objetos)","Instancia_(programacion)","Variable_(programaci%C3%B3n)","Constante_(programaci%C3%B3n)","Programaci%C3%B3n_estructurada","Simula","Ole-Johan_Dahl","Kristen_Nygaard","Oslo","Smalltalk","Xerox_PARC","Basic","A%C3%B1os_1980","C%2B%2B","Lenguaje_de_programaci%C3%B3n_C","Interfaz_gr%C3%A1fica_de_usuario","Programaci%C3%B3n_dirigida_por_eventos","Lenguaje_de_programaci%C3%B3n_Ada","BASIC","Lisp","Lenguaje_de_programaci%C3%B3n_Pascal","Lenguaje_de_programaci%C3%B3n_Eiffel","Java_(lenguaje_de_programaci%C3%B3n)","Internet","M%C3%A1quina_virtual_Java","Navegadores_web","PHP","Unified_Modeling_Language","MIT","Inteligencia_artificial","Sketchpad","Ivan_Sutherland","Simula","Clase_(inform%C3%A1tica)","Objeto_(programaci%C3%B3n)","Herencia_(inform%C3%A1tica)","Python","Ruby","Java_(programming_language)","Sun_Microsystems","C_Sharp","Visual_Basic.NET","Clase_(inform%C3%A1tica)","Herencia_(inform%C3%A1tica)","Objeto_(programaci%C3%B3n)","M%C3%A9todo_(programaci%C3%B3n_orientada_a_objetos)","Abstracci%C3%B3n_(programaci%C3%B3n_orientada_a_objetos)","Encapsulamiento_(programaci%C3%B3n_orientada_a_objetos)","Dise%C3%B1o_estructurado","Polimorfismo_(programaci%C3%B3n_orientada_a_objetos)","Sobrecarga","Herencia_(programaci%C3%B3n_orientada_a_objetos)","Herencia_m%C3%BAltiple","Modularidad_(programaci%C3%B3n_orientada_a_objetos)","Principio_de_ocultaci%C3%B3n","Rompecabezas","Recolecci%C3%B3n_de_basura_(programaci%C3%B3n_orientada_a_objetos)","Object_Pascal","A%C3%B1os_1970","Programaci%C3%B3n_basada_en_prototipos","Simula","Smalltalk","ABAP","ActionScript","ActionScript_3","C_Sharp","Clarion_(lenguaje_de_programaci%C3%B3n)","Clipper_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n_D","Object_Pascal","Embarcadero_Delphi","Gambas","GObject","Genie_(lenguaje_de_programaci%C3%B3n)","Compilador_Harbour","Lenguaje_de_programaci%C3%B3n_Eiffel","Fortran","Lenguaje_de_programaci%C3%B3n_Java","JavaScript","L%C3%A9xico","Objective-C","Lenguaje_de_programaci%C3%B3n_Oz","Lenguaje_de_programaci%C3%B3n_R","Pauscal","Perl","Perl_6","PHP","Processing","Python","Ruby","Self_(lenguaje_de_programaci%C3%B3n)","Smalltalk","Swift_(lenguaje_de_programaci%C3%B3n)","Magik_(lenguaje_de_programaci%C3%B3n)","Vala_(lenguaje_de_programaci%C3%B3n)","VB.NET","Visual_FoxPro","Visual_Basic","XBase%2B%2B","Lenguaje_de_programaci%C3%B3n_Scala","Object_REXX","Programaci%C3%B3n_Orientada_a_Aspectos","Base_de_datos_orientada_a_objetos","Ingenier%C3%ADa_de_software_basada_en_componentes","ISBN","Phyllis_Fox","Boston","Massachusetts","MIT_Press","ISBN","Semantic_Scholar","Digital_object_identifier","ISBN","Luca_Cardelli","ISSN","Digital_object_identifier","SAP_Business_Suite","SAP_AG","Programaci%C3%B3n_basada_en_prototipos","%C3%81rbol_(estructura_de_datos)","CPAN","Lenguaje_de_programaci%C3%B3n","Twitter","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Desarrollo_de_software","titulo":"Ingenieria de software","contenido":"La Ingenieria de Software es una de las ramas de las ciencias de la computacion que estudia la creacion de software confiable y de calidad, basandose en metodos y tecnicas de ingenieria, y brindando soporte operacional y de mantenimiento. El campo de estudio de la ingenieria de software\u200b integra ciencias de la computacion, ciencias aplicadas y las ciencias basicas en las cuales se encuentra apoyada la ingenieria.\u200b  Se citan las definiciones mas reconocidas, formuladas por los siguientes prestigiosos autores:  En 2004, la U. S. Bureau of Labor Statistics (Oficina de Estadisticas del Trabajo de Estados Unidos) conto 760\u00a0840\u00a0ingenieros de software de computadora.\u200b[actualizar]  El termino \"ingeniero de software\", sin embargo, se utiliza de manera generica en el ambiente empresarial, y no todos los que se desempe\u00f1an en el puesto de ingeniero de software poseen realmente titulos de ingenieria de universidades reconocidas.\u200b  Algunos autores consideran que \"desarrollo de software\" es un termino mas apropiado que \"ingenieria de software\" para el proceso de crear software. Personas como Pete McBreen (autor de Software Craftmanship) cree que el termino IS implica niveles de rigor y prueba de procesos que no son apropiados para todo tipo de desarrollo de software.  Indistintamente se utilizan los terminos \"ingenieria de software\" o \"ingenieria del software\"; aunque menos comun tambien se suele referenciar como \"ingenieria en software\".\u200b\u200b\u200b En Hispanoamerica los terminos mas comunmente usados son los dos primeros.  La creacion del software es un proceso intrinsecamente creativo y la ingenieria del software trata de sistematizar este proceso con el fin de acotar el riesgo de fracaso en la consecucion del objetivo, por medio de diversas tecnicas que se han demostrado adecuadas sobre la base de la experiencia previa.  La ingenieria de software se puede considerar como la ingenieria aplicada al software, esto es, por medios sistematizados y con herramientas preestablecidas, la aplicacion de ellos de la manera mas eficiente para la obtencion de resultados optimos; objetivos que siempre busca la ingenieria. No es solo de la resolucion de problemas, sino mas bien teniendo en cuenta las diferentes soluciones, elegir la mas apropiada.  La produccion de software utiliza criterios y normas de la ingenieria de software, lo que permite transformarlo en un producto industrial usando bases de la ingenieria como metodos, tecnicas y herramientas para desarrollar un producto innovador regido por metodologias y las buenas practicas. Dicho producto es un medio que interviene en las funciones de sus usuarios para obtener un proceso productivo mas eficaz y eficiente; hoy en dia las empresas no podrian funcionar sin software porque este es un producto de uso masivo; por lo cual, el nivel de una empresa esta determinado por la calidad de su infraestructura tecnologica y los productos desarrollados o adquiridos de acuerdo con sus necesidades.  Cuando aparecieron las primeras computadoras digitales en la decada de 1940,\u200b el desarrollo de software era algo tan nuevo que era casi imposible hacer predicciones de las fechas estimadas de finalizacion del proyecto y muchos de ellos sobrepasaban los presupuestos y tiempo estimados. Los desarrolladores tenian que volver a escribir todos sus programas para correr en maquinas nuevas que salian cada uno o dos a\u00f1os, haciendo obsoletas las ya existentes.  El termino ingenieria del software aparecio por primera vez a finales de la decada de 1950. La ingenieria de software fue estimulada por la crisis del software de las decadas de entre 1960 y 1980. La ingenieria del software viene a ayudar a identificar y corregir mediante principios y metodologias los procesos de desarrollo y mantenimiento de sistemas de software.  Aparte de la crisis del software de las decadas de entre 1960 y 1980, la ingenieria de software se ve afectada por accidentes que conllevaron a la muerte de seis personas; esto sucedio cuando la maquina de radioterapia Therac-25 la cual emite una sobredosis masiva de radiacion y afecto la vida de estas 6 personas dejando a otras mas marcadas de por vida.\u200b Esto remarca los riesgos de control por software,\u200b afectando directamente al nombre de la ingenieria de software.  A principios de los 1980,\u200b la ingenieria del software ya habia surgido como una genuina profesion, para estar al lado de las ciencias de la computacion y la ingenieria tradicional. Antes de esto, las tareas eran corridas poniendo tarjetas perforadas como entrada en el lector de tarjetas de la maquina y se esperaban los resultados devueltos por la impresora.  Debido a la necesidad de traducir frecuentemente el software viejo para atender las necesidades de las nuevas maquinas, se desarrollaron lenguajes de orden superior. A medida que aparecio el software libre, las organizaciones de usuarios comunmente lo liberaban.  Durante mucho tiempo, solucionar la crisis del software fue de suma importancia para investigadores y empresas que se dedicaban a producir herramientas de software.  Para la decada de 1980, el costo de propiedad y mantenimiento del software fue dos veces mas caro que el propio desarrollo del software, y durante la decada de 1990, el costo de propiedad y mantenimiento aumento 30\u00a0% con respecto a la decada anterior. En 1995, muchos de los proyectos de desarrollo estaban operacionales, pero no eran considerados exitosos. El proyecto de software medio sobrepasaba en un 50\u00a0% la estimacion de tiempo previamente realizada, ademas, el 75\u00a0% de todos los grandes productos de software que eran entregados al cliente tenian fallas tan graves, que no eran usados en lo absoluto o simplemente no cumplian con los requerimientos del cliente.  Algunos expertos argumentaron que la crisis del software era debido a la falta de disciplina de los programadores.  Cada nueva tecnologia y practica de la decada de 1970 a la de 1990 fue pregonada como la unica solucion a todos los problemas y el caos que llevo a la crisis del software. Lo cierto es que la busqueda de una unica clave para el exito nunca funciono. El campo de la ingenieria de software parece un campo demasiado complejo y amplio para una unica solucion que sirva para mejorar la mayoria de los problemas, y cada problema representa solo una peque\u00f1a porcion de todos los problemas de software.  El auge del uso del Internet llevo a un vertiginoso crecimiento en la demanda de sistemas internacionales de despliegue de informacion en la World Wide Web. Los desarrolladores se vieron en la tarea de manejar ilustraciones, mapas, fotografias y animaciones, a un ritmo nunca antes visto, con casi ningun metodo para optimizar la visualizacion y almacenamiento de imagenes. Tambien fueron necesarios sistemas para traducir el flujo de informacion en multiples idiomas extranjeros a lenguaje natural humano, con muchos sistemas de software dise\u00f1ados para uso multilenguaje, basado en traductores humanos.  La ingenieria de software contribuyo alrededor de 90\u00a0000 millones de dolares por a\u00f1o, ya que entro en juego el Internet. Esto hace que los desarrolladores tuviesen que manejar imagenes mapas y animaciones para optimizar la visualizacion/almacenamiento de imagenes (como el uso de imagenes en miniatura). El uso de los navegadores y utilizacion de lenguaje HTML cambia drasticamente la vision y recepcion de la informacion.  Las amplias conexiones de red causaron la proliferacion de virus informaticos y  basura o spam en los correos electronicos (Correo electronico). Esta situacion puso en una carrera contra el tiempo a los desarrolladores con el fin de crear nuevos sistemas de bloqueo o seguridad de dichas anomalias en la informatica, ya que se volvian sumamente tediosas y dificiles de arreglar  Despues de una fuerte y creciente demanda surge la necesidad de crear soluciones de software a bajo costo, lo que conlleva al uso de metodologias mas simples y rapidas que desarrollan software funcional. Cabe se\u00f1alar que los sistemas mas peque\u00f1os tenian un enfoque mas simple y rapido para poder administrar el desarrollo de calculos y algoritmos de software.  La ingenieria de software aplica diferentes normas y metodos que permiten obtener mejores resultados, en cuanto al desarrollo y uso del software, mediante la aplicacion correcta de estos procedimientos se puede llegar a cumplir de manera satisfactoria con los objetivos fundamentales de la ingenieria de software.  Entre los objetivos de la ingenieria de software estan:  Son todas aquellas personas que intervienen en la planificacion de cualquier instancias de software (por ejemplo: gestor, ingeniero de software experimentado, etc.), El numero de personas requerido para un proyecto de software solo puede ser determinado despues de hacer una estimacion del esfuerzo de desarrollo...  Es el entorno de las aplicaciones (software y hardware) el hardware proporciona el medio fisico para desarrollar las aplicaciones (software), este recurso es indispensable.\u200b  En los Estados Unidos, el software contribuyo a una octava parte de todo el incremento del PIB durante la decada de 1990 (alrededor de 90\u00a0000 millones de dolares por a\u00f1o), y un noveno de todo el crecimiento de productividad durante los ultimos a\u00f1os de la decada (alrededor de 33.000 millones de dolares estadounidenses por a\u00f1o). La ingenieria de software contribuyo a US$ 1 billon de crecimiento economico y productividad en esa decada. Alrededor del globo, el software contribuye al crecimiento economico de maneras similares, aunque es dificil de encontrar estadisticas fiables. [cita\u00a0requerida]  Ademas, con la industria del lenguaje esta hallando cada vez mas campos de aplicacion a escala global.  La ingenieria de software cambia la cultura del mundo debido al extendido uso de la computadora. El correo electronico (e-mail), la WWW y la mensajeria instantanea permiten a la gente interactuar de nuevas maneras. El software baja el costo y mejora la calidad de los servicios de salud, los departamentos de bomberos, las dependencias gubernamentales y otros servicios sociales. Los proyectos exitosos donde se han usado metodos de ingenieria de software incluyen a GNU/Linux, el software del transbordador espacial, los cajeros automaticos y muchos otros.  Es un lenguaje de modelado muy reconocido y utilizado actualmente que se utiliza para describir o especificar metodos. Tambien es aplicable en el desarrollo de software.  Las siglas UML significan lenguaje unificado de modelado esto quiere decir que no pretende definir un modelo estandar de desarrollo, sino unicamente un lenguaje de modelado.\u200b  Un lenguaje de modelado consta de vistas, elementos de modelo y un conjunto de reglas sintacticas, semanticas y pragmaticas que indican como utilizar los elementos.  En esta materia nos encontramos con varios diagramas que se pueden usar tales como: casos de uso, de clases, componentes, despliegue, etc.  El objetivo de la notacion para el modelado de procesos de negocios es proporcionar de una manera facil de definir y analizar los procesos de negocios publicos y privados simulando un diagrama de flujo. La notacion ha sido dise\u00f1ada especificamente para coordinar la secuencia de los procesos y los mensajes que fluyen entre los participantes del mismo, con un conjunto de actividades relacionadas. Caracteristicas basicas de los elementos de BPMN  Un diagrama de flujo de datos permite representar el movimiento de datos a traves de un sistema por medio de modelos que describen los flujos de datos, los procesos que transforman o cambian los datos, los destinos de datos y los almacenamientos de datos a la cual tiene acceso el sistema.  Su inventor fue Larry Constantine, basado en el modelo de computacion de Martin y Estrin: flujo grafico de datos. Con los diagramas de flujo de datos determina la manera en que cualquier sistema puede desarrollarse, ayuda en la identificacion de los datos de la transaccion en el modelo de datos y proporciona al usuario una idea fisica de como resultaran los datos a ultima instancia.\u200b  Las Herramienta CASE son herramientas computacionales (software) que estan destinadas a asistir en los procesos de ciclo de vida de un software, facilitan la produccion del software, varias se basan principalmente en la idea de un modelo grafico.\u200b  Un objetivo de decadas ha sido el encontrar procesos y metodologias, que sean sistematicas, predecibles y repetibles, a fin de mejorar la productividad en el desarrollo y la calidad del producto software, en pocas palabras, determina los pasos a seguir y como realizarlos para finalizar una tarea.  La ingenieria de software requiere llevar a cabo numerosas tareas agrupadas en etapas, al conjunto de estas etapas se le denomina ciclo de vida. Las etapas comunes a casi todos los modelos de ciclo de vida son las siguientes:  Se debe identificar sobre que se esta trabajando, es decir, el tema principal que motiva el inicio del estudio y creacion del nuevo software o modificacion de uno ya existente. A su vez identificar los recursos que se tienen, en esto entra el conocer los recursos humanos y materiales que participan en el desarrollo de las actividades. Es importante entender el contexto del negocio para identificar adecuadamente los requisitos.  Se tiene que tener dominio de la informacion de un problema, lo cual incluye los datos fuera del software (usuarios finales, otros sistemas o dispositivos externos), los datos que salen del sistema (por la interfaz de usuario, interfaces de red, reportes, graficas y otros medios) y los almacenamientos de datos que recaban y organizan objetos persistentes de datos (por ejemplo, aquellos que se conservan de manera permanente).  Tambien hay que ver los puntos criticos, lo que significa tener de una manera clara los aspectos que entorpecen y limitan el buen funcionamiento de los procedimientos actuales, los problemas mas comunes y relevantes que se presentan, los motivos que crean insatisfaccion y aquellos que deben ser cubiertos a plenitud. Por ejemplo: \u00bfEl contenido de los reportes generados, satisface realmente las necesidades del usuario? \u00bfLos tiempos de respuesta ofrecidos, son oportunos?, etc.  Hay que definir las funciones que realizara el software ya que estas ayudan al usuario final y al funcionamiento del mismo programa.  Se tiene que tener en cuenta como sera el comportamiento del software ante situaciones inesperadas como lo son por ejemplo una gran cantidad de usuarios usando el software o una gran cantidad de datos entre otros.  El analisis de requisitos puede parecer una tarea sencilla, pero no lo es debido a que muchas veces los clientes piensan que saben todo lo que el software necesita para su buen funcionamiento, sin embargo se requiere la habilidad y experiencia de algun especialista para reconocer requisitos incompletos, ambiguos o contradictorios. Estos requisitos se determinan tomando en cuenta las necesidades del usuario final, introduciendo tecnicas que nos permitan mejorar la calidad de los sistemas sobre los que se trabaja.\u200b  El resultado del analisis de requisitos con el cliente se plasma en el documento ERS (especificacion de requisitos del sistema), cuya estructura puede venir definida por varios estandares, tales como CMMI. Asimismo, se define un diagrama de entidad/relacion, en el que se plasman las principales entidades que participaran en el desarrollo del software.  La captura, analisis y especificacion de requisitos (incluso pruebas de ellos), es una parte crucial; de esta etapa depende en gran medida el logro de los objetivos finales. Se han ideado modelos y diversos procesos metodicos de trabajo para estos fines. Aunque aun no esta formalizada, ya se habla de la ingenieria de requisitos.  La IEEE Std. 830-1998 normaliza la creacion de las especificaciones de requisitos de software (Software Requirements Specification).  Finalidades del analisis de requisitos:  No siempre en la etapa de \"analisis de requisitos\" las distintas metodologias de desarrollo llevan asociado un estudio de viabilidad y/o estimacion de costes. El mas conocido de los modelos de estimacion de coste del software es el modelo COCOMO  Los software tienen la capacidad de emular inteligencia creando un modelo de ciertas caracteristicas de la inteligencia humana pero solo posee funciones predefinidas que abarcan un conjunto de soluciones que en algunos campos llega a ser limitado. Aun cuando tiene la capacidad de imitar ciertos comportamientos humanos no es capaz de emular el pensamiento humano porque actua bajo condiciones.  Otro aspecto limitante de los software proviene del proceso totalmente mecanico que requiere de un mayor esfuerzo y tiempos elevados de ejecucion lo que lleva a tener que implementar el software en una maquina de mayor capacidad.  La especificacion de requisitos describe el comportamiento esperado en el software una vez desarrollado. Gran parte del exito de un proyecto de software radicara en la identificacion de las necesidades del negocio (definidas por la alta direccion), asi como la interaccion con los usuarios funcionales para la recoleccion, clasificacion, identificacion, priorizacion y especificacion de los requisitos del software.  Entre las tecnicas utilizadas para la especificacion de requisitos se encuentran:  Siendo los primeros mas rigurosas y formales, los segundas mas agiles e informales.  La integracion de infraestructura, desarrollo de aplicaciones, bases de datos y herramientas gerenciales, requieren de capacidad y liderazgo para poder ser conceptualizados y proyectados a futuro, solucionando los problemas de hoy. El rol en el cual se delegan todas estas actividades es el del Arquitecto.  El arquitecto de software es la persona que a\u00f1ade valor a los procesos de negocios gracias a su valioso aporte de soluciones tecnologicas.  La arquitectura de sistemas en general, es una actividad de planeacion, ya sea a nivel de infraestructura de red y hardware, o de software.  Lo principal en este punto es poner en claro los aspectos logicos y fisicos de las salidas, modelos de organizacion y representacion de datos, entradas y procesos que componen el sistema, considerando las bondades y limitaciones de los recursos disponibles en la satisfaccion de las pacificaciones brindadas para el analisis.  Hay que tener en consideracion la arquitectura del sistema en la cual se va a trabajar, elaborar un plan de trabajo viendo la prioridad de tiempo y recursos disponibles. En los dise\u00f1os de salidas entra los que es la interpretacion de requerimientos lo cual es el dominio de informacion del problema, las funciones visibles para el usuario, el comportamiento del sistema y un conjunto de clases de requerimientos que agrupa los objetos del negocio con los metodos que les dan servicio.  La arquitectura de software consiste en el dise\u00f1o de componentes de una aplicacion (entidades del negocio), generalmente utilizando patrones de arquitectura. El dise\u00f1o arquitectonico debe permitir visualizar la interaccion entre las entidades del negocio y ademas poder ser validado, por ejemplo por medio de diagramas de secuencia. Un dise\u00f1o arquitectonico describe en general el como se construira una aplicacion de software. Para ello se documenta utilizando diagramas, por ejemplo:  Los diagramas de clases y de base de datos son los minimos necesarios para describir la arquitectura de un proyecto que iniciara a ser codificado. Dependiendo del alcance del proyecto, complejidad y necesidades, el arquitecto elegira cuales de los diagramas se requiere elaborar.  Las herramientas para el dise\u00f1o y modelado de software se denominan CASE (Computer Aided Software Engineering) entre las cuales se encuentran:  Implementar un dise\u00f1o en codigo puede ser la parte mas obvia del trabajo de ingenieria de software, pero no necesariamente es la que demanda mayor trabajo y ni la mas complicada. La complejidad y la duracion de esta etapa esta intimamente relacionada al o a los lenguajes de programacion utilizados, asi como al dise\u00f1o previamente realizado.  Para el desarrollo de la aplicacion es necesario considerar cinco fases para tener una aplicacion o programa eficiente, estas son:  Consiste en comprobar que el software realice correctamente las tareas indicadas en la especificacion del problema. Una tecnica es probar por separado cada modulo del software (prueba unitaria), y luego probarlo de manera integral (pruebas de integracion), para asi llegar al objetivo. Se considera una buena practica el que las pruebas sean efectuadas por alguien distinto al desarrollador que la programo, idealmente un area de pruebas; sin perjuicio de lo anterior el programador debe hacer sus propias pruebas. En general hay dos grandes maneras de organizar un area de pruebas, la primera es que este compuesta por personal inexperto y que desconozca el tema de pruebas, de esta manera se evalua que la documentacion entregada sea de calidad, que los procesos descritos son tan claros que cualquiera puede entenderlos y el software hace las cosas tal y como estan descritas. El segundo enfoque es tener un area de pruebas conformada por programadores con experiencia, personas que saben sin mayores indicaciones en que condiciones puede fallar una aplicacion y que pueden poner atencion en detalles que personal inexperto no consideraria.  De acuerdo con Roger S. Pressman, el proceso de pruebas se centra en los procesos logicos internos del software, asegurando que todas las sentencias se han comprobado, y en los procesos externos funcionales, es decir, la realizacion de pruebas para la deteccion de errores. Se requiere poder probar el software con sujetos reales que puedan evaluar el comportamiento del software con el fin de proporcionar realimentacion a los desarrolladores. Es importante que durante el proceso de desarrollo del software no se pierda contacto con los interesados o solicitantes del desarrollo de software, de esta manera los objetivos del proyecto se mantendran vigentes y se tendra una idea clara de los aspectos que tienen que probarse durante el periodo de pruebas.\u200b  Una implementacion es la realizacion de una especificacion tecnica o algoritmos con un programa, componente software, u otro sistema de computo. Muchas especificaciones son dadas segun a su especificacion o un estandar. Las especificaciones recomendadas segun el World Wide Web Consortium, y las herramientas de desarrollo del software contienen implementaciones de lenguajes de programacion. El modelo de implementacion es una coleccion de componentes y los subsistemas que contienen. Componentes tales como: ficheros ejecutables, ficheros de codigo fuente y todo otro tipo de ficheros que sean necesarios para la implementacion y despliegue del sistema.  La etapa de implementacion del dise\u00f1o de software es el proceso de convertir una especificacion del sistema en un sistema ejecutable. Siempre implica los procesos de dise\u00f1o y programacion de software, pero, si se utiliza un enfoque evolutivo de desarrollo, tambien puede implicar un refinamiento de la especificacion del software. Esta etapa es una descripcion de la estructura del software que se va a implementar, los datos que son parte del sistema, las interfaces entre los componentes del sistema, y algunas veces los algoritmos utilizados.\u200b  Es todo lo concerniente a la documentacion del propio desarrollo del software y de la gestion del proyecto, pasando por modelaciones (UML), diagramas de casos de uso, pruebas, manuales de usuario, manuales tecnicos, etc; todo con el proposito de eventuales correcciones, usabilidad, mantenimiento futuro y ampliaciones al sistema.  Fase dedicada a mantener y mejorar el software para corregir errores descubiertos e incorporar nuevos requisitos. Esto puede llevar mas tiempo incluso que el desarrollo del software inicial. Alrededor de 2/3 del tiempo de ciclo de vida de un proyecto\u200b esta dedicado a su mantenimiento. Una peque\u00f1a parte de este trabajo consiste eliminar errores (bugs); siendo que la mayor parte reside en extender el sistema para incorporarle nuevas funcionalidades y hacer frente a su evolucion.  El mantenimiento de software, segun la investigacion de Lehman, el 80% del mantenimiento no son acciones correctivas. Son mejoras de funcionalidad (e incorporacion de nuevos requisitos), segun Lehman el software evoluciona con el tiempo. Teniendo en cuenta eso, la etapa de mantenimiento en si misma puede incluir las etapas anteriores entre el despliegue de cada nueva version, reutilizando el software ya existente, reformandolo y adaptandolo.  La ingenieria de software, con el fin de ordenar el caos que era anteriormente el desarrollo de software, dispone de varios modelos, paradigmas y filosofias de desarrollo, estos los conocemos principalmente como modelos o ciclos de vida del desarrollo de software, esto incluye el proceso que se sigue para construir, entregar y hacer evolucionar el software, desde la concepcion de una idea hasta la entrega y el retiro del sistema y representa todas las actividades y artefactos (productos intermedios) necesarios para desarrollar una aplicacion.\u200b  El ciclo de vida de un software contiene los siguientes procedimientos:  En ingenieria de software el modelo en cascada \u2015tambien llamado desarrollo en cascada o ciclo de vida clasico\u2015 se basa en un enfoque metodologico que ordena rigurosamente las etapas del ciclo de vida del software, esto sugiere una aproximacion sistematica secuencial hacia el proceso de desarrollo del software, que se inicia con la especificacion de requisitos del cliente y continua con la planificacion, el modelado, la construccion y el despliegue para culminar en el soporte del software terminado.\u200b  En ingenieria de software, el modelo de prototipos pertenece a los modelos de desarrollo evolutivo. Este permite que todo el sistema, o algunos de sus partes, se construyan rapidamente para comprender con facilidad y aclarar ciertos aspectos en los que se aseguren que el desarrollador, el usuario, el cliente esten de acuerdo en lo que se necesita asi como tambien la solucion que se propone para dicha necesidad y de esta manera minimizar el riesgo y la incertidumbre en el desarrollo, este modelo se encarga del desarrollo de dise\u00f1os para que estos sean analizados y prescindir de ellos a medida que se adhieran nuevas especificaciones, es ideal para medir el alcance del producto, pero no se asegura su uso real.  Este modelo principalmente se aplica cuando un cliente define un conjunto de objetivos generales para el software a desarrollarse sin delimitar detalladamente los requisitos de entrada procesamiento y salida, es decir cuando el responsable no esta seguro de la eficacia de un algoritmo, de la adaptabilidad del sistema o de la manera en que interactua el hombre y la maquina.  Este modelo se encarga principalmente de ayudar al ingeniero de sistemas y al cliente a entender de mejor manera cual sera el resultado de la construccion cuando los requisitos esten satisfechos.\u200b  El modelo en espiral, que Barry Boehm propuso originalmente en 1986, es un modelo de proceso de software evolutivo que conjuga la naturaleza iterativa de la construccion de prototipos con los aspectos controlados y sistematicos del modelo en cascada, es decir, cuando se aplica este modelo, el software se desarrolla en una serie de entregas evolutivas (ciclos o iteraciones), cada una de estas entregando prototipos mas completas que el anterior, todo esto en funcion del analisis de riesgo y las necesidades del cliente. Aunque el modelo espiral representa ventajas por sobre el desarrollo lineal, el calculo de los riesgos puede ser muy complicado y por lo cual su uso en el ambito real es muy escaso.\u200b  Es un modelo en el que el software se muestra al cliente en etapas refinadas sucesivamente. Con esta metodologia se desarrollan las capacidades mas importantes reduciendo el tiempo necesario para la construccion de un producto; el modelo de entrega por etapas es util para el desarrollo de la herramienta debido a que su uso se recomienda para problemas que pueden ser tratados descomponiendolos en problemas mas peque\u00f1os y se caracteriza principalmente en que las especificaciones no son conocidas en detalle al inicio del proyecto y por tanto se van desarrollando simultaneamente con las diferentes versiones del codigo.  En este modelo pueden distinguirse las siguientes fases:  Cuando es por etapas, en el dise\u00f1o global estas fases pueden repetirse segun la cantidad de etapas que sean requeridas.  Entre sus ventajas tenemos:  Desarrollo iterativo y creciente (o incremental) es un proceso de desarrollo de software, creado en respuesta a las debilidades del modelo tradicional de cascada, es decir, este modelo aplica secuencias lineales como el modelo en cascada, pero de una manera iterativa o escalada segun como avance el proceso de desarrollo y con cada una de estas secuencias lineales se producen incrementos (mejoras) del software.\u200b  Se debe tener en cuenta que el flujo del proceso de cualquier incremento puede incorporar el paradigma de construccion de prototipos, ya que como se menciono anteriormente, este tipo de modelo es iterativo por naturaleza, sin embargo se diferencia en que este busca la entrega de un producto operacional con cada incremento que se le realice al software.  Este modelo \u2015como su nombre lo indica\u2015 utiliza las tecnicas del dise\u00f1o estructurado o de la programacion estructurada para su desarrollo, tambien se utiliza en la creacion de los algoritmos del programa. Este formato facilita la comprension de la estructura de datos y su control.\u200b Entre las principales caracteristicas de este modelo se encuentran las siguientes:  Este modelo tambien presenta sus desventajas entre las cuales podemos mencionar algunas:  En el modelo estructurado las tecnicas que comunmente se utilizan son:  Estos modelos tienen sus raices en la programacion orientada a objetos y como consecuencia de ella gira en torno al concepto de clase, tambien lo hacen el analisis de requisitos y el dise\u00f1o. Esto ademas de introducir nuevas tecnicas, tambien aprovecha las tecnicas y conceptos del desarrollo estructurado, como diagramas de estado y transiciones. El modelo orientado a objetos tiene dos caracteristicas principales, las cuales ha favorecido su expansion:  El RAD (rapid application development: \u2018desarrollo rapido de aplicaciones\u2019), es un modelo de proceso de software incremental, desarrollado inicialmente por James Maslow en 1980, que resalta principalmente un ciclo corto de desarrollo.  Esta es una metodologia que posibilita la construccion de sistemas computacionales que combinen tecnicas y utilidades CASE (Computer Aided Software Engineering), la construccion de prototipos centrados en el usuario y el seguimiento lineal y sistematico de objetivos, incrementando la rapidez con la que se producen los sistemas mediante la utilizacion de un enfoque de desarrollo basado en componentes.\u200b  Si se entienden bien los requisitos y se limita el ambito del proyecto, el proceso RAD permite que un equipo de desarrollo cree un producto completamente funcional dentro de un periodo muy limitado de tiempo sin reducir en lo mas minimo la calidad del mismo.\u200b  El modelo de desarrollo concurrente es un modelo de tipo de red donde todas las personas actuan simultaneamente o al mismo tiempo. Este tipo de modelo se puede representar a manera de esquema como una serie de actividades tecnicas importantes, tareas y estados asociados a ellas.  El modelo de proceso concurrente define una serie de acontecimientos que dispararan transiciones de estado a estado para cada una de las actividades de la ingenieria del software. Por ejemplo, durante las primeras etapas del dise\u00f1o, no se contempla una inconsistencia del modelo de analisis. Esto genera la correccion del modelo de analisis de sucesos, que disparara la actividad de analisis del estado hecho al estado cambios en espera. Este modelo de desarrollo se utiliza a menudo como el paradigma de desarrollo de aplicaciones cliente/servidor. Un sistema cliente/servidor se compone de un conjunto de componentes funcionales. Cuando se aplica a cliente/servidor, el modelo de proceso concurrente define actividades en dos dimensiones: una division de sistemas y una division de componentes. Los aspectos del nivel de sistemas se afrontan mediante dos actividades: dise\u00f1o y realizacion.  La concurrencia se logra de dos maneras:  En realidad, el modelo de desarrollo concurrente es aplicable a todo tipo de desarrollo de software y proporciona una imagen exacta del estado actual de un proyecto. En vez de confinar actividades de ingenieria de software a una secuencia de sucesos, define una red de actividades, todas las actividades de la red existen simultaneamente con otras. Los sucesos generados dentro de una actividad dada o algun otro lado de la red de actividad inicia las transiciones entre los estados de una actividad.  El proceso unificado es un proceso de software generico que puede ser utilizado para una gran cantidad de tipos de sistemas de software, para diferentes areas de aplicacion, diferentes tipos de organizaciones, diferentes niveles de competencia y diferentes tama\u00f1os de proyectos.  Provee un enfoque disciplinado en la asignacion de tareas y responsabilidades dentro de una organizacion de desarrollo. Su meta es asegurar la produccion de software de muy alta calidad que satisfaga las necesidades de los usuarios finales, dentro de un calendario y presupuesto predecible.\u200b  El proceso unificado tiene dos dimensiones:  La primera dimension representa el aspecto dinamico del proceso conforme se va desarrollando, se expresa en terminos de fases, iteraciones e hitos (milestones).  La segunda dimension representa el aspecto estatico del proceso: como es descrito en terminos de componentes del proceso, disciplinas, actividades, flujos de trabajo, artefactos y roles.  El refinamiento mas conocido y documentado del proceso unificado es el RUP (proceso unificado racional).  El proceso unificado no es simplemente un proceso, sino un marco de trabajo extensible que puede ser adaptado a organizaciones o proyectos especificos. De la misma manera, el proceso unificado de rational, tambien es un marco de trabajo extensible, por lo que muchas veces resulta imposible decir si un refinamiento particular del proceso ha sido derivado del proceso unificado o del RUP. Por dicho motivo, los dos nombres suelen utilizarse para referirse a un mismo concepto.\u200b  El software se ha convertido en algo muy necesario en nuestra sociedad actual, es la maquina que conduce a la toma de decisiones comerciales, sirve para la investigacion cientifica moderna, es un factor clave que diferencia productos y servicios modernos. Esto se da porque el software esta inmerso en sistemas de todo tipo alrededor de nosotros.  El software de computadora es el producto que dise\u00f1an y construyen los ingenieros de software. Esto abarca programas que se ejecutan dentro de una computadora de cualquier tama\u00f1o y arquitectura, despues de estar construido casi cualquier persona en el mundo industrializado, ya sea directa o indirectamente.  Los productos se pueden clasificar en:  Estos productos deben cumplir varias caracteristicas al ser entregados, estas son:  Lo que constituye el producto final es diferente para el ingeniero y los usuarios, para el ingeniero son los programas, datos y documentos que configuran el software pero para el usuario el producto final es la informacion que de cierto modo soluciona el problema planteado por el usuario.  La ingenieria de software es una disciplina que esta orientada a aplicar conceptos y metodos de ingenieria al desarrollo de software de calidad.  Los programas tienen muchas propiedades matematicas. Por ejemplo la correccion y la complejidad de muchos algoritmos son conceptos matematicos que pueden ser rigurosamente probados. El uso de matematicas en la IS es llamado metodos formales.  Los programas son construidos en una secuencia de pasos. El hecho de definir propiamente y llevar a cabo estos pasos, como en una linea de ensamblaje, es necesario para mejorar la productividad de los desarrolladores y la calidad final de los programas. Este punto de vista inspira los diferentes procesos y metodologias que se encuentran en la IS.  El desarrollo de software de gran porte requiere una adecuada gestion del proyecto. Hay presupuestos, establecimiento de tiempos de entrega, un equipo de profesionales que liderar. Recursos (espacio de oficina, insumos, equipamiento) por adquirir. Para su administracion se debe tener una clara vision y capacitacion en gestion de proyectos.  Para el desarrollo de un sistema de software es necesaria la colaboracion de muchas personas con diversas competencias, capacidades e intereses. Al conjunto de personas involucradas en el proyecto se les conoce como participantes.  Al conjunto de funciones y responsabilidades que hay dentro del proyecto o sistema se le conoce como roles o papeles. Los roles estan asociados a las tareas que son asignadas a los participantes, en consecuencia, una persona puede desempe\u00f1ar uno o multiples roles, asi tambien un mismo rol puede ser representado por un equipo.\u200b  Es frecuente el uso de los terminos \"usuarios\", \"usuarios finales\" y \"clientes\" como sinonimos, lo cual puede provocar confusion; estrictamente, el cliente (persona, empresa u organizacion) es quien especifica los requisitos del sistema,\u200b en tanto que el usuario es quien utiliza u opera finalmente el producto software, pudiendo ser o no el cliente.  Esta clase de participantes estan relacionados con todas las facetas del proceso de desarrollo del software. Su trabajo incluye la investigacion, dise\u00f1o, implementacion, pruebas y depuracion del software.\u200b  En el contexto de ingenieria de software, el gestor de desarrollo de software es un participante, que reporta al director ejecutivo de la empresa que presta el servicio de desarrollo. Es responsable del manejo y coordinacion de los recursos y procesos para la correcta entrega de productos de software, mientras participa en la definicion de la estrategia para el equipo de desarrolladores, dando iniciativas que promuevan la vision de la empresa.\u200b  El usuario final es quien interactua con el producto de software una vez es entregado.\u200b Generalmente son los usuarios los que conocen el problema, ya que dia a dia operan los sistemas.  Un ingeniero de software debe tener un codigo donde asegura, en la medida posible, que los esfuerzos realizados se utilizaran para realizar el bien y deben comprometerse para que la ingenieria de software sea una profesion benefica y respetada. Para el cumplimiento de esta norma, se toman en cuenta ocho principios relacionados con la conducta y las decisiones tomadas por el ingeniero; donde estos principios identifican las relaciones eticamente responsables de los individuos, grupos y organizaciones donde participen. Los principios a los que deben sujetarse son sobre la sociedad, cliente y empresario, producto, juicio, administracion, profesion, colegas y por ultimo el personal.   ","snippet":"La Ingenieria de Software es una de las ramas de las ciencias de la computacion que estudia la creacion de software confiable y de calidad, basandose en metodos y tecnicas de ingenieria, y brindando s","enlaces_salientes":["Ingenier%C3%ADa_de_software","Ingenier%C3%ADa_de_software","Ingenier%C3%ADa_de_software","Inform%C3%A1tica","Software_de_aplicaci%C3%B3n","Software_de_sistema","Desarrollo_web","Aplicaci%C3%B3n_m%C3%B3vil","Computaci%C3%B3n_gr%C3%A1fica","Aplicaci%C3%B3n_de_escritorio","Bot_conversacional","Cadena_de_bloques","F%C3%ADsica_computacional","Qu%C3%ADmica_computacional","Visi%C3%B3n_artificial","Software_rob%C3%B3tico","Software_m%C3%A9dico","SCADA","Herramientas_de_dise%C3%B1o_asistido","Aplicaciones_de_la_inteligencia_artificial","Ciencias_de_la_computaci%C3%B3n","San_Francisco_(California)","Fundaci%C3%B3n_Wikimedia","Software","Ciencias_de_la_computaci%C3%B3n","Ciencias_aplicadas","Ciencias_b%C3%A1sicas","Ingenier%C3%ADa","Creatividad","Resoluci%C3%B3n_de_problemas","Historia_de_la_ingenier%C3%ADa_del_software","Crisis_del_software","Therac-25","Ciencias_de_la_computaci%C3%B3n","Internet","HTM","Virus_inform%C3%A1ticos","Correo_electr%C3%B3nico","Recursos_humanos","Software","Industria_del_lenguaje","Cultura","Correo_electr%C3%B3nico","WWW","Mensajer%C3%ADa_instant%C3%A1nea","GNU/Linux","Transbordador_espacial","Cajero_autom%C3%A1tico","Lenguaje_unificado_de_modelado","Desarrollo_de_software","Diagrama_de_casos_de_uso","Diagrama_de_clases","Diagrama_de_componentes","Diagrama_de_despliegue","Business_Process_Model_and_Notation","Diagrama_de_flujo_de_datos","Diagrama_de_flujo_de_datos","Herramienta_CASE","Metodolog%C3%ADa_de_desarrollo_de_software","CMMI","Modelo_entidad-relaci%C3%B3n","Ingenier%C3%ADa_de_requisitos","COCOMO","Caso_de_uso","Historias_de_usuario","Arquitectura_de_software","Diagrama_de_clases","Diagrama_de_despliegue","Diagrama_de_secuencia","Herramienta_CASE","Programaci%C3%B3n","Lenguajes_de_programaci%C3%B3n","Diagrama_de_flujo","Pruebas_de_software","Prueba_unitaria","Pruebas_de_integraci%C3%B3n","Realimentaci%C3%B3n","Implementaci%C3%B3n","World_Wide_Web_Consortium","Lenguaje_unificado_de_modelado","Mantenimiento_de_software","Mantenimiento_de_software","Meir_M._Lehman","Meir_M._Lehman","Ciclo_de_vida_del_desarrollo_de_software","Desarrollo_en_cascada","Modelo_de_prototipos","Desarrollo_en_espiral","Desarrollo_por_etapas","Desarrollo_iterativo_y_creciente","Dise%C3%B1o_estructurado","Programaci%C3%B3n_estructurada","Modelo_entidad-relaci%C3%B3n","Diagrama_de_flujo_de_datos","Programaci%C3%B3n_orientada_a_objetos","UML","Desarrollo_r%C3%A1pido_de_aplicaciones","Herramientas_CASE","Proceso_Unificado","Rational_Unified_Process","Complejidad","Requisito_(sistemas)","Proceso_para_el_desarrollo_de_software","IEEE_Computer_Society","Association_for_Computing_Machinery","Software_Engineering_Institute","British_Computer_Society","RUSSOFT","Consejo_General_de_Colegios_Oficiales_de_Ingenier%C3%ADa_T%C3%A9cnica_en_Inform%C3%A1tica","Ingenier%C3%ADa_de_sistemas","Ingenier%C3%ADa_inform%C3%A1tica","Gesti%C3%B3n_de_la_configuraci%C3%B3n","Proceso_para_el_desarrollo_de_software","Mantenimiento_de_software","Fragilidad_del_software","Error_de_software","Usabilidad","M%C3%89TRICA","Historia_de_la_ingenier%C3%ADa_del_software","Crisis_del_software","No_hay_balas_de_plata","IEEE_Computer_Society","ISBN","IEEE","Internet_Archive","Internet_Archive","ISBN","ISBN","Wayback_Machine","Universidad_de_los_Andes_(Colombia)","Wayback_Machine","Wayback_Machine","Addison_Wesley","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Simula","titulo":"Simula","contenido":"Simula es un lenguaje de programacion orientada a objetos (POO) de 1962. Fue el primero de este tipo que incluyo el concepto de clase. Varios a\u00f1os despues de su desarrollo, casi todos los lenguajes modernos comenzaron a utilizar sus principios de orientacion a objetos. Asi fue como se popularizaron terminos como clases, objetos, instancias, herencia, polimorfismo, etc.  Simula 67 fue lanzado oficialmente por sus autores Ole Johan Dahl y Kristen Nygaard en mayo de 1967, en la Conferencia de Trabajo en Lenguajes de Simulacion IFIO TC 2, en Lysebu cerca de Oslo  Hoy en dia, los creadores de Simula han desarrollado un nuevo lenguaje de programacion, llamado Beta, que generaliza todas las construcciones del lenguaje en una unica idea denominada patron.  Este es el famoso programa \"Hola Mundo\" en Simula 67:  Simula es un lenguaje orientado a objetos. Esto significa que el ejemplo de 'Hola Mundo' tambien se puede escribir instanciando una clase que se encarga de escribir el saludo.  Este programa tambien muestra \"\u00a1Hola Mundo!\".  El mensaje esta codificado en el bloque de codigo de la clase Saludos. Este bloque de codigo se ejecuta solamente cuando existe una instancia o variable de tipo Saludos; lo que ocurre efectivamente al crear una instancia por medio de la instruccion New.  En Simula, los objetos siempre son manejados por medio de referencias. Existe un recolector de basura que se encarga de eliminar de la memoria los objetos que se han quedado sin referencias a ellos. Una de estas referencias la vemos con variable objeto. Utilizamos el operador :- para asignar referencias.  A diferencia de muchos lenguajes modernos, Simula entiende de dos tipos de objetos.  Activos son aquellos objetos que aun no han completado su bloque asociado begin/end.  Inactivos por otra parte, han completado su bloque de instrucciones.  Tanto de unos como de otros, es posible ejecutar los procedimientos miembro y consultar los atributos en cualquier momento.  Dado que Simula 67 es un lenguaje ya un poco a\u00f1ejo, los conceptos que maneja son un poco distintos a los actualmente utilizados por la comunidad de programacion orientada a objetos. Las instancias a las que estamos habituados corresponden a los objetos inactivos. En tanto que el bloque de instrucciones constituye una serie de constructores.  En cuanto a los objetos activos, estos existen debido a una funcionalidad de pseudo-paralelismo encontrada en Simula y ausente en casi todos los lenguajes modernos. Esta funcionalidad recibe el nombre de co-rutina y es controlada directamente por el lenguaje por medio de un grupo de palabras clave.  Un grupo de objetos activos pueden coexistir en un mismo programa Simula, y transferir el control de unos a otros en cualquier momento. Esta funcionalidad es la base de las caracteristicas de simulacion que dan nombre al lenguaje. ","snippet":"Simula es un lenguaje de programacion orientada a objetos (POO) de 1962. Fue el primero de este tipo que incluyo el concepto de clase. Varios a\u00f1os despues de su desarrollo, casi todos los lenguajes mo","enlaces_salientes":["Simula","Simula","Simula","Lenguaje_de_programaci%C3%B3n","Programaci%C3%B3n_orientada_a_objetos","Ole_Johan_Dahl","Kristen_Nygaard","1967","Oslo","Programaci%C3%B3n_orientada_a_objetos","Bloque_de_c%C3%B3digo","Instancia_(programaci%C3%B3n)","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Programaci%C3%B3n_imperativa","titulo":"Programacion imperativa","contenido":"En ciencias de la computacion se denomina programacion imperativa a un paradigma de programacion de software que utiliza formulas que alteran el estado de un programa.  La programacion imperativa se considera el paradigma de programacion mas antiguo. Segun este, un programa es \u00abuna secuencia claramente definida de instrucciones para un ordenador\u00bb.\u200b  En una programacion imperativa, el codigo fuente encadena una serie de instrucciones que determinan lo que debe hacer un ordenador para alcanzar en cada momento un resultado deseado. Los valores usados en las variables se modifican mientras el programa se ejecuta, de tal modo que para gestionar las instrucciones, se integran estructuras de control como bucles o estructuras anidadas en el codigo fuente.\u200b  Los lenguajes de programacion imperativa son muy concretos. Esto permite que el codigo sea facilmente comprensible, aunque, como contraparte, requiere de muchas lineas de codigo para describir lo que en programacion declarativa se consigue con solo una parte de las instrucciones.\u200b ","snippet":"En ciencias de la computacion se denomina programacion imperativa a un paradigma de programacion de software que utiliza formulas que alteran el estado de un programa.  La programacion imperativa se c","enlaces_salientes":["Programaci%C3%B3n_imperativa","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_imperativa","Ciencias_de_la_computaci%C3%B3n","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n","Software","Estado_(inform%C3%A1tica)","Programa_inform%C3%A1tico","Programa_inform%C3%A1tico","C%C3%B3digo_fuente","Estructuras_de_control","Programaci%C3%B3n_declarativa","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Lenguaje_de_programaci%C3%B3n_C","titulo":"C (lenguaje de programacion)","contenido":"B (BCPL, CPL), ALGOL 68,\u200b:\u200a201-208  C es un lenguaje de programacion de proposito general\u200b:\u200a1\u200a originalmente desarrollado por Dennis Ritchie entre 1969 y 1972 en los Laboratorios Bell,\u200b como evolucion del anterior lenguaje B, a su vez basado en BCPL.\u200b:\u200a1\u200a\u200b\u200b  Al igual que B, es un lenguaje orientado a la implementacion de sistemas operativos, concretamente Unix. C es apreciado por la eficiencia del codigo que produce y es el lenguaje de programacion mas popular para crear softwares de sistemas y aplicaciones.  Se trata de un lenguaje de tipos de datos estaticos, debilmente tipado, que dispone de las estructuras tipicas de los lenguajes de alto nivel pero, a su vez, dispone de construcciones del lenguaje que permiten un control a bajo nivel. Los compiladores suelen ofrecer extensiones al lenguaje que posibilitan mezclar codigo en ensamblador con codigo C o acceder directamente a memoria o dispositivos perifericos.  La primera estandarizacion del lenguaje C fue en ANSI, con el estandar X3.159-1989. El lenguaje que define este estandar fue conocido vulgarmente como ANSI C. Posteriormente, en 1990, fue ratificado como estandar ISO (ISO/IEC 9899:1990). La adopcion de este estandar es muy amplia por lo que, si los programas creados lo siguen, el codigo es portable entre plataformas y/o arquitecturas.  Uno de los objetivos de dise\u00f1o del lenguaje C es que solo sean necesarias pocas instrucciones en lenguaje maquina para traducir cada elemento del lenguaje, sin que haga falta un soporte intenso en tiempo de ejecucion. Es muy posible escribir C a bajo nivel de abstraccion; de hecho, C se uso como intermediario entre diferentes lenguajes.  En parte, a causa de ser de relativamente bajo nivel y de tener un modesto conjunto de caracteristicas, se pueden desarrollar compiladores de C facilmente. En consecuencia, el lenguaje C esta disponible en un amplio abanico de plataformas (mas que cualquier otro lenguaje). Ademas, a pesar de su naturaleza de bajo nivel, el lenguaje se desarrollo para incentivar la programacion independiente de la maquina. Un programa escrito cumpliendo los estandares e intentando que sea portatil puede compilarse en muchos computadores.  C se desarrollo originalmente (conjuntamente con el sistema operativo Unix, con el que ha estado asociado mucho tiempo) por programadores para programadores. Sin embargo, ha alcanzado una popularidad enorme, y se ha usado en contextos muy alejados de la programacion de software de sistema, para la que se dise\u00f1o originalmente.  Los programadores novatos deben tener cuidado con la gestion de la memoria; en C el programador ha de reservar y liberar la memoria explicitamente. En otros lenguajes (como C# o Java) la memoria es gestionada de forma transparente para el programador. Esto alivia la carga de trabajo y evita errores, pero le quita flexibilidad al lenguaje para escribir controladores del hardware.  Por esta razon es muy importante que los recien iniciados adopten buenas practicas a la hora de escribir en C y manejar la memoria, como por ejemplo un uso intensivo de indentacion y conocer a fondo todo lo que implica el manejo de punteros y direcciones de memoria.  Aunque la lista de las caracteristicas utiles de las que carece C es larga, este factor ha sido importante para su aceptacion, porque escribir rapidamente nuevos compiladores para nuevas plataformas, mantiene lo que realmente hace el programa bajo el control directo del programador, y permite implementar la solucion mas natural para cada plataforma. Esta es la causa de que a menudo C sea mas eficiente que otros lenguajes. Tipicamente, solo la programacion cuidadosa en lenguaje ensamblador produce un codigo mas rapido, pues da control total sobre la maquina, aunque los avances en los compiladores de C y la complejidad creciente de los microprocesadores modernos han reducido gradualmente esta diferencia.  El lenguaje se puede extender mediante bibliotecas y macros. Por ejemplo, la implementacion original de C++ consistia en un preprocesador que traducia codigo fuente Q++ a Q  El desarrollo inicial de C se llevo a cabo en los Laboratorios Bell de AT&T entre 1969 y 1973; segun Dennis Ritchie, el periodo mas creativo tuvo lugar en 1972.\u200b Se le dio el nombre \"C\" porque muchas de sus caracteristicas fueron tomadas de un lenguaje anterior llamado \"B\".  Hay muchas leyendas acerca del origen de C y el sistema operativo con el que esta intimamente relacionado, Unix. Algunas de ellas son:  En 1973, el lenguaje C se habia vuelto tan potente que la mayor parte del kernel Unix, originalmente escrito en el lenguaje ensamblador PDP-11, fue reescrita en C.\u200b Este fue uno de los primeros nucleos de sistema operativo implementados en un lenguaje distinto al ensamblador. (Algunos casos anteriores son el sistema Multics, escrito en PL/I, y Master Control Program para el B5000 de Burroughs, escrito en ALGOL en 1961).  En 1978, Ritchie y Brian Kernighan publicaron la primera edicion de El lenguaje de programacion C, tambien conocido como La biblia de C. Este libro fue durante a\u00f1os la especificacion informal del lenguaje.\u200b:\u200a2\u200a El lenguaje descrito en este libro recibe habitualmente el nombre de \"el C de Kernighan y Ritchie\" o simplemente \"K&R C\" (La segunda edicion del libro cubre el estandar ANSI C, descrito mas abajo).  Kernighan y Ritchie introdujeron las siguientes caracteristicas al lenguaje:  El C de Kernighan y Ritchie es el subconjunto mas basico del lenguaje que un compilador debe de soportar. Durante muchos a\u00f1os, incluso tras la introduccion del ANSI C, fue considerado \"el minimo comun denominador\" en el que los programadores debian programar cuando deseaban que sus programas fueran transportables, pues no todos los compiladores soportaban completamente ANSI, y el codigo razonablemente bien escrito en K&R C es tambien codigo ANSI C valido.  En las primeras versiones del lenguaje, la definicion de funciones se hacia mediante un 'prototipo de funcion' (function prototype), el cual indicaba al compilador el tipo de retorno de la funcion. Aunque este metodo tiene una gran desventaja respecto al nuevo, debido a que no comprueba el numero ni el tipo en la lista de argumentos; en otras palabras, es mucho mas facil cometer errores al hacer una llamada a una funcion con argumentos incorrectos.  Ejemplo del \"viejo estilo\":  Ejemplo de la nueva definicion:  (*) Por defecto, el tipo de retorno en C es int, por lo que la declaracion entera int power(); podria haberse omitido.  En los a\u00f1os siguientes a la publicacion del C de Kernighan y Ritchie, se a\u00f1adieron al lenguaje muchas caracteristicas no oficiales, que estaba soportadas por los compiladores de AT&T, entre otros. Algunas de estas caracteristicas eran:  A finales de la decada de 1970, C empezo a sustituir a BASIC como lenguaje de programacion de microcomputadores predominante. Durante la decada de 1980 se empezo a usar en los IBM PC, lo que incremento su popularidad significativamente. Al mismo tiempo, Bjarne Stroustrup empezo a trabajar con algunos compa\u00f1eros de Bell Labs para a\u00f1adir funcionalidades de programacion orientada a objetos a C. El lenguaje que crearon, llamado C++, es hoy en dia el lenguaje de programacion de aplicaciones mas comun en el sistema operativo Microsoft Windows; mientras que C sigue siendo mas popular en el entorno Unix. Otro lenguaje que se desarrollo en esa epoca, Objective C, tambien a\u00f1adio caracteristicas de programacion orientada a objetos a C. Aunque hoy en dia no es tan popular como C++, se usa para desarrollar aplicaciones Cocoa para Mac OS X.  En 1983, el Instituto Nacional Estadounidense de Estandares (ANSI) organizo un comite, X3j11, para establecer una especificacion estandar de C. Tras un proceso largo y arduo, se completo el estandar en 1989 y se ratifico como el \"Lenguaje de Programacion C\" ANSI X3.159-1989. Esta version del lenguaje se conoce a menudo como ANSI C, o a veces como C89 (para distinguirla de C99).  En 1990, el estandar ANSI (con algunas modificaciones menores) fue adoptado por la Organizacion Internacional para la Estandarizacion (ISO) en el estandar ISO/IEC 9899:1990. Esta version se conoce a veces como C90. No obstante, \"C89\" y \"C90\" se refieren en esencia al mismo lenguaje.  Uno de los objetivos del proceso de estandarizacion del ANSI C fue producir una extension al C de Kernighan y Ritchie, incorporando muchas funcionalidades no oficiales. Sin embargo, el comite de estandarizacion incluyo tambien muchas funcionalidades nuevas, como prototipos de funcion, y un preprocesador mejorado. Tambien se cambio la sintaxis de la declaracion de parametros para hacerla semejante a la empleada habitualmente en C++:  paso a ser:  ANSI C esta soportado hoy en dia por casi la totalidad de los compiladores. La mayoria del codigo C que se escribe actualmente esta basado en ANSI C. Cualquier programa escrito solo en C estandar sin codigo que dependa de un hardware determinado funciona correctamente en cualquier plataforma que disponga de una implementacion de C compatible. Sin embargo, muchos programas han sido escritos de forma que solo pueden compilarse en una cierta plataforma, o con un compilador concreto, esto puede ser debido a diversos motivos:  La macro __STDC__ puede usarse para dividir el codigo en secciones ANSI y K&R para el compilador.  Algunos programadores recomiendan usar \"#if __STDC__\", como en el ejemplo, en lugar de \"#ifdef __STDC__\" porque algunos compiladores le asignan el valor cero a __STDC__ para indicar que no son compatibles con ANSI.  En el siguiente ejemplo, el programa pide al usuario que introduzca un numero. El programa dividira dicho numero entre 2 e imprimira el resultado mientras que este sea par, y terminara cuando el numero sea impar:  Tras el proceso de estandarizacion de ANSI, la especificacion del lenguaje C permanecio relativamente estable durante algun tiempo, mientras que C++ siguio evolucionando. Sin embargo, el estandar continuo bajo revision a finales de la decada de 1990, lo que llevo a la publicacion del estandar ISO 9899:1999 en 1999.\u200b Este estandar se denomina habitualmente \"C99\". Se adopto como estandar ANSI en marzo de 2000.  Las nuevas caracteristicas de C99 incluyen:\u200b:\u200axi\u2013xii  El compilador GCC, entre muchos otros, soportan hoy en dia la mayoria de las nuevas caracteristicas de C99. Sin embargo, este nuevo estandar ha tenido poca acogida entre algunos desarrolladores de compiladores, como Microsoft y Borland, que se han centrado en C++. Brandon Bray, de Microsoft, dijo a este respecto:  C11 (antes conocido como C2X) es un nombre informal para ISO/IEC 9899:2011\u200b. El borrador final, N1570, fue publicado en abril de 2011.\u200b El nuevo estandar supero su ultima revision el 10 de octubre de 2011 y fue oficialmente ratificado por la ISO y publicado el 8 de diciembre de 2011.  Historicamente la programacion en C embebido ha requerido extensiones no estandar del lenguaje C para implementar caracteristicas no oficiales tales como aritmetica de punto fijo y operaciones basicas de entrada y salida.  En 2008 el comite de estandarizacion de C, para implementar estas caracteristicas no oficiales, publico un informe tecnico en el que extendia el lenguaje C proporcionando un estandar comun al que todas las implementaciones se podian adherir. Incluia varias caracteristicas no disponibles en C normal, tales como aritmetica de punto fijo, espacios de direcciones con nombres y direccionamiento por hardware de entrada y salida basico.  El ultimo estandar publicado para C ISO/IEC 9899:2018.\u200b  Desde el inicio del lenguaje han surgido varias ramas de evolucion que han generado varios lenguajes:  Tambien se han creado numerosos lenguajes inspirados en la sintaxis de C, pero que no son compatibles con el:  La compilacion de un programa C se realiza en varias fases que normalmente son automatizadas y ocultadas por los entornos de desarrollo:  El siguiente programa imprime en pantalla la frase \"Hola Mundo\" (C99).   El siguiente programa muestra el uso de punteros en C. El siguiente escribe \"Hola Mundo\" en C89  Estructura de control \"else if\"  Al programar en C, es habitual usar algunas herramientas de programacion de uso muy extendido, sobre todo en entorno de tipo Unix:  Hecho principalmente para la fluidez de programacion en sistemas Unix. Se usa tambien para el desarrollo de otros sistemas operativos como Windows o GNU/Linux. Igualmente para aplicaciones de escritorio como GIMP, cuyo principal lenguaje de programacion es C.  De la misma forma, es muy usado en aplicaciones cientificas (para experimentos informaticos, fisicos, quimicos, matematicos, entre otros, parte de ellos conocidos como modelos y simuladores), industriales (industria robotica, cibernetica, sistemas de informacion y base de datos para la industria petrolera y petroquimica. Predominan tambien todo lo que se refiere a simulacion de maquinas de manufactura), simulaciones de vuelo (es la mas delicada, ya que se tienen que usar demasiados recursos tanto de hardware como de software para desarrollar aplicaciones que permitan simular el vuelo real de una aeronave). Se aplica por tanto, en diversas areas desconocidas por gran parte de los usuarios noveles.  Los ordenadores de finales de los 90 son varios ordenes de magnitud mas potentes que las maquinas en que C se desarrollo originalmente. Programas escritos en lenguajes de tipo dinamico y facil codificacion (Ruby, Python, Perl...) que anta\u00f1o hubieran resultado demasiado lentos, son lo bastante rapidos como para desplazar en uso a C. Aun asi, se puede seguir encontrando codigo C en grandes desarrollos de animaciones, modelados y escenas en 3D en peliculas y otras aplicaciones multimedia.  Actualmente, los grandes proyectos de software se dividen en partes, dentro de un equipo de desarrollo. Aquellas partes que son mas \"burocraticas\" o \"de gestion\" con los recursos del sistema, se suelen realizar en lenguajes de tipo dinamico o de guion (script), mientras que aquellas partes \"criticas\", por su necesidad de rapidez de ejecucion, se realizan en un lenguaje de tipo compilado, como C o C++. Si, despues de hacer la division, las partes criticas no superan un cierto porcentaje del total (aproximadamente el 10%) entonces todo el desarrollo se realiza con lenguajes dinamicos. Si la parte critica no llega a cumplir las expectativas del proyecto, se comparan las alternativas de una inversion en nuevo hardware frente a invertir en el coste de un programador para que reescriba dicha parte critica.  C es el lenguaje comun para programar sistemas embebidos.[cita\u00a0requerida] El codigo ligero que un compilador C genera, combinado con la capacidad de acceso a capas del software cercanas al hardware son la causa de su popularidad en estas aplicaciones.  Una caracteristica donde C demuestra comodidad de uso particularmente valiosa en sistemas embebidos es la manipulacion de bits. Los sistemas contienen registros mapeados en memoria (en ingles, MMR) a traves de los cuales los perifericos se configuran. Estos registros mezclan varias configuraciones en la misma direccion de memoria, aunque en bits distintos. Con C es posible modificar facilmente uno de estos bits sin alterar el resto. Por ejemplo:  Este tipo de manipulacion es muy tediosa o sencillamente imposible en otros lenguajes de alto nivel, dado que se utilizan operaciones comunes del lenguaje ensamblador como las operaciones a nivel bit OR, AND, SHL y CPL pero que estan disponibles en el lenguaje C.  Otras caracteristicas de C consideradas desventajas en la programacion para PC -como la ausencia de control de memoria automatico- se convierten en ventajas cuando los sistemas embebidos necesitan codigo peque\u00f1o y optimizado. Ese es el caso de los sistemas basados en microcontroladores de poca potencia como el intel 8051 o muchos sistemas ARM.  Una biblioteca de C es una coleccion de funciones utilizadas en el lenguaje de programacion C. Las bibliotecas mas comunes son la biblioteca estandar de C y la biblioteca del estandar ANSI C, la cual provee las especificaciones de los estandares que son ampliamente compartidas entre bibliotecas. La biblioteca ANSI C estandar, incluye funciones para la entrada y salida de archivos, alojamiento de memoria y operaciones con datos comunes: funciones matematicas, funciones de manejo de cadenas de texto y funciones de hora y fecha.  Otras bibliotecas C son aquellas utilizadas para desarrollar sistemas Unix, las cuales proveen interfaces hacia el nucleo. Estas funciones son detalladas en varios estandares tales como POSIX y el Single UNIX Specification.  Ya que muchos programas han sido escritos en el lenguaje C existe una gran variedad de bibliotecas disponibles. Muchas bibliotecas son escritas en C debido a que C genera codigo objeto rapido; los programadores luego generan interfaces a la biblioteca para que las rutinas puedan ser utilizadas desde lenguajes de mayor nivel, tales como Java, Perl y Python. ","snippet":"B (BCPL, CPL), ALGOL 68,\u200b:\u200a201-208  C es un lenguaje de programacion de proposito general\u200b:\u200a1\u200a originalmente desarrollado por Dennis Ritchie entre 1969 y 1972 en los Laboratorios Bell,\u200b como evolucion","enlaces_salientes":["C_(lenguaje_de_programaci%C3%B3n)","C_(lenguaje_de_programaci%C3%B3n)","C_(lenguaje_de_programaci%C3%B3n)","Dennis_Ritchie","Laboratorios_Bell","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_procedural","Programaci%C3%B3n_estructurada","1972","Dennis_Ritchie","Sistema_de_tipos","GCC","Intel_C%2B%2B_Compiler","Unified_Parallel_C","Cilk","B_(lenguaje_de_programaci%C3%B3n)","BCPL","Combined_Programming_Language","ALGOL#Algol_68","Lenguaje_ensamblador","PL/I","Fortran","Vala_(lenguaje_de_programaci%C3%B3n)","C_Sharp","Objective-C","C%2B%2B","AWK","Lenguaje_de_programaci%C3%B3n_bc","Java_(lenguaje_de_programaci%C3%B3n)","JavaScript","PHP","Perl","D_(lenguaje_de_programaci%C3%B3n)","Go_(lenguaje_de_programaci%C3%B3n)","Rust_(lenguaje_de_programaci%C3%B3n)","Python","Sistema_operativo","Multiplataforma","Lenguaje_de_programaci%C3%B3n","Dennis_Ritchie","1969","1972","Laboratorios_Bell","B_(lenguaje_de_programaci%C3%B3n)","BCPL","Sistema_operativo","Unix","Lenguajes_de_alto_nivel","Lenguaje_de_bajo_nivel","Lenguaje_ensamblador","Memoria_de_ordenador","Dispositivos_perif%C3%A9ricos","ANSI","ANSI_C","ISO","Lenguaje_m%C3%A1quina","Unix","Programaci%C3%B3n","Software_de_sistema","Gesti%C3%B3n_de_archivos","Biblioteca_(inform%C3%A1tica)","Preprocesador","Preprocesador_de_C","Macro","C%C3%B3digo_fuente","Puntero_(programaci%C3%B3n)","Palabra_clave","Control_Data_Corporation","Indentaci%C3%B3n","Recolecci%C3%B3n_de_basura","Sun_Microsystems","Programaci%C3%B3n_orientada_a_objetos","C%2B%2B","GObject","GCC","Multihilo","Compilador","Lenguaje_ensamblador","Microprocesador","C%2B%2B","Dennis_Ritchie","Ken_Thompson","Laboratorios_Bell","AT%26T","Dennis_Ritchie","Lenguaje_de_programaci%C3%B3n_B","Mainframe","Ken_Thompson","Dennis_Ritchie","PDP-7","Sistema_operativo","PDP-11","N%C3%BAcleo_(inform%C3%A1tica)","Multics","PL/I","B5000","ALGOL","Dennis_Ritchie","Brian_Kernighan","El_lenguaje_de_programaci%C3%B3n_C","Especificaci%C3%B3n","ANSI_C","ANSI_C","BASIC","IBM_PC","Bjarne_Stroustrup","C%2B%2B","Microsoft_Windows","Objective_C","Cocoa_(inform%C3%A1tica)","Mac_OS_X","Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","ANSI_C","Organizaci%C3%B3n_Internacional_para_la_Estandarizaci%C3%B3n","C%2B%2B","D%C3%A9cada_de_1990","Variable_(programaci%C3%B3n)","Booleano","N%C3%BAmeros_complejos","Array","BCPL","Archivo_de_cabecera","Microsoft","Borland","Objective-C","Programaci%C3%B3n_orientada_a_objetos","Mac_OS_X","IOS_(sistema_operativo)","GNUstep","C%2B%2B","Bjarne_Stroustrup","Programaci%C3%B3n_orientada_a_objetos","Lenguaje_de_programaci%C3%B3n_Java","Smalltalk","Objective_C","JavaScript","Scripting","Netscape_Communications_Corporation","P%C3%A1gina_web","ECMAScript","C_Sharp","Microsoft","Java_(lenguaje_de_programaci%C3%B3n)","Compilador","Preprocesado","C%C3%B3digo_fuente","Compilador","Compilaci%C3%B3n","C%C3%B3digo_objeto","Enlazado","C%C3%B3digo_objeto","C%C3%B3digo_objeto","Unix","Make","Lint","Valgrind","Fuga_de_memoria","GNU_Debugger","Dbx_(depurador)","Data_Display_Debugger","Programaci%C3%B3n","Unix","Sistemas_operativos","Windows","GNU/Linux","Escritorio","GIMP","Experimento","F%C3%ADsica","Qu%C3%ADmica","Matem%C3%A1ticas","Modelo_matem%C3%A1tico","Simulaci%C3%B3n","Industria","Rob%C3%B3tica","Cibern%C3%A9tica","Sistemas_de_informaci%C3%B3n","Base_de_datos","Industria_petrolera","Petroqu%C3%ADmica","Simulaci%C3%B3n","M%C3%A1quinas","Simulador_de_vuelo","Hardware","Software","Vuelo","Aeronave","Usuarios","Ruby","Python","Perl","Animaciones","Pel%C3%ADcula","Multimedia","Sistema_embebido","E/S_mapeada_en_memoria","Lenguaje_ensamblador","Bitwise","Intel_8051","Arquitectura_ARM","Biblioteca_est%C3%A1ndar_de_C","Unix","N%C3%BAcleo_(inform%C3%A1tica)","POSIX","Single_UNIX_Specification","C%C3%B3digo_objeto","Lenguaje_de_programaci%C3%B3n_Java","Perl","Python","C%2B%2B","Dennis_Ritchie","Digital_object_identifier","Brian_Kernighan","Dennis_Ritchie","ISBN","Eric_S._Raymond","ISBN","Eric_S._Raymond","International_Organization_for_Standardization","International_Organization_for_Standardization","International_Organization_for_Standardization","International_Organization_for_Standardization","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Programaci%C3%B3n_dirigida_por_eventos","titulo":"Programacion dirigida por eventos","contenido":"La programacion dirigida por eventos es un paradigma de programacion en el que tanto la estructura como la ejecucion de los programas van determinados por los sucesos que ocurran en el sistema, definidos por el usuario o que ellos mismos provoquen.  Para entender la programacion dirigida por eventos, podemos oponerla a lo que no es: mientras en la programacion secuencial (o estructurada) es el programador el que define cual va a ser el flujo del programa, en la programacion dirigida por eventos sera el propio usuario \u2014o lo que sea que este accionando el programa\u2014 el que dirija el flujo del programa. Aunque en la programacion secuencial puede haber intervencion de un agente externo al programa, estas intervenciones ocurriran cuando el programador lo haya determinado, y no en cualquier momento como puede ser en el caso de la programacion dirigida por eventos.  El creador de un programa dirigido por eventos debe definir los eventos que manejaran su programa y las acciones que se realizaran al producirse cada uno de ellos, lo que se conoce como el administrador de evento. Los eventos soportados estaran determinados por el lenguaje de programacion utilizado, por el sistema operativo e incluso por eventos creados por el mismo programador.  En la programacion dirigida por eventos, al comenzar la ejecucion del programa se llevaran a cabo las inicializaciones y demas codigo inicial y a continuacion el programa quedara bloqueado hasta que se produzca algun evento. Cuando alguno de los eventos esperados por el programa tenga lugar, el programa pasara a ejecutar el codigo del correspondiente administrador de evento. Por ejemplo, si el evento consiste en que el usuario ha hecho clic en el boton de play de un reproductor de peliculas, se ejecutara el codigo del administrador de evento, que sera el que haga que la pelicula se muestre por pantalla.  Un ejemplo claro lo tenemos en los sistemas de programacion Lexico y Visual Basic, en los que a cada elemento del programa (objetos, controles, etcetera) se le asignan una serie de eventos que generara dicho elemento, como la pulsacion de un boton del raton sobre el o el redibujado del control. O en Javascript que asigna manejadores de eventos a los que responder a eventos en una web en el caso del navegador o a eventos producidos por objetos emisores en el caso de NodeJS.  La programacion dirigida por eventos es la base de lo que llamamos interfaz de usuario, aunque puede emplearse tambien para desarrollar interfaces entre componentes de Software o modulos del nucleo.  En los primeros tiempos de la computacion, los programas eran secuenciales, tambien llamados Batch. Un programa secuencial arranca, lee parametros de entrada, procesa estos parametros, y produce un resultado, todo de manera lineal y sin intervencion del usuario mientras se ejecuta.  Con la aparicion y popularizacion de los PC, el software empezo a ser demandado para usos alejados de los clasicos academicos y empresariales para los cuales era necesitado hasta entonces, y quedo patente que el paradigma clasico de programacion no podia responder a las nuevas necesidades de interaccion con el usuario que surgieron a raiz de este hecho.  En contraposicion al modelo clasico, la programacion orientada a eventos permite interactuar con el usuario en cualquier momento de la ejecucion. Esto se consigue debido a que los programas creados bajo esta arquitectura se componen por un bucle exterior permanente encargado de recoger los eventos, y distintos procesos que se encargan de tratarlos. Habitualmente, este bucle externo permanece oculto al programador que simplemente se encarga de tratar los eventos, aunque en algunos entornos de desarrollo (IDE) sera necesaria su construccion.  Ejemplo de programa orientado a eventos en pseudo lenguaje:  La programacion orientada a eventos supone una complicacion a\u00f1adida con respecto a otros paradigmas de programacion, debido a que el flujo de ejecucion del software escapa al control del programador. En cierta manera podriamos decir que en la programacion clasica el flujo estaba en poder del programador y era este quien decidia el orden de ejecucion de los procesos, mientras que en programacion orientada a eventos, es el usuario el que controla el flujo y decide.  Pongamos como ejemplo de la problematica existente, un menu con dos botones, boton 1 y boton 2. Cuando el usuario pulsa boton 1, el programa se encarga de recoger ciertos parametros que estan almacenados en un fichero y calcular algunas variables. Cuando el usuario pulsa el boton 2, se le muestran al usuario por pantalla dichas variables. Es sencillo darse cuenta de que la naturaleza indeterminada de las acciones del usuario y las caracteristicas de este paradigma pueden facilmente desembocar en el error fatal de que se pulse el boton 2 sin previamente haber sido pulsado el boton 1. Aunque esto no pasa si se tienen en cuenta las propiedades de dichos botones, haciendo inaccesible la pulsacion sobre el boton 2 hasta que previamente se haya pulsado el boton 1.  Con la evolucion de los lenguajes orientados a eventos, la interaccion del software con el usuario ha mejorado enormemente permitiendo la aparicion de interfaces que, aparte de ser la via de comunicacion del programa con el usuario, son la propia apariencia del mismo. Estas interfaces, tambien llamadas GUI (Graphical User Interface), han sido la herramienta imprescindible para acercar la informatica a los usuarios, permitiendo en muchos casos, a principiantes utilizar de manera intuitiva y sin necesidad de grandes conocimientos, el software que ha colaborado a mejorar la productividad en muchas tareas.  Uno de los perifericos que ha cobrado mayor importancia tras la aparicion de los programas orientados a eventos ha sido el raton, gracias tambien en parte a la aparicion de los sistemas operativos modernos con sus interfaces graficas. Estas suelen dirigir directamente al controlador interior que va entrelazado al algoritmo.  Con el paso del tiempo, han ido apareciendo una nueva generacion de herramientas que incluyen codigo que automatiza parte de las tareas mas comunes en la deteccion y tratamiento de eventos.  Destacan particularmente los entornos de programacion visual que conjugan una herramienta de dise\u00f1o grafica para la GUI y un lenguaje de alto nivel. Entre estas herramientas se encuentra la conocida Visual Basic, lenguaje altamente apreciado por principiantes debido a la facilidad para desarrollar software en poco tiempo y con pocos conocimientos, y denostado por tantos otros debido a su falta de eficiencia. ","snippet":"La programacion dirigida por eventos es un paradigma de programacion en el que tanto la estructura como la ejecucion de los programas van determinados por los sucesos que ocurran en el sistema, defini","enlaces_salientes":["Programaci%C3%B3n_dirigida_por_eventos","Programaci%C3%B3n_dirigida_por_eventos","Programaci%C3%B3n_dirigida_por_eventos","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_estructurada","Lenguaje_de_programaci%C3%B3n","Sistema_operativo","L%C3%A9xico","Visual_Basic","Javascript","Interfaz_de_usuario","M%C3%B3dulo_de_n%C3%BAcleo","Paradigma_de_programaci%C3%B3n","Interfaz_gr%C3%A1fica_de_usuario","ActionScript","Visual_Basic","Visual_C%2B%2B","Visual_Basic_.NET","C_Sharp","J_Sharp","L%C3%A9xico","ActionScript","Qt_(biblioteca)","GTK%2B","AWT","Swing_(biblioteca_gr%C3%A1fica)","SWT","JavaFX","ASP.NET","ASP.NET#El_modelo_Code-behind","Programaci%C3%B3n_estructurada","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_l%C3%B3gica","Bertrand_Meyer","ISBN","Portland_Pattern_Repository","Control_de_autoridades"]}
{"url":"Programaci%C3%B3n_declarativa","titulo":"Programacion declarativa","contenido":"En ciencias de la computacion se denomina programacion declarativa a un paradigma de programacion de software en el que no se detallan los pasos a seguir, sino solo el resultado deseado con cierto codigo fuente.\u200b  La programacion declarativa no determina el como, sino que funciona con un nivel de abstraccion mas alto que la programacion imperativa. A diferencia de esta, la programacion declarativa deja margen para la optimizacion. Este tipo de paradigma da como resultado un software mejor preparado para el futuro, ya que no es necesario determinar mediante que procedimiento se alcanza un resultado.\u200b  Una ventaja de la programacion declarativa es que tiene la capacidad de describir problemas de forma mas corta y precisa que el lenguaje imperativo.\u200b ","snippet":"En ciencias de la computacion se denomina programacion declarativa a un paradigma de programacion de software en el que no se detallan los pasos a seguir, sino solo el resultado deseado con cierto cod","enlaces_salientes":["Programaci%C3%B3n_declarativa","Programaci%C3%B3n_declarativa","Programaci%C3%B3n_declarativa","Ciencias_de_la_computaci%C3%B3n","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n","Software","C%C3%B3digo_fuente","Programaci%C3%B3n_imperativa","Optimizaci%C3%B3n_de_software","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Transparencia_referencial","titulo":"Transparencia referencial","contenido":"La transparencia referencial es un termino utilizado en la programacion funcional que se refiere a la propiedad por la cual \"en un programa, una expresion E del lenguaje puede ser sustituida por otra de igual valor V, resultando en un programa cuya semantica no va a diferir de la del original\".  En otras palabras, el resultado de evaluar una expresion compuesta depende unicamente del resultado de evaluar las subexpresiones que la componen y de nada mas; no depende de la historia del programa en ejecucion ni del orden de evaluacion de las subexpresiones que la componen.  Esta propiedad no se da en lenguajes imperativos, donde abundan los efectos colaterales por asignaciones destructivas. Por ejemplo, en esta clase escrita en lenguaje Java:  No podemos sustituir dame() por su valor, en el metodo hola(), pues suprimiriamos el efecto lateral de incremento dando un estado del programa diferente al original. La sustitucion de una expresion por su valor genera un estado diferente.  Como ya se ha dicho, otra complicacion de los lenguajes sin transparencia referencial es que dificultan el razonamiento ecuacional: los metodos a1(),a2() no devuelven los mismos resultados con un mismo valor inicial de m. Por ejemplo: para m=0, a1() devolvera 0 la primera vez que se ejecute, mientras que a2() devolvera 1 la primera vez que se ejecute.   La transparencia referencial es muy util a la hora de modificar un programa, ya que no tenemos que preocuparnos de que las modificaciones que hagamos en una parte del mismo afecten los calculos que se hacen en otras. Tambien es muy poderosa a la hora de verificar un programa (demostrar matematicamente que cumple la especificacion), ya que podemos utilizar propiedades ya demostradas de todas las subexpresiones que constituyen una expresion y que son validas en cualquier contexto.   ","snippet":"La transparencia referencial es un termino utilizado en la programacion funcional que se refiere a la propiedad por la cual \"en un programa, una expresion E del lenguaje puede ser sustituida por otra ","enlaces_salientes":["Transparencia_referencial","Transparencia_referencial","Transparencia_referencial","Programaci%C3%B3n_funcional","Lenguajes_imperativos","Lenguaje_de_programaci%C3%B3n_Java","Control_de_autoridades"]}
{"url":"Scheme","titulo":"Scheme","contenido":"Scheme es un lenguaje de programacion funcional (si bien impuro pues sus estructuras de datos no son inmutables) y un dialecto de Lisp. Fue desarrollado por Guy L. Steele y Gerald Jay Sussman en la decada de los setenta e introducido en el mundo academico a traves de una serie de articulos conocidos como los Lambda Papers de Sussman y Steele.  La filosofia de Scheme es minimalista. Su objetivo no es acumular un gran numero de funcionalidades, sino evitar las debilidades y restricciones que hacen necesaria su adicion. Asi, Scheme proporciona el minimo numero posible de nociones primitivas, construyendo todo lo demas a partir de un reducido numero de abstracciones. Por ejemplo, el mecanismo principal para el control de flujo son las llamadas recursivas.  Scheme fue el primer dialecto de Lisp que uso ambito estatico, tambien conocido como ambito lexico, (en lugar de dinamico) de forma exclusiva. Tambien fue uno de los primeros lenguajes de programacion con continuaciones explicitas, un mecanismo para guardar y usar el estado entero de un programa en un momento determinado. Scheme ofrece tambien gestion automatica de memoria (recoleccion de basura).  Las listas son la estructura de datos basica del lenguaje, que tambien ofrece arrays entre sus tipos predefinidos. Debido a su especificacion minimalista, no hay sintaxis explicita para crear registros o estructuras, o para programacion orientada a objetos, pero muchas implementaciones ofrecen dichas funcionalidades.  Scheme se llamaba originalmente \"Schemer\", siguiendo la tradicion de los lenguajes Planner y Conniver. Su nombre actual es debido a que sus autores usaban el sistema operativo ITS, que limitaba la longitud de los nombres de fichero a 6 caracteres.  Scheme, como todos los dialectos de Lisp, tiene una sintaxis muy reducida comparado con muchos otros lenguajes. No necesita reglas de precedencia en su gramatica, ya que usa notacion prefija para todas las llamadas a funcion. En el mundo de Lisp tales expresiones son conocidas como S-expressions.  El poder caracteristico de los Lisp reside en la simpleza de su sintaxis homoiconica hecha de listas anidadas, que refleja la estructura del arbol de sintaxis abstracta del programa y lo pone a disposicion del programador. Esto facilita la metaprogramacion mediante macros. Las macros de Scheme permiten adaptarlo a nuevos dominios con facilidad, por ejemplo, para a\u00f1adir soporte a la programacion orientada a objetos. Existe por ejemplo una extension que implementa un sistema de objetos escrito en menos de mil lineas de codigo de Scheme, incluyendo comentarios.\u200b Scheme proporciona un sistema de macros higienico que, aunque no tan potente como el de Common Lisp, es mucho mas seguro y, con frecuencia, sencillo de utilizar. La ventaja de un sistema de macros de este tipo (que tambien se encuentra en otros lenguajes, como Dylan) es que evita automaticamente colisiones entre los nombres usados en la definicion de la macro y en el contexto en que esta se expande. En contrapartida, las macros higienicas no pueden introducir nuevos simbolos.  Scheme facilita la programacion funcional. Aunque Scheme es impuro porque permite la asignacion destructiva, usarlo al estilo de la programacion funcional pura evita variables globales y sufrir de efectos secundarios, haciendolo mas seguro en presencia de procesos concurrentes (thread-safe), amen de facilitar considerablemente la verificacion de programas, al menos en comparacion con el estilo imperativo.  En Scheme, los procedimientos o funciones son objetos de primera clase. Ello permite la definicion de funciones de orden superior; funciones que reciben o devuelven otras funciones, que facilitan un mayor grado de abstraccion en los programas. Tambien es posible la creacion de procedimientos anonimos (literales) mediante el primitivo (lambda (arg1 ...) (...)).  El estandar de Scheme es tambien minimalista. Ello conlleva ventajas e inconvenientes. Por ejemplo, escribir un compilador o interprete de Scheme que sea fiel al estandar es mas facil que implementar uno de Common Lisp; empotrar Lisp en dispositivos con poca memoria sera tambien mas factible si usamos Scheme en lugar de Common Lisp. A los aficionados a Scheme les divierte mucho se\u00f1alar que su estandar, con solo 50 paginas, es mas corto que el indice del libro de Guy Steele Common Lisp: The Language.  El estandar de Scheme es realmente minimalista y especifico en si. Ello provoca que existan multitud de implementaciones diferentes, cada una de las cuales introduce extensiones y bibliotecas propias que las hace incompatibles entre si. Los Scheme Requests for Implementation (SRFI) tratan de poner remedio a este problema.  Hay quien ve el hecho de que los procedimientos y variables compartan el mismo espacio de nombres como una desventaja, ya que algunas funciones tienen nombres que son de uso comun para variables. Por ejemplo, list es el nombre de un procedimiento, asi que es muy habitual ver lst o xs como nombres de variables, en lugar de \"list\".  Como hemos dicho, el espacio de nombres es unico (Scheme es un LISP-1) y, por tanto, tambien incluye a las macros. Ello hace imposible distinguir el uso de una macro del de una funcion, asi que, si no consultamos la definicion de cada uno de los objetos usados, no sera en general posible determinar el orden de evaluacion en programas con los que no estemos familiarizados.  Existen dos estandares que definen el lenguaje de programacion Scheme: el estandar oficial de la IEEE, y un estandar de facto conocido como Revisedn-th Report on the Algorithmic Language Scheme, casi siempre abreviado como RnRS, donde n es el numero de la revision. El ultimo RnRS es R6RS, y esta displonible en linea.  Para agregar un comentario en Scheme se inicia con un punto y coma (;) y continuan hasta el final de la linea.  Las variables son dinamicamente tipadas. Para asociarlas a un valor concreto, podemos usar define, una expresion let, o alguna de sus variantes. Las variables asignadas en el primer nivel usando define estan en ambito global (es decir, son visibles en el resto de programa).  Las variables asignadas mediante let ven su ambito reducido al cuerpo de dicho let:  Las funciones o procedimientos son objetos de primera clase en Scheme. Pueden ser asignados a variables. Por ejemplo, una funcion de dos argumentos arg1 y arg2 puede definirse como:  o en la forma abreviada equivalente:  Las llamadas a funcion tienen la sintaxis siguiente:  Como vemos, la funcion invocada se encuentra en primer lugar, seguida de los argumentos de la llamada, formando una lista. Podemos tambien utilizar el procedimiento apply, que toma dos argumentos: el primero es el procedimiento que queremos invocar, mientras que el segundo es la lista de argumentos. Asi, la anterior llamada a funcion puede escribirse, de forma equivalente, como:  En Scheme, las funciones se dividen, basicamente, en dos categorias: los procedimientos definidos por el usuario y las primitivas. Las primitivas estan pre-definidas en el lenguaje, e incluyen +, -, *, /, set!, car, cdr, y otros procedimientos basicos. Muchas implementaciones permiten al usuario redefinir algunas primitivas. Por ejemplo, el siguiente codigo:  convierte la primitiva + en un procedimiento definido por el usuario que resta sus dos argumentos en lugar de sumarlos.  Scheme usa listas enlazadas de forma analoga a otros dialectos de Lisp.  Tengase en cuenta que la utilizacion de listas es mucho mas sencilla que en otros lenguajes de programacion tales como C, C++ y Pascal.  Otros tipos de datos en Scheme son los enteros, racionales, reales, complejos, simbolos, cadenas, y puertos, listas asociativas, tablas hash, vectores, arrays y estructuras.  La mayoria de implementaciones proporciona lo que se conoce como una torre numerica completa, asi como aritmetica exacta e inexacta.  Los valores booleanos se representan mediante los simbolos #t y #f. En realidad, cualquier valor distinto de #f (incluyendo la lista vacia) se interpreta como 'verdadero' en un contexto adecuado, mientras que en otros dialectos de Lisp la lista vacia es interpretada como el valor booleano falso.  Los simbolos pueden ser definidos de varias maneras, siendo  las mas comunes.  Scheme tiene tres tipos diferentes de igualdad:  Tambien existen en Scheme los operadores de equivalencia dependientes del tipo:  La primera expresion para la que la prueba resulte ser cierto (cualquier cosa salvo #f cuenta como cierto) sera evaluada. Si todas las pruebas resultan ser #f, se evalua la clausula else.  Una variante de la clausula cond es:  En este caso, expr debe resultar en una funcion que toma un solo argumento. Si test resulta ser cierto, se llama a la funcion anterior con el valor devuelto por test.  Scheme tambien tiene:  pero se usa mucho menos porque cond es mas general y normalmente resulta mas legible.  Los bucles en Scheme suelen tomar la forma de una recursion final o tail recursion en ingles. Este tipo de recursion es preferido porque dispensa la acumulacion de tramas en la pila de llamadas y su subsecuente desbordamiento. El estandar exige a las implementaciones optimizar llamadas en posicion de recursion final para generar codigo equivalente a un ciclo en lenguajes imperativos. Un ejemplo clasico es la funcion factorial, que puede definirse sin recursion final como:  O con recursion final usando un procedimiento extra:  Otra forma tipica de bucle es una funcion de orden superior como map, que aplica una funcion a cada elemento de una lista, puede tambien definirse sin recursion final de la siguiente forma:  Podemos definir ambas usando la recursion final como sigue. La expresion let con nombre y la sentencia do son azucar sintactica que simplifica las definiciones con recursion final.  Adviertase que en ambos casos se prefiere la version con recursion final debido a su menor uso de espacio.  Scheme tiene el concepto de puertos de donde leer o a los que escribir. Scheme define tres puertos por defecto, accesibles con las funciones current-input-port, current-output-port y current-error-port. ","snippet":"Scheme es un lenguaje de programacion funcional (si bien impuro pues sus estructuras de datos no son inmutables) y un dialecto de Lisp. Fue desarrollado por Guy L. Steele y Gerald Jay Sussman en la de","enlaces_salientes":["Scheme","Scheme","Scheme","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","1975","Sistema_de_tipos","GNU_Guile","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n_funcional","Dialecto_(programaci%C3%B3n)","Lisp","A%C3%B1os_1970","Minimalismo","Recursi%C3%B3n_(ciencias_de_computaci%C3%B3n)","%C3%81mbito_(programaci%C3%B3n)","%C3%81mbito_(programaci%C3%B3n)","Recolector_de_basura","Programaci%C3%B3n_orientada_a_objetos","Incompatible_Timesharing_System","Lisp","Orden_de_evaluaci%C3%B3n","Notaci%C3%B3n_prefija","S-expression","Homoiconicidad","%C3%81rbol_de_sintaxis_abstracta","Metaprogramaci%C3%B3n","Macro","Programaci%C3%B3n_orientada_a_objetos","Common_Lisp","Dylan_(lenguaje_de_programaci%C3%B3n)","Programaci%C3%B3n_funcional","Programaci%C3%B3n_imperativa","Funci%C3%B3n_de_orden_superior","Compilador","Int%C3%A9rprete_(inform%C3%A1tica)","Lisp","IEEE","Punto_y_coma","CAR_y_CDR","CAR_y_CDR","Lista_enlazada","Lisp","N%C3%BAmero_entero","N%C3%BAmero_racional","N%C3%BAmero_real","N%C3%BAmero_complejo","S%C3%ADmbolo","Cadena","Puerto_(inform%C3%A1tica)","Tabla_hash","Vector_(programaci%C3%B3n)","Array","Estructura_de_datos","Az%C3%BAcar_sint%C3%A1ctica","Lisp","Common_Lisp","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Programaci%C3%B3n_con_restricciones","titulo":"Programacion con restricciones","contenido":"La programacion por restricciones es un paradigma de la programacion en informatica, donde las relaciones entre las variables son expresadas en terminos de restricciones (ecuaciones). Actualmente es usada como una tecnologia de software para la descripcion y resolucion de problemas combinatorios particularmente dificiles, especialmente en las areas de planificacion y programacion de tareas (calendarizacion).  Este paradigma representa uno de los desarrollos mas fascinantes en los lenguajes de programacion desde 1990 y no es sorprendente que, recientemente haya sido identificada por la ACM (Asociacion de Maquinaria Computacional) como una direccion estrategica en la investigacion en computacion.  Se trata de un paradigma de programacion basado en la especificacion de un conjunto de restricciones, las cuales deben ser satisfechas por cualquier solucion del problema planteado, en lugar de especificar los pasos para obtener dicha solucion.  La programacion con restricciones se relaciona mucho con la programacion logica y con la investigacion operativa. De hecho cualquier programa logico puede ser traducido en un programa con restricciones y viceversa. Muchas veces los programas logicos son traducidos a programas con restricciones debido a que la solucion es mas eficiente que su contraparte.  La diferencia entre ambos radica principalmente en sus estilos y enfoques en el modelado del mundo. Para ciertos problemas es mas natural (y por ende mas simple) escribirlos como programas logicos, mientras que en otros es mas natural escribirlos como programas con restricciones.  El enfoque de la programacion con restricciones se basa principalmente en buscar un estado en el cual una gran cantidad de restricciones sean satisfechas simultaneamente. Un problema se define tipicamente como un estado de la realidad en el cual existe un numero de variables con valor desconocido. Un programa basado en restricciones busca dichos valores para todas las variables.  Algunos dominios de aplicacion de este paradigma son:  Los lenguajes de programacion con restricciones son tipicamente ampliaciones de otro lenguaje. El primer lenguaje utilizado a tal efecto fue Prolog. Por esta razon es que este campo fue llamado inicialmente Programacion Logica con Restricciones. Ambos paradigmas comparten caracteristicas muy similares, tales como las variables logicas (una vez que una variable es asignada a un valor, no puede ser cambiado), o el backtracking.  La programacion con restricciones puede ser implementado como un lenguaje propio o como bibliotecas para ser usadas en algun lenguaje de programacion imperativo. Algunos lenguajes populares de programacion con restricciones son:  Algunas bibliotecas populares:   ","snippet":"La programacion por restricciones es un paradigma de la programacion en informatica, donde las relaciones entre las variables son expresadas en terminos de restricciones (ecuaciones). Actualmente es u","enlaces_salientes":["Programaci%C3%B3n_con_restricciones","Programaci%C3%B3n_con_restricciones","Programaci%C3%B3n_con_restricciones","Programaci%C3%B3n","Inform%C3%A1tica","Ecuaci%C3%B3n","Software","Lenguajes_de_programaci%C3%B3n","Association_for_Computing_Machinery","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_l%C3%B3gica","Investigaci%C3%B3n_operativa","%C3%81lgebra_de_Boole","N%C3%BAmero_entero","N%C3%BAmero_racional","%C3%81lgebra_lineal","Prolog","Backtracking","Lenguaje_de_programaci%C3%B3n_C","C%2B%2B","Software_libre","Licencia_p%C3%BAblica_general_de_GNU","GNU_LGPL","Lenguaje_de_programaci%C3%B3n_Oz","X_Window_System","GNU_Prolog","SWI-Prolog","Lenguaje_de_programaci%C3%B3n_Java","Gecode","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Reflexi%C3%B3n_(inform%C3%A1tica)","titulo":"Reflexion (informatica)","contenido":"En informatica, reflexion (o reflexion computacional) es la capacidad que tiene un programa para observar y opcionalmente modificar su estructura de alto nivel.  Normalmente, la reflexion es dinamica o en tiempo de ejecucion, aunque algunos lenguajes de programacion permiten reflexion estatica o en tiempo de compilacion. Es mas comun en lenguajes de programacion de alto nivel ejecutandose sobre una maquina virtual, como Smalltalk o Java, y menos comun en lenguajes como C.  En un sentido mas amplio, la reflexion es una actividad computacional que razona sobre su propia computacion.  Cuando el codigo fuente de un programa se compila, normalmente se pierde la informacion sobre la estructura del programa conforme se genera el codigo de bajo nivel (normalmente lenguaje ensamblador). Si un sistema permite reflexion, se preserva la estructura como metadatos en el codigo generado. Dependiendo de la implementacion, el codigo con reflexion tiende a ser mas lento que el que no lo tiene.  En los lenguajes que no distinguen entre tiempo de ejecucion y tiempo de compilacion (como las distintas variantes de Lisp), no hay diferencia entre compilacion o interpretacion de codigo y reflexion.  Un lenguaje con reflexion proporciona un conjunto de caracteristicas disponibles en tiempo de ejecucion que, de otro modo, serian muy dificilmente realizables en un lenguaje de mas bajo nivel. Algunas de estas caracteristicas son las habilidades para:  Abajo un ejemplo con PHP: ","snippet":"En informatica, reflexion (o reflexion computacional) es la capacidad que tiene un programa para observar y opcionalmente modificar su estructura de alto nivel.  Normalmente, la reflexion es dinamica ","enlaces_salientes":["Reflexi%C3%B3n_(inform%C3%A1tica)","Reflexi%C3%B3n_(inform%C3%A1tica)","Reflexi%C3%B3n_(inform%C3%A1tica)","Inform%C3%A1tica","Programa_inform%C3%A1tico","Lenguaje_de_alto_nivel","Tiempo_de_ejecuci%C3%B3n","Est%C3%A1tica","Tiempo_de_compilaci%C3%B3n","Smalltalk","Lenguaje_de_programaci%C3%B3n_Java","Lenguaje_de_programaci%C3%B3n_C","C%C3%B3digo_fuente","Compilador","Lenguaje_de_bajo_nivel","Lenguaje_ensamblador","Tiempo_de_ejecuci%C3%B3n","Tiempo_de_compilaci%C3%B3n","Lisp","Clase_(programaci%C3%B3n_orientada_a_objetos)","Python","C_Sharp","PHP","Lenguajes_de_programaci%C3%B3n_con_tipos_din%C3%A1micos","Metaprogramaci%C3%B3n","Control_de_autoridades"]}
{"url":"Bjarne_Stroustrup","titulo":"Bjarne Stroustrup","contenido":"Bjarne Stroustrup (AFI: [b\u029d\u0251'n\u00f8 st\u027b\u0264u'st\u027b\u0275p]), (n. 30 de diciembre de 1950 en Aarhus, Dinamarca) es un cientifico de la computacion y catedratico de Ciencias de la Computacion en la Universidad A&M de Texas. Es reconocido principalmente por el desarrollo del lenguaje de programacion C++. Citando palabras del propio Stroustrup:  Stroustrup escribio tambien el considerado por muchos como el texto introductorio de referencia para el lenguaje, su titulo original es The C++ Programming Language, el cual alcanza actualmente su cuarta edicion. Existe una version especial editada en 2000, aunque no figuran en ella cambios significativos respecto al original. Este ultimo texto ha sido revisado tanto para reflejar la evolucion del lenguaje, como el trabajo del comite de estandares de C++.  Stroustrup es un cand. scient. (el equivalente danes a un master) en matematicas y ciencias de la computacion (1979) por la Universidad de Aarhus, Dinamarca, y Doctor en ciencias de la computacion (1979) por la Universidad de Cambridge, Inglaterra. Anteriormente trabajo a la cabeza del departamento de Investigacion en Programacion de los laboratorios Bell de AT&T, desde su creacion hasta finales de 2002. ","snippet":"Bjarne Stroustrup (AFI: [b\u029d\u0251'n\u00f8 st\u027b\u0264u'st\u027b\u0275p]), (n. 30 de diciembre de 1950 en Aarhus, Dinamarca) es un cientifico de la computacion y catedratico de Ciencias de la Computacion en la Universidad A&M de","enlaces_salientes":["Bjarne_Stroustrup","Bjarne_Stroustrup","Bjarne_Stroustrup","Aarhus","Dinamarca","Estados_Unidos","Churchill_College","Universidad_de_Cambridge","Philosophi%C3%A6_doctor","Universidad_de_Aarhus","David_Wheeler","Cient%C3%ADfico_de_la_computaci%C3%B3n","AT%26T","Bell_Labs","Universidad_de_Texas_A%26M","Morgan_Stanley","Universidad_de_Columbia","C%2B%2B","Institute_of_Electrical_and_Electronics_Engineers","Academia_Nacional_de_Ingenier%C3%ADa_(Estados_Unidos)","Association_for_Computing_Machinery","30_de_diciembre","1950","Aarhus","Dinamarca","Ciencias_de_la_computaci%C3%B3n","Ciencias_de_la_Computaci%C3%B3n","Universidad_A%26M_de_Texas","C%2B%2B","2000","Matem%C3%A1ticas","Ciencias_de_la_computaci%C3%B3n","1979","Universidad_de_Aarhus","Dinamarca","1979","Universidad_de_Cambridge","Inglaterra","Laboratorios_Bell","AT%26T","2002","1990","Am%C3%A9rica","1993","Premio_Grace_Murray_Hopper","Association_for_Computing_Machinery","1995","Revista_Byte","Inform%C3%A1tica","1996","1998","ACM","2004","2004","IEEE_Computer_Society","2005","2008","Dr._Dobb%27s","Doctor_Honoris_Causa","Universidad_Carlos_III","1_de_enero","1990","29_de_marzo","1994","15_de_febrero","2000","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","CiNii","Syst%C3%A8me_universitaire_de_documentation","Scopus","BIBSYS","Mathematics_Genealogy_Project","Open_Library","Google_Acad%C3%A9mico","Internet_Movie_Database"]}
{"url":"Genie_(lenguaje_de_programaci%C3%B3n)","titulo":"Genie (lenguaje de programacion)","contenido":"Genie es un lenguaje de programacion de alto nivel, moderno, y de proposito general en desarrollo activo desde el a\u00f1o 2008.\u200b Fue dise\u00f1ado como un dialecto  alternativo mas simple y limpio para el compilador Vala, preservando al mismo tiempo la misma funcionalidad del lenguaje Vala. La sintaxis de Genie se deriva de numerosos lenguajes modernos como Python, Boo, D y Delphi.  Al igual que Vala, Genie usa el sistema de tipos GObject para crear clases e interfaces declaradas en el codigo fuente de Genie, sin imponer requisitos adicionales de tiempo de ejecucion (es decir, a diferencia de Python, Java o Mono, este no requiere una maquina virtual).  Genie permite el acceso a las bibliotecas de C, especialmente las basadas en GObject (como GTK+), sin necesidad de utilizar otro API. Durante la compilacion, el codigo se traduce primero a codigo fuente y cabeceras de C, que se compilan entonces al codigo de maquina con cualquier compilador C disponible como GCC, lo cual permite el desarrollo de software multi-plataforma.  Aunque tanto Vala como Genie son desarrollados y promovidos por el proyecto Gnome, los programas desarrollados en Genie no dependen del entorno de escritorio Gnome, y usualmente requieren solo de GLib.  Genie usa el mismo compilador y bibliotecas que Vala; de hecho, los dos se pueden utilizar juntos.\u200b Las diferencias son solo sintacticas.  Como un lenguaje que toma a Python como referencia, Genie utiliza espacios en blanco o tabuladores en lugar de llaves para delimitar bloques.  En este ejemplo se utiliza de forma explicita cuatro espacios para el sangrado.  Otro ejemplo:  Sin ninguna declaracion explicita para el sangrado, por defecto se usa la tabulacion. ","snippet":"Genie es un lenguaje de programacion de alto nivel, moderno, y de proposito general en desarrollo activo desde el a\u00f1o 2008.\u200b Fue dise\u00f1ado como un dialecto  alternativo mas simple y limpio para el comp","enlaces_salientes":["Genie_(lenguaje_de_programaci%C3%B3n)","Genie_(lenguaje_de_programaci%C3%B3n)","Genie_(lenguaje_de_programaci%C3%B3n)","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_estructurada","Programaci%C3%B3n_orientada_a_objetos","Sistema_de_tipos","Python","Boo_(programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n_D","Embarcadero_Delphi","Sistema_operativo","GLib","Licencia_de_software","LGPL","Lenguaje_de_programaci%C3%B3n","Vala_(lenguaje_de_programaci%C3%B3n)","Python","Boo_(programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n_D","Object_Pascal","Python","Java_(lenguaje_de_programaci%C3%B3n)","Proyecto_Mono","C_(lenguaje_de_programaci%C3%B3n)","GTK%2B","C_(lenguaje_de_programaci%C3%B3n)","GCC","GNOME","GLib","Control_de_autoridades"]}
{"url":"Delphi","titulo":"Delfos","contenido":"Delfos (en griego \u0394\u03b5\u03bb\u03c6\u03bf, Delfoi, latin Delphi) es un yacimiento arqueologico \u2014declarado Patrimonio Mundial de la Unesco en 1987\u200b\u2014 y una moderna ciudad de Grecia. En epocas antiguas era el lugar del oraculo de Delfos, dentro de un templo dedicado al dios Apolo. Delfos era reverenciado en todo el mundo griego como el lugar del onfalos o centro del universo.  Fue una ciudad de Focida, a un lado del monte Parnaso y al otro lado de Cirfis. Delfos se ubica en una meseta en la ladera meridional del monte Parnaso, adyacente al santuario de Apolo, el lugar del oraculo. Esta proyeccion semicircular se llama Fedriades Phaedriades, es decir, las Resplandecientes. Son unas pe\u00f1as altisimas que se llaman, respectivamente, la Flemboukos (la Flameante) y la Rhodini (la Roja) por los vivos reflejos que arranca de ella el sol.  Frente al santuario se abre el estrecho valle del rio Pleistos. La ciudad de Delfos estaba en medio de las dos estribaciones monta\u00f1osas y los antiguos comparaban su posicion con un teatro. Hoy esta cercana la ciudad de Kastri. A unos 15\u00a0km al sudoeste de Delfos esta el puerto de Cirra, en el golfo de Corinto.  La ondulada llanura de Crisa, cubierta de verdes olivos, que se extiende entre Delfos y el no lejano golfo de Corinto, contrasta con el paisaje severo y agreste del santuario. Aqui se encuentra la carretera que lleva de la Grecia oriental al mar Jonico, y la que desde el norte conduce a Itea y el Peloponeso.  La ciudad era casi inaccessible, pero tenia tres caminos que llevaban a ella: uno desde Beocia llamado Skiste, al este, y dos mas al oeste desde Anfisa y desde Crisa. Los peregrinos que venian de Cirra lo hacian por el tercer camino.  El unico lado de la ciudad no defendido por accidentes naturales era el sur, donde se habia construido una muralla. La ciudad era peque\u00f1a y no tenia mas de 3\u00a0km de circuito. El templo estaba bajo la ciudad junto a las rocas Fedriades, en medio de les construcciones sagradas o recinto del templo, recinto circundado por una muralla y atravesado por la via sagrada, flanqueada de los edificios de los tesoros (tesaurus) de los pueblos vinculados al oraculo; la via sagrada llegaba al templo, hexastilo de orden dorico, y daba entrada a un recinto subterraneo donde, delante del onfalos, la Pitia despues de beber agua de la fuente Castalia, hacia su profecia en medio de emanaciones gaseosas que salian de una hendidura de la roca.  La mitologia dice que Delfos pertenecio a diversos dioses antes de ser posesion de Apolo. Esquilo dice que pertenecio a Gea, Temis; Pausanias dice que fue un oraculo de Poseidon y de Gea, que esta dio su parte a Temis y Temis a Apolo, que mas tarde obtuvo de Poseidon la otra parte a cambio de la isla de Calauria.  La leyenda de la fundacion del templo se sabe por Homero, que cuenta que Apolo queria fundar un oraculo y llego a Crisa, cerca del monte Parnaso, le agrado el lugar y comenzo a construir el templo que se acabo bajo la direccion de dos hermanos, Trofonio y Agamedes. Apolo mato a las serpientes que infestaban el lugar y a un monstruo (la serpiente Piton), y abrio el templo que fue llamado de Piton, y su dios Piton (Pytho). Apolo se convirtio en delfin para atraer a un barco cretense, del que queria utilizar a la gente como sacerdotes; los cretenses desembarcaron y fundaron Crisa y se les encargo ser sacerdotes del templo y que adorasen al dios bajo el nombre de Apolo Delfinio para rememorar su conversion en delfin, de donde vino el nombre de Delphi.\u200b Otra propuesta acerca del origen del toponimo de Delfos es la que propone que viene de Delfine (\u0394\u03b5\u03bb\u03c6\u03bd\u03b7\u03c2), que era el nombre del dragon mitologico que custodiaba el oraculo antes de la llegada de Apolo.\u200b  Crisa tenia el dominio sobre el santuario de Piton y cuando el consejo de la Anfictionia  comenzo a tener sus reuniones de primavera alli, conservo el dominio y se convirtio en guardiana del templo. Al lado del santuario se formo una ciudad que pronto reclamo administrar el templo sin intervencion de Crisa; al mismo tiempo Cirra, el puerto de Crisa, se hizo mas grande que la misma ciudad, que entro en decadencia, mientras Delfos y Cirra aumentaban. Hacia el 595\u00a0a.\u00a0C., Crisa era ya, seguramente, una ciudad poco importante. Este a\u00f1o Cirra fue destruida por orden del consejo anfictionico y la llanura de Cirra fue declarada sagrada y al servicio del templo. Desde entonces se celebraron unos juegos llamados Juegos Piticos (Pythis), que se realizaron bajo la direccion del consejo anfictionico cada cuatro a\u00f1os, y fueron los primeros en 586\u00a0a.\u00a0C. En la llanura de Cirra se hacian exhibiciones de caballos de raza y otros animales y estaban el hipodromo y el estadio (este ultimo fue trasladado mas tarde a la ciudad de Delfos. Hacia esta epoca Delfos ya era una ciudad-estado independiente gobernada por magistrados naturales de la ciudad.  La poblacion de Delfos venia en gran parte de Licorea, una ciudad del Parnaso, dirigidos por Deucalion, supuesto jefe de la nobleza local. Cinco sacerdotes locales, llamados Hosioi, eran elegidos entre la descendencia de Deucalion y eran los jefes del oraculo y el templo. La ciudad de Licorea estaba en el sitio de la actual Liakura, y se supone que fue una ciudad dorica y que los habitantes de Delfos tenian este mismo origen (se sabe que hablaban dorico, y ciertamente no eran focidios).  El gobierno de Delfos estaba en manos de las familias nobles que ademas tenian el control del oraculo. Mas tarde, entre los nobles se escogieron los magistrados y entre estos se escogia un rey, mas tarde llamado Pritano (Prytanis). En los ultimos tiempos aparecen unos arcontes y un senado.  El gobierno de Delfos era teocratico. El templo y su dios poseian extensos dominios de tierra que eran cultivados por esclavos del templo; ademas los sacerdotes recibian regalos de reyes y hombres ricos que iban a consultar el oraculo, y ofrecian sacrificios. La riqueza de la ciudad hizo decadentes a los ciudadanos. El oraculo se consultaba desde el siglo\u00a0VIII\u00a0a.\u00a0C. y la fama se extendio rapidamente por las naciones vecinas; algunos reyes o personajes relevantes enviaban embajadas a preguntar el parecer del dios. Casi todas las colonias griegas fueron fundadas bajo la influencia del oraculo, y despues Apolo era el patron de las nuevas colonias. Giges de Lidia hizo importantes donaciones al templo, pero las mas importantes donaciones fueron las de Creso. La ciudad etrusca de Caere tenia un tesoro en Delfos. Incluso el ultimo rey de Roma, Lucio Tarquinio el Soberbio, consulto el oraculo.  En el 548\u00a0a.\u00a0C., el templo fue destruido por el fuego. El consejo anfictionico decidio reconstruirlo mucho mas grande y magnificente. Delfos habia de pagar el coste y el resto lo habian de pagar otras ciudades y reinos; el coste fue de 300 talentos y la ejecucion fue encargada a la familia ateniense de los Alcmeonidas, que entonces vivian en el exilio. El arquitecto fue el corintio Espintaros. Gran parte fue hecha con marmol de Paros.  En 480\u00a0a.\u00a0C. los persas llegaron ante Delfos. Los ciudadanos huyeron al monte, pero el oraculo prohibio mover los tesoros del templo. Seis habitantes quedaron en Delfos para defender el templo. Cuando los persas avanzaban se sintio un trueno espectacular y cayeron unas piedras de la monta\u00f1a y aplastaron a muchos persas; estos, presas del panico, huyeron y fueron perseguidos por dos guerreros de gran tama\u00f1o que los habitantes dijeron que eran los heroes Filacos y Autonoos, cuyos santuarios estaban cerca.  En 373\u00a0a.\u00a0C. fue destruida por un terremoto, pero fue reconstruida.  En 357\u00a0a.\u00a0C., los focidios fueron sentenciados por el consejo anfictionico a pagar una gran multa por haber cultivado parte de la llanura sagrada de Cirra. El jefe focidio Filomelo, convencio a sus compatriotas para completar el supuesto sacrilegio ocupando el templo de Delfos; Filomelo, llevo a termino la conquista y se apodero de todos los tesoros. Eso origino la guerra sagrada. Primero, los focidios no querian utilizar los tesoros, pero despues, bajo presion de tebanos y locrios, convirtieron los tesoros en dinero para pagar a los soldados. Filipo II de Macedonia, general del consejo anfictionico, gano la guerra y devolvio el templo a la anfictionia (346\u00a0a.\u00a0C.), con los tesoros que quedaban. Los focidios fueron sentenciados a devolver los tesoros (unos 10\u00a0000 talentos) con pagos anuales, pero los focidios eran demasiado pobres para poder pagar una cantidad tan grande.  Un nuevo terremoto lo volvio a da\u00f1ar en 330\u00a0a.\u00a0C. y fue reconstruido por los arquitectos Espintaro, Jenodoro y Agaton de Corinto.  En 279\u00a0a.\u00a0C., Delfos fue atacada por los (galatas) dirigidos por Breno, tentado por las supuestas riquezas del templo (que ya no eran las mismas despues del 346\u00a0a.\u00a0C.), pero fue rechazado de manera sobrenatural como lo fueron antes los persas, al caer grandes rocas desde las monta\u00f1as.  En el siglo\u00a0III\u00a0a.\u00a0C. recibio el patronazgo de los reyes de Pergamo. Durante dicho siglo paso al control de la Liga Etolia hasta que en 189\u00a0a.\u00a0C. cayo en manos de Roma.  Mas tarde, en 86\u00a0a.\u00a0C., fue saqueada por Sila, que tambien habia saqueado Olimpia y Epidauro. En esta epoca ya era muy pobre.  A mitad del siglo\u00a0I fue saqueada por Neron, que se llevo 500 estatuas de bronce, y le separo la llanura de Cirra, que repartio entre sus soldados, y abolio el oraculo. Pero Adriano, mas tarde, lo restauro y volvio a tener cierto renombre y esplendor por un tiempo. En tiempos de Caracalla dejo de emitirse moneda en Delfos. Constantino el Grande se llevo algunas figuras para su nueva capital. Juliano el Apostata aun consulto el oraculo, pero finalmente fue suprimido por Teodosio I el Grande  en 385 al prohibir el culto pagano.  Dentro del recinto sagrado del templo de Apolo hay que mencionar:  Delfos fue explorada por primera vez en 1676 por Spon, y en 1756 por Chandler. Mas tarde se hicieron otras exploraciones mas cientificas dirigidas por la Escuela francesa de estudios clasicos de Atenas (la misma que las hizo en Delos) entre 1861 y 1880, en que una disputa entre los franceses y los griegos paralizo los permisos, disputa que se resolvio en 1891. Desde entonces las excavaciones no han parado.  Algunos de los tesoros mejor conservados de Delfos pertenecen a la epoca arcaica, mientras que del mas antiguo, el de Corinto (650\u00a0a.\u00a0C.), en el que se conservaban tambien las donaciones votivas del rey Midas de Frigia, y de los lidios Giges y Creso, quedan escasas ruinas.  El tesoro de los sicionios, datado en torno al 500\u00a0a.\u00a0C., aunque no es unanime dicha fecha entre los arqueologos, tenia, como muchos otros, forma de templete dorico, con dos columnas entre las dos antas de la fachada.  Para sus cimientos se reutilizaron bloques de otros dos edificios mas antiguos. De uno circular (un tholos), de hacia el 580\u00a0a.\u00a0C., y de otro edificio monoptero rectangular, es decir, consistente en una simple columnata abierta para sosten de un techo. Se ha supuesto que este ultimo estaba rematado por la cuadriga de Clistenes, el tirano de Sicion, quien habia vencido en los primeros Juegos Piticos del 582\u00a0a.\u00a0C., y al mismo edificio monoptero, que se fecha en torno al 560\u00a0a.\u00a0C., parecen corresponder las famosas metopas encontradas tambien entre los cimientos del tesoro y que representan escenas mitologicas esculpidas en un estilo arcaico de fuerte realismo.  Son celebres las del Robo de los bueyes, que representan a los Dioscuros llevandose el reba\u00f1o por el que hallarian la muerte a manos de Idas y Linceo y otras con la nave Argo, o con Europa y el toro, etc.  Dinsmoor, uno de los mayores especialistas de arquitectura griega, data el tesoro del siglo\u00a0V\u00a0a.\u00a0C., y atribuye las metopas a un anterior tesoro de los siracusanos, del siglo\u00a0VI\u00a0a.\u00a0C., con base en que el empleo de metopas figuradas, comun en Sicilia, y en la Magna Grecia, era inusual en los monumentos propiamente griegos.  Brunilde Sismondo Ridgway, en su importante libro sobre la escultura de la Grecia arcaica publicado en 1977, observa que las metopas sicionias formaron parte de un tesoro ofrecido por alguna ciudad de la Magna Grecia, excluyendo Siracusa, y realizado en Delfos por artistas foraneos o locales. Porque es posible que en Delfos, ademas de los artistas que sabemos por las fuentes literarias e historicas, llegados de todo el mundo griego, hubiera talleres locales, responsables en definitiva de la formacion de un estilo \u00abdelfico\u00bb.  El de  los sifnios era el mas suntuoso del santuario. De estilo jonico y construido enteramente con marmol de Paros, tenia en su frente dos cariatides en lugar de columnas y estaba adornado con dos frontones y un largo friso esculpido con representaciones de episodios mitologicos.  Como se desprende de pasajes de Herodoto y de Pausanias, este tesoro lo erigieron los habitantes de Sifnos en el 525\u00a0a.\u00a0C. (o quiza algunos a\u00f1os antes, como ha indicado la norteamericana Richter en su estudio de los Kuroi) con los diezmos de las minas de oro de la isla.  Es el monumento mejor datado del periodo arcaico, lo mismo que sus esculturas.  Afortunadamente las excavaciones han restituido gran parte del fronton oriental y casi la mitad del friso que corria por el exterior del edificio y media mas de 20\u00a0m.  En el fronton esta representada la disputa entre Apolo y Heracles por la posesion del tripode delfico, con la imagen de Zeus en el centro (y no la de Atenea como en un primer momento se penso).  Tambien el friso contiene escenas mitologicas. El lado este esta dividido en dos partes. En la de la derecha hay un combate frente a Troya alrededor de un guerrero caido. En la de la izquierda un concilio de dioses, con las divinidades a favor de los troyanos \u2014Ares, Afrodita, Artemisa, Apolo y Zeus\u2014 sentadas frente a las partidarias de los griegos, ente las que se hallan Atenea, Hera y Hebe.  En el lado norte se desarrolla una larga y movida Gigantomaquia, en la que participan muchas divinidades del Olimpo: Apolo, Artemisa, Hefesto y Ares, entre otras.  Del friso oeste, con el Juicio de Paris, se conserva solo una parte. Y en el del lado sur, del que tan solo quedan unas losas, debia de narrarse el rapto de las hijas de Leucipo, el rey mesenio, por parte de los Dioscuros, o tal vez de Helena por Paris.  Hay claras pruebas de que en su dia el friso estaba policromado. Aun puede distinguirse el color azul del fondo y huellas de color rojo en el borde inferior y en algunos detalles: ropas, cabellos, armas, crines y colas de caballos, etc.  Otros detalles y elementos decorativos aparecian realizados en bronce, y algunas figuras estaban acompa\u00f1adas de inscripciones que han facilitado su identificacion.  Se advierte el trabajo de dos maestros: uno \u2014seguramente un maestro de la escuela de arte jonico, si no de la propia Sifnos\u2014 muy imaginativo, autor de las secciones este y norte del friso. Otro, mas tradicional, de escuela atica, que esculpio las secciones oriental y meridional. Mas aun, si es correcta la lectura de una inscripcion propuesta por la epigrafista Lilian H. Jeffery, que aparece en el escudo de uno de los gigantes, este segundo escultor seria Aristion de Paros, un artista jonio que trabajo durante muchos a\u00f1os en Atenas y al que se debe, entre otras, la estatua de la Kore Frasikleia, hallada en Merenda, junto a Atenas.  Hay restos de muchos otros monumentos, si bien la mayoria de las veces reducidos a los cimientos, como el bouleterion donde se reunian los 15 senadores y los 8 pritanos de la ciudad, o el tesoro de los cnidios, de mediados del siglo\u00a0VI\u00a0a.\u00a0C.  En la Marmaria, el templo en piedra caliza de Atenea Pronaia, del que quedan abundantes vestigios, parece datar de finales del siglo\u00a0VI\u00a0a.\u00a0C., pero han aparecido algunos tambores de columnas y 12 capiteles, que corresponden a un templo construido tal vez hacia la mitad del siglo\u00a0VII\u00a0a.\u00a0C., que seria uno de los mas antiguos de Grecia.  El vecino tesoro de los massaliotas, los colonos griegos de la actual Marsella, muy rico, podria fecharse en torno al 530\u00a0a.\u00a0C.  Las dos estatuas colosales de Cleobis y Biton, que se encuentran entre las mas antiguas esculturas griegas de marmol, ya que datan de entre el 610 y el 580\u00a0a.\u00a0C., y marcan la transicion del arte dedalico del siglo\u00a0VII\u00a0a.\u00a0C. al arcaico del VI\u00a0a.\u00a0C. Se trata de dos gemelos miticos, hermanos de  la ciudad de Argos, que segun la leyenda se uncieron al carro de su madre, sacerdotisa de Hera, en lugar de los bueyes para llevarla a donde se celebraba la fiesta de la diosa. Una inscripcion incompleta las atribuye a un... medes de Argos, en quien se reconoce al escultor argivo Polimedes.  Quiza del 570-560\u00a0a.\u00a0C. es la gran Esfinge de los Naxios, que se apoya sobre un capitel jonico y una alta columna acanalada. Este importante monumento, que originalmente debio de medir mas de doce metros de altura, tiene especial interes para conocer el arte arcaico de la isla de Naxos.  La moderna Delfos se encuentra inmediatamente al oeste de la zona arqueologica y por lo tanto es un destino turistico popular. Esta en una carretera principal que une Amfisa con Itea y Arajova. Hay muchos hoteles y casas de huespedes en la ciudad, y muchas tabernas y bares. Las principales calles son estrechas y con frecuencia de un solo sentido. Delfos tambien tiene una escuela, un liceo, una iglesia y una plaza (plateia). El Sendero Europeo E-4 pasa por el extremo este de la ciudad. Ademas del interes arqueologico, Delfos atrae a los turistas que visitan el Centro de esqui del Parnaso y las localidades costeras mas populares de la region.  En la epoca medieval una ciudad llamada Kastri fue construida en el sitio arqueologico. Los residentes habian utilizado las columnas y estructuras de marmol como materiales de construccion de sus casas, una forma habitual de la reconstruccion de las ciudades que fueron destruidas parcial o totalmente, sobre todo despues del terremoto de 1580, que derribo varias ciudades de Focida. En 1893 arqueologos de la Escuela Francesa de Atenas encontraron el lugar donde se habia situado la antigua Delfos y el pueblo se traslado a una nueva ubicacion, al oeste del lugar donde habian estado los templos.  El Museo Arqueologico de Delfos se encuentra al pie del principal complejo arqueologico, en el lado este de la aldea y en el lado norte de la carretera principal. El museo alberga una coleccion asociada con la antigua Delfos, incluyendo la primera notacion conocida de una melodia, el famoso auriga, tesoros de oro descubiertos debajo de la Via Sacra y fragmentos de relieves del Tesoro de los sifnios. Inmediatamente adyacente a la salida esta la inscripcion que menciona al proconsul romano Galion.  Un poco mas al este, en el lado sur de la carretera principal, estan el gimnasio y el tholos. ","snippet":"Delfos (en griego \u0394\u03b5\u03bb\u03c6\u03bf, Delfoi, latin Delphi) es un yacimiento arqueologico \u2014declarado Patrimonio Mundial de la Unesco en 1987\u200b\u2014 y una moderna ciudad de Grecia. En epocas antiguas era el lugar del or","enlaces_salientes":["Delfos","Delfos","Delfos","Coordenadas_geogr%C3%A1ficas","Delphi_(desambiguaci%C3%B3n)","Unesco","Patrimonio_de_la_Humanidad","Patrimonio_de_la_Humanidad","Teatro_de_la_Grecia_Antigua","Grecia","Coordenadas_geogr%C3%A1ficas","Patrimonio_de_la_Humanidad#Criterios_de_selecci\u00f3n","Patrimonio_de_la_Humanidad#Lugares_Patrimonio_de_la_Humanidad","1987","Patrimonio_de_la_Humanidad#Sesiones_del_Comit\u00e9_del_Patrimonio_de_la_Humanidad","Idioma_griego","Lat%C3%ADn","Yacimiento_arqueol%C3%B3gico","Patrimonio_Mundial","Unesco","1987","Grecia","Or%C3%A1culo_de_Delfos","Dios","Apolo","%C3%93nfalos","F%C3%B3cida","Parnaso","Templo_de_Apolo_(Delfos)","Or%C3%A1culo_griego","Cirra","Golfo_de_Corinto","Crisa","Golfo_de_Corinto","Mar_J%C3%B3nico","Peloponeso","Beocia_(regi%C3%B3n_hist%C3%B3rica)","Anfisa","Crisa","Tesoro_(Grecia)","Orden_d%C3%B3rico","%C3%93nfalos","Pitia","Fuente_de_Castalia","Mitolog%C3%ADa_griega","Esquilo","Gea","Temis_(mitolog%C3%ADa)","Pausanias_(ge%C3%B3grafo)","Poseid%C3%B3n","Calauria","Homero","Trofonio","Agamedes","Delphinidae","Creta","Drag%C3%B3n","Anfiction%C3%ADa","595_a._C.","Juegos_P%C3%ADticos","586_a._C.","Ciudad-estado","Licorea","Parnaso","Deucali%C3%B3n","Dorios","D%C3%B3rico_(dialecto)","Magistrados_de_la_Antigua_Grecia","Pritano","Arconte","Teocracia","Esclavitud_en_la_Antigua_Grecia","Siglo_VIII_a._C.","Colonizaci%C3%B3n_griega","Giges_de_Lidia","Creso","Caere","Antigua_Roma","Lucio_Tarquinio_el_Soberbio","A%C3%B1os_540_a._C.","Talento_(moneda)","Alcme%C3%B3nidas","Paros","480_a._C.","Imperio_aquem%C3%A9nida","373_a._C.","357_a._C.","Filomelo_(focidio)","Sacrilegio","Guerras_Sagradas","Tebas_(Grecia)","L%C3%B3crida","Filipo_II_de_Macedonia","346_a._C.","330_a._C.","Antigua_Corinto","279_a._C.","Galacia","Breno_(siglo_III_a._C.)","346_a._C.","Siglo_III_a._C.","P%C3%A9rgamo","Liga_Etolia","189_a._C.","Antigua_rep%C3%BAblica_romana","86_a._C.","Sila","Olimpia","Epidauro","Siglo_I","Ner%C3%B3n","Adriano","Caracalla","Constantino_el_Grande","Juliano_el_Ap%C3%B3stata","Teodosio_I_el_Grande","385","Religi%C3%B3n_de_la_Antigua_Grecia_(culto)","Pagano","Antigua_Atenas","Batalla_de_Marat%C3%B3n","Atenea","Palestra_de_Delfos","Estadio_de_Delfos","Fuente_de_Castalia","Templo_de_Apolo_(Delfos)","Bouleteri%C3%B3n","Stoa_de_los_atenienses","%C3%81talo_I","Estoa_de_los_etolios","1676","1756","Delos","1861","1880","1891","Tesoro_(Grecia)","%C3%89poca_arcaica","Midas","Frigia","Lidia","Giges","Creso","500_a._C.","Templete","Orden_d%C3%B3rico","Fachada","Tholos","580_a._C.","Columnata","Cuadriga","Cl%C3%ADstenes_de_Sici%C3%B3n","Sici%C3%B3n","Juegos_P%C3%ADticos","A%C3%B1os_580_a._C.","560_a._C.","Metopa","Cimentaci%C3%B3n","Escultura_de_la_Antigua_Grecia#Periodo_arcaico","Dioscuros","Idas","Linceo_(hijo_de_Afareo)","Argo","Europa_(mitolog%C3%ADa)","Arquitectura_en_la_Antigua_Grecia","Siglo_V_a._C.","Siracusa_(Sicilia)","Sicilia","Magna_Grecia","1977","Metopa","Sici%C3%B3n","Siracusa_(Sicilia)","Policrom%C3%ADa","Tesoro_de_los_sifnios","Ciclo_troyano","Museo_Arqueol%C3%B3gico_de_Delfos","Tesoro_de_los_sifnios","Orden_j%C3%B3nico","Paros","Cari%C3%A1tide","Front%C3%B3n_(arquitectura)","Friso","Her%C3%B3doto","Sifnos","525_a._C.","Kur%C3%B3s","Diezmo","Heracles","Tr%C3%ADpode","Zeus","Atenea","Troya","Ares","Afrodita","Artemisa","Hera","Hebe_(mitolog%C3%ADa)","Gigantomaquia","Olimpo","Hefesto","Juicio_de_Paris","Leucipo_(hijo_de_Perieres)","Mesenia","Dioscuros","Helena_(mitolog%C3%ADa)","Paris","Epigraf%C3%ADa","Jonia","Kor%C3%A9_(escultura)","Atenas","Tesoro_(Grecia)#Tesoro_de_los_atenienses","Esfinge_de_los_Naxios","Bouleteri%C3%B3n","Pritano","Gnido","Capitel","Colonizaci%C3%B3n_griega","Marsella","530_a._C.","Cleobis_y_Bit%C3%B3n","610_a._C.","580_a._C.","Arte_cicl%C3%A1dico","Argos_(Grecia)","Hera","Argos_(Grecia)","570_a._C.","560_a._C.","Esfinge_de_los_Naxios","Naxos_(isla)","Delfo%C3%AD","%C3%81mfisa","Ar%C3%A1jova","Sendero_Europeo_E-4","1580","1893","Escuela_Francesa_de_Atenas","Gali%C3%B3n","Or%C3%A1culo_de_Delfos","Graves,_Robert","Wayback_Machine","Griego_moderno","Plutarco","Moralia_(Obras_morales_y_de_costumbres)","Proyecto_Perseus","Idioma_ingl%C3%A9s","Griego_antiguo","Or%C3%A1culo_de_Delfos","Or%C3%A1culo_de_Delfos#Pit\u00f3n_(Pitia)","Griego_antiguo","Or%C3%A1culo_de_Delfos#Decadencia","Griego_antiguo","Estudios_cl%C3%A1sicos","Universidad_de_Harvard","Neolat%C3%ADn","Paleograf%C3%ADa","Xen%C3%ADa","Vadem%C3%A9cum","Universidad_de_Cambridge","Cambridge_University_Press","Facs%C3%ADmil","Internet_Archive","Estudios_cl%C3%A1sicos","Ling%C3%BC%C3%ADstica","Universidad_de_B%C3%BAfalo","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Enciclopedia_Brit%C3%A1nica","Patrimonio_de_la_Humanidad"]}
{"url":"D_(lenguaje_de_programaci%C3%B3n)","titulo":"D (lenguaje de programacion)","contenido":"D es un lenguaje de programacion de proposito general desarrollado por Walter Bright cuya primera version aparecio en 1999. Se origina como un redise\u00f1o de C++, con un enfoque mas pragmatico, pero no es un lenguaje puramente derivado del anterior. D ha mantenido algunas caracteristicas de C++ y tambien esta influido por otros conceptos de otros lenguajes como Java, C# y Eiffel. Una version estable fue lanzada el 2 de enero de 2007.  D esta siendo dise\u00f1ado con lecciones aprendidas del uso de C++ en vez de ser dise\u00f1ado desde una perspectiva teorica. Aunque usa muchos de los conceptos de C/C++ tambien descarta algunos, y por lo tanto no es compatible con codigo escrito en C o C++. D retiene la habilidad de C++ de hacer codigo de bajo nivel, permitiendo incluir codigo en ensamblador. La herencia multiple de C++ es reemplazada por herencia simple e interfaces y 'mixins'. La sintaxis de declaracion y la sintaxis para las expresiones se parecen a las de C++.  El soporte del lenguaje ensamblador demuestra una de las diferencias entre D con respecto a otros lenguajes como Java y C#. Esto permite incluir codigo especifico de la maquina con codigo D, una tecnica comunmente usada por programadores de software de sistema para acceder a caracteristicas de bajo nivel necesarias para interactuar directamente con el hardware, permitiendo escribir software como sistemas operativos y drivers.  D incluye soporte para comentarios de documentacion, pero hasta ahora solo el compilador entregado por Digital Mars implementa un generador de documentacion.  La programacion orientada a objetos esta basada en herencia simple, con todas las clases derivadas de la clase Object. D no soporta herencia multiple; en vez de eso, usa interfaces parecidas a las de Java, que son comparables a las clases abstractas de C++.  La Metaprogramacion esta soportada por una combinacion de plantillas, la ejecucion de funciones en tiempo de compilacion, tuplas y 'mixins' de cadenas. Soporta CTFE (evaluacion de funciones en tiempo de compilacion). Los siguientes ejemplos demuestran algunas de las caracteristicas en tiempo de ejecucion del lenguaje D.  Las plantillas en D se pueden escribir en mas de un estilo imperativo comparado con el estilo funcional de las plantillas de C++. El siguiente ejemplo es una funcion regular que calcula el producto factorial de un numero:  Aqui, se muestra el uso de la palabra reservada static for (la construccion iterativa en tiempo de ejecucion en D), para construir una plantilla que es capaz de realizar el mismo calculo:  En los siguientes dos ejemplos, la plantilla y la funcion definidas arriba se utilizan para calcular factoriales. No es necesario especificar explicitamente los tipos de las constantes cuando el compilador infiere sus tipos desde el lado derecho de las asignaciones:  Este es un ejemplo de una funcion en tiempo de ejecucion. Las funciones ordinarias pueden usar constantes, aunque expresiones en tiempo de ejecucion deben reunir ciertos criterios:  La funcion std.string.format, del estilo printf, sirve para dar formato a los datos (tambien en tiempo de ejecucion, a traves de CTFE (ejecucion de funcion en tiempo de ejecucion), y el pragma \"msg\" (directiva) que muestra el resultado en tiempo de ejecucion:  Los \"mixins\" de cadenas, combinadas con las CTFE, permiten generar codigo D usando operaciones expresadas en cadenas de caracteres, en tiempo de ejecucion. Puede ser utilizado para analisis sintactico de un lenguaje especifico del dominio hacia codigo D, el cual se compila como parte del programa:  D soporta caracteristicas de programacion funcional tal como funciones anonimas, clausuras, objetos recursivamente immutables y el uso de funciones de orden superior. Hay dos sintaxis para funciones anonimas, incluyendo una forma de declaracion multiple y una notacion abreviada de expresiones simples:\u200b  La memoria es usualmente manejada por un recolector de basura, pero objetos especificos pueden ser finalizados inmediatamente cuando salen del ambito. Es posible el manejo de memoria explicito usando los operadores sobrecargados new y delete, y simplemente llamando las funciones malloc y free de C directamente. La recoleccion de basura puede ser controlada: los programadores pueden agregar y excluir rangos de memoria de ser observados por el recolector, pueden pausar y reanudar el recolector y forzar un ciclo generacional o de recoleccion completa.\u200b El manual da muchos ejemplos de como implementar diferentes esquemas de manejo de memoria altamente optimizados para cuando la recoleccion de basura es inadecuada para el programa.  La API de C es admitida, al igual que todos los tipos fundamentales y derivados de C, permitiendo acceso directo al codigo existente escrito en C y bibliotecas. La biblioteca estandar de C es parte del D estandar. A menos que se usen namespaces muy explicitos puede ser de alguna forma dificil de acceder, como se puede observar en modulos escritos en D que hagan uso de dicha caracteristica. Pero la biblioteca estandar de D es usualmente suficiente.  Este programa imprime sus argumentos de la linea de comandos. La funcion principal main es el punto de inicio de un programa en D, y args es un arreglo de cadena de caracteres que representa los argumentos de linea de comandos. En D, string es un arreglo de caracteres, que se representa con char[] en D1, o immutable(char)[] en D2.  La palabra reservada foreach puede iterar cualquier coleccion. En este caso, produce una sucesion de indices (i) y valores (arg) desde el arreglo args. El indice i y el valor arg tiene sus tipos inferidos desde del tipo del arreglo args.  Las implementaciones actuales de D compilan el codigo directamente a codigo maquina para lograr una ejecucion eficiente.  Cambios al lenguaje no se hacen regularmente desde la version 1.0. El dise\u00f1o esta virtualmente congelado, y nuevos lanzamientos se concentran en resolver bugs existentes. El compilador oficial de Walter Bright define el lenguaje.  D todavia no esta soportado en muchos entornos de desarrollo, lo cual es un problema esencial para muchos usuarios. Editores que pueden ser usados incluyen a Entice Designer, emacs, vim, SciTE y Zeus entre otros. Vim soporta el resaltado de sintaxis y completado de codigo (a traves de ctags parcheados). Code::Blocks incluye soporte parcial del lenguaje.  Hay dos plu-gins en desarrollo para Eclipse, Descent y Mmrnmhrm.  Adicionalmente, hay IDEs escritas en el propio D como Poseidon, que incluye completado de codigo, resaltado de sintaxis y depurador.  Aplicaciones escritas en D pueden ser depuradas con cualquier depurador de C o C++, como GDB o WinDbg, aunque soporte para varias caracteristicas fundamentales de D es limitado. Un depurador con soporte explicito para D es Ddbg para Windows. El depurador comercial ZeroBUGS para Linux tiene soporte experimental para D. Ddbg puede ser usado con varios IDEs o desde la linea de comandos, ZeroBUGS tiene su propia interfaz grafica.  La sobrecarga de operadores en D a veces son menos poderosas que las de C++. Un ejemplo es el opIndex, que sufre porque D no permite regresar referencias. Esto hace operaciones como obj[i]++; imposibles. La solucion parcial de D es el operador opIndexAssign, que solo repara casos donde la expresion indexeada es solo un valor L como obj[i] = 5 pero no los casos originales.  La biblioteca estandar en D es llamada Phobos. Algunos miembros de la comunidad piensan que Phobos es demasiado simple y que posee numerosos problemas, por lo cual un reemplazo llamado Tango fue escrito.\u200b Sin embargo, Tango y Phobos eran incompatibles debido a varias diferencias (soporte de hilos, recolector de basura, etc). La existencia de dos bibliotecas, ambas de uso elevado, llevo a problemas significativos donde algunos paquetes usan Phobos y otros usan Tango. Este problema fue resuelto con la version 2.0 del lenguaje.  Bibliotecas compartidas ELF de Unix son soportadas hasta un punto usando el compilador GDC. En Windows, DLLs son soportadas y permiten a objetos recolectados por el recolector de basura de ser seguramente pasados a funciones de C, ya que el recolector de basura revisa el stack por punteros. Sin embargo, todavia hay limitaciones con DLLs en D incluyendo el hecho de que la informacion en tiempo de ejecucion de clases definidas en la DLL es incompatible con esas definidas en el ejecutable, y que cualquier objeto creado desde la DLL debe ser finalizado antes de que la DLL sea descargada.\u200b ","snippet":"D es un lenguaje de programacion de proposito general desarrollado por Walter Bright cuya primera version aparecio en 1999. Se origina como un redise\u00f1o de C++, con un enfoque mas pragmatico, pero no e","enlaces_salientes":["D_(lenguaje_de_programaci%C3%B3n)","D_(lenguaje_de_programaci%C3%B3n)","D_(lenguaje_de_programaci%C3%B3n)","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_multiparadigma","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_funcional","Metaprogramaci%C3%B3n","Walter_Bright","Sistema_de_tipos","C%2B%2B","Lenguaje_de_programaci%C3%B3n_C","C_Sharp","Lenguaje_de_programaci%C3%B3n_Java","Lenguaje_de_programaci%C3%B3n_Eiffel","Python","Ruby","Vala_(lenguaje_de_programaci%C3%B3n)","Sistema_operativo","Unix-like","FreeBSD","Distribuci%C3%B3n_Linux","Microsoft_Windows","OS_X","Licencia_de_software","GNU_General_Public_License","Artistic_License","Boost_Software_License","Lenguaje_de_programaci%C3%B3n","Walter_Bright","C%2B%2B","Lenguaje_de_programaci%C3%B3n_Java","C_Sharp","Lenguaje_de_programaci%C3%B3n_Eiffel","Metaprogramaci%C3%B3n","Factorial","Asignaci%C3%B3n","Printf","Lenguaje_espec%C3%ADfico_del_dominio","Programaci%C3%B3n_funcional","Funci%C3%B3n_de_orden_superior","GCC","LLVM","Emacs","Vim","SciTE","12_de_junio","2010","GNU_Compiler_Collection","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Lenguaje_de_programaci%C3%B3n_Oz","titulo":"Oz (lenguaje de programacion)","contenido":"Oz es un lenguaje de programacion multi-paradigma.  Oz fue originalmente desarrollado en el laboratorio de Programacion de Sistemas en la Universidad de Saarland por Gert Smolka y sus estudiantes a comienzos de 1990. En 1996 el desarrollo de Oz continuo en cooperacion con el grupo de investigacion de Seif Haridi en el Instituto Sueco de Ciencias de la Computacion. Desde 1999, Oz ha sido continuamente desarrollado por un grupo internacional, el Consorcio Mozart, que estuvo compuesto originalmente por la Universidad de Saarland, el Instituto Sueco de Ciencias de la Computacion, y la Universidad Catolica de Lovaina. En 2005, la responsabilidad de gestionar el desarrollo de Mozart fue transferida a un grupo base, el Tablero Mozart, con el proposito expreso de abrir el desarrollo de Mozart a una comunidad mayor.  Oz tiene una implementacion de gran calidad, el Sistema de Programacion Mozart, que fue liberado bajo una licencia de Codigo Abierto por el Consorcio Mozart. Mozart ha sido portado a diferentes plataformas como Unix, FreeBSD, Linux, Microsoft Windows y Mac OS X.  El lenguaje de programacion Oz es la interfaz de usuario del sistema de composicion musical mediante restricciones Strasheela.  Oz contiene una forma simple y bien hecha de la mayoria de los conceptos de los principales paradigmas de programacion, incluyendo programacion logica, funcional, imperativa, orientada a objetos, con restricciones, distribuida, concurrente. Oz tiene una semantica formal simple y una implementacion eficiente, el Sistema de Programacion Mozart. Oz es un lenguaje orientado a la concurrencia, termino introducido por Joe Armstrong, el principal dise\u00f1ador del lenguaje Erlang. Un lenguaje orientado a la concurrencia hace a la concurrencia facil de usar y eficiente.  Como complemento a la programacion multiparadigma, las principales ventajas de Oz radican en la programacion con restricciones y la programacion distribuida. Debido a su dise\u00f1o, Oz implementa un modelo de programacion distribuido que hace a la red transparente. Este modelo hace facil programar aplicaciones abiertas y tolerantes de fallos en el lenguaje. Para programacion con restricciones, Oz introduce la idea de espacios de computacion, los cuales permiten busquedas definidas por el usuario y estrategias de distribucion que son ortogonales al dominio de restricciones. ","snippet":"Oz es un lenguaje de programacion multi-paradigma.  Oz fue originalmente desarrollado en el laboratorio de Programacion de Sistemas en la Universidad de Saarland por Gert Smolka y sus estudiantes a co","enlaces_salientes":["Oz_(lenguaje_de_programaci%C3%B3n)","Oz_(lenguaje_de_programaci%C3%B3n)","Oz_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n","Unix","FreeBSD","Linux","Microsoft_Windows","Mac_OS_X","Programaci%C3%B3n_l%C3%B3gica","Programaci%C3%B3n_funcional","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_con_restricciones","Programaci%C3%B3n_distribuida","Programaci%C3%B3n_concurrente","Erlang","Control_de_autoridades","Open_Hub"]}
{"url":"Lenguaje_espec%C3%ADfico_del_dominio","titulo":"Lenguaje especifico de dominio","contenido":"En desarrollo de software e ingenieria de dominio, un lenguaje especifico de dominio, o \"lenguaje especifico del dominio\", (en ingles domain-specific language, DSL) es un lenguaje de programacion o especificacion dedicado a resolver un problema en particular, representar un problema especifico y proveer una tecnica para solucionar una situacion particular. El concepto no es nuevo pero se ha vuelto mas popular debido al aumento del uso de modelaje especifico del dominio.\u200b  Ejemplos de lenguajes especificos del dominio incluyen, Logo para ni\u00f1os, Verilog y VHSIC, R y S para estadisticas, Mata para programacion matricial, Mathematica y Maxima para matematicas, formulas de hojas de calculo y macros, SQL para consultas a bases de datos relacionales, Yacc para crear parseadores, expresiones regulares para crear analisis lexico, Generic Eclipse Modeling System para crear lenguajes con el objetivo de diagramar, Csound un lenguaje para sintesis digital, y los lenguajes de entrada de GraphViz y GrGen, paquetes de software usados para graficar y reescribir graficas.  Lo opuesto es:  Crear un lenguaje especifico del dominio (con software que lo soporte) vale la pena cuando permite que un tipo particular de problemas o soluciones puedan ser expresadas mas claramente que con otros lenguajes existentes, y el tipo de problema en cuestion reaparece lo suficiente. La programacion orientada a lenguajes considera la creacion de lenguajes especificos para expresar problemas una parte estandar para el proceso de solucionar el problema.  En los DSL, la semantica del lenguaje esta muy cercana al dominio del problema para el cual se dise\u00f1a. Tienen un alto nivel de abstraccion al usuario, por tanto, estan dirigidos a expertos en el dominio.  Metamodelado es el analisis, dise\u00f1o y construccion de los metamodelos necesarios para cubrir un determinado tipo de problemas, asi como las reglas y restricciones aplicables.   Metamodelo: conjunto de conceptos del dominio a modelar (metaclases) y las relaciones entre ellos (metasociaciones).  Tendremos que elegir, segun el problema a resolver, cual es el formato de representacion mas adecuado para nuestro DSL. \u00bfCual es el tipo de problema que queremos modelar? \u00bfQuienes seran los usuarios del lenguaje?  Dos tipos de DSL:  Existen varios tipos de transformaciones:  El Eclipse Modeling Project centra la evolucion y promocion del desarrollo de tecnologias basadas en modelos dentro de la comunidad Eclipse, proveyendo un conjunto unificado de frameworks para el modelaje, herramientas e implementacion de estandares. ","snippet":"En desarrollo de software e ingenieria de dominio, un lenguaje especifico de dominio, o \"lenguaje especifico del dominio\", (en ingles domain-specific language, DSL) es un lenguaje de programacion o es","enlaces_salientes":["Lenguaje_espec%C3%ADfico_de_dominio","Lenguaje_espec%C3%ADfico_de_dominio","Lenguaje_espec%C3%ADfico_de_dominio","Desarrollo_de_software","Lenguaje_de_programaci%C3%B3n","Verilog","Very_High_Speed_Integrated_Circuit","Mathematica","SQL","Yacc","Parseador","Expresi%C3%B3n_regular","C_(lenguaje_de_programaci%C3%B3n)","Java_(lenguaje_de_programaci%C3%B3n)","UML","Metamodelado","Framework","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Logo_(lenguaje_de_programaci%C3%B3n)","titulo":"Logo (lenguaje de programacion)","contenido":"Logo es un lenguaje de programacion de alto nivel, en parte funcional, en parte estructurado; de muy facil aprendizaje, razon por la cual suele ser el lenguaje de programacion preferido para trabajar con ni\u00f1os y jovenes. Fue dise\u00f1ado con fines didacticos por Wally Feurzeig, Seymour Papert y Cynthia Solomon, quienes se basaron en las caracteristicas del lenguaje Lisp. Se creo con la finalidad de usarlo para ense\u00f1ar programacion y puede usarse para ense\u00f1ar la mayoria de los principales conceptos de la programacion, ya que proporciona soporte para manejo de listas, archivos y entrada/salida. Cuenta con varias versiones.  Papert desarrollo un enfoque basado en su experiencia con Piaget a principios de los sesenta. Fundamentalmente consiste en presentar a los ni\u00f1os retos intelectuales que puedan ser resueltos mediante el desarrollo de programas en Logo. El proceso de revision manual de los errores contribuye a que el ni\u00f1o desarrolle habilidades metacognitivas al poner en practica procesos de autocorreccion. Es conocido por poder manejar con facilidad graficas tortuga, listas, archivos y recursividad.  Logo es uno de los pocos lenguajes de programacion con instrucciones en espa\u00f1ol en algunos interpretes, entre ellos: FMSLogo, LogoWriter, WinLogo, Logo Grafico, XLogo, MSWLogo y LogoEs. Logo tiene mas de 180 interpretes y compiladores, segun constan en el proyecto \"Logo Tree\".  XLogo, MSWLogo y LogoES tienen la particularidad de ser ademas software libre.  Una caracteristica mas explotada de Logo es poder producir \u00abgraficos tortuga\u00bb, es decir, poder en dar instrucciones a una tortuga virtual, un cursor grafico usado para crear dibujos, que en algunas versiones es un triangulo, en otras tiene la figura de una tortuga vista desde arriba. Esta tortuga o cursor se maneja mediante palabras que representan instrucciones, por ejemplo:  La caracteristica de que las instrucciones se puedan comprender en las diferentes lenguas es lo que hace al Logo un lenguaje de programacion tan facil de aprender. Una secuencia de instrucciones en Logo puede constituirse en un rudimentario programa, usandose como un bloque. Esta caracterisctica modular y reutilizable de las instrucciones hace que Logo sea muy flexible, recursivo, y apto para trabajarse en forma de modulos.  Otras instrucciones basicas de Logo en espa\u00f1ol son:  Las instrucciones basicas de desplazamiento varian de una version de LOGO a otra, pudiendo encontrar como equivalentes: DE, DERECHA, GD, por ejemplo, para indicar un giro en sentido de las agujas del reloj. ","snippet":"Logo es un lenguaje de programacion de alto nivel, en parte funcional, en parte estructurado; de muy facil aprendizaje, razon por la cual suele ser el lenguaje de programacion preferido para trabajar ","enlaces_salientes":["Logo_(lenguaje_de_programaci%C3%B3n)","Logo_(lenguaje_de_programaci%C3%B3n)","Logo_(lenguaje_de_programaci%C3%B3n)","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_funcional","Programaci%C3%B3n_imperativa","Reflexi%C3%B3n_(inform%C3%A1tica)","Wally_Feurzeig","Seymour_Papert","Cynthia_Solomon","Sistema_de_tipos","UCBLogo","NetLogo","NetLogo","Smalltalk","Etoys_(lenguaje_de_programaci%C3%B3n)","Scratch_(lenguaje_de_programaci%C3%B3n)","KTurtle","Simetr%C3%ADa_central","Lenguaje_de_programaci%C3%B3n","Wally_Feurzeig","Seymour_Papert","Cynthia_Solomon","Lisp","Programaci%C3%B3n","Seymour_Papert","Piaget","A%C3%B1os_1960","Gr%C3%A1ficas_tortuga","Int%C3%A9rprete_(inform%C3%A1tica)","LogoWriter","MSWLogo","Software_libre","Gr%C3%A1ficas_tortuga","Lenguaje_de_programaci%C3%B3n_FP","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Variable_(programaci%C3%B3n)","titulo":"Variable (programacion)","contenido":"En programacion, una variable esta formada por un espacio en el sistema de almacenaje (memoria principal de un ordenador) y un nombre simbolico (un identificador) que esta asociado a dicho espacio. Ese espacio contiene una cantidad de informacion conocida o desconocida, es decir un valor. El nombre de la variable es la forma usual de referirse al valor almacenado: esta separacion entre nombre y contenido permite que el nombre sea usado independientemente de la informacion exacta que representa. El identificador, en el codigo fuente de la computadora puede estar ligado a un valor durante el tiempo de ejecucion y el valor de la variable puede por lo tanto cambiar durante el curso de la ejecucion del programa. El concepto de variables en computacion puede no corresponder directamente al concepto de variables en matematica. El valor de una variable en computacion no es necesariamente parte de una ecuacion o [[Formula (expresion)|formula como en matematicas. En computacion una variable puede ser utilizada en un proceso repetitivo: puede asignarsele un valor en un sitio, ser luego utilizada en otro, mas adelante reasignarsele un nuevo valor para mas tarde utilizarla de la misma manera. Procedimientos de este tipo son conocidos con el nombre de iteracion. En programacion de computadoras, a las variables, frecuentemente se le asignan nombres largos para hacerlos relativamente descriptivas para su uso, mientras que las variables en matematicas a menudo tienen nombres escuetos, formados por uno o dos caracteres para hacer breve en su transcripcion y manipulacion.  El espacio en el sistema de almacenaje puede ser referido por diferentes identificadores . Esta situacion es conocida entre los angloparlantes como \"aliasing\"  y podria traducirse como \"sobre nombramiento\" para los hispanoparlantes. Asignarle un valor a una variable utilizando uno de los identificadores cambiara el valor al que se puede acceder a traves de los otros identificadores.  En el proceso de compilacion de un programa, los compiladores deben transformar el codigo escrito por el programador en codigo ejecutable. Asi, las variables que son nombradas por el programador con un nombre simbolico, como por ejemplo \"x\", deben ser reemplazadas por la ubicacion real de los datos en la memoria del ordenador.  Esto significa que el compilador debe asignar una direccion de memoria especifica para cada variable utilizada en el programa, y luego reemplazar el nombre simbolico utilizado por el programador por esta direccion de memoria real. De esta manera, cuando el programa comienza a ejecutarse, el ordenador puede encontrar y manipular los datos almacenados en la memoria utilizando estas direcciones de memoria reales.  Mientras que el nombre, tipo y ubicacion de una variable permanecen fijos, los datos almacenados en la ubicacion pueden ser cambiados durante la ejecucion del programa.  Las variables no pueden almacenar declaraciones (como \"for\" o \"if\") o funciones que no devuelvan datos. En el caso contrario, devolveran error.  Las variables pueden ser de longitud:  Debido a que las variables contienen o apuntan y muestran a valores de tipos determinados, las operaciones sobre las mismas y el dominio de sus propios valores estan determinadas por el tipo de datos en cuestion. Algunos tipos de datos usados:  Las variables pueden ser intercambiadas entre rutinas, por valor y por referencia:  Las variables se representan con identificadores que hacen referencia a un lugar de la memoria del programa en donde se almacena un dato. Una variable esta asociada a un tipo de datos, el cual y en funcion del tama\u00f1o del mismo determina la cantidad de bytes que seran necesarios para almacenar la variable. En el caso de colecciones y al contrario que con el resto de tipo de datos, ya sean primitivos u objetos complejos, la memoria asignada a almacenar tales variables no se conoce de antemano, lo cual lleva a establecer politicas de reserva de memoria:  Respecto al ambito de una variable, este puede ser:  Si bien es cierto, que de una forma basica, se puede definir el ambito de las variables de la forma expuesta mas arriba, existen grados de globalidad de las mismas, pudiendo ser accesibles desde unos puntos u otros, o incluso pudiendo ser accesibles entre aplicaciones distintas, llegando al caso de la superglobalidad. Ejemplo del ambito de una variable en el lenguaje de programacion Java. ","snippet":"En programacion, una variable esta formada por un espacio en el sistema de almacenaje (memoria principal de un ordenador) y un nombre simbolico (un identificador) que esta asociado a dicho espacio. Es","enlaces_salientes":["Variable_(programaci%C3%B3n)","Variable_(programaci%C3%B3n)","Variable_(programaci%C3%B3n)","Programaci%C3%B3n","Memoria_principal","Ordenador","Identificador","Valor_(inform%C3%A1tica)","Referencia_(inform%C3%A1tica)","C%C3%B3digo_fuente","Binding","Tiempo_de_ejecuci%C3%B3n","Variable_(matem%C3%A1ticas)","Ecuaci%C3%B3n","Iteraci%C3%B3n","Compilador","Software","Tipo_de_dato","Array","Cadena_(inform%C3%A1tica)","Tipo_de_dato","Tipo_de_dato_l%C3%B3gico","Tipo_de_dato_entero","Coma_flotante","Tipo_de_dato_car%C3%A1cter","Cadena_(inform%C3%A1tica)","Subalgoritmo","Argumento_(Ciencias_de_la_computaci%C3%B3n)#Paso_de_Argumentos","Subrutina","Pila_de_llamadas","Puntero_(programaci%C3%B3n)","Asignaci%C3%B3n_de_memoria","Tipo_de_dato","Byte","Memoria_de_ordenador","%C3%81mbito_(programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n_Java","%C3%81mbito_(programaci%C3%B3n)","Variable_global","Variable_est%C3%A1tica","Variable_externa","Variable_de_instancia","Variable_de_clase","Variable_de_entorno","Tipo_de_dato","Constante_(inform%C3%A1tica)","Control_de_autoridades"]}
{"url":"Pauscal","titulo":"Pauscal","contenido":"Pauscal es un lenguaje de programacion para Microsoft Windows de 32 bits desarrollado por Paul Guerra. La caracteristica particular de este lenguaje de programacion es que su sintaxis esta basada en el idioma espa\u00f1ol. Esto lo hace ideal para aquellos que desean iniciarse en la programacion. Sin embargo, este lenguaje es potente y no se limita a fines educativos.  El compilador de Pauscal genera codigo nativo para Microsoft Windows de 32 bits. Por este motivo, los programas hechos en Pauscal no requieren ningun tipo de soporte externo para poder ejecutarse.  El editor de Pauscal incluye un sistema de resalte sintactico, el cual permite ver el codigo de sus programas de una forma mas comoda. Para simplificar la creacion de aplicaciones con interfaces visuales, Pauscal incluye Visual Pauscal, el cual permite dise\u00f1ar visualmente las ventanas de sus programas. Los programas creados en Pauscal son de su propiedad y los puede distribuir libremente.    La idea de un lenguaje en espa\u00f1ol surgio cuando el desarrollador principal vio a sus compa\u00f1eros programar en pseudocodigo. El proyecto fue iniciado en 2001 con un compilador hecho en Visual Basic, C y Ensamblador.  El nombre Pauscal (Paul + Pascal = Pauscal) fue dado por los compa\u00f1eros de colegio del desarrollador. Es una combinacion entre el nombre del desarrollador y el lenguaje Pascal, que era el que usaban en clases.[cita\u00a0requerida]  Actualmente la comunidad de Pauscal tiene la meta de que sea un lenguaje potente orientado a objetos, facil de usar, con un buen entorno de desarrollo, y gratuito.  Pauscal a pesar de ser un lenguaje de programacion estructural permite el uso de la sentencia GoTo que este tipo de paradigma considera \"innecesario y contraproducente\".  Los identificadores de las variables son opcionales, puede evitarse el nombrado de estos en procedimientos, clases, estructuras, uniones y prototipos. La siguiente linea de codigo es permitida y totalmente funcional.  Pauscal posee funciones indocumentadas pertenecientes a la maquina virtual de Microsoft Visual Basic 6.0 (MSVBVM60) que son compatibles con el lenguaje y facilmente utilizables, esta biblioteca es actualmente incluida por defecto en Windows 7, 8 y 10.  Pauscal tiene un bucle que nunca se acaba o tambien denominado como \"bucle infinito\" (Repetir ... PorSiempre), pero esto no es ningun error como se describe en la referencia recien establecida, sino que es una caracteristica del lenguaje y es muy util cuando se trabaja con aplicaciones sin interfaz grafica. ","snippet":"Pauscal es un lenguaje de programacion para Microsoft Windows de 32 bits desarrollado por Paul Guerra. La caracteristica particular de este lenguaje de programacion es que su sintaxis esta basada en e","enlaces_salientes":["Pauscal","Pauscal","Pauscal","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_basada_en_prototipos","Programaci%C3%B3n_funcional","Programaci%C3%B3n_gen%C3%A9rica","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_por_procedimientos","Programaci%C3%B3n_estructurada","Sistema_de_tipos","Tipado_fuerte","Sistema_operativo","Windows","Microsoft_Windows","32_bits","Lenguaje_de_programaci%C3%B3n","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_basada_en_prototipos","JavaScript","Self","API","Windows_95","Windows_98","Windows_98_SE","Windows_ME","Windows_XP","Windows_Vista","Windows_7","Windows_8","Protocolo_de_internet","Transmission_Control_Protocol","UDP","Win32","Puntero_(inform%C3%A1tica)","Multihilo","Visual_Basic","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Autoit","AutoHotkey","Windows","Autoit","Windows","GOTO","Brainfuck","C%C3%B3digo_objeto","Pseudoc%C3%B3digo","Visual_Basic","C_(lenguaje_de_programaci%C3%B3n)","Ensamblador","Pascal_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n","Programaci%C3%B3n_estructurada","GOTO","Windows","Bucle_infinito","Wayback_Machine","Control_de_autoridades"]}
{"url":"JavaScript","titulo":"JavaScript","contenido":"JavaScript (abreviado comunmente JS) es un lenguaje de programacion interpretado, dialecto del estandar ECMAScript. Se define como orientado a objetos,\u200b basado en prototipos, imperativo, debilmente tipado y dinamico.  Se utiliza principalmente del  lado del cliente, implementado como parte de un navegador web permitiendo mejoras en la interfaz de usuario y paginas web dinamicas\u200b y JavaScript del lado del servidor (Server-side JavaScript o SSJS). Su uso en aplicaciones externas a la web, por ejemplo en documentos PDF, aplicaciones de escritorio (mayoritariamente widgets) es tambien significativo.  Desde 2012, todos los navegadores modernos soportan completamente ECMAScript 5.1, una version de JavaScript. Los navegadores mas antiguos soportan por lo menos ECMAScript 3. La sexta edicion se libero en julio de 2015.\u200b  JavaScript se dise\u00f1o con una sintaxis similar a C++ y Java,\u200b\u200b aunque adopta nombres y convenciones del lenguaje de programacion Java. Sin embargo, Java y JavaScript tienen semanticas y propositos diferentes. Su relacion es puramente comercial, tras la compra del creador de Java (Sun Microsystems) de Netscape Navigator (creador de LiveScript) y el cambio de nombre del lenguaje de programacion.  Todos los navegadores modernos interpretan el codigo JavaScript integrado en las paginas web. Para interactuar con una pagina web se provee al lenguaje JavaScript de una implementacion del Document Object Model (DOM). Javascript es el unico lenguaje de programacion que entienden de forma nativa los navegadores.  Tradicionalmente se venia utilizando en paginas web HTML para realizar operaciones y unicamente en el marco de la aplicacion cliente, sin acceso a funciones del servidor. Actualmente es ampliamente utilizado para enviar y recibir informacion del servidor junto con ayuda de otras tecnologias como AJAX. JavaScript se interpreta en el agente de usuario al mismo tiempo que las sentencias van descargandose junto con el codigo HTML.  Desde el lanzamiento en junio de 1997 del estandar ECMAScript 1, han existido las versiones 2, 3 y 5, que es la mas usada actualmente (la 4 se abandono\u200b). En junio de 2015 se cerro y publico la version ECMAScript 6.\u200b  JavaScript fue desarrollado originalmente por Brendan Eich de Netscape con el nombre de Mocha, el cual fue renombrado posteriormente a LiveScript, para finalmente quedar como JavaScript. El cambio de nombre coincidio aproximadamente con el momento en que Netscape agrego compatibilidad con la tecnologia Java en su navegador web Netscape Navigator en la version 2002 en diciembre de 1995. La denominacion produjo confusion, dando la impresion de que el lenguaje es una prolongacion de Java, y fue considerada por muchos como una estrategia de mercadotecnia de Netscape para obtener prestigio e innovar en el ambito de los nuevos lenguajes de programacion web.\u200b\u200b  \u00abJAVASCRIPT\u00bb es una marca registrada de Oracle Corporation.\u200b Es usada con licencia por los productos creados por Netscape Communications y entidades actuales como la Fundacion Mozilla.\u200b\u200b  Microsoft dio como nombre a su dialecto de JavaScript \u00abJScript\u00bb, para evitar problemas relacionadas con la marca. JScript fue adoptado en la version 3.0 de Internet Explorer, liberado en agosto de 1996, e incluyo compatibilidad con el Efecto 2000 con las funciones de fecha, una diferencia de los que se basaban en ese momento. Los dialectos pueden parecer tan similares que los terminos \u00abJavaScript\u00bb y \u00abJScript\u00bb a menudo se utilizan indistintamente, pero la especificacion de JScript es incompatible con la de ECMA en muchos aspectos.  Para evitar estas incompatibilidades, el World Wide Web Consortium dise\u00f1o el estandar Document Object Model (DOM, o Modelo de Objetos del Documento en espa\u00f1ol), que incorporan Konqueror, las versiones 6 de Internet Explorer y Netscape Navigator, Opera la version 7, Mozilla Application Suite y Mozilla Firefox desde su primera version.[cita\u00a0requerida]  En 1997 los autores propusieron\u200b JavaScript para que fuera adoptado como estandar de la European Computer Manufacturers 'Association ECMA, que a pesar de su nombre no es europeo sino internacional, con sede en Ginebra. En junio de 1997 fue adoptado como un estandar ECMA, con el nombre de ECMAScript. Poco despues tambien como un estandar ISO.  Netscape introdujo una implementacion de script del lado del servidor con Netscape Enterprise Server, lanzada en diciembre de 1994 (poco despues del lanzamiento de JavaScript para navegadores web).\u200b\u200b A partir de mediados de la decada de los 2000, ha habido una proliferacion de implementaciones de JavaScript para el lado servidor. Node.js es uno de los notables ejemplos de JavaScript en el lado del servidor, siendo usado en proyectos importantes.\u200b\u200b  JavaScript se ha convertido en uno de los lenguajes de programacion mas populares en internet y mas usados. Al principio, sin embargo, muchos desarrolladores renegaban del lenguaje porque el publico al que va dirigido lo formaban publicadores de articulos y demas aficionados, entre otras razones.\u200b La llegada de Ajax devolvio JavaScript a la fama y atrajo la atencion de muchos otros programadores. Como resultado de esto hubo una proliferacion de un conjunto de frameworks y bibliotecas de ambito general, mejorando las practicas de programacion con JavaScript, y aumentado el uso de JavaScript fuera de los navegadores web, como se ha visto con la proliferacion de entornos JavaScript del lado del servidor. En enero de 2009, el proyecto CommonJS fue inaugurado con el objetivo de especificar una biblioteca para uso de tareas comunes principalmente para el desarrollo fuera del navegador web.\u200b  En junio de 2015 se cerro y publico el estandar ECMAScript 6\u200b\u200b con un soporte irregular entre navegadores\u200b y que dota a JavaScript de caracteristicas avanzadas que se echaban de menos y que son de uso habitual en otros lenguajes como, por ejemplo, modulos para organizacion del codigo, verdaderas clases para programacion orientada a objetos, expresiones de flecha, iteradores, generadores o promesas para programacion asincrona.  La version 7 de ECMAScript se conoce como ECMAScript 2016,\u200b y es la ultima version disponible, publicada en junio de 2016. Se trata de la primera version para la que se usa un nuevo procedimiento de publicacion anual y un proceso de desarrollo abierto.\u200b  Las siguientes caracteristicas son comunes a todas las implementaciones que se ajustan al estandar ECMAScript, a menos que especifique explicitamente en caso contrario.  JavaScript es compatible con gran parte de la estructura de programacion de C (por ejemplo, sentencias if, bucles for, sentencias switch, etc.). Con una salvedad, en parte: en C, el ambito de las variables alcanza al bloque en el cual fueron definidas; sin embargo JavaScript no es compatible con esto, puesto que el ambito de las variables es el de la funcion en la cual fueron declaradas. Esto cambia con la version de ECMAScript 2015, ya que a\u00f1ade compatibilidad con block scoping por medio de la palabra clave let. Como en C, JavaScript hace distincion entre expresiones y sentencias. Una diferencia sintactica con respecto a C es la insercion automatica de punto y coma, es decir, en JavaScript los puntos y coma que finalizan una sentencia pueden ser omitidos.\u200b  JavaScript se encuentra oficialmente bajo la organizacion de Mozilla Foundation, y periodicamente se a\u00f1aden nuevas caracteristicas del lenguaje. Sin embargo, solo algunos motores JavaScript son compatibles con estas caracteristicas:  La ultima version del lenguaje es ECMAScript 2016 publicada el 17 de junio del a\u00f1o 2016.\u200b  Las variables en JavaScript se definen usando la palabra clave var:\u200b  A considerar los comentarios en el ejemplo de arriba, los cuales van precedidos con 2 barras diagonales.  No existen funcionalidades para I/O incluidas en el lenguaje; el entorno de ejecucion ya lo proporciona. La especificacion ECMAScript en su edicion 5.1 hace mencion:\u200b  ... en efecto, no existen provisiones en esta especificacion para entrada de datos externos o salida para resultados computados. Sin embargo, la mayoria de los entornos de ejecucion tiene un objeto\u200b llamado console que puede ser usado para imprimir por el flujo de salida de la consola de depuracion. He aqui un simple programa que imprime \u201cHello world!\u201d:  Una funcion recursiva:  Ejemplos de funcion anonima (o funcion lambda) y una clausura:  Las expresiones con invocacion automatica permiten a las funciones pasarle variables por parametro dentro de sus propias clausuras.  El siguiente codigo muestra varias caracteristicas de JavaScript.  El siguiente ejemplo muestra la salida que deberia ser mostrada en la ventana de un navegador.  El uso mas comun de JavaScript es escribir funciones embebidas o incluidas en paginas HTML y que interactuan con el Document Object Model (DOM o Modelo de Objetos del Documento) de la pagina. Algunos ejemplos sencillos de este uso son:  Dado que el codigo JavaScript puede ejecutarse localmente en el navegador del usuario (en lugar de en un servidor remoto), el navegador puede responder a las acciones del usuario con rapidez, haciendo una aplicacion mas sensible. Por otra parte, el codigo JavaScript puede detectar acciones de los usuarios que HTML por si sola no puede, como pulsaciones de teclado. Las aplicaciones como Gmail se aprovechan de esto: la mayor parte de la logica de la interfaz de usuario esta escrita en JavaScript, enviando peticiones al servidor (por ejemplo, el contenido de un mensaje de correo electronico). La tendencia cada vez mayor por el uso de la programacion Ajax explota de manera similar esta tecnica.  Un motor de JavaScript (tambien conocido como interprete de JavaScript o implementacion JavaScript) es un interprete que interpreta el codigo fuente de JavaScript y ejecuta la secuencia de comandos en consecuencia. El primer motor de JavaScript fue creado por Brendan Eich en Netscape Communications Corporation, para el navegador web Netscape Navigator. El motor, denominado SpiderMonkey, esta implementado en C. Desde entonces, ha sido actualizado (en JavaScript 1.5) para cumplir con el ECMA-262 edicion 3. El motor Rhino, creado principalmente por Norris Boyd (antes de Netscape, ahora en Google) es una implementacion de JavaScript en Java. Rhino, como SpiderMonkey, es compatible con el ECMA-262 edicion 3.  Un navegador web es, con mucho, el entorno de acogida mas comun para JavaScript. Los navegadores web suelen crear objetos no nativos, dependientes del entorno de ejecucion, para representar el Document Object Model (DOM) en JavaScript. El servidor web es otro entorno comun de servicios. Un servidor web JavaScript suele exponer sus propios objetos para representar objetos de peticion y respuesta HTTP, que un programa JavaScript podria entonces interrogar y manipular para generar dinamicamente paginas web.  Debido a que JavaScript es el unico lenguaje por el que los mas populares navegadores comparten su apoyo, se ha convertido en un lenguaje al que muchos frameworks en otros lenguajes compilan, a pesar de que JavaScript no fue dise\u00f1ado para tales propositos.\u200b A pesar de las limitaciones de rendimiento inherentes a su naturaleza dinamica, el aumento de la velocidad de los motores de JavaScript ha hecho de este lenguaje un entorno para la compilacion sorprendentemente factible.  A continuacion se muestra un breve ejemplo de una pagina web (ajustandose a las normas del estandar para HTML5) que utiliza JavaScript para el manejo del DOM:  Debido a que JavaScript se ejecuta en entornos muy variados, una parte importante de las pruebas y la depuracion es probar y verificar que el codigo JavaScript funciona correctamente en multiples navegadores. La interfaz DOM para acceder y manipular paginas web no es parte del estandar ECMAScript, o de la propia JavaScript. El DOM es definido por los esfuerzos de estandarizacion del W3C, una organizacion independiente. En la practica, las implementaciones que hacen de JavaScript los distintos navegadores difieren tanto entre ellos mismos como de las normas del estandar.  Para hacer frente a estas diferencias, los autores de JavaScript pudieron ser capaces de escribir codigo compatible con los estandares que tambien fuera capaz de ejecutarse correctamente en la mayoria de los navegadores, o en su defecto, que al menos se pudiera escribir codigo capaz de comprobar la presencia de ciertas funcionalidades del navegador y que se comportase de manera diferente si no se dispusiese de dicha funcionalidad.\u200b Existen casos en los que dos navegadores pueden llegar a implementar la misma caracteristica, pero con un comportamiento diferente, hecho que a los programadores les puede resultar de ayuda para detectar que navegador se esta ejecutando en ese instante y asi cambiar el comportamiento de su escritura para que coincida.\u200b\u200b Los programadores tambien suelen utilizar bibliotecas o herramientas que tengan en cuenta las diferencias entre navegadores.  Ademas, los scripts pueden no funcionar para algunos usuarios. Por ejemplo, un usuario puede:  Para apoyar a estos usuarios, los programadores web suelen crear paginas que sean tolerante de fallos segun el agente de usuario (tipo de navegador) que no admita JavaScript. En particular, la pagina debe seguir siendo util aunque sin las caracteristicas adicionales que JavaScript habria a\u00f1adido. Un enfoque alternativo que muchos encuentran preferible es primero crear contenido utilizando las tecnologias que funcionan en todos los navegadores, y mejorar el contenido para los usuarios que han permitido JavaScript.  Suponiendo que el usuario no haya desactivado la ejecucion de codigo JavaScript, en el lado del cliente JavaScript debe ser escrito tanto con el proposito de mejorar las experiencias de los visitantes con discapacidad visual o fisica, como el de evitar ocultar informacion a estos visitantes.\u200b  Los lectores de pantalla, utilizados por los ciegos y deficientes visuales, pueden ser tenidos en cuenta por JavaScript y asi poder acceder y leer los elementos DOM de la pagina. El codigo HTML escrito debe ser lo mas conciso, navegable y semanticamente rico posible, tanto si JavaScript se ejecuta como si no.  JavaScript no deberia de ser totalmente dependiente de los eventos de raton del navegador y deberia ser accesible para aquellos usuarios que no quieran hacer uso del raton (informatica) para navegar o que opten por utilizar solamente el teclado. Hay eventos independientes del dispositivo, tales como onfocus y onchange que son preferibles en la mayoria de los casos.\u200b  JavaScript no debe ser utilizado para crear confusion o desorientacion al usuario web. Por ejemplo, modificar o desactivar la funcionalidad normal del navegador, como cambiar la forma en que el boton de navegar hacia atras o el evento de actualizacion se comportan, son practicas que generalmente son mejores evitar. Igualmente, desencadenar eventos que el usuario puede no tener en cuenta reduce la sensacion de control del usuario y provoca cambios inesperados al contenido de la pagina.\u200b  A menudo, el proceso de dotar a una pagina web compleja el mayor grado accesibilidad posible, se convierte en un problema no trivial donde muchos temas se acaban llevando al debate y a la opinion, siendo necesario el compromiso de todos hasta el final. Sin embargo, los agentes de usuario y las tecnologias de apoyo a personas con discapacidad estan en constante evolucion y nuevas directrices e informacion al respecto siguen publicandose en la web.\u200b  JavaScript y el DOM permite que existan programadores que hagan un uso inapropiado para introducir scripts que ejecuten codigo con contenido malicioso sin el consentimiento del usuario y que pueda asi comprometer su seguridad.  Los desarrolladores de los navegadores tienen en cuenta este riesgo utilizando dos restricciones. En primer lugar, los scripts se ejecutan en un sandbox en el que solo se pueden llevar a cabo acciones relacionadas con la web, no con tareas de programacion de proposito general, como la creacion de archivos. En segundo lugar, esta limitada por la politica del mismo origen: los scripts de un sitio web no tienen acceso a la informacion enviada a otro sitio web (de otro dominio) como pudiera ser nombres de usuario, contrase\u00f1as o cookies. La mayoria de los fallos de seguridad de JavaScript estan relacionados con violaciones de cualquiera de estas dos restricciones.  Existen proyectos como AdSafe o Secure ECMA script (SES) que proporcionan mayores niveles de seguridad, en especial en el codigo creado por terceros (tales como los anuncios).\u200b\u200b  La Politica de Contenido Seguro (CSP) es el metodo principal previsto para garantizar que solo codigo de confianza pueda ser ejecutado en una pagina web.  Un problema comun de seguridad en JavaScript es el cross-site scripting o XSS, una violacion de la politica de mismo origen. Las vulnerabilidades XSS permiten a un atacante inyectar codigo JavaScript en paginas web visitadas por el usuario. Una de esas webs podria ser la de un banco, pudiendo el atacante acceder a la aplicacion de banca con los privilegios de la victima, lo que podria revelar informacion secreta o transferir dinero sin la autorizacion de la victima. Una solucion para las vulnerabilidades XSS es utilizar HTML escaping cuando se muestre informacion de fuentes no confiables.  Algunos navegadores incluyen una proteccion parcial contra los ataques XSS reflejados (el atacante esta en la misma peticion web). El atacante proporciona una URL incluyendo codigo malicioso. Sin embargo, incluso los usuarios de los navegadores son vulnerables a otros ataques XSS, tales como aquellos en los que el codigo malicioso se almacena en una base de datos. Solo el correcto dise\u00f1o de las aplicaciones Web en la parte servidora puede prevenir totalmente XSS. Las vulnerabilidades XSS tambien pueden ocurrir debido a errores de ejecucion por los desarrolladores del navegador.\u200b  Otra vulnerabilidad es la falsificacion de peticion de sitio cruzado o CSRF. En CSRF, el codigo del sitio web atacante enga\u00f1a al navegador de la victima, permitiendo al atacante realizar peticiones en nombre de la victima, haciendo imposible saber a la aplicacion de destino (por ejemplo, la de un banco haciendo una transferencia de dinero) saber si la peticion ha sido realizada voluntariamente por el usuario o por un ataque CSRF.  El ataque funciona porque, si el sitio de destino hace uso unicamente de las cookies para autenticar las solicitudes de la victima, las peticiones iniciadas por el codigo del atacante tendran las mismas credenciales de acceso legitimo que las solicitudes iniciadas por el propio usuario.  En general, la solucion a CSRF consiste en introducir un campo de formulario oculto cuyo valor se utilice para realizar la autenticacion, y no solo por medio de las cookies, en solicitudes que puedan tener efectos duraderos. La comprobacion de la cabecera HTTP referer tambien puede servir de ayuda.  \"Hijacking JavaScript\" es un tipo de ataque CSRF en el que una etiqueta <script> en el sitio web del atacante explota una vulnerabilidad en la pagina del sitio de la victima que le hace devolver informacion privada, en forma de JSON o codigo JavaScript. Las posibles soluciones son:  En JavaScript, disponer de un depurador se convierte en necesario cuando se desarrollan grandes aplicaciones, no triviales. Dado que puede haber diferencias de implementacion entre los diferentes navegadores (especialmente en cuanto al DOM), es util tener acceso a un depurador para cada uno de los navegadores a los cuales nuestra aplicacion web ira dirigido.\u200b  Los depuradores web estan disponibles para Internet Explorer, Firefox, Safari, Google Chrome y Opera.\u200b  Existen tres depuradores disponibles para Internet Explorer: Microsoft Visual Studio es el mas avanzado de los tres, seguido de cerca por Microsoft Script Editor (un componente de Microsoft Office)\u200b y, finalmente, Microsoft Script Debugger, que es mucho mas basico que el otro dos, aunque es gratuito. El IDE gratuito Microsoft Visual Web Developer Express ofrece una version limitada de la funcionalidad de depuracion de JavaScript en el Microsoft Visual Studio. Internet Explorer ha incluido herramientas de desarrollo desde la version 8 (se muestra pulsando la tecla F12). Las aplicaciones web dentro de Firefox se pueden depurar usando el Firebug add-on o el antiguo depurador Venkman. Firefox tambien tiene integrada una consola de errores basica, que registra y evalua JavaScript. Tambien registra errores de CSS y advertencias. Opera incluye un conjunto de herramientas llamado Dragonfly.\u200b El Inspector Web de WebKit incluye un depurador de JavaScript\u200b utilizado en Safari, junto con una version modificada de Google Chrome.  Existen algunas herramientas de ayuda a la depuracion, tambien escritas en JavaScript y construidas para ejecutarse en la Web. Un ejemplo es el programa JSLint, desarrollado por Douglas Crockford, quien ha escrito extensamente sobre el lenguaje. JSLint analiza el codigo JavaScript para que este quede conforme con un conjunto de normas y directrices y que aseguran su correcto funcionamiento y mantenibilidad. ","snippet":"JavaScript (abreviado comunmente JS) es un lenguaje de programacion interpretado, dialecto del estandar ECMAScript. Se define como orientado a objetos,\u200b basado en prototipos, imperativo, debilmente ti","enlaces_salientes":["JavaScript","JavaScript","JavaScript","Java_(lenguaje_de_programaci%C3%B3n)","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n#Clasificaci\u00f3n_por_paradigmas","Programaci%C3%B3n_funcional","Programaci%C3%B3n_basada_en_prototipos","Programaci%C3%B3n_imperativa","Lenguaje_de_programaci%C3%B3n_interpretado","Netscape_Communications","Fundaci%C3%B3n_Mozilla","Sistema_de_tipos","Duck_typing","SpiderMonkey","Rhino_(int%C3%A9rprete_de_JavaScript)","KJS","JavaScriptCore","V8_(motor_JavaScript)","Chakra_(int%C3%A9rprete_de_JScript)","ECMAScript","Java_(lenguaje_de_programaci%C3%B3n)","Perl","Self","Python","C_(lenguaje_de_programaci%C3%B3n)","Scheme","Lenguaje_de_programaci%C3%B3n","Int%C3%A9rprete_(inform%C3%A1tica)","ECMAScript","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_basada_en_prototipos","Tipado_fuerte#Lenguajes_no_tipados","Tipado_din%C3%A1mico","Cliente_(inform%C3%A1tica)","Navegador_web","Interfaz_de_usuario","P%C3%A1gina_web","Script_del_lado_del_servidor","Aplicaci%C3%B3n_inform%C3%A1tica","World_Wide_Web","PDF","Widget","C%2B%2B","Java_(lenguaje_de_programaci%C3%B3n)","Document_Object_Model","HTML","Cliente_(inform%C3%A1tica)","Servidor","AJAX","Agente_de_usuario","HTML","ECMAScript","Brendan_Eich","Netscape_Communications_Corporation","Netscape_Navigator","Marca_registrada","Oracle_Corporation","Netscape_Communications","Fundaci%C3%B3n_Mozilla","Microsoft","JScript","Efecto_2000","World_Wide_Web_Consortium","Document_Object_Model","Konqueror","Internet_Explorer","Netscape_Navigator","Opera_(navegador)","Mozilla_Application_Suite","Mozilla_Firefox","ECMA","ECMAScript","Organizaci%C3%B3n_Internacional_para_la_Estandarizaci%C3%B3n","Script_del_lado_del_servidor","Netscape_Enterprise_Server","Node.js","AJAX","Framework_para_aplicaciones_web","Biblioteca_(inform%C3%A1tica)","Navegador_web","CommonJS","ECMAScript","Clase_(inform%C3%A1tica)","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_estructurada","C_(lenguaje_de_programaci%C3%B3n)","%C3%81mbito_(programaci%C3%B3n)","Variable_(programaci%C3%B3n)","Expresi%C3%B3n_(inform%C3%A1tica)","Script","Sistema_de_tipos","String","Duck_typing","Programaci%C3%B3n_orientada_a_objetos","Az%C3%BAcar_sint%C3%A1ctico","Subrutinas","Clausura_(inform%C3%A1tica)","Programaci%C3%B3n_basada_en_prototipos","Clase_(inform%C3%A1tica)","Herencia_(inform%C3%A1tica)","Navegador_web","HTML","M%C3%A9todo_(inform%C3%A1tica)","JSON","Expresiones_regulares","Perl","Mozilla_Foundation","Int%C3%A9rprete_de_JavaScript","Python","Variable_(programaci%C3%B3n)","Comentario_(inform%C3%A1tica)","Entrada/salida","Recursion","Lambda","Int%C3%A9rprete_de_JavaScript","AJAX","Gmail","SpiderMonkey","Rhino_(int%C3%A9rprete_de_JavaScript)","Java_(lenguaje_de_programaci%C3%B3n)","Rhino_(int%C3%A9rprete_de_JavaScript)","SpiderMonkey","HTML5","Document_Object_Model","Interoperabilidad_web","W3C","Tolerancia_a_fallos","Accesibilidad_web","Lector_de_pantalla","Rat%C3%B3n_(inform%C3%A1tica)","Accesibilidad_web","Seguridad_del_navegador","Script","Sandbox_(seguridad_inform%C3%A1tica)","Cross-site_scripting","Cross_Site_Request_Forgery","Cross-site_scripting","Internet_Explorer","Microsoft_Visual_Studio","Microsoft_Office","Entorno_de_desarrollo_integrado","Firefox","Firebug","Hojas_de_estilo_en_cascada","WebKit","Safari","Google_Chrome","Douglas_Crockford","Mantenibilidad","VBScript","AJAX","Aplicaci%C3%B3n_web","Document_Object_Model","JQuery","JSON","HTML","HTML5","Ars_Technica","Cond%C3%A9_Nast_Publications","Mozilla","ISBN","ISBN","ISBN","ISBN","Ecma_International","Mozilla","Piwik","Wayback_Machine","Control_de_autoridades","MediaWiki","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Enciclopedia_Brit%C3%A1nica","MediaWiki"]}
{"url":"C%C3%B3digo_duro","titulo":"Codificacion rigida","contenido":"La codificacion rigida,\u200b\u200b mas conocida por el anglicismo hard code[nota 1]\u200b[nota 2]\u200b termino del mundo de la informatica que hace referencia a una practica en el desarrollo de software que consiste en incrustar datos directamente en el codigo fuente del programa, en lugar de obtener esos datos de una fuente externa como un archivo de configuracion o parametros de la linea de comandos, o un archivo de recursos.  Esta practica tiene limitaciones, ya que requiere la modificacion del codigo fuente cada vez que cambian los datos, cuando lo conveniente seria que el usuario final pudiera cambiar estos detalles fuera del codigo fuente del programa.  Por ejemplo, una referencia a un fichero codificada rigidamente tendria escrito el nombre y la ruta al fichero en un lugar especifico del disco. Si la localizacion del fichero cambia, el programador ha de cambiar el codigo fuente para que apunte a la nueva localizacion. Una solucion a este problema seria tener una variable interna llamada \u00abnombreDeFichero\u00bb, que podria ser asignada mediante una ventana de dialogo de navegacion de ficheros, de esta manera no seria necesario cambiar el programa por un cambio en los datos.  Otro ejemplo de las limitaciones de la codificacion rigida puede producirse durante el desarrollo de una API, con la adicion o generacion de datos de forma dinamica que no se encuentran persistidos en almacen alguno ni especificados en archivos de configuracion. Delegar en el codigo fuente la generacion de esta informacion, en un principio no mutable, consumida muy habitualmente por un cliente de la API, provocara problemas de mantenimiento a medio y largo plazo, a pesar de sus aparentes ventajas a corto plazo, ademas de introducir un dise\u00f1o blackbox del sistema.  El abuso de esta practica es muy extendido entre programadores noveles, basicamente debido a su poco conocimiento de los estandares de programacion, aunque tambien puede darse en programadores de experiencia contrastada; en este caso algunos autores consideran que se trata de un sintoma de agotamiento que puede llevar al programador a abandonar practicas correctas en favor de otras mas rapidas, aun sabiendo que son incorrectas.  Un caso del uso correcto de esta practica es en sistemas embebidos que jamas tendran interaccion con ningun usuario y que tienen que mantener unos parametros de funcionamiento minimos a lo largo de toda su vida, de manera que en caso de perder los parametros configurados siempre pueda seguir funcionando. Esos parametros minimos deben indicarse explicitamente. Otro caso correcto de la codificacion rigida es definir los pines fisicos de un microcontrolador a los que tiene conectado los perifericos, por lo general estos valores son propios del sistema y jamas deberian poder ser modificados externamente al desarrollo. ","snippet":"La codificacion rigida,\u200b\u200b mas conocida por el anglicismo hard code[nota 1]\u200b[nota 2]\u200b termino del mundo de la informatica que hace referencia a una practica en el desarrollo de software que consiste en","enlaces_salientes":["Codificaci%C3%B3n_r%C3%ADgida","Codificaci%C3%B3n_r%C3%ADgida","Codificaci%C3%B3n_r%C3%ADgida","Anglicismo","Inform%C3%A1tica","Desarrollo_de_software","C%C3%B3digo_fuente","Programa_(computaci%C3%B3n)","Archivo_de_configuraci%C3%B3n","Argumento_(inform%C3%A1tica)","L%C3%ADnea_de_comandos","Ruta_(inform%C3%A1tica)","Fichero","Disco_duro","Programador","C%C3%B3digo_fuente","API","Persistencia_de_datos","Mantenimiento_de_software","Idioma_espa%C3%B1ol","Google_Acad%C3%A9mico","Control_de_autoridades"]}
{"url":"Expresi%C3%B3n_regular","titulo":"Expresion regular","contenido":"En computo teorico y teoria de lenguajes formales, una expresion regular o expresion racional \u200b\u200b (tambien son conocidas como regex o regexp,\u200b por su contraccion de las palabras inglesas regular expression) es una secuencia de caracteres que conforma un patron de busqueda. Se utilizan principalmente para la busqueda de patrones de cadenas de caracteres u operaciones de sustituciones.  Las expresiones regulares son patrones utilizados para encontrar una determinada combinacion de caracteres dentro de una cadena de texto. Las expresiones regulares proporcionan una manera muy flexible de buscar o reconocer cadenas de texto. Por ejemplo, el grupo formado por las cadenas Handel, Handel y Haendel se describe con el patron H(a|a|ae)ndel.  La mayoria de las formalizaciones proporcionan los siguientes constructores: una expresion regular es una forma de representar los lenguajes regulares (finitos o infinitos) y se construye utilizando caracteres del alfabeto sobre el cual se define el lenguaje.  Especificamente, las expresiones regulares se construyen utilizando los operadores union, concatenacion y clausura de Kleene. Toda expresion regular tiene algun automata finito asociado.  Una barra vertical separa las alternativas, las cuales son evaluadas de izquierda a derecha. Por ejemplo, amarillo|azul se corresponde con amarillo o azul.  Un cuantificador tras un caracter especifica la frecuencia con la que este puede ocurrir. Los cuantificadores mas comunes son ?, + y *:  Los parentesis pueden usarse para definir el ambito y precedencia de los demas operadores. Por ejemplo, (p|m)adre es lo mismo que padre|madre, y (des)?amor se corresponde con amor y con desamor.  Los constructores pueden combinarse libremente dentro de la misma expresion, por lo que H(ae?|a)ndel equivale a H(a|ae|a)ndel. La sintaxis precisa de las expresiones regulares cambia segun las herramientas y aplicaciones consideradas.  Su utilidad mas obvia es la de describir un conjunto de cadenas para una determinada funcion, resultando de utilidad en editores de texto y otras aplicaciones informaticas para buscar y manipular textos.  Numerosos editores de texto y otras herramientas utilizan expresiones regulares para buscar y reemplazar patrones en un texto. Por ejemplo, las herramientas proporcionadas por las distribuciones de Unix (incluyendo el editor sed y el filtro grep) popularizaron el concepto de expresion regular entre usuarios no programadores, aunque ya era familiar entre los programadores.  Inicialmente, este reconocimiento de cadenas se programaba para cada aplicacion sin mecanismo alguno inherente al lenguaje de programacion pero, con el tiempo, se ha ido incorporando el uso de expresiones regulares para facilitar programar la deteccion de ciertas cadenas. Por ejemplo, Perl tiene un potente motor de expresiones regulares directamente incluido en su sintaxis. Otros lenguajes lo han incorporado como funciones especificas sin incorporarlo a su sintaxis.  En el area de la programacion, las expresiones regulares son un metodo por medio del cual se pueden realizar busquedas dentro de cadenas de caracteres. Sin importar la amplitud de la busqueda requerida de un patron definido de caracteres, las expresiones regulares proporcionan una solucion practica al problema. Adicionalmente, un uso derivado de la busqueda de patrones es la validacion de un formato especifico en una cadena de caracteres dada, como por ejemplo fechas o identificadores.  Para poder utilizar las expresiones regulares al programar es necesario tener acceso a un motor de busqueda con la capacidad de utilizarlas. Es posible clasificar los motores disponibles en dos tipos segun su uso: motores para el programador y motores para el usuario final.  Motores para el usuario final: son programas que permiten realizar busquedas sobre el contenido de un archivo o sobre un texto extraido y colocado en el programa. Estan dise\u00f1ados para permitir al usuario realizar busquedas avanzadas usando este mecanismo, sin embargo es necesario aprender a redactar expresiones regulares adecuadas para poder utilizarlos eficientemente. Algunos programas disponibles de este tipo son:  Motores para el programador: permiten automatizar el proceso de busqueda de modo que sea posible utilizarlo muchas veces para un proposito especifico. Estas son algunas de las herramientas de programacion disponibles que ofrecen motores de busqueda con soporte a expresiones regulares:  Nota: de las herramientas mencionadas con anterioridad se utilizan el EditPad Pro y el .Net Framework para dar ejemplos, tambien es posible utilizar las expresiones regulares con cualquier combinacion de las herramientas mencionadas. Aunque en general las Expresiones Regulares utilizan un lenguaje comun en todas las herramientas, las explicaciones practicas acerca de la utilizacion de las herramientas y los ejemplos de codigo deben ser interpretados de forma diferente. Tambien es necesario hacer notar que existen algunos detalles de sintaxis de las expresiones regulares que son propios del .Net Framework que se utilizan en forma diferente en las demas herramientas de programacion. Cuando estos casos se den se hara notar en forma explicita para que el lector pueda buscar informacion respecto a estos detalles en fuentes adicionales. En el futuro se incluiran adicionalmente ejemplos de otras herramientas y lenguajes de programacion.  Expresiones regulares como motor de busqueda  Las expresiones regulares permiten encontrar porciones especificas de texto dentro de una cadena mas grande de caracteres. Asi, si es necesario encontrar el texto \"lote\" en la expresion \"el ocelote salto al lote contiguo\" cualquier motor de busqueda seria capaz de efectuar esta labor. Sin embargo, la mayoria de los motores de busqueda encontrarian tambien el fragmento \"lote\" de la palabra \"ocelote\", lo cual podria no ser el resultado esperado. Algunos motores de busqueda permiten adicionalmente especificar que se desea encontrar solamente palabras completas, solucionando este problema. Las expresiones regulares permiten especificar todas estas opciones adicionales y muchas otras sin necesidad de configurar opciones adicionales, sino utilizando el mismo texto de busqueda como un lenguaje que permite enviarle al motor de busqueda exactamente lo que deseamos encontrar en todos los casos, sin necesidad de activar opciones adicionales al realizar la busqueda.  Expresiones regulares como lenguaje  Para especificar opciones dentro del texto a buscar se utiliza un lenguaje o convencion mediante el cual se le transmite al motor de busqueda el resultado que se desea obtener. Este lenguaje le da un significado especial a una serie de caracteres. Por lo tanto cuando el motor de busqueda de expresiones regulares encuentre estos caracteres no los buscara en el texto en forma literal, sino que buscara lo que los caracteres significan. A estos caracteres se les llama algunas veces \"meta-caracteres\". A continuacion se listan los principales meta-caracteres y su funcion y como los interpreta el motor de expresiones regulares.  El punto se interpreta por el motor de busqueda como \"cualquier caracter\", es decir, busca cualquier caracter incluyendo los saltos de linea. Los motores de expresiones regulares tienen una opcion de configuracion que permite modificar este comportamiento. En .Net Framework se utiliza la opcion RegexOptions.Singleline para especificar la opcion de que busque todos los caracteres incluidos el salto de linea (\\n).  El punto se utiliza de la siguiente forma: Si se le dice al motor de RegEx que busque g.t en la cadena \"el gato de piedra en la gotica puerta de getisboro goot\" el motor de busqueda encontrara \"gat\", \"got\" y por ultimo \"get\". Notese que el motor de busqueda no encuentra \"goot\"; esto es porque el punto representa un solo caracter y unicamente uno. Si es necesario que el motor encuentre tambien la expresion \"goot\", sera necesario utilizar repeticiones, las cuales se explican mas adelante.  Aunque el punto es muy util para encontrar caracteres que no conocemos, es necesario recordar que corresponde a cualquier caracter y que muchas veces esto no es lo que se requiere. Es muy diferente buscar cualquier caracter que buscar cualquier caracter alfanumerico o cualquier digito o cualquier no-digito o cualquier no-alfanumerico. Se debe tomar esto en cuenta antes de utilizar el punto y obtener resultados no deseados.  Se utiliza para realizar una \"busqueda anticipada negativa\". La construccion de la expresion regular es con el par de parentesis, el parentesis de apertura seguido de un signo de interrogacion y un signo de exclamacion. Dentro de la busqueda tenemos la expresion regular. Por ejemplo, para excluir exactamente una palabra, habra que utilizar ^(palabra.+|(?!palabra).*)$.  La barra inversa se utiliza para escapar el siguiente caracter de la expresion de busqueda de forma que este adquiera un significado especial o deje de tenerlo. O sea, la barra inversa no se utiliza nunca por si sola, sino en combinacion con otros caracteres. Al utilizarlo por ejemplo en combinacion con el punto \\. este deja de tener su significado normal y se comporta como un caracter literal.  De la misma forma, cuando se coloca la barra inversa seguida de cualquiera de los caracteres especiales que discutiremos a continuacion, estos dejan de tener su significado especial y se convierten en caracteres de busqueda literal.  Como ya se menciono con anterioridad, la barra inversa tambien puede darle significado especial a caracteres que no lo tienen. A continuacion hay una lista de algunas de estas combinaciones:     Notas: La funcion de los corchetes en el lenguaje de las expresiones regulares es representar \"clases de caracteres\", o sea, agrupar caracteres en grupos o clases. Son utiles cuando es necesario buscar uno de un grupo de caracteres. Dentro de los corchetes es posible utilizar el guion - para especificar rangos de caracteres. Adicionalmente, los metacaracteres pierden su significado y se convierten en literales cuando se encuentran dentro de los corchetes. Por ejemplo, como vimos en la entrega anterior \\d es util para buscar cualquier caracter que represente un digito. Sin embargo esta denominacion no incluye el punto . que divide la parte decimal de un numero. Para buscar cualquier caracter que representa un digito o un punto podemos utilizar la expresion regular [\\d.]. Como se hizo notar anteriormente, dentro de los corchetes, el punto representa un caracter literal y no un metacaracter, por lo que no es necesario antecederlo con la barra inversa. El unico caracter que es necesario anteceder con la barra inversa dentro de los corchetes es la propia barra inversa. La expresion regular [\\dA-Fa-f] nos permite encontrar digitos hexadecimales. Los corchetes nos permiten tambien encontrar palabras aun si estan escritas de forma erronea, por ejemplo, la expresion regular expresi[oo]n permite encontrar en un texto la palabra \"expresion\" aunque se haya escrito con o sin tilde. Es necesario aclarar que sin importar cuantos caracteres se introduzcan dentro del grupo por medio de los corchetes, el grupo solo le dice al motor de busqueda que encuentre un solo caracter a la vez, es decir, que expresi[oo]n encontrara \"expresion\" o \"expresion\".  Sirve para indicar una de varias opciones. Por ejemplo, la expresion regular a|e encontrara cualquier \"a\" o \"e\" dentro del texto. La expresion regular este|oeste|norte|sur permitira encontrar cualquiera de los nombres de los puntos cardinales. La barra se utiliza comunmente en conjunto con otros caracteres especiales.  Representa el final de la cadena de caracteres o el final de la linea, si se utiliza el modo multilinea. No representa un caracter en especial sino una posicion. Si se utiliza la expresion regular \\.$ el motor encontrara todos los lugares donde un punto finalice la linea, lo que es util para avanzar entre parrafos.  Este caracter tiene una doble funcionalidad, que difiere cuando se utiliza individualmente y cuando se utiliza en conjunto con otros caracteres especiales. En primer lugar su funcionalidad como caracter individual: el caracter ^ representa el inicio de la cadena (de la misma forma que el signo de dolar $ representa el final de la cadena). Por tanto, si se utiliza la expresion regular ^[a-z] el motor encontrara todos los parrafos que den inicio con una letra minuscula. Cuando se utiliza en conjunto con los corchetes de la siguiente forma [^\\w ] permite encontrar cualquier caracter que NO se encuentre dentro del grupo indicado. La expresion indicada permite encontrar, por ejemplo, cualquier caracter que no sea alfanumerico o un espacio, es decir, busca todos los simbolos de puntuacion y demas caracteres especiales.  La utilizacion en conjunto de los caracteres especiales ^ y $ permite realizar validaciones en forma sencilla. Por ejemplo ^\\d$ permite asegurar que la cadena a verificar representa un unico digito ^\\d\\d/\\d\\d/\\d\\d\\d\\d$ permite validar una fecha en formato corto, aunque no permite verificar si es una fecha valida, ya que 99/99/9999 tambien seria valido en este formato; la validacion completa de una fecha tambien es posible mediante expresiones regulares, como se ejemplifica mas adelante.  De forma similar que los corchetes, los parentesis sirven para agrupar caracteres, sin embargo existen varias diferencias fundamentales entre los grupos establecidos por medio de corchetes y los grupos establecidos por parentesis:  El signo de interrogacion tiene varias funciones dentro del lenguaje de las expresiones regulares. La primera de ellas es especificar que una parte de la busqueda es opcional. Por ejemplo, la expresion regular ob?scuridad permite encontrar tanto \"oscuridad\" como \"obscuridad\". En conjunto con los parentesis redondos permite especificar que un conjunto mayor de caracteres es opcional; por ejemplo Nov(\\.|iembre|ember)? permite encontrar tanto \"Nov\" como \"Nov.\", \"Noviembre\" y \"November\".  Como se menciono anteriormente, los parentesis nos permiten establecer un \"punto de referencia\" para el motor de busqueda. Sin embargo, algunas veces, no se desea utilizarlos con este proposito, como en el ejemplo anterior Nov(\\.|iembre|ember)?. En este caso el establecimiento de este punto de referencia (que se detalla mas adelante) representa una inversion inutil de recursos por parte del motor de busqueda. Para evitarlo se puede utilizar el signo de pregunta de la siguiente forma: Nov(?:\\.|iembre|ember)?. Aunque el resultado obtenido sera el mismo, el motor de busqueda no realizara una inversion inutil de recursos en este grupo, sino que lo ignorara. Cuando no sea necesario reutilizar el grupo, es aconsejable utilizar este formato.  De forma similar, es posible utilizar el signo de pregunta con otro significado: Los parentesis definen grupos \"anonimos\", sin embargo el signo de pregunta en conjunto con los parentesis triangulares (< y >) permite \"nombrar\" estos grupos de la siguiente forma: ^(?<Dia>\\d\\d)\\/(?<Mes>\\d\\d)\\/(?<A\u00f1o>\\d\\d\\d\\d)$; Con lo cual se le especifica al motor de busqueda que los primeros dos digitos encontrados llevaran la etiqueta \"Dia\", los segundos la etiqueta \"Mes\" y los ultimos cuatro digitos llevaran la etiqueta \"A\u00f1o\".  NOTA: a pesar de la complejidad y flexibilidad dada por los caracteres especiales estudiados hasta ahora, en su mayoria nos permiten encontrar solamente un caracter a la vez, o un grupo de caracteres a la vez. Los metacaracteres enumerados en adelante permiten establecer repeticiones.  Comunmente las llaves son caracteres literales cuando se utilizan por separado en una expresion regular. Para que adquieran su funcion de metacaracteres es necesario que encierren uno o varios numeros separados por coma y que esten colocados a la derecha de otra expresion regular de la siguiente forma: \\d{2} Esta expresion le dice al motor de busqueda que encuentre dos digitos contiguos. Utilizando esta formula podriamos convertir el ejemplo ^\\d\\d/\\d\\d/\\d\\d\\d\\d$ que servia para validar un formato de fecha en ^\\d{2}/\\d{2}/\\d{4}$ para una mayor claridad en la lectura de la expresion.  \\d{2,4} Esta forma a\u00f1ade un segundo numero separado por una coma, el cual indica al motor de busqueda que como maximo podria aparecer 4 veces la expresion regular \\d. Los posibles valores son:  Nota: aunque esta forma de encontrar elementos repetidos es muy util, algunas veces no se conoce con claridad cuantas veces se repite lo que se busca o su grado de repeticion es variable. En estos casos los siguientes metacaracteres son utiles.  El asterisco sirve para encontrar algo que se encuentra repetido 0 o mas veces. Por ejemplo, utilizando la expresion [a-zA-Z]\\d* sera posible encontrar tanto \"H\" como \"H1\", \"H01\", \"H100\" y \"H1000\", es decir, una letra seguida de un numero indefinido de digitos. Es necesario tener cuidado con el comportamiento del asterisco, ya que este, por defecto, trata de encontrar la mayor cantidad posible de caracteres que correspondan con el patron que se busca. De esta forma si se utiliza \\(.*\\) para encontrar cualquier cadena que se encuentre entre parentesis y se lo aplica sobre el texto \"Ver (Fig. 1) y (Fig. 2)\" se esperaria que el motor de busqueda encuentre los textos \"(Fig. 1)\" y \"(Fig. 2)\", sin embargo, debido a esta caracteristica, en su lugar encontrara el texto \"(Fig. 1) y (Fig. 2)\". Esto sucede porque el asterisco le dice al motor de busqueda que llene todos los espacios posibles entre los dos parentesis. Para obtener el resultado deseado se debe utilizar el asterisco en conjunto con el signo de interrogacion de la siguiente forma: \\(.*?\\) Esto es equivalente a decirle al motor de busqueda que \"Encuentre un parentesis de apertura y luego encuentre cualquier secuencia de caracteres hasta que encuentre un parentesis de cierre\".  Se utiliza para encontrar una cadena que se encuentre repetida una o mas veces. A diferencia del asterisco, la expresion [a-zA-Z]\\d+ encontrara \"H1\" pero no encontrara \"H\". Tambien es posible utilizar este metacaracter en conjunto con el signo de interrogacion para limitar hasta donde se efectua la repeticion.  Los grupos anonimos se establecen cada vez que se encierra una expresion regular en parentesis, por lo que la expresion <([a-zA-Z]\\w*?)> define un grupo anonimo. El motor de busqueda almacenara una referencia al grupo anonimo que corresponda a la expresion encerrada entre los parentesis.  La forma mas inmediata de utilizar los grupos que se definen, es dentro de la misma expresion regular, lo cual se realiza utilizando la barra inversa \"\\\" seguida del numero del grupo al que se desea hacer referencia de la siguiente forma: <([a-zA-Z]\\w*?)>.*?</\\1> Esta expresion regular encontrara tanto la cadena \"<span>Esta</span>\" como la cadena \"<b>prueba</b>\" en el texto \"<span>Esta</span> es una <b>prueba</b>\" a pesar de que la expresion no contiene los literales \"font\" y \"B\".  Otra forma de utilizar los grupos es en el lenguaje de programacion que se este utilizando. Cada lenguaje tiene una forma distinta de acceder a los grupos. Los ejemplos enumerados a continuacion utilizan las clases del .Net Framework, usando la sintaxis de C# (la cual puede facilmente adaptarse a VB .Net o cualquier otro lenguaje del Framework o incluso Java o JavaScript).  Para utilizar el motor de busqueda del .Net Framework es necesario en primer lugar hacer referencia al espacio de nombres System.Text.RegularExpressions. Luego es necesario declarar una instancia de la clase Regex de la siguiente forma:  Luego asumiendo que el texto que se desea examinar con la expresion regular se encuentra en la variable \"sText\" podemos recorrer todas las instancias encontradas de la siguiente forma:  Luego se puede utilizar la propiedad Groups de la clase Match para traer el resultado de la busqueda:  Grupos nominales  Los grupos nominales son aquellos a los que se les asigna un nombre, dentro de la expresion regular para poder utilizarlos posteriormente. Esto se hace de forma diferente en los distintos motores de busqueda, a continuacion se explica como hacerlo en el motor del .Net Framework.  Utilizando el ejemplo anterior es posible convertir <([a-zA-Z]\\w*?)> en <(?<TagName>[a-zA-Z]\\w*?)> Para encontrar etiquetas HTML. Notese el signo de pregunta y el texto \"TagName\" encerrado entre parentesis triangulares, seguido de este. Para utilizar este ejemplo en el .Net Framework es posible utilizar el siguiente codigo:  Es posible definir tantos grupos como sea necesario, de esta forma se puede definir algo como: <(?<TagName>[a-zA-Z]\\w*?)\u00a0?(?<Attributes>.*?)> para encontrar no solo el nombre del tag HTML sino tambien sus atributos de la siguiente forma:  Pero es posible ir mucho mas alla de la siguiente forma:  Esta expresion permite encontrar el nombre de la etiqueta, el nombre del atributo y su valor.  Sin embargo, una etiqueta HTML puede tener mas de un atributo. Este puede resolverse utilizando repeticiones de la siguiente forma:  Y en el codigo puede utilizarse de la siguiente forma:  Es posible profundizar utilizando una expresion regular como esta:  La cual permitiria encontrar el nombre de la etiqueta, sus atributos, valores y el contenido de esta, todo con una sola expresion regular. ","snippet":"En computo teorico y teoria de lenguajes formales, una expresion regular o expresion racional \u200b\u200b (tambien son conocidas como regex o regexp,\u200b por su contraccion de las palabras inglesas regular expres","enlaces_salientes":["Expresi%C3%B3n_regular","Expresi%C3%B3n_regular","Expresi%C3%B3n_regular","Stephen_Kleene","Ciencia_computacional_te%C3%B3rica","Lenguaje_formal","Car%C3%A1cter_(tipo_de_dato)","Patr%C3%B3n_(estructura)","B%C3%BAsqueda_de_patrones","Cadena_de_texto","H%C3%A4ndel","Lenguaje_regular","Tipograf%C3%ADa","Alfabeto","Lenguaje","Uni%C3%B3n_de_conjuntos","Concatenaci%C3%B3n","Clausura_de_Kleene","Sintaxis","Editor_de_textos","Aplicaci%C3%B3n_(inform%C3%A1tica)","Editor_de_texto","Unix","Sed_(Unix)","Grep","Lenguaje_de_programaci%C3%B3n","Perl","Lenguajes_de_programaci%C3%B3n","Cadena_de_caracteres","Grep","Unix","GNU/Linux","Sed_(inform%C3%A1tica)","Unix","GNU/Linux","Windows","Awk","Unix","GNU/Linux","C%2B%2B","C%2B%2B11","Lenguaje_de_programaci%C3%B3n_Java","JavaScript","Perl","Visual_Basic","PHP","POSIX","Python",".NET#.NET_Framework","Alfanum%C3%A9rico","Barra_inversa","Windows","Unix","Mac_OS","ASCII","ISO/IEC_8859-1","Unicode","Alfanum%C3%A9rico","Windows","GNOME","ASCII","UNICODE","Metacaracter","C_Sharp","Java_(lenguaje_de_programaci%C3%B3n)","JavaScript","HTML","HTML","Oxford_University_Press","ISBN","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa"]}
{"url":"Notaci%C3%B3n_de_Backus-Naur","titulo":"Notacion de Backus-Naur","contenido":"La notacion de Backus-Naur, tambien conocida por sus denominaciones inglesas Backus-Naur form (BNF), Backus-Naur formalism o Backus normal form, es un metalenguaje usado para expresar gramaticas libres de contexto: es decir, una manera formal de describir lenguajes formales.  El BNF se utiliza extensamente como notacion para las gramaticas de los lenguajes de programacion, de los sistemas de comando y de los protocolos de comunicacion, asi como una notacion para representar partes de las gramaticas de la lengua natural (por ejemplo, el metro en la poesia de Venpa). La mayoria de los libros de textos para la teoria o la semantica del lenguaje de programacion documentan el lenguaje de programacion en BNF.  Algunas variantes, tales como la Augmented Backus-Naur Form (ABNF) y la Extended Backus\u2013Naur Form (EBNF), tienen su propia documentacion.  La idea de transcribir la estructura del lenguaje con reglas de reescritura se remonta cuando menos al trabajo del gramatico indio Panini (hacia el 460\u00a0a.\u00a0C.), que la utilizo en su descripcion de la estructura de palabras del idioma sanscrito (algunos incluso han sugerido renombrar BNF a Forma Panini-Backus). Linguistas estadounidenses como Leonard Bloomfield y Zellig Harris llevaron esta idea un paso mas adelante al tratar de formalizar el lenguaje y su estudio en terminos de definiciones formales y procedimientos (1920-1960).  Noam Chomsky, maestro de linguistica de alumnos de teoria de la informacion del MIT, combino la linguistica y las matematicas, tomando esencialmente el formalismo de Axel Thue como la base de su descripcion de la sintaxis del lenguaje natural. Tambien introdujo una clara distincion entre reglas generativas (de la gramatica libre de contexto) y reglas transformativas (1956).  John Backus, un dise\u00f1ador de lenguajes de programacion de IBM, adopto las reglas generativas de Chomsky para describir la sintaxis del nuevo lenguaje de programacion IAL, conocido en la actualidad como ALGOL 58 (1959), presentando en el primer Congreso de Computacion Mundial (World Computer Congress) el articulo \u00abThe syntax and semantics of the proposed international algebraic language of the Zurich ACM-GAMM Conference\u00bb.  Peter Naur, en su reporte sobre ALGOL 60 de 1963, identifico la notacion de Backus como la Forma Normal de Backus (Backus Normal Form), y la simplifico para usar un conjunto de simbolos menor, pero a sugerencia de Donald Knuth, su apellido fue agregado en reconocimiento a su contribucion, reemplazando la palabra \u00abNormal\u00bb por Naur, dado que no se trata de una forma normal en ningun sentido, a diferencia, por ejemplo de la Forma Normal de Chomsky.\u200b  Una especificacion de BNF es un sistema de reglas de derivacion, escrito como:  donde <simbolo> es un no terminal, y la expresion consiste en secuencias de simbolos o secuencias separadas por la barra vertical, '|', indicando una opcion, el conjunto es una posible substitucion para el simbolo a la izquierda. Los simbolos que nunca aparecen en un lado izquierdo son terminales.  Como ejemplo, considere este BNF para una direccion postal de los EE. UU.  Esto se traduce a espa\u00f1ol como:  Observe que muchas cosas (tales como el formato de una parte personal, de una especificacion del apartamento, o codigo postal) estan dejadas sin especificar aqui. Si es necesario, pueden ser descritas usando reglas adicionales de BNF, o dejadas como abstraccion si es inaplicable para el proposito actual.  Bastante interesante, la sintaxis de BNF se puede representar en  BNF como sigue:  Esto asume que no hay Whitespace necesario para la interpretacion apropiada de la regla. El <QUOTE> se presume para ser el caracter \", y el <EOL> para ser el fin de linea apropiado especificado (en ASCII, retorno de carro o linea nueva, dependiendo del sistema operativo). El <rule-name> y el <text> deben ser substituidos con nombre/etiqueta o el texto literal de una regla declarada, respectivamente.  Hay muchas variantes y extensiones de BNF, posiblemente conteniendo algunos o todos los comodines de expresiones regulares como un \"*\" o \"+\". El Extended Backus-Naur form (EBNF) es una variante comun. De hecho el ejemplo anterior no es la forma pura inventada para el informe del ALGOL 60.  La notacion de los corchetes \"[ ]\" fue introducida algunos a\u00f1os mas tarde en la definicion de PL/I de la IBM pero ahora se reconoce universal. La ABNF es otra extension usada comunmente para describir protocolos del IETF.  Las expresiones gramaticales de analizadores sintacticos construidas en BNF y las notaciones de expresion regular para formar una clase alternativa de la gramatica formal, que es esencialmente analitica mas que generativa en caracter.  Muchas especificaciones de BNF disponibles en linea tienen como proposito ser legibles a simple vista y no son especificaciones formales.  Estas incluyen con frecuencia algunas de estas reglas sintacticas y extensiones: ","snippet":"La notacion de Backus-Naur, tambien conocida por sus denominaciones inglesas Backus-Naur form (BNF), Backus-Naur formalism o Backus normal form, es un metalenguaje usado para expresar gramaticas libre","enlaces_salientes":["Notaci%C3%B3n_de_Backus-Naur","Notaci%C3%B3n_de_Backus-Naur","Notaci%C3%B3n_de_Backus-Naur","Metalenguaje","Gram%C3%A1tica_libre_de_contexto","Lenguaje_formal","Gram%C3%A1tica","Lenguaje_de_programaci%C3%B3n","Protocolo_de_comunicaci%C3%B3n","Lengua_natural","BNF_extendido","Panini_(hindu)","A%C3%B1os_460_a._C.","Idioma_s%C3%A1nscrito","Noam_Chomsky","MIT","John_Backus","IBM","Donald_Knuth","S%C3%ADmbolo","F%C3%B3rmula_(expresi%C3%B3n)","Barra_vertical","Opci%C3%B3n","Substituci%C3%B3n","Direcci%C3%B3n_postal","Estados_Unidos","Abstracci%C3%B3n_(inform%C3%A1tica)","Whitespace","ASCII","Sistema_operativo","Expresi%C3%B3n_regular","BNF_extendido","PL/I","International_Business_Machines","Protocolo_de_comunicaciones","IETF","Expresi%C3%B3n_regular","Gram%C3%A1tica_formal","Gram%C3%A1tica_generativa","Astadyayi","Yacc","GNU_bison","Donald_Knuth","Control_de_autoridades","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Perl","titulo":"Perl","contenido":"5.38.0\u200b / 02 de julio de 2023 (4 meses)  Perl es un lenguaje de programacion dise\u00f1ado por Larry Wall en 1987. Perl toma caracteristicas del lenguaje C, del lenguaje interpretado bourne shell (sh), AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programacion.  Estructuralmente, Perl esta basado en un estilo de bloques como los del C o AWK, y fue ampliamente adoptado por su destreza en el procesado de texto y no tener ninguna de las limitaciones de los otros lenguajes de script.  Larry Wall comenzo a trabajar en Perl en 1987 mientras trabajaba como programador en Unisys\u200b y anuncio la version 1.0 en el grupo de noticias comp.sources.misc el 18 de diciembre de 1987. El lenguaje se expandio rapidamente en los siguientes a\u00f1os. Perl 2, publicado en 1988, aporto un mejor motor de expresiones regulares. Perl 3, publicado en 1989, a\u00f1adio soporte para datos binarios.  Hasta 1991 la unica documentacion de Perl era una simple (y cada vez mas larga) pagina de manual Unix. En 1991 se publico Programming Perl (el libro del camello) y se convirtio en la referencia de facto del lenguaje. Al mismo tiempo, el numero de version de Perl salto a 4, no por marcar un gran cambio en el lenguaje, sino por identificar a la version que estaba documentada en el libro.  Perl 4 trajo consigo una serie de lanzamientos de mantenimiento, culminando en Perl 4.036 en 1993. En este punto, Larry Wall abandono Perl 4 para comenzar a trabajar en Perl 5. Perl 4 se quedaria en esa version hasta hoy.  El desarrollo de Perl 5 continuo en 1994. La lista de correo perl5-porters se establecio en mayo de 1994 para coordinar el trabajo de adaptacion de Perl 5 a diferentes plataformas. Es el primer foro para desarrollo, mantenimiento y adaptacion de Perl 5.  Perl 5 fue publicado el 17 de octubre de 1994. Fue casi una completa reescritura del interprete y a\u00f1adio muchas nuevas caracteristicas al lenguaje, incluyendo objetos, referencias, paquetes y modulos. A destacar, los modulos proveen de un mecanismo para extender el lenguaje sin modificar el interprete. Esto permitio estabilizar su nucleo principal, ademas de permitir a los programadores de Perl a\u00f1adirle nuevas caracteristicas.    El 26 de octubre de 1995, se creo el Comprehensive Perl Archive Network (CPAN). CPAN es una coleccion de sitios web que almacenan y distribuyen fuentes en Perl, binarios, documentacion, scripts y modulos. Originalmente, cada sitio CPAN debia ser accedido a traves de su propio URL; hoy en dia, http://www.cpan.org redirige automaticamente a uno de los cientos de repositorios espejo de CPAN.  En 2008, Perl 5 continua siendo mantenido. Caracteristicas importantes y algunas construcciones esenciales han sido a\u00f1adidas, incluyendo soporte Unicode, hilos, un soporte importante para la programacion orientada a objetos y otras mejoras.  Perl se llamo originalmente \"Pearl\". Larry Wall queria darle al lenguaje un nombre corto con connotaciones positivas; asegura que miro (y rechazo) todas las combinaciones de tres y cuatro letras del diccionario. Tambien considero nombrarlo como su esposa Gloria. Wall descubrio antes del lanzamiento oficial que ya existia un lenguaje de programacion llamado PEARL y cambio la ortografia del nombre.  El nombre normalmente comienza con mayuscula (Perl) cuando se refiere al lenguaje y con minuscula (perl) cuando se refiere al propio programa interprete debido a que los sistemas de ficheros Unix distinguen mayusculas y minusculas. Antes del lanzamiento de la primera edicion de Programming Perl era comun referirse al lenguaje como perl; Randal L. Schwartz, sin embargo, forzo el nombre en mayuscula en el libro para que destacara mejor cuando fuera impreso. La distincion fue subsiguientemente adoptada por la comunidad.  El nombre es descrito ocasionalmente como \"PERL\" (por Practical Extraction and Report Language - Lenguaje Practico para la Extraccion e Informe). Aunque esta expansion ha prevalecido en muchos manuales actuales, incluyendo la pagina de manual de Perl, es un retroacronimo y oficialmente el nombre no quiere decir nada. La ortografia de PERL en mayusculas es por eso usada como jerga para detectar a individuos ajenos a la comunidad. Sin embargo, se han sugerido varios retroacronimos, incluyendo el comico Pathologically Eclectic Rubbish Lister (Contabilizador de Basura Patologicamente Eclectico).  Perl se simboliza generalmente por un camello de una sola joroba (camello arabigo o dromedario), que fue la imagen elegida por el editor O'Reilly para la cubierta de Programming Perl, que por consiguiente adquirio el nombre de El Libro del Camello.\u200b O'Reilly es propietario de este simbolo como marca registrada, pero dice que usa sus derechos legales solo para proteger la \"integridad e impacto de este simbolo\".\u200b O'Reilly permite el uso no comercial del simbolo, y ofrece logos Programming Republic of Perl y botones Powered by Perl.  Desde hace unos a\u00f1os, y para evitar este tipo de problemas con la licencia comercial, la Fundacion Perl elaboro nuevos logotipos basados en una cebolla, a raiz de las conferencias anuales que Larry Wall ofrece con el titulo: State of the Onion (\"Estado de la Cebolla\") Onion se pronuncia muy parecido a Union, por lo que suena parecido a State of the Union (\"Estado de la Union\"), evento en el cual el presidente de los Estados Unidos informa a los ciudadanos del estado en que se encuentra su pais.  La pagina de manual Unix perlintro(1) dice:    La estructura completa de Perl deriva ampliamente del lenguaje C. Perl es un lenguaje imperativo, con variables, expresiones, asignaciones, bloques de codigo delimitados por llaves, estructuras de control y subrutinas.  Perl tambien toma caracteristicas de la programacion shell. Todas las variables son marcadas con un Sigilo precedente (Sigil, en ingles). Los sigilos identifican inequivocamente los nombres de las variables, permitiendo a Perl tener una rica sintaxis. Notablemente, los sigilos permiten interpolar variables directamente dentro de las cadenas de caracteres (string). Como en los shell, Perl tiene muchas funciones integradas para tareas comunes y para acceder a los recursos del sistema.  Perl toma las listas del Lisp, hash (memoria asociativa) del AWK y expresiones regulares del sed. Todo esto simplifica y facilita todas las formas del analisis sintactico, manejo de texto y tareas de gestion de datos.  En Perl 5, se a\u00f1adieron caracteristicas para soportar estructuras de datos complejas, funciones de primer orden (p. e. clausuras como valores) y un modelo de programacion orientada a objetos. Estos incluyen referencias, paquetes y una ejecucion de metodos basada en clases y la introduccion de variables de ambito lexico, que hizo mas facil escribir codigo robusto (junto con el pragma  strict). Una caracteristica principal introducida en Perl 5 fue la habilidad de empaquetar codigo reutilizable como modulos. Larry Wall indico mas adelante que \"la intencion del sistema de modulos de Perl 5 era apoyar el crecimiento de la cultura Perl en vez del nucleo de Perl\".\u200b  Todas las versiones de Perl hacen el tipificado automatico de datos y la gestion de memoria. El interprete conoce el tipo y requerimientos de almacenamiento de cada objeto en el programa; reserva y libera espacio para ellos segun sea necesario. Las conversiones legales de tipo se hacen de forma automatica en tiempo de ejecucion; las conversiones ilegales son consideradas errores fatales.  El dise\u00f1o de Perl puede ser entendido como una respuesta a tres amplias tendencias de la industria informatica: rebaja de los costes en el hardware, aumento de los costes laborales y las mejoras en la tecnologia de compiladores. Anteriormente, muchos lenguajes de ordenador como Fortran y C, fueron dise\u00f1ados para hacer un uso eficiente de un hardware caro. En contraste, Perl es dise\u00f1ado para hacer un uso eficiente de los costosos programadores de ordenador.  Perl tiene muchas caracteristicas que facilitan la tarea del programador a costa de unos requerimientos de CPU y memoria mayores. Estas incluyen gestion de memoria automatica; tipo de dato dinamico; strings, listas y hashes; expresiones regulares; introspeccion y una funcion eval().  Larry Wall fue adiestrado como linguista y el dise\u00f1o de Perl ha sido muy aleccionado con principios linguisticos. Ejemplos incluyen la Codificacion Huffman (las construcciones mas comunes deben ser las mas cortas), buena distribucion (la informacion importante debe ir primero) y una larga coleccion de primitivas del lenguaje. Perl favorece las construcciones del lenguaje, tan naturales, como para los humanos son la lectura y la escritura, incluso si eso hace mas complicado al interprete Perl.  La sintaxis de Perl refleja la idea de que \"cosas que son diferentes deben parecer diferentes\".  Por ejemplo, escalares, arrays y hashes tienen diferente sigilo. Indices de array y claves hash usan diferentes clases de parentesis. Strings y expresiones regulares tienen diferentes delimitadores estandar. Esta aproximacion puede contrastarse con lenguajes como Lisp, donde la misma construccion S-expresion y sintaxis basica se usa para muchos y variados propositos.  Perl tiene caracteristicas que soportan una variedad de paradigmas de programacion, como la imperativa, funcional y la orientada a objetos. Al mismo tiempo, Perl no obliga a seguir ningun paradigma en particular, ni obliga al programador a elegir alguna de ellas.  Hay un amplio sentido de lo practico, tanto en el lenguaje Perl como en la comunidad y la cultura que lo rodean. El prefacio de Programming Perl comienza con, \"Perl es un lenguaje para tener tu trabajo terminado\". Una consecuencia de esto es que Perl no es un lenguaje ordenado. Incluye caracteristicas si la gente las usa, tolera excepciones a las reglas y emplea la heuristica para resolver ambiguedades sintacticas. Debido a la naturaleza indulgente del compilador, a veces los errores pueden ser dificiles de encontrar. Hablando del variado comportamiento de las funciones internas en los contextos de lista y escalar, la pagina de manual de perlfunc(1) dice \"En general, hacen lo que tu quieras, siempre que quieras la coherencia.\"  Perl tiene varios lemas que transmiten aspectos de su dise\u00f1o y uso. Uno es There's more than one way to do it (Hay mas de una forma de hacerlo) (TMTOWTDI, usualmente pronunciado 'Tim Toady'). Otros son \"Perl: la motosierra del ejercito Suizo de los lenguajes de programacion\" y \"Limites imprecisos\". Una meta prefijada de Perl es hacer las cosas faciles de forma facil y las tareas dificiles, posibles.  A Perl tambien se le ha llamado \"El esparadrapo de Internet\".  Perl tiene muchas y variadas aplicaciones, gracias a la disponibilidad de muchos modulos estandares y de terceras partes.  Se ha usado desde los primeros dias del Web para escribir guiones (scripts) CGI. Es una de las \"tres Pes\" (Perl, Python y PHP), que son los lenguajes mas populares para la creacion de aplicaciones Web, y es un componente integral de la popular solucion LAMP para el desarrollo web. Grandes proyectos escritos en Perl son Slash, IMDb\u200b y UseModWiki, un motor de Wiki. Muchos sitios web con alto trafico, como Amazon.com y Ticketmaster.com usan Perl extensamente.  Perl se usa a menudo como un \"lenguaje pegamento\", ligando sistemas e interfaces que no fueron dise\u00f1ados especificamente para interoperar; y para el \"escarbado de datos\", convirtiendo o procesando grandes cantidades de datos para tareas como por ejemplo crear informes. De hecho, estas fortalezas estan intimamente unidas. Su combinacion hace a Perl una popular herramienta de proposito general para los administradores de sistemas, especialmente en programas peque\u00f1os que pueden ser escritos y ejecutados en una sola linea de comandos.  Perl es tambien ampliamente usado en finanzas y bioinformatica, donde es apreciado por su desarrollo rapido, tanto de aplicaciones como de despliegue, asi como la habilidad de manejar grandes volumenes de datos.  Perl esta implementado como un interprete, escrito en C, junto con una gran coleccion de modulos, escritos en Perl y C. La distribucion fuente tiene, en 2005, 12 MB cuando se empaqueta y comprime en un fichero tar. El interprete tiene 150.000 lineas de codigo C y se compila en un ejecutable de 1 MB en las arquitecturas de hardware mas tipicas. De forma alternativa, el interprete puede ser compilado como una biblioteca y ser embebida en otros programas. Hay cerca de 500 modulos en la distribucion, sumando 200.000 lineas de Perl y unas 350.000 lineas adicionales de codigo C. Mucho del codigo C en los modulos consiste en tablas de codificacion de caracteres.  El interprete tiene una arquitectura orientada a objetos. Todos los elementos del lenguaje Perl \u2014escalares, listas, hashes, referencias a codigo, manejadores de archivo\u2014 estan representados en el interprete como estructuras C. Las operaciones sobre estas estructuras estan definidas como una numerosa coleccion de macros, typedef y funciones; esto constituye la API C de Perl. La API Perl puede ser desconcertante para el no iniciado, pero sus puntos de entrada siguen un esquema de nombres coherente, que ayuda a los que quieran utilizarla.  La ejecucion de un programa Perl se puede dividir, generosamente, en dos fases: tiempo de compilacion y tiempo de ejecucion.\u200b En tiempo de compilacion el interprete parsea el texto del programa en un arbol sintactico. En tiempo de ejecucion, ejecuta el programa siguiendo el arbol. El texto es parseado solo una vez y el arbol sintactico es optimizado antes de ser ejecutado, para que la fase de ejecucion sea relativamente eficiente. Las optimizaciones del arbol sintactico en tiempo de compilacion incluyen simplificacion de expresiones constantes, propagacion del contexto y optimizacion en trozos sueltos de codigo. Sin embargo, las fases de compilacion y ejecucion pueden anidarse: un bloque BEGIN se ejecuta en tiempo de compilacion, mientras que una funcion eval inicia una compilacion durante una ejecucion. Ambas operaciones estan implicitas en otras  -de forma notable, la clausula use que carga bibliotecas, conocidas en Perl como modulos, implica un bloque BEGIN.  Perl es un lenguaje dinamico y tiene una gramatica sensible al contexto que puede quedar afectada por el codigo ejecutado durante una fase de ejecucion intermedia (Ver ejemplos.\u200b). Por eso Perl no puede ser parseado mediante una aplicacion directa de analizadores sintacticos/parseadores Lex/Yacc. En cambio, el interprete implementa su propio analizador lexico, que coordinado con un parseador modificado GNU bison resuelve las ambiguedades del lenguaje. Se ha dicho que \"solo perl puede parsear Perl\", queriendo decir que solo el interprete Perl (perl) puede parsear el lenguaje Perl (Perl). La razon de esto se atestigua por las persistentes imperfecciones de otros programas que emprenden la tarea de parsear Perl, como los analizadores de codigo y los auto-indentadores, que tienen que verselas no solo con las muchas formas de expresar inequivocamente construcciones sintacticas, sino tambien con el hecho de que tambien Perl no puede, en general, ser parseado sin antes ser ejecutado.  El mantenimiento del interprete Perl, a lo largo de los a\u00f1os, se ha vuelto cada vez mas dificil. El nucleo ha estado en continuo desarrollo desde 1994. El codigo ha sido optimizado en rendimiento a expensas de la simplicidad, claridad y unas interfaces internas mas fuertes. Nuevas caracteristicas han sido a\u00f1adidas, manteniendo todavia, compatibilidad virtualmente completa hacia atras con las primeras versiones. El tama\u00f1o y la complejidad del interprete son una barrera para los desarrolladores que desean trabajar en el.  Perl es distribuido con unos 120.000 test funcionales. Estos se ejecutan como parte del proceso normal de construccion y comprueban extensamente al interprete y a sus modulos principales. Los desarrolladores Perl confian en los test funcionales para asegurarse que los cambios en el interprete no introducen errores; reciprocamente, los usuarios Perl que vean al interprete pasar los test funcionales en su sistema pueden tener un alto grado de confianza de que esta funcionando adecuadamente.  No hay una especificacion o estandar escrito para el lenguaje Perl y no hay planes de crear uno para la version actual de Perl. Siempre ha existido solo una implementacion del interprete. Este interprete, junto con los test funcionales, forman la especificacion de facto del lenguaje.  Perl es software libre y esta licenciado bajo la Licencia Artistica y la GNU General Public License. Existen distribuciones disponibles para la mayoria de sistemas operativos. Esta especialmente extendido en Unix y en sistemas similares, pero ha sido portado a las plataformas mas modernas (y otras mas obsoletas). Con solo seis excepciones confirmadas, puede ser compilado desde el codigo fuente en todos los Unix, compatibles POSIX o cualquier otra plataforma Unix compatible. Sin embargo, esto no es normalmente necesario, porque Perl esta incluido por defecto en la instalacion de los sistemas operativos mas populares.\u200b  Debido a los cambios especiales necesarios para soportar al Mac OS Classic, existe una adaptacion especial llamada MacPerl.\u200b  Perl esta preinstalado en las distribuciones mas populares de GNU/Linux incluyendo Gentoo, Slackware, Mandriva, Debian, RedHat y SUSE.  Los usuarios de Microsoft Windows normalmente instalan una distribucion binaria de Perl.\u200b Compilar Perl desde el codigo fuente bajo Windows es posible, pero la mayoria de las instalaciones no disponen del necesario compilador de C.  La capa de emulacion Cygwin proporciona otra forma de correr Perl bajo Windows. Cygwin proporciona en entorno parecido al Unix en Windows que incluye gcc, por lo que compilar Perl desde el codigo es una opcion accesible para los usuarios que prefieren esta opcion.  En junio de 2006, win32.perl.org fue lanzado por Adam Kennedy en nombre de la Fundacion Perl. Es una comunidad web \"para todo lo relacionado con Windows y Perl\".\u200b  En Perl, el programa canonico \"Hola mundo\" es:  La primera linea contiene el shebang (par de caracteres que identifica el texto que sigue), que le indica al sistema operativo donde encontrar el interprete de Perl. La segunda imprime el string \u00a1Hola mundo! y un caracter de nueva linea.  El shebang es la forma normal para invocar al interprete en los sistemas Unix. Los sistemas Windows pueden seguir utilizandolo o pueden asociar la extension de archivo .pl con el interprete Perl. Algunos editores de texto tambien usan la linea shebang como una pista sobre el modo de trabajo en que deben operar. Si el programa es ejecutado por perl y no invocado por el shell, la linea que empieza por el shebang es parseada para interpretar las opciones. En otro caso, es ignorada. Para ver los detalles de esto, consultar la pagina de manual perlrun.  Perl tiene tres tipos de datos: escalares, listas y hashes:  Todas las variables estan precedidas por un sigilo, que identifica el tipo de dato que es accedido (no el tipo de dato de la misma variable). Se puede usar el mismo nombre para variables de diferentes tipos, sin que tengan conflictos.  Los numeros se escriben de la forma usual; los strings estan rodeados entre comillas de varias clases.  Perl convertira los strings en numeros y viceversa dependiendo del contexto en que sean usados. En el siguiente ejemplo los strings $n y $m son tratados como numeros cuando son argumentos del operador suma. Este codigo imprime el numero '5', desechando cualquier informacion no numerica de la operacion y dejando los valores de las variables intactos. (El operador de concatenacion no es +, sino ..)  Perl tambien tiene un contexto booleano que utiliza en la evaluacion de declaraciones condicionales. Los siguientes valores en Perl evaluan todos como falso:  Todos los demas valores se evaluan a verdadero. Esto incluye el curioso string auto-descriptivo \"0 pero verdadero\", que de hecho es 0 como numero, pero verdadero como booleano. (Cualquier string no numerico tambien tendra esta propiedad, pero este string en particular es ignorado por Perl en contextos numericos).  Las expresiones booleanas evaluadas tambien devuelven valores escalares. Aunque la documentacion no indica que valor particular se devuelve como verdadero o falso (y por lo tanto no fiable), muchos operadores booleanos devuelven 1 por verdadero y el string vacio para falso (que evalua a cero en contexto numerico). La funcion defined() le dice si la variable tiene algun valor. En el ejemplo anterior defined($falso) sera verdadero con cada uno de los valores anteriores, excepto undef. Si, especificamente, quiere asegurarse de tener un resultado 1/0 (como en C), necesita realizar el calculo siguiente:  Una lista se define listando sus elementos, separados por comas y rodeados por parentesis donde asi sea requerido por la precedencia de los operadores.  Un hash puede ser inicializado desde una lista de pares clave/valor.  Los elementos individuales de una lista son accedidos utilizando un indice numerico, dentro de corchetes. Valores individuales en un hash son accedidos utilizando la correspondiente clave, dentro de llaves. El sigilo $ identifica que el elemento accedido es un escalar.  Multiples elementos pueden ser accedidos usando en su lugar el sigilo @ (identificando el resultado como una lista).  El numero de elementos en un array puede ser obtenido evaluando el array en contexto escalar o con la ayuda del sigilo $#. Este ultimo da el indice del ultimo elemento dentro del array, no el numero de elementos.  Hay unas pocas funciones que operan sobre hashes enteros.  Perl tiene varias clases de estructuras de control.  Tiene estructuras de control orientado al bloque, similar a los de los lenguajes de programacion C y Java. Las condiciones estan rodeadas por parentesis y los bloques subordinados por llaves:  Cuando se controla a una sola declaracion, los modificadores de declaracion proporcionan una sintaxis mas ligera:  Los operadores logicos cortocircuito son normalmente usados para controlar el flujo del programa a nivel de expresion:  Las palabras clave de control de flujo next, last, return y redo son expresiones, por lo que pueden ser usadas con los operadores cortocircuito.  Perl tambien tiene dos construcciones implicitas para bucles:  grep devuelve todos los elementos de lista en que el bloque subordinado evalua a verdadero. map evalua el bloque subordinado por cada elemento de lista y devuelve una lista de los valores resultantes. Estas construcciones permiten un estilo simple de programacion funcional.  La declaracion switch (llamada \"given\"/\"when\") existe desde la version 5.10:  Perl incluye una declaracion goto etiqueta, pero es usada raramente. Las situaciones donde en otros lenguajes se utiliza goto no ocurren tan a menudo en Perl debido a sus amplias opciones de control de flujo.  Existe tambien una declaracion goto &sub que realiza una llamada 'final'. Termina la subrutina actual e inmediatamente llama a la sub especificada. Esto se usa en situaciones donde una nueva subrutina puede realizar una gestion de la pila mas eficiente que el propio Perl (porque tipicamente no se requiere ningun cambio en la pila actual), y en una recursion muy profunda este tipo de llamadas puede tener un sustancial impacto positivo en el funcionamiento porque evita la sobrecarga de la gestion contexto/pila en el momento de retornar.  Las subrutinas se definen con la palabra clave sub e invocadas simplemente nombrandolas. Si la subrutina en cuestion no ha sido todavia declarada, es necesario, para el proceso de analisis sintactico, poner los parentesis.  Una lista de argumentos pueden ser indicados despues del nombre de la subrutina. Los argumentos pueden ser escalares, listas o hashes.  Los parametros de una subrutina no necesitan ser declarados, ni en numero ni en tipo; de hecho, pueden variar en cada llamada. Los arrays son expandidos a sus elementos, los hashes a una lista de pares clave/valor y todo el conjunto es pasado a la subrutina como una indiferenciada lista de escalares.  Cualesquiera de los argumentos pasados estan disponibles para la subrutina en el array especial @_. Los elementos de @_ son asociados a los argumentos actuales; cambiando un elemento de @_ cambia el argumento correspondiente.  Los elementos de @_ pueden ser accedidos con los subindices de la forma normal.  Sin embargo, el codigo resultante puede ser dificil de leer y los parametros tener una semantica de pase por referencia, que puede resultar algo no deseable.  Un modismo comun es asignar @_ a una lista de variables con nombres.  Esto afecta tanto a la mnemonica de los nombres de los parametros como a la semantica de los valores pasados por valor. La palabra clave my indica que las siguientes variables estan lexicamente embebidas en el bloque que las contienen.  Otro modismo es sacar los parametros de @_. Esto es muy comun cuando la subrutina toma un solo argumento.  Las subrutinas pueden devolver valores.  Si la subrutina no sale via declaracion return, entonces devuelve la ultima expresion evaluada en el cuerpo de la subrutina. Arrays y hashes en el valor de retorno son expandidos a una lista de escalares, igual que si fueran argumentos de una funcion.  La expresion devuelta es evaluada en el contexto de la llamada de la subrutina; esto puede sorprender al desprevenido.  Una subrutina puede descubrir su contexto de llamada con la funcion wantarray.  El lenguaje Perl incluye una sintaxis especializada para escribir expresiones regulares y el interprete contiene un motor para emparejar strings con expresiones regulares. El motor de expresiones regulares usa un algoritmo de Vuelta Atras (backtracking), extendiendo sus capacidades desde el simple emparejamiento de patrones simples con la captura y sustitucion de strings. El motor de expresiones regulares se deriva de regex, escrito por Henry Spencer.  La sintaxis de expresiones regulares fue originalmente tomada de las expresiones regulares de Unix Version 8. Sin embargo, se diferencio ya antes del primer lanzamiento de Perl y desde entonces ha ido incorporando muchas mas caracteristicas. Otros lenguajes y aplicaciones estan adoptando las expresiones regulares de Perl (PCRE) en vez de las expresiones regulares POSIX, incluyendo PHP, Ruby, Java y el Servidor HTTP Apache.  El operador m// (empareja) permite comprobar un emparejamiento por medio de una expresion regular. (Para abreviar, el precedente m puede ser omitido.) En el caso mas simple, una expresion como:  evalua a verdadero si y solo si el string $x empareja con la expresion regular abc.  Partes de la expresion regular pueden ser incluidas entre parentesis: las partes correspondientes de un string emparejado son capturadas. Los strings capturados son asignados de forma secuencial a las variables internas $1, $2, $3,... y una lista de strings capturados se devuelve como valor del emparejamiento.  El operador s/// (sustitucion) especifica una operacion de busqueda y reemplazo:  Las expresiones regulares en Perl pueden tomar unos modificadores. Son sufijos de una sola letra que modifican el significado de la expresion:  Las expresiones regulares pueden ser densas y cripticas. Esto es porque la sintaxis de las expresiones regulares es extremadamente compacta, generalmente usando caracteres sueltos o pares de caracteres que representan sus operaciones. Perl alivia un poco este problema con el modificador /x que permite a los programadores poner espacio en blanco y comentarios dentro de las expresiones regulares:  Un uso comun de las expresiones regulares es el de especificar delimitadores de campos al operador split:  El operador split complementa la captura de string. La captura de string devuelve las partes de un string que emparejan con una expresion regular; split devuelve las partes que no emparejan.  Perl esta ampliamente favorecido para las aplicaciones de bases de datos. Sus facilidades de manejo de texto son buenas para generar consultas SQL; arrays, hashes y la gestion de memoria automatica hace facil recoger y procesar los datos devueltos.  En las primeras versiones de Perl, las interfaces de bases de datos fueron creadas enlazando el interprete con una biblioteca de base de datos desde el lado del cliente. Esto era algo torpe; un problema en particular fue que el ejecutable perl resultante estaba restringido a usar solo una interfaz de base de datos, la que habia sido enlazada. Tambien, reenlazar el interprete era lo suficientemente dificultoso que solo fue realizado para algunas de las mas famosas e importantes bases de datos.  En Perl 5, las interfaces de bases de datos estan implementadas por el modulo Perl DBI. El modulo DBI presenta una unica interfaz a las aplicaciones Perl, independiente de las bases de datos, mientras que los modulos DBD:: (Controlador de base de datos) manejan los detalles de acceso a unas 50 bases de datos diferentes. Existen controladores DBD:: para la mayor parte de las bases de datos ANSI SQL.  El \"Computer Language Shootout Benchmarks\" compara el funcionamiento de implementaciones de problemas de programacion tipicos, en diversos lenguajes. Sus implementaciones Perl normalmente toman mas memoria que las implementaciones en otros lenguajes, y esto varia los resultados de velocidad. Las prestaciones de Perl son similares a las de otros lenguajes como Python, PHP o Ruby, pero mas lento que la mayor parte de lenguajes compilados.  Perl puede ser mas lento que otros lenguajes haciendo lo mismo porque tiene que compilar el codigo fuente cada vez que corre el programa. En \"A Timely Start\", Jean-Louis Leroy encontro que sus scripts en Perl tardaban mucho mas tiempo en correr que lo que el esperaba porque el interprete perl perdia la mayor parte del tiempo buscando y compilando los modulos. Como Perl no puede salvar su compilacion intermedia como lo hacen Java, Python y Ruby, los scripts Perl conllevan esta sobrecarga en cada ejecucion. La sobrecarga no es un problema cuando la fase de ejecucion es muy larga, pero puede sesgar significativamente en tiempos de ejecucion muy cortos, como se encuentra a menudo en los benchmarks. Una vez que perl inicia la fase de ejecucion, sin embargo, puede ser muy rapido y tipicamente supera a otros lenguajes dinamicos. Tecnologias como mod perl superan esto guardando el programa compilado en memoria entre ejecuciones, o Class::Autouse que retrasa la compilacion de partes del programa hasta que son necesarias.  Nicholas Clark, un desarrollador principal de Perl, diserta sobre algunas mejoras en el dise\u00f1o con Perl y otras soluciones en \"When perl is not quite fast enough\".  Las rutinas mas criticas de un programa Perl pueden escribirse en C o incluso en lenguaje ensamblador con XS o Inline.  Optimizar Perl puede requerir un conocimiento intimo de su funcionamiento en lugar de la destreza con el lenguaje y su sintaxis, significando que el problema esta con la implementacion de Perl en lugar de con el lenguaje mismo. Raku, la siguiente version, tomara algunas de estas ideas como lecciones, que otros lenguajes ya han aprendido.  En el a\u00f1o 2000, en la conferencia Perl, Jon Orwant hizo una peticion para una nueva version del lenguaje.\u200b Esto condujo a una decision para comenzar el trabajo del redise\u00f1o del lenguaje, que se llamaria Perl 6. Se pidieron propuestas a la comunidad Perl para las nuevas caracteristicas del lenguaje, y se recibieron mas de 300 RFC (del ingles Request For Comments, peticion de comentarios).  Larry Wall estuvo los siguientes a\u00f1os digiriendo los RFC y sintetizandolos en un entorno de trabajo coherente para Perl 6. Presento su dise\u00f1o de Perl 6 en una serie de documentos llamados Apocalipsis, que se numeran para corresponderse con los capitulos de Programming Perl. La actual, inacabada especificacion de Perl 6, esta resumida en unos documentos de dise\u00f1o llamados Sinopsis, que estan numerados para corresponder a los Apocalipsis.  Perl 6 no tiene la intencion de ser compatible para atras, aunque existira un modo de compatibilidad.  En 2001 se decidio que Perl 6 corriese en una maquina virtual llamada Parrot. Esto quiere decir que otros lenguajes que usen Parrot podran ganar acceso nativo a CPAN y permitira algun cierto nivel de desarrollo cruzado.  En 2005 Audrey Tang creo el proyecto pugs, una implementacion de Perl 6 en Haskell. Fue y es una plataforma de testeo del lenguaje Perl 6 (separado del desarrollo actual de la implementacion) permitiendo a los dise\u00f1adores explorar. El proyecto pugs engendro una activa comunidad Perl/Haskell centrada alrededor del canal irc #perl6 en Freenode.  Un cierto numero de caracteristicas en el lenguaje Perl 6 muestran una similitud con las de Haskell y Perl 6 ha sido acogido por la comunidad Haskell como un potencial lenguaje de scripting.  En el 2006, Perl 6, Parrot y pugs siguen estando bajo desarrollo y un nuevo modulo para Perl 5 llamado v6 permite a una parte del codigo Perl 6 correr directamente sobre Perl 5.  En octubre de 2019, ante la evidencia de que Perl 6 es un lenguaje muy diferente de Perl 5, y para que no se generara una confusion entre los dos lenguajes, se decidio renombrarlo a Raku.  Como en C, las competiciones de codigo ofuscado son un rasgo popular de la cultura Perl. El Obfuscated Perl contest homenajea la virtud de la flexibilidad sintactica de Perl. El programa siguiente imprime el texto \"Just another Perl / Unix hacker\", usando 32 procesos en paralelo coordinados con pipes. La explicacion completa esta disponible en el sitio web del autor.  De forma similar al codigo ofuscado pero con un proposito diferente, \"Poesia Perl\" es la practica de escribir poemas que puedan ser compilados como codigo legal de Perl (aunque generalmente sin sentido). Esta aficion es mas o menos unica en Perl debido al gran numero de palabras normales del Ingles que el lenguaje utiliza. Los nuevos poemas se publican de forma regular en el sitio Perl Monks, en la seccion Poesia Perl. Parte del saber de Perl esta en Black Perl, un ejemplo infame de la poetica de Perl.  Otro pasatiempo es \"Perl Golf\". Como con el deporte real, la meta es reducir el numero de golpes necesarios para completar un objetivo, pero aqui, los \"golpes\" se refieren a los pulsaciones de teclado en vez de a los recorridos en un club de golf. Se propone una tarea, como \"escanear un string de entrada y devolver el palindromo mas grande que contenga\" y los participantes intentan batir a sus oponentes escribiendo soluciones que requieran cada vez menos caracteres de codigo fuente Perl.  Otra tradicion entre los hacker Perl es escribir JAPH, que es una especie de peque\u00f1os programas ofuscados que imprimen la frase \"Just another Perl hacker,\". El \"canonico\" JAPH incluye la coma al final, aunque a menudo se omite, y otras muchas variantes que se han creado (ejemplo,\u200b que imprime \"Just Another Perl Pirate!\").  Un modulo Perl interesante es Lingua::Romana::Perligata (en CPAN). Este modulo traduce el codigo fuente de un script escrito en Latin a Perl, permitiendo al programador escribir programas ejecutables en Latin.  La comunidad Perl ha reservado el espacio de nombres \"Acme\" para los modulos que sean divertidos o experimentales.  Algunos de los modulos Acme estan implementados de maneras muy entretenidas. Algunos ejemplos:  La comunidad Perl esta constituida por grupos que a su vez conforman Perl Mongers.\u200b  En Espa\u00f1a hay tres grupos:  En America Latina hay 17 grupos distribuidos entre los siguientes paises: Argentina\u200b, Brasil\u200b, Chile\u200b, Ecuador\u200b, Paraguay\u200b y Peru\u200b ","snippet":"5.38.0\u200b / 02 de julio de 2023 (4 meses)  Perl es un lenguaje de programacion dise\u00f1ado por Larry Wall en 1987. Perl toma caracteristicas del lenguaje C, del lenguaje interpretado bourne shell (sh), AWK","enlaces_salientes":["Perl","Perl","Perl","Perl_(desambiguaci%C3%B3n)","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_funcional","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_orientada_a_objetos","Clase_(inform%C3%A1tica)","Reflexi%C3%B3n_(inform%C3%A1tica)","Programaci%C3%B3n_procedural","Programaci%C3%B3n_dirigida_por_eventos","Programaci%C3%B3n_gen%C3%A9rica","Larry_Wall","Sistema_de_tipos","Raku_(lenguaje_de_programaci%C3%B3n)","AWK","Smalltalk","Lisp","Lenguaje_de_programaci%C3%B3n_C","C%2B%2B","Lenguaje_de_programaci%C3%B3n_Pascal","Sed_(inform%C3%A1tica)","Unix_shell","Python","PHP","Ruby","ECMAScript","Windows_PowerShell","JavaScript","Falcon_(lenguaje_de_programaci%C3%B3n)","Sistema_operativo","Multiplataforma","Licencia_de_software","GPL","Lenguaje_de_programaci%C3%B3n","Larry_Wall","1987","C_(lenguaje_de_programaci%C3%B3n)","Bourne_Shell","AWK","Sed_(inform%C3%A1tica)","Lisp","Script","1987","Unisys","Newsgroup","18_de_diciembre","1988","1989","1991","Camelus_dromedarius","1994","17_de_octubre","Int%C3%A9rprete_(inform%C3%A1tica)","26_de_octubre","1995","CPAN","2008","Unicode","Hilo_(inform%C3%A1tica)","Randal_L._Schwartz","Jerga","Camelus_dromedarius","O%27Reilly_%26_Associates","Discurso_del_Estado_de_la_Uni%C3%B3n","Man_(Unix)","Texto","Sistema_inform%C3%A1tico","Desarrollo_web","Interfaz_gr%C3%A1fica_de_usuario","Programaci%C3%B3n_estructurada","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_funcional","Lenguaje_de_programaci%C3%B3n_C","Programaci%C3%B3n_imperativa","Variable_(programaci%C3%B3n)","Expresi%C3%B3n_(programaci%C3%B3n)","Par%C3%A9ntesis","Estructuras_de_control","Subrutina","Unix_shell","Sigilo","Sigil","Cadena_de_caracteres","String","Lista_(estructura_de_datos)","Lisp","Hash","AWK","Expresi%C3%B3n_regular","Sed","Analizador_sint%C3%A1ctico","Estructura_de_datos","Clausura_(inform%C3%A1tica)","Programaci%C3%B3n_orientada_a_objetos","M%C3%A9todo_(inform%C3%A1tica)","M%C3%B3dulo_(inform%C3%A1tica)","Lenguaje_de_programaci%C3%B3n_fuertemente_tipado","Gesti%C3%B3n_de_memoria","Fortran","Tipo_de_dato","Codificaci%C3%B3n_Huffman","Lisp","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_funcional","Programaci%C3%B3n_orientada_a_objetos","Heur%C3%ADstica","LAMP","Squid_(programa)","Guion_(inform%C3%A1tica)","Common_Gateway_Interface","Soluciones_LAMP","Slash_(CMS)","Internet_Movie_Database","UseModWiki","Amazon.com","Ticketmaster","Lenguaje_pegamento","Interfaz","Administrador_de_sistemas","Finanzas","Bioinform%C3%A1tica","Desarrollo_r%C3%A1pido_de_aplicaciones","Int%C3%A9rprete_inform%C3%A1tico","2005","Megabyte","Compresi%C3%B3n_de_datos","Tar","Compilador","Ejecutable","Arquitectura_de_computadores","Sistema_embebido","Codificaci%C3%B3n_de_caracteres","Escalar_(inform%C3%A1tica)","Lista_(estructura_de_datos)","Tabla_hash","Typedef","Application_Programming_Interface","Tiempo_de_compilaci%C3%B3n","Tiempo_de_ejecuci%C3%B3n","Analizador_sint%C3%A1ctico","Gram%C3%A1tica_libre_de_contexto#Derivaciones_y_\u00e1rboles_sint\u00e1cticos","Optimizaci%C3%B3n_(c%C3%B3mputo)","Eficiencia","Programaci%C3%B3n_estructurada#Anidamiento","Gram%C3%A1tica","Gram%C3%A1ticas_sensibles_al_contexto","Analizadores_sint%C3%A1cticos","Herramienta_de_programaci%C3%B3n_lex","Yacc","GNU_bison","Mantenimiento_de_Software","1994","Rendimiento","De_facto","Software_libre","Licencia_p%C3%BAblica_general_de_GNU","Sistema_operativo","Unix","*nix","C%C3%B3digo_fuente","POSIX","Mac_OS","GNU/Linux","Gentoo_Linux","Slackware_Linux","Mandriva","Debian","RedHat","SUSE","Microsoft_Windows","Cygwin","Gcc","Hola_mundo","Shebang","Nueva_l%C3%ADnea","Extensi%C3%B3n_de_archivo","Tipo_de_dato","Escalar_(inform%C3%A1tica)","Lista_(estructura_de_datos)","Tabla_hash","Referencia","Vector_(programaci%C3%B3n)","Hash","Tipo_de_dato_l%C3%B3gico","Switch","GOTO","Pila_(estructura_de_datos)","Subrutina","Expresi%C3%B3n_regular","Vuelta_Atr%C3%A1s","POSIX","Servidor_HTTP_Apache","Coimplicaci%C3%B3n","Bases_de_datos","SQL","ANSI","Lenguaje_ensamblador","Raku_(lenguaje_de_programaci%C3%B3n)","Raku_(lenguaje_de_programaci%C3%B3n)","2001","M%C3%A1quina_virtual","M%C3%A1quina_virtual_Parrot","2005","Audrey_Tang","Pugs","Haskell","Freenode","2006","Raku_(lenguaje_de_programaci%C3%B3n)#Objetivos_iniciales_y_consecuencias","C%C3%B3digo_ofuscado","Golf","Pal%C3%ADndromo","Hacker","Lat%C3%ADn","Acme","Euro","VeriSign","Bloque_de_c%C3%B3digo","Software_libre","O%27Reilly_%26_Associates","Microsoft_Windows","Open_Directory_Project","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica","Open_Hub"]}
{"url":"Tipos_de_datos","titulo":"Tipo de dato","contenido":"En ciencias de la computacion, un tipo de dato informatico o simplemente tipo es un atributo de los datos que indica al ordenador (y/o al programador/programadora) sobre la clase de datos que se va a manejar. Esto incluye imponer restricciones en los datos, como que valores pueden tomar y que operaciones se pueden realizar.  Los tipos de datos mas comunes son: numeros enteros, numeros con signo (negativos), numeros de coma flotante (decimales), cadenas alfanumericas (y unicodes), estados, etc.  Un tipo de dato es un espacio en memoria con restricciones. Por ejemplo, el tipo \"int\" representa, generalmente, un conjunto de enteros de 32 bits cuyo rango va desde el -2.147.483.648 al 2.147.483.647, asi como las operaciones que se pueden realizar con los enteros, como son la suma, la resta, y la multiplicacion. Los colores, por su parte, se representan como tres bytes denotando la cantidad de rojo, verde y azul, y una cadena de caracteres representando el nombre del color (en este caso, las operaciones permitidas incluyen la adicion y la sustraccion, pero no la multiplicacion).  Este es un concepto propio de la informatica, y mas especificamente de los lenguajes de programacion, aunque tambien se encuentra relacionado con nociones similares de la matematica y la logica.  En un sentido amplio, un tipo de datos define un conjunto de valores y las operaciones sobre esos valores. Casi todos los lenguajes de programacion explicitamente incluyen la notacion del tipo de datos, aunque lenguajes diferentes pueden usar terminologias diferentes. La mayor parte de los lenguajes de programacion permiten al programador definir tipos de datos adicionales, normalmente combinando multiples elementos de otros tipos y definiendo las operaciones del nuevo tipo de dato. Por ejemplo, un programador puede crear un nuevo tipo de dato llamado \"Persona\", contemplando que el dato interpretado como \"Persona\" incluya un nombre y una fecha de nacimiento.  Un tipo de dato puede ser tambien visto como una limitacion impuesta en la interpretacion de los datos en un sistema de tipificacion, describiendo la representacion, la interpretacion y la estructura de los valores u objetos almacenados en la memoria del ordenador. El sistema de tipificacion usa informacion de los tipos de datos para comprobar la verificacion de los programas que acceden o manipulan los datos.  Los tipos de datos hacen referencia al tipo de informacion que se trabaja, donde la unidad minima de almacenamiento es el dato, tambien se puede considerar como el rango de valores que puede tomar una variable durante la ejecucion del programa.  El tipo de dato caracter es un digito individual el cual se puede representar como numericos  (0 al 9), letras (a-z) y simbolos (!\"$&/\\).  El tipo de dato caracter unicode es una \"extension\" del tipo de dato caracter, permite ampliar los simbolos de escritura, provee exactamente hasta 65535 caracteres diferentes.  Nota: En el lenguaje java la codificacion Unicode permite trabajar con todos los caracteres de distintos idiomas.  Este tipo de dato puede ser real o entero, dependiendo del tipo de dato que se vaya a utilizar.  Enteros: son los valores que no tienen punto decimal, pueden ser positivos o negativos y el cero.  Reales: estos caracteres almacenan numeros muy grandes que poseen parte entera y parte decimal.  estos serian sus rangos y tama\u00f1os ordenados  Este tipo de dato se emplea para valores logicos, los podemos definir como datos comparativos dicha comparacion devuelve resultados logicos (Verdadero o Falso).  Los tipos compuestos se derivan de uno o mas datos primitivos. A las distintas maneras de formar o combinar estos datos se les conocen con el nombre de \u201cEstructura de datos\u201d. Al combinarlo podemos crear un nuevo tipo, por ejemplo:  \"array-de-enteros\" es distinto al tipo \"entero\".  El lenguaje de programacion Pascal permite declarar variables de tipo caracter (Cadena) y numerica. Como se puede apreciar, todas las variables excepto la de tipo Cadena son de tipo numericas (incluyendo Booleano).  El lenguaje de programacion Java permite declarar variables de tipo primitivo, pero dada que los envoltorios de dichas funciones presentan muchas operaciones utiles, es mas comun hacer uso de las clases que las tratan.  No hay que confundir estos tipos de datos con los tipos de datos abstractos.  Los TDA siguen una interfaz que especifica que hace ese tipo de datos (la estructura de datos seria la implementacion concreta). Formalmente se trata de un modelo matematico para tipos de datos que estan definidos por su comportamiento o semantica. A nivel de usuario se puede ver como el esquema de los datos y operaciones para manipular los elementos que componen ese tipo de datos. La estructura de datos seria la representacion concreta de los datos. ","snippet":"En ciencias de la computacion, un tipo de dato informatico o simplemente tipo es un atributo de los datos que indica al ordenador (y/o al programador/programadora) sobre la clase de datos que se va a ","enlaces_salientes":["Tipo_de_dato","Tipo_de_dato","Tipo_de_dato","Ciencias_de_la_computaci%C3%B3n","Programador","Dato","N%C3%BAmero_entero","N%C3%BAmero_negativo","Coma_flotante","Unicode","Entero_(tipo_de_dato)","Rojo","Verde","Azul","Inform%C3%A1tica","Programaci%C3%B3n","Matem%C3%A1tica","L%C3%B3gica","Dato","Programaci%C3%B3n","Programador","Dato","Sistema_de_tipificaci%C3%B3n","Valor_(inform%C3%A1tica)","Objetos_(programaci%C3%B3n_orientada_a_objetos)","Pruebas_de_validaci%C3%B3n","Dato","Tipos_de_datos_primitivos","Tipo_de_dato_abstracto","Informaci%C3%B3n","S%C3%ADmbolo","Unicode","Vector_(inform%C3%A1tica)","Registro_(estructura_de_datos)","Tupla","Conjunto_(programaci%C3%B3n)","Pascal_(lenguaje_de_programaci%C3%B3n)","Java_(lenguaje_de_programaci%C3%B3n)","Tipo_de_dato_abstracto","Interfaz","Sem%C3%A1ntica_de_lenguajes_de_programaci%C3%B3n","Sistema_de_tipos","Teor%C3%ADa_de_tipos","Tipo_de_dato_abstracto","Diccionario_de_datos","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Scripts","titulo":"Script","contenido":"En informatica, un script, secuencia de comandos\u200b o guion\u200b\u200b\u200b (traduciendo desde ingles) es un termino informal que se usa para designar un lenguaje de programacion que se utiliza para manipular, personalizar y automatizar las instalaciones de un sistema existente.\u200b Regularmente almacenadas en un archivo de texto que deben ser interpretados linea a linea en tiempo real para su ejecucion, se distinguen   de   los   programas,   pues   deben   ser   convertidos   a   un   archivo   binario ejecutable para que funcionen.\u200b Los scripts regularmente no se compilan con anticipacion a codigo maquina, sino que son ejecutados por un interprete que lee el archivo de codigo fuente al momento; o incluso por una consola interactiva donde el usuario suministra el programa al interprete paso a paso. Los scripts o guiones se pueden usar para hacer prototipos de programas, automatizar tareas repetitivas, hacer procesamiento por lotes e interactuar con el sistema operativo y el usuario (debido a esto, los interpretes de comandos o shells suelen dise\u00f1arse con funcionalidades de programacion).  Algunos lenguajes de programacion son considerados \u00ablenguajes de scripts\u00bb (scripting languages) si son idoneos para realizar guiones con soltura, pese a que tambien se utilizan para codificar programas mucho mas complejos. Por ejemplo, Python a menudo se considera un lenguaje de scripting, sin embargo tambien se puede usar para programar aplicaciones sofisticadas (ejemplo: Deluge) o bibliotecas enteras (como SciPy); las cuales se consideran mas que simples scripts.  Los archivos script suelen ser identificados por el sistema a traves de uno de los siguientes encabezamientos en el contenido del archivo, conocido como shebang:  Aunque en entornos UNIX la mayoria de los guiones son identificados por dicho encabezamiento, tambien pueden ser identificados a traves de la extension \".sh\", siendo esta quiza menos importante que el encabezamiento, ya que casi todos los sistemas no necesitan dicha extension para ejecutar el guion, por lo tanto, esta suele ser a\u00f1adida por tradicion, o mas bien, es util para que el usuario pueda identificar estos archivos a traves de una interfaz de linea de comandos sin necesidad de abrirlo.  Difieren de los programas de aplicacion, debido a que los ultimos son mas complejos; ademas, los guiones son mas bien, un programa que le da instrucciones a otros mas avanzados.  En el sistema operativo DOS, a los scripts creados para ser interpretados por cmd.exe o el obsoleto COMMAND.COM se les conoce como archivos \u00abbatch\u00bb (procesamiento por lotes) y acaban en .bat o .cmd. En el sistema operativo Windows, existen varios lenguajes interpretados como Visual Basic Script (VBScript), JScript, Batch, y PowerShell.  Los scripts en Internet se pueden clasificar en guiones del lado del cliente y del lado del servidor.  Los guiones del lado del cliente se deben incluir con la etiqueta <script>, incluyendo el atributo type con el tipo MIME.  Generalmente se usa JavaScript, pero se puede usar VBScript (solo Internet Explorer o Google Chrome). Tiene como objetivo, por lo general, AJAX o manipulacion del DOM.  No tienen los problemas de accesibilidad que pueden presentar los guiones del lado del cliente. Tambien permiten modificar las cabeceras HTTP, u obtenerlas. Ademas, permiten acceso a bases de datos y otros archivos internos.  El termino ingles script se tomo del guion escrito de las artes escenicas, el cual es interpretado por una serie de actores/actrices (o, en este caso, programas) siguiendo un orden establecido.  En algunos textos se traduce script como \u00abguion\u00bb.\u200b Esta traduccion de momento esta empezando a establecerse y es bastante frecuente en el ambito de algunas comunidades y publicaciones sobre software libre \u2014como el equipo de traduccion de KDE, que traduce en la mayoria de las aplicaciones para este escritorio, script como \u00abguion\u00bb\u2014,\u200b\u200b o diversas guias y manuales de software.\u200b\u200b No obstante su uso es todavia minoritario a nivel general, pero junto con las expresiones  \u00absecuencia de comandos\u00bb y \u00abarchivo de ordenes\u00bb, empleada esta ultima en America, es la castellanizacion mas difundida. ","snippet":"En informatica, un script, secuencia de comandos\u200b o guion\u200b\u200b\u200b (traduciendo desde ingles) es un termino informal que se usa para designar un lenguaje de programacion que se utiliza para manipular, perso","enlaces_salientes":["Script","Script","Script","Script_(desambiguaci%C3%B3n)","Inform%C3%A1tica","Lenguaje_de_programaci%C3%B3n","Compilador","Lenguaje_de_m%C3%A1quina","Int%C3%A9rprete_(inform%C3%A1tica)","C%C3%B3digo_fuente","REPL","Procesamiento_por_lotes","Sistema_operativo","Shell_(inform%C3%A1tica)","Python","Deluge_(software)","Biblioteca_(inform%C3%A1tica)","SciPy","Shebang","L%C3%ADnea_de_comandos","DOS","S%C3%ADmbolo_del_sistema","COMMAND.COM","Windows","VBScript","JScript","Archivo_batch","PowerShell","JavaScript","Etiqueta_(c%C3%B3digo)","MIME","VBScript","Internet_Explorer","Google_Chrome","AJAX","Document_Object_Model","Script_del_lado_del_servidor","JSP","Active_Server_Pages","PHP","Common_Gateway_Interface","Guion_(g%C3%A9nero_literario)","Software_libre","KDE","Am%C3%A9rica","Castellanizaci%C3%B3n","Shell_(inform%C3%A1tica)","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"REXX","titulo":"REXX","contenido":"REXX (REstructured eXtended eXecutor) es un lenguaje de programacion desarrollado en IBM por Mike Cowlishaw del que existen numerosas implementaciones disponibles con codigo abierto. Es un lenguaje de programacion estructurado de alto nivel dise\u00f1ado para ser al mismo tiempo facil de entender y facil de leer. Hay interpretes para REXX tanto comerciales como de codigo abierto para un amplio rango de plataformas y hay compiladores para los mainframes de IBM.  El nombre tambien se aplica a la familia de lenguajes relacionados con el lenguaje de programacion REXX: el propio REXX (llamado en ese contexto REXX clasico o tradicional), Object REXX y NetREXX.  REXX tiene, entre otras, las siguientes caracteristicas:  REXX tiene solamente 23 instrucciones de significado bastante evidente para los angloparlantes (call, parse y select son unos ejemplos) con unos requerimientos minimos de puntuacion y formateo. Es esencialmente un lenguaje de formato libre con solamente un tipo de dato primitivo: la cadena de caracteres. Esta filosofia implica que todos los datos son visibles y que la depuracion y el trazado se simplifican.  La sintaxis de REXX parece similar a la de PL/I, pero tiene menos notaciones; esto hace que el codigo sea mas dificil de analizar por el interprete o el compilador pero mas facil de usar para el programador.  REXX fue dise\u00f1ado e implementado por vez primera como un proyecto personal de Mike Cowlishaw de IBM entre el 20 de marzo de 1979 y mediados de 1982, originalmente como un lenguaje de programacion de 'scripting' para reemplazar los lenguajes EXEC y EXEC 2. Fue dise\u00f1ado para ser un lenguaje de scripting o macros para cualquier sistema y como tal, se considera a REXX precursor de lenguajes como Tcl y Python. Ademas, Cowlishaw se centro en que estuviese orientado a las personas en lugar de orientado a los ordenadores e intento que el lenguaje se mantuviese peque\u00f1o y manejable por ello (\"Keep the language small\" -\"Manten el lenguaje peque\u00f1o\"- se leia en la pared sobre su escritorio).  La primera version publica aparecio en mayo de 1979 distribuida a traves de VNET, la red interna de IBM y los primeros usuarios aparte del propio Cowlishaw fueron Ray Mansell (de Hursley en el Reino Unido) y Les Koehler (de Raleigh en Carolina del Norte) que contribuyeron al lenguaje. A finales de 1979 al menos habia unos 70 ordenadores con una implementacion del lenguaje.  Algunas versiones fueron distribuidas entre compradores seleccionados de IBM como el SLAC (Stanford Linear Accelerator Center) donde la capacidad de REXX de trabajar con aritmetica decimal de precision arbitraria fue bien recibida. Al ser descrito por primera vez en publico en la conferencia SHARE 56 en Houston, Texas, en 1981, la reaccion de los clientes de IBM, liderada por Ted Johnston de SLAC (parcialmente motivada por la aritmetica de REXX), condujo a que se convirtiese en producto oficial de IBM en 1982 y se incluyese en 1983 como parte del sistema VM/CMS.  A lo largo de los a\u00f1os, IBM incluyo REXX en forma de interprete o compilador en casi todos sus sistemas operativos desde los mainframes a los ordenadores personales (VM/CMS, VM/GCS, MVS TSO/E, AS/400, OS/2, VSE/ESA, AIX, CICS/ESA y PC-DOS) y ha hecho versiones disponibles para Novell Netware, Windows, Java y Linux.  La primera version fuera de IBM fue escrita por Charles Daney en 1984/5. Otras versiones han sido tambien desarrolladas para Atari, Amiga, Unix (multiples variantes), Solaris, DEC, Windows, Windows CE, PocketPC, MS-DOS, Palm OS, QNX, OS/2, Linux, BeOS, EPOC32, AtheOS, OpenVMS, OpenEdition, Macintosh y Mac OS X.  La version de REXX para Amiga, llamada ARexx debida a Bill Hawes se incluyo con AmigaOS 2 y fue popular tanto para scripting como para control de aplicaciones. Muchas aplicaciones Amiga tienen \"puertos ARexx\" en ellas lo que permite controlar la aplicacion a traves de un \"script\" definido por el usuario.  Numerosas versiones gratuitas de REXX estan disponibles. En 1992 aparecieron las dos versiones de codigo abierto mas ampliamente utilizadas: REXX/imc del britanico Ian Collier para UNIX y Regina del noruego Anders Christensen (posteriormente adoptada por el australiano Mark Hessling) para Windows y Linux. BREXX del griego Vasilis Vlachoudis es bien conocido para DOS, WinCE y PocketPC.  Microsoft decidio incluir Regina en todos sus Windows Resource Kits como lenguaje de scripting y continuo esta practica hasta Windows 2000 mientras introducia sus propias aproximaciones al scripting a traves de WSH (Windows Scripting Host) y VBA (Visual Basic for Applications).  En 1990, Cathy Dager de SLAC organizo el primer simposio REXX independiente que conduciria cuatro a\u00f1os despues a la formacion de la RexxLA (REXX Language Association). Los simposios se llevan a cabo anualmente.  La RexxLA promovio la aparicion de un estandar ANSI para REXX asi como de un borrador para un estandar de Object REXX.  En 1996, ANSI se publico el estandar para REXX: ANSI X3.274\u20131996 \u201cInformation Technology \u2013 Programming Language REXX\u201d.  Desde mediados de la decada de 1990, existen dos variantes nuevas de REXX:  REXX cumplio su vigesimoquinto aniversario el 20 de marzo de 2004, lo que se celebro en el decimoquinto Simposio Internacional de REXX organizado por la RexxLA (REXX Language Association) en Boblingen, Alemania, en mayo de 2004.  En el mismo decimoquinto Simposio Internacional de REXX, el 4 de mayo de 2004, IBM anuncia que retira Object REXX como producto y la intencion de abrir el codigo fuente de Object REXX. Ante este anuncio, la RexxLA se ofrece a gestionar el futuro de Object REXX y nombra un comite para encargarse de la transicion. El 12 de octubre de ese mismo a\u00f1o anuncia que transferira el codigo a RexxLA para que se convierta en un proyecto de codigo abierto bajo la licencia Common Public License y el 29 de noviembre de ese mismo a\u00f1o se ha terminado de transferir todo el codigo excepto el codigo especifico de la version para OS/2, el IBM Resource Workshop (que permitia crear dialogos para Windows), Object REXX Workbench (IDE) y el paquete de funciones RxFTP. En febrero de 2005 aparece la primera version publica de ooRexx (Open Object REXX) gestionada por David Ashley y Rick McGuire.  En REXX las variables no tienen tipo e inicialmente se les asigna como valor su nombre en mayusculas. De este modo, el tipo de una variable puede cambiar con el uso dentro del programa. Como ilustra el siguiente codigo:  REXX ofrece solamente un tipo de variable primitivo (la cadena) y un tipo de variable compuesta (que en REXX suele nombrarse precisamente de ese modo).  Los simbolos para las variables simples en REXX tienen como caracteres permitidos los tipicos en casi todos los lenguajes de programacion, pero nunca pueden tener un punto despues del primer caracter dado que eso las convierte en una variable compuesta.  REXX ofrece la operacion de concatenacion, la instruccion PARSE y un gran numero de funciones para trabajar con cadenas por lo que muchas tareas con ellas resultan especialmente sencillas en este lenguaje.  Las cadenas estan delimitadas por apostrofos o comillas y al contrario que en otros lenguajes de programacion interpretados, no existen las secuencias de escape ni la interpolacion de variables; normalmente se utiliza la concatenacion para conseguir los mismos efectos.  La concatenacion de cadenas puede hacerse implicitamente al poner de forma contigua dos variables o explicitamente con el operador de concatenacion (||):  Cuando una cadena literal va seguida de \"b\" o \"x\" es tratada como una cadena binaria o hexadecimal:  Las cadenas son tratadas como numeros dependiendo del contexto y cuando son numeros, pueden escribirse sin los delimitadores:  REXX ofrece la instruccion NUMERIC para establecer la precision de los calculos numericos (con NUMERIC DIGITS), la forma de la salida de las cadenas como numeros (con NUMERIC FORM) y los digitos significativos descartados a la hora de realizar las comparaciones (con NUMERIC FUZZ). Ademas las funciones digits(), form() y fuzz() permiten consultar la precision, la forma y los digitos significativos descartados en las comparaciones.  REXX ofrece una serie de funciones y operadores basicos para trabajar con numeros, pero carece de las funciones matematicas basicas (raiz cuadrada, funciones trigonometricas...).  Si una cadena vale uno o cero, entonces puede utilizarse como un valor logico:   Puede asignarse el valor logico de una expresion:  Debido a la facilidades que ofrece REXX para trabajar con cadenas, resulta relativamente sencillo crear con una cadena una estructura de datos concreta (un numero complejo, una matriz, los datos de un libro...):  En REXX cualquier variable que incluya un punto tras el primer caracter de su nombre es una variable compuesta (compound variable en ingles). Los caracteres entre el primero y el primer punto (ambos estan incluidos) son considerados el nombre de la variable y recibe el nombre de tronco (stem en ingles). Los caracteres posteriores al punto son la cola (tail en ingles). Asi, por ejemplo, si tenemos el simbolo cv.libro.i, cv. es el tronco de la variable compuesta y libro.i es la cola de la variable compuesta.  En REXX clasico, las variables compuestas no pueden pasarse como parametros por referencia a una funcion, una funcion no puede devolverlas como resultado y no se incluye un modo de recorrerlas, copiarlas, ni ordenarlas.  Las variables compuestas en REXX funcionan esencialmente como arrays asociativos multidimensionales (a los arrays asociativos tambien se les llama, dependiendo del contexto, tablas de dispersion, hashes o diccionarios).  El siguiente ejemplo muestra el uso de una variable compuesta como array asociativo para manejar una peque\u00f1a agenda de telefonos:  Si el usuario introduce un nombre conocido tal y como esta escrito, se imprimira el numero correspondiente. Si el nombre no es conocido (\"Paco\", por ejemplo) imprimira el valor por defecto de la variable compuesta (es decir, \"No se encuentra el numero\").  Las variables compuestas en REXX se usan con frecuencia como arrays con la peculiar convencion de que se considera que el primer elemento tiene como indice 1 (al contrario que en otros lenguajes, en los que el primer elemento del array tiene como indice el 0) y el elemento con indice 0 se reserva para indicar el numero de elementos del array:  Siguiendo convenciones similares, pueden construirse arrays de mas de una dimension como en el siguiente codigo:  Las variables compuestas en REXX pueden usarse para crear estructuras de datos mas complejas (arrays de arrays asociativos, arboles binarios...):  Los operadores de concatenacion de cadenas en REXX son:  Ejemplos de uso de estos operadores pueden encontrarse en la seccion dedicada al uso de variables simples en REXX como cadenas.  Los operadores aritmeticos binarios en REXX son los siguientes:  Los operadores aritmeticos unarios en REXX son:  Los operadores logicos en REXX son:  REXX tiene solamente tres instrucciones basicas para construir todas las estructuras de control propias de la programacion estructurada: DO/END, IF/THEN/ELSE y SELECT/WHEN/OTHERWISE/END.  La instruccion DO/END sirve para agrupar el codigo en bloques y para hacer bucles. Las otras dos instrucciones permiten hacer selecciones condicionales de codigo.  En REXX es posible interceptar los errores y otras excepciones utilizando las instrucciones SIGNAL o CALL. El estandar ANSI establece que hay siete condiciones (ERROR, FAILURE, HALT, NOVALUE, NOTREADY, LOSTDIGITS y SYNTAX) y no permite definir nuevas excepciones ni generarlas (lo que si es posible en Object REXX y NetREXX).  Este ejemplo funcionara hasta que sea interrumpido por el usuario o termine el millon de iteraciones del bucle:  La siguiente tabla muestra las condiciones, da una somera idea de cuando aparecen, establece con que instrucciones pueden atraparse y el nivel del lenguaje en el que fueron introducidas.  Cuando una condicion es manejada por SIGNAL ON, las variables especiales SIGL y RC pueden ser analizadas para entender la situacion. RC contiene el codigo de error de REXX y SIGL el numero de linea donde ocurre el error.  En la primera especificacion del lenguaje en 1979, Cowlishaw lo llamo simplemente \"REX\" porque le gusto como sonaba y justifico ese nombre como proveniente de \"Reformed EXecutor\".  La letra \"X\" adicional se a\u00f1adio en 1982 para evitar problemas con marcas registradas cuando un estudio de IBM descubrio que habia un producto comercial llamado Rex-80.  Normalmente se considera que REXX es un acronimo y por lo general Cowlishaw y los documentos de IBM dicen que viene de \"REstructured eXtended eXecutor\", aunque tambien puede encontrarse como \"Restructured EXtended eXecutor\".  Debido al hecho de que el nombre original era igual a la palabra latina para \"rey\", existen muchas referencias a ello en el mundo que rodea al lenguaje: logos en forma de corona (Regina, Open Object REXX...), el nombre del interprete Regina (\"reina\" en latin)...  En texto plano, Cowlishaw parece preferir Rexx, mientras que en los documentos de IBM y en la mayor parte de la web se usa REXX. El estandar ANSI utiliza la forma preferida por el comite de estandarizacion, que tiene letras mayusculas peque\u00f1as para las tres letras finales: REXX.  Se pronuncia como \"rex\", sin hacer enfasis en la \"x\" final.   ","snippet":"REXX (REstructured eXtended eXecutor) es un lenguaje de programacion desarrollado en IBM por Mike Cowlishaw del que existen numerosas implementaciones disponibles con codigo abierto. Es un lenguaje de","enlaces_salientes":["REXX","REXX","REXX","IBM","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","ANSI","Object_REXX","NetREXX","PL/I","BASIC","Lenguaje_de_programaci%C3%B3n","IBM","C%C3%B3digo_abierto","Int%C3%A9rprete_(inform%C3%A1tica)","C%C3%B3digo_abierto","Mainframe","Object_REXX","NetREXX","Precisi%C3%B3n_arbitraria","Depuraci%C3%B3n_de_programas","PL/I","Tcl","Python","SLAC","1982","1983","VM/CMS","VM/CMS","MVS","AS/400","OS/2","AIX","PC-DOS","Novell_Netware","Microsoft_Windows","Plataforma_Java","GNU/Linux","Atari","Commodore_Amiga","Unix","Solaris_Operating_Environment","Digital_Equipment_Corporation","Microsoft_Windows","Windows_CE","PocketPC","MS-DOS","Palm_OS","QNX","OS/2","GNU/Linux","BeOS","AtheOS","OpenVMS","OpenEdition","Apple_Macintosh","Mac_OS_X","Commodore_Amiga","ARexx","1992","1990","ANSI","Object_REXX","1996","ANSI","NetREXX","Object_REXX","2004","Common_Public_License","Ap%C3%B3strofo","Perl","Object_REXX","NetREXX","IBM","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"SGML","titulo":"SGML","contenido":"El lenguaje de marcado generalizado estandar o SGML (por sus siglas en ingles de Standard Generalized Markup Language) (SGML; ISO 8879: 1986) es un estandar para definir lenguajes de marcado generalizados para documentos. ISO 8879 define el Anexo A.1 de marcado generalizado:  HTML en teoria era un ejemplo de un lenguaje basado en SGML hasta HTML5, que admite que los navegadores no pueden analizar como SGML (por razones de compatibilidad) y codifica exactamente lo que debe hacer en su lugar.  DocBook SGML y LinuxDoc son ejemplos mejores, ya que se utilizaban casi exclusivamente con herramientas reales SGML.  SGML es un estandar ISO: \"ISO 8879: 1986 Tratamiento de la informacion - Sistemas de texto y de oficina - Lenguaje de marcado generalizado estandar (SGML)\", de los cuales hay tres versiones:  SGML es parte de un trio de permitir a las normas ISO para documentos electronicos desarrollados por ISO/IEC JTC 1/SC 34 (ISO/IEC se une al Comite Tecnico 1, Subcomite 34 - Descripcion del documento y los lenguajes de procesamiento):  SGML es apoyado por varios reportes informaticos, en particular,  SGML es un descendiente del lenguaje de marcado generalizado de IBM (GML, Generalized Markup Language), El cual Charles Goldfarb, Edward Mosher, y Raymond Lorie desarrollaron en la decada de 1960. Goldfarb, director de la norma internacional, acu\u00f1o el termino \"GML\" usando las iniciales de sus apellidos. Goldfarb tambien escribio la obra definitiva sobre la sintaxis de SGML en \"El manual de SGML\". La sintaxis de SGML es muy similar al formato COCOA. Como un lenguaje de marcado de documentos, SGML fue dise\u00f1ado originalmente para permitir el intercambio de grandes documentos en el gobierno, leyes, e industrias. Muchos de esos documentos deben permanecer intactos durante varias decadas - por un largo tiempo en el campo de la informatica (Information Technology). SGML tambien fue aplicado ampliamente por militares, y la industria aeroespacial, para referencias tecnicas, y por la industria editorial. El advenimiento del perfil XML ha hecho SGML adecuado para la aplicacion generalizada de peque\u00f1a escala, y el uso de proposito general. ","snippet":"El lenguaje de marcado generalizado estandar o SGML (por sus siglas en ingles de Standard Generalized Markup Language) (SGML; ISO 8879: 1986) es un estandar para definir lenguajes de marcado generaliz","enlaces_salientes":["SGML","SGML","SGML","Charles_Goldfarb","Extensi%C3%B3n_de_archivo","Multipurpose_Internet_Mail_Extensions","Uniform_Type_Identifier","Lenguaje_de_marcado","IBM_Generalized_Markup_Language","HTML","XML","Est%C3%A1ndar_internacional","Formato_abierto","Lenguaje_de_marcado","HTML","HTML5","DocBook","LinuxDoc","Organizaci%C3%B3n_Internacional_de_Normalizaci%C3%B3n","Extensible_Markup_Language","DSSSL","Scheme","DSSSL","World_Wide_Web_Consortium","Extensible_Stylesheet_Language_Transformations","XSL_Formatting_Objects","Extensible_Markup_Language","DSSSL","World_Wide_Web_Consortium","XLink","IBM_Generalized_Markup_Language","Tecnolog%C3%ADa_de_la_informaci%C3%B3n","Extensible_Markup_Language","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Forth","titulo":"Forth","contenido":"Forth o FORTH es un lenguaje de programacion y un ambiente de programacion para computadores ideado por Charles H. Moore entre los a\u00f1os 1965 y 1970 en el National Radio Astronomy Observatory de Kitt Peak, Arizona.  Su nombre es una contraccion de la palabra inglesa fourth, dado que sus creadores le consideraban destinado a la cuarta generacion de computadoras, pero la primera edicion del lenguaje fue preparada para un IBM 1130, que solo permitia nombres con una longitud maxima de cinco letras; su nombre se quedo ya para siempre en FORTH. Forth es deletreado a veces con todas las letras en mayusculas siguiendo el uso acostumbrado durante los primeros a\u00f1os, aunque el nombre no es un acronimo.  Inicialmente dise\u00f1ado para una aplicacion muy concreta, la astronomia (calculo de trayectorias de cuerpos en orbita, cromatografias, analisis de espectros de emision), ha evolucionado hasta ser aplicable a casi todos los demas campos relacionados o no con esa rama de la ciencia (calculos de probabilidad, bases de datos, analisis estadisticos y hasta financieros).  Posteriormente, un programa para la adquisicion automatica y continua de datos realizado en este lenguaje ha descubierto al menos la mitad de los cumulos interestelares conocidos en la actualidad.  Forth es un lenguaje de programacion de computadoras procedimental, estructurado, imperativo, reflexivo, basado en pila y sin comprobacion de tipos. Forth ofrece tanto la ejecucion interactiva de comandos (haciendolo conveniente como shell para los sistemas que carecen de un sistema operativo mas formal) como la capacidad de compilar secuencias de comandos para la ejecucion posterior. Algunas implementaciones del Forth (usualmente las versiones tempranas o las escritas para ser extremadamente portable) compilan codigo enhebrado (threaded code), pero muchas implementaciones de hoy generan codigo de maquina optimizado como otros compiladores de lenguajes.  Una de sus importantes caracteristicas es la utilizacion de una pila de datos para pasar los argumentos entre las palabras, que son los constituyentes de un programa en Forth.  Aunque no es tan popular como otros sistemas de programacion, Forth tiene suficiente soporte para mantener varios vendedores y contratistas lenguaje en el negocio. Forth es usado actualmente en cargadores (boot loaders) tales como Open Firmware, aplicaciones espaciales,\u200b y otros sistemas empotrados. Una implementacion de Forth por el Proyecto GNU es activamente mantenida, y su ultimo lanzamiento fue en noviembre de 2008. El estandar de 1994 esta actualmente siendo sometido a revision, llamado provisionalmente Forth 200x.\u200b  Un ambiente Forth combina el compilador con una shell interactivo. El usuario interactivamente define y corre subrutinas, o \"palabras\", en una maquina virtual similar al ambiente de runtime. Las palabras pueden ser probadas, redefinidas, y depuradas a medida que el codigo fuente es ingresado sin recompilar o reiniciar el programa entero. Todos los elementos sintacticos, incluyendo las variables y los operadores basicos, aparecen como tales procedimientos (en forma de palabras). Incluso si una particular palabra es optimizada para no requerir una llamada de subrutina, todavia sigue tambien disponible como subrutina. Por otro lado, la shell puede compilar comandos interactivamente mecanografiados en codigo de maquina antes de correrlos. (Este comportamiento es comun, pero no requerido). Los ambientes Forth varian en como es almacenado el programa resultante, pero idealmente, correr el programa tiene el mismo efecto que entrar manualmente el codigo fuente de nuevo. Esto contrasta con la combinacion de C con los shells de UNIX, en donde las funciones compiladas son una clase especial de objetos de programa y los comandos interactivos son estrictamente interpretados [cita\u00a0requerida]. La mayor parte de las caracteristicas unicas de Forth resultan de este principio. Al incluir la interaccion, el scripting, y la compilacion, Forth fue popular en los computadores con recursos limitados, tales como el BBC Micro y las series del Apple II, y permanece asi en aplicaciones tales como firmware y peque\u00f1os microcontroladores. Donde los compiladores C ahora pueden generar codigo mas compacto y con mejor desempe\u00f1o, Forth conserva la ventaja de la interactividad.[cita\u00a0requerida]  Cada ambiente de programacion con subrutinas implementa una pila para el flujo de control. Esta estructura tipicamente tambien almacena las variables locales, incluyendo los parametros de la subrutina (en un sistema de llamada por valor como en C). Con frecuencia, sin embargo, Forth no tiene variables locales, ni es llamado-por-valor. En lugar de eso, los valores intermedios son mantenidos en una segunda pila. Las palabras operan directamente en los valores superiores de esta pila. Por lo tanto, puede ser llamada la pila de \"parametro\" o de \"datos\", pero es mas conocida como la \"pila\". La pila de llamada de funciones es entonces llamada la pila de retorno o de \"encadenamiento\" ( en ingles linkage o return stack), abreviado rstack. Las funciones especiales de manipulacion del rstack proporcionadas por el nucleo permiten que sea usado para el almacenamiento temporal dentro de una palabra, pero no puede ser usado de otra manera para pasar parametros o para manipular datos.  La mayoria de las palabras son especificadas en terminos de su efecto sobre la pila. Tipicamente, los parametros son colocados en el tope de la pila antes de que la palabra se ejecute. Despues de la ejecucion, los parametros son borrados y substituidos por valores de retorno. Para los operadores aritmeticos, esto sigue la regla de la notacion polaca inversa. Ver abajo para los ejemplos que ilustran el uso de la pila.  Forth es un lenguaje simple y extensible; su modularidad y extensibilidad permiten la escritura de programas de alto nivel tales como sistemas de CAD. Sin embargo, la extensibilidad tambien ayuda a que programadores pobres escriban codigo incomprensible, que ha dado a Forth una reputacion como \"lenguaje de solo escritura\". Forth ha sido usado con exito en proyectos grandes y complejos, mientras que las aplicaciones desarrolladas por profesionales competentes y disciplinados han probado ser de facil mantenimiento en plataformas de hardware cambiantes durante decadas de uso.\u200b Forth tiene un nicho tanto en aplicaciones astronomicas como espaciales.\u200b Todavia hoy, Forth es usado en muchos sistemas empotrados (peque\u00f1os dispositivos computarizados), debido a su portabilidad, uso eficiente de la memoria, corto tiempo de desarrollo, y rapida velocidad de ejecucion. Ha sido implementado eficientemente en procesadores RISC modernos, y han sido producidos procesadores que usan Forth como lenguaje de maquina.\u200b Otros usos de Forth incluyen Open Firmware, boot ROMs usadas por Apple, IBM, Sun, y OLPC XO-1; y la primera etapa del controlador de arranque basada en FICL del sistema operativo FreeBSD.  Forth se desarrollo a partir del sistema de programacion personal de Charles H. Moore, que habia estado en desarrollo continuo desde 1958.\u200b Forth fue expuesto por primera vez a otros programadores a principios de los a\u00f1os 1970, comenzando con Elizabeth Rather en el National Radio Astronomy Observatory de los Estados Unidos.\u200b Despues de su trabajo en NRAO, Charles Moore y Elizabeth formaron Forth, inc. en 1973, refinando y portando sistemas Forth a docenas de otras plataformas en la siguiente decada.  Forth fue nombrado asi porque en 1968 \"el archivo conteniendo el interpretador fue etiquetado FOURTH, por la 4.\u00aa (siguiente) generacion de software - pero el sistema operativo del IBM 1130 restringia los nombres de archivo a 5 caracteres\".\u200b Moore vio a Forth como el sucesor de compilar-encadenar-ejecutar de los lenguajes de tercera generacion, o software para hardware \"de cuarta generacion\", no en el sentido de un lenguaje de programacion de cuarta generacion como ha venido a ser usado el termino.  Debido a que Charles Moore se habia trasladado con frecuencia de un trabajo a otro en su carrera, una presion temprana en el lenguaje de desarrollo era la facilidad de portarlo a diversas arquitecturas de computadora. Un sistema Forth ha sido usado con frecuencia para \"levantar\" un nuevo hardware. Por ejemplo, Forth fue el primer software residente en el nuevo chip Intel 8086 en 1978 y MacFORTH era el primer sistema de desarrollo residente para el primer Apple Macintosh en 1984.\u200b  Comenzando en 1976, el microFORTH de Forth inc. fue desarrollado para los microprocesadores Intel 8080, Motorola 6800, y el Zilog Z80. MicroFORTH fue usado despues por aficionados para generar sistemas Forth para otras arquitecturas, tales como los MOS 6502 de 1978. La amplia diseminacion finalmente llevo a la estandarizacion del lenguaje. La practica comun era codificada en los estandares de facto de FORTH-79\u200b y FORTH-83\u200b de los a\u00f1os 1979 y 1983, respectivamente. Estos estandares fueron unificados por el ANSI en 1994, comunmente referenciado como ANS Forth.\u200b  Forth llego a ser muy popular en los a\u00f1os 1980 porque estaba bien adaptado a los peque\u00f1os microcomputadores de ese tiempo, pues es compacto y portable. Por lo menos un computador personal, el Jupiter Ace britanico, tenia a Forth en su sistema operativo residente en ROM. El Canon Cat tambien usaba Forth para su programacion de sistema. Rockwell tambien produjo los microcomputadores en un simple chip, el R65F11 y el R65F12, con nucleos Forth residentes.  Forth confia fuertemente en el uso explicito de una pila de datos y de la notacion polaca inversa (RPN o notacion postfija, comunmente usada en calculadoras de Hewlett-Packard. En RPN, el operador es colocado despues de sus operandos, a diferencia de la mas comun notacion infija donde es colocado entre los operandos. La notacion postfija hace al lenguaje mas facil analizar gramaticalmente (parse) y extender; Forth no usa una gramatica BNF, y no tiene un compilador monolitico. Extender el compilador solo requiere la escritura de una nueva palabra, en vez de modificar una gramatica y de cambiar la implementacion subyacente.  Usando RPN, se puede conseguir al resultado de la expresion matematica (25 * 10 + 50) de esta manera:   Esta linea de comando primero pone los numeros 25 y 10 en la pila implicada.  La palabra * multiplica los dos numeros en el tope de la pila y los sustituye por su producto.  Entonces el numero 50 se pone en la pila.  La palabra + lo agrega al producto anterior. Finalmente, el comando . imprime el resultado al terminal de usuario.\u200b Incluso las caracteristicas estructurales del Forth son basadas en la pila. Por ejemplo:  Este codigo define una nueva palabra llamada FLOOR5 usando los comandos siguientes (otra vez, \"palabra\" es el termino usado para una subrutina):  El texto entre parentesis es un comentario, advirtiendo que esta palabra espera un numero en la pila y retornara un numero posiblemente cambiado. La palabra FLOOR5 es equivalente a esta funcion escrita en el lenguaje de programacion C:  Esta funcion se escribe mas sucintamente como:  Se puede correr esta palabra como sigue:  Primero el interpretador empuja (push) un numero (1 u 8) sobre la pila, despues llama a FLOOR5, que retira (pop) este numero otra vez y empuja el resultado. Finalmente, una llamada a \".\" retira el resultado de la pila y lo imprime al terminal del usuario.  El analizador sintactico (parser) de Forth es simple, puesto que no tiene una gramatica explicita. El interpretador lee una linea de entrada desde un dispositivo de entrada de usuario, la cual es entonces analizada sintacticamente para una palabra usando los espacios como delimitadores; algunos sistemas reconocen caracteres de espacio en blanco adicionales. Cuando el interpretador encuentra una palabra, intenta encontrar la palabra en el diccionario. Si la palabra es encontrada, el interpretador ejecuta el codigo asociado con la palabra, y despues retorna para analizar (parse) el resto del flujo de entrada (stream). Si la palabra no es encontrada, se asume que la palabra es un numero, y se hace una tentativa de convertirlo el texto que lo representa en un numero y de empujarlo (push) en la pila; si se tiene exito, el interpretador continua analizando el flujo de entrada. De lo contrario, si las operaciones de busqueda de la palabra y la conversion del numero fallan, el interpretador imprime la palabra seguida por un mensaje de error indicando que la palabra no es reconocida, se limpia (flush) el flujo de entrada, y se espera la nueva entrada del usuario.\u200b  La definicion de una nueva palabra comienza con la palabra : (dos puntos) y finaliza con la palabra ; (punto y coma). Por ejemplo:  Esto compilara la palabra X, y hace el nombre hallable en el diccionario. Cuando es ejecutada al mecanografiar, por ejemplo, 10 X en la consola esto imprimira 11 10.\u200b  La mayoria de los sistemas Forth incluyen un ensamblador especializado que produce palabras ejecutables. El ensamblador es un dialecto especial del compilador. Los ensambladores Forth frecuentemente usan una sintaxis polaca inversa en la cual los parametros de una instruccion preceden a la instruccion. El dise\u00f1o usual del ensamblador Forth es para construir la instruccion en la pila, despues la copia en memoria como el paso pasado. Los registros pueden ser referidos por el nombre usado por el fabricante, numerado (0..n, segun lo usado en el codigo de operacion real) o nombrado para su proposito en el sistema Forth: ej. \"S\" para el registro usado como puntero de la pila.\u200b  Los sistemas Forth clasicos tradicionalmente no usan ni el sistema operativo ni el sistema de archivos. En lugar de almacenar el codigo en archivos, el codigo fuente es almacenado en bloques escritos a direcciones fisicas del disco. La palabra BLOCK es empleada para traducir el numero de un bloque de disco de 1 KB de tama\u00f1o hacia la direccion de un buffer que contiene los datos, el cual es manejado automaticamente por el sistema Forth. Algunos sistemas implementan archivos de disco contiguos usando el acceso al disco del sistema, donde los archivos estan situados en los rangos de bloques de disco fijos. Usualmente estos se implementan como registros binarios de longitud fija, con un numero entero de registros por bloque del disco. Una busqueda rapida es alcanzada por el acceso hash en los datos clave.  La multitarea, (mas comunmente por planificacion Round-robin cooperativa), esta normalmente disponible (aunque las palabras multitarea y el soporte no son cubiertos por el estandar del ANSI Forth). La palabra PAUSE es usada para guardar el contexto de ejecucion de la tarea actual, para localizar la siguiente tarea, y restaurar su contexto de ejecucion. Cada tarea tiene sus propias pilas, copias privadas de algunas variables de control y un area de scratch. Como resultado, el intercambio de tareas es simple y eficiente, Las multitareas del Forth estan disponibles incluso en los microcontroladores muy simples tales como el Intel 8051, Atmel AVR, y TI MSP430.\u200b  Por contraste, algunos sistemas Forth corren bajo un sistema operativo anfitrion como Microsoft Windows, Linux o una version de UNIX y usan el sistema de archivos del sistema operativo anfitrion para los archivos de fuente y de datos; el estandar ANSI Forth describe las palabras usadas para la entrada-salida. Otras facilidades no estandar incluyen un mecanismo para hacer llamadas al SO o al sistema de ventanas anfitrion, y muchos proporcionan extensiones que emplean la previsiones proporcionadas por el sistema operativo. Tipicamente tienen un conjunto mas grande y diferente de palabras que la palabra por defecto PAUSE del Forth, para la creacion, suspension, destruccion y modificacion de prioridad de la tarea.  Un sistema Forth con todas las facilidades, con todo el codigo fuente, se compilara a si mismo, con una tecnica comunmente llamada por los programadores Forth como metacompilacion (aunque el termino no equivale exactamente a la metacompilacion como se define normalmente). Usualmente el metodo consiste en redefinir un pu\u00f1ado de palabras que ponen bits compilados en la memoria. Las palabras del compilador usan versiones especialmente nombradas de fetch y store que son redireccionadas a un area de buffer en memoria. El area del buffer simula o accesa un area de memoria comenzando en una direccion diferente que el buffer de codigo. Tales compiladores definen palabras para acceder tanto a la memoria del computador destino como la memoria del computador anfitrion (compilacion).\u200b  Despues de que las operaciones de fetch y store son redefinidas para el espacio del codigo, el compilador, ensamblador, etc. son recopilados usando la nueva definicion de fetch y store. Esto efectivamente rehusa todo el codigo del compilador y del interpretador. Entonces, el codigo del sistema Forth es compilado, pero esta version es almacenada en el buffer. El buffer en memoria es escrito al disco, y se proporcionan las maneras de cargarlo temporalmente en la memoria para pruebas. Cuando la nueva version parece trabajar, se escribe sobre la version previa.  Hay numerosas variaciones de tales compiladores para diversos ambientes. Para los sistemas embebidos, el codigo puede ser escrito en otro computador, una tecnica conocida como compilacion cruzada, sobre un puerto serial o aun por un solo bit TTL, mientras se mantienen los nombres de las palabras y otras partes no ejecutables del diccionario en la computadora de compilacion original. Las definiciones minimas para este compilador Forth son las palabras fetch y store para un byte, y la palabra que ordena sea ejecutada una palabra de Forth. Con frecuencia la parte que consume mas tiempo de escribir un puerto remoto es construir el programa inicial para implementar fecth, store y execute, pero muchos microprocesadores modernos tienen caracteristicas de depuradores integrados (tales como el Motorola CPU32) que eliminan esta tarea.\u200b  La estructura basica de datos de Forth es el \"diccionario\" que mapea \"palabras\" a codigo ejecutable o a estructuras de datos con nombre. El diccionario descansa en la memoria como arbol de lista encadenada con los enlaces procediendo desde la ultima palabra definida (la mas reciente) hasta la mas antigua, hasta que es encontrado un centinela, usualmente un puntero NULL. Un cambio de contexto causa que la busqueda de la lista comience en una hoja diferente y la busqueda de la lista encadenada continua de tal manera que la rama se combina en el tronco principal de nuevo dirigiendose finalmente al centinela (NULL), la raiz (en raros casos como en meta-compilacion el diccionario puede estar aislado, hay varios). El efecto es un uso sofisticado de espacio de nombres (namespaces) y criticamente puede tener el efecto de sobrecargar palabras claves, el significado es contextual.  Una palabra definida generalmente consiste en un encabezado (head) y un cuerpo (body), con el encabezado consistiendo en el name field (NF) y el link field (LF) y un cuerpo consistiendo del code field (CF) y el parameter field (PF).  El encabezado y al cuerpo de una entrada de diccionario son tratados separadamente porque ellos pueden no estar contiguos. Por ejemplo, cuando un programa de Forth es recompilado para una nueva plataforma, el,encabezado puede quedar en el computador de compilacion, mientras que el cuerpo va a la nueva plataforma. En algunos ambientes (tales como sistemas empotrados) los encabezados ocupan memoria innecesariamente. Sin embargo, algunos compiladores cruzados pueden poner las cabezas en el computador destino si se espera que este computador soporte un sistema Forth interactivo.\u200b  El formato exacto de una entrada de diccionario no esta prescrito, y las implementaciones varian. Sin embargo, ciertos componentes casi siempre estan presentes, aunque el tama\u00f1o exacto y la orden pueden variar. Descrito como estructura, una entrada de diccionario pudo verse asi:\u200b  El campo nombre comienza con un prefijo que da la longitud del nombre de la palabra (tipicamente hasta 32 bytes), y varios bits para los flags. Entonces, la representacion de caracteres del nombre de la palabra sigue al prefijo. Dependiendo de la implementacion particular del Forth, puede haber para alineacion, uno o mas bytes NUL (\"\\0\").  El campo link contiene un puntero a la palabra previamente definida. El puntero puede ser un desplazamiento relativo o una direccion absoluta que apunta al hermano anterior.  El puntero del campo del codigo sera: o la direccion de la palabra que ejecutara el codigo, o datos en el campo del parametro, o el principio del codigo de maquina que el procesador ejecutara directamente. Para las palabras definidas por la palabra \"dos puntos\" :, el puntero del campo del codigo apunta a la palabra que guardara el puntero de instruccion actual (IP) de Forth en la pila de retorno, y carga el IP con la nueva direccion desde la cual continuar la ejecucion de palabras. Esto es lo mismo que lo que hacen las instrucciones call/return del procesador.  El compilador en si mismo consiste de palabras Forth visibles al sistema, no es un programa monolitico. Esto permite que un programador cambie las palabras del compilador para propositos especiales.  El flag de \"tiempo de compilacion\" en el campo nombre es ajustado para las palabras con comportamiento en \"tiempo de compilacion\". La mayoria de las palabras simples ejecutan el mismo codigo si estan mecanografiadas en una linea de comandos, o insertadas en otro codigo. Al compilar estas, el compilador simplemente coloca el codigo o un puntero enhebrado (threaded pointer) hacia la palabra.\u200b  Los ejemplos clasicos de palabras de tiempo de compilacion son las estructuras de control, como por ejemplo IF y WHILE. Todas las estructuras de control de Forth, y casi todo su compilador son implementados como palabras de tiempo de compilacion. Todas las palabras de flujo de control de Forth son ejecutadas durante la compilacion para compilar varias combinaciones de las palabras primitivas BRANCH y ?BRANCH (branch y branch if false). Durante la compilacion, la pila de datos es usado para soportar el balanceo, anidado, y backpatching de las direcciones de bifurcacion de las estructuras de control. El peque\u00f1o codigo de ejemplo:  sera compilado como la siguiente secuencia dentro de una definicion:  Los numeros despues de BRANCH representan direcciones relativas de saltos (jump). LIT es la palabra primitiva para empujar (push) un numero \"literal\" sobre la pila de datos.  La palabra : (dos puntos) analiza sintacticamente (parse)un nombre como parametro, crea una palabra (una definicion de \"dos puntos\") y entra en el estado de compilacion. El interprete continua leyendo palabras delimitadas por espacio desde el dispositivo de entrada del usuario. Si una palabra es encontrada, el interprete ejecuta la semantica de compilacion asociada a la palabra, en vez de la semantica de interpretacion. Por defecto la semantica de compilacion de una palabra es a\u00f1adir su semantica de interpretacion a la definicion actual.\u200b  La palabra ; (punto y coma) finaliza la definicion actual y retorna al estado de interpretacion. Ella es un ejemplo de una palabra cuya semantica de compilacion difiere de la que se tiene por defecto. La semantica de interpretacion de ; (punto y coma), la de la mayoria de las palabras de flujo de control, y la de algunas otras palabras estan indefinidas en ANS Forth, lo que significa que ellas solo deben ser usadas dentro de definiciones y no en la linea interactiva de comando.\u200b  El estado del interprete puede ser cambiado manualmente con las palabras [ y ] (corchete izquierdo y corchete derecho) entran en el estado de interpretacion o en el estado de compilacion, respectivamente. Estas palabras pueden ser usadas con la palabra LITERAL para calcular un valor durante una compilacion e insertarlo en la actual definicion de dos puntos. El LITERAL tiene la semantica de compilacion para tomar un objeto de la pila de datos y a\u00f1adir la semantica a la definicion actual de dos puntos para poner ese objeto en la pila de datos.  En ANS Forth, el estado actual del interprete puede ser leido desde el flag STATE que contiene el valor true cuando esta en estado de compilacion y false en caso contrario. Esto permite la implementacion de palabras de estado inteligente con un comportamiento que cambia segun el estado actual del interprete.  La palabra IMMEDIATE marca la definicion dos puntos mas reciente como una palabra inmediata, reemplazando efectivamente su semantica de compilacion por su semantica de interpretacion.\u200b Las palabras inmediatas son normalmente ejecutadas durante la compilacion, no se compilan, pero esto puede ser sobreescrito por el programador, en cualquier estado. ; es un ejemplo de una palabra inmediata. En el ANS Forth, la palabra POSTPONE toma un nombre como un parametro y a\u00f1ade la semantica de compilacion de la palabra nombrada a la definicion actual, incluso si la palabra era marcado inmediata. Forth-83 definio las palabras separadas COMPILE y [COMPILE] para forzar la compilacion de palabras no-inmediatas e inmediatas, respectivamente.  En ANS Forth, las palabras sin nombre pueden ser definidas con la palabra :NONAME (sin nombre) que compila las palabras siguientes hasta el proximo ; (punto y coma) y deja un token de ejecucion en la pila de datos. El token de ejecucion proporciona un manejador (handle) opaco para la semantica de compilacion, similar a los punteros de funcion del lenguaje de programacion C.  Los tokens de ejecucion pueden ser almacenados en variables. La palabra EXECUTE toma un token de ejecucion de la pila de datos y realiza la semantica asociada. La palabra COMPILE, (compila-coma) toma un token de ejecucion de la pila de datos y a\u00f1ade la semantica asociada a la definicion actual.  La palabra ' (comilla sencilla) toma el nombre de una palabra como parametro, y retorna en la pila de datos, el token de ejecucion asociado con esa palabra. En el estado de interpretacion, ' RANDOM-WORD EXECUTE es equivalente a RANDOM-WORD.\u200b  Las palabras : (dos puntos) y ' (comilla sencilla) son ejemplos de palabras que toman sus argumentos del dispositivo de entrada del usuario en vez de la pila de datos. Otro ejemplo es la palabra ( (parentesis abierto) la cual lee e ignora las siguientes palabras hasta, e incluyendo, el parentesis cerrado y es usada para poner comentarios. Similarmente, la palabra \\ (barra de division hacia atras) es usada para los comentarios que continuan hasta el extremo de la linea actual. ( (parentesis abierto) y \\ (barra de division hacia atras) son palabras como el resto, y por ello tienen que estar separadas de lo que las sigue (en este caso el comentario) por al menos un espacio en blanco.  En la mayoria de los sistemas Forth, el cuerpo de una definicion de codigo consiste en lenguaje de maquina o una cierta forma de codigo enhebrado (threaded code). La Forth original que sigue el estandar informal del Forth Interest Group (FIG), es un Threaded Interpretive Language (TIL). Esto tambien es llamado codigo enhebrado indirecto (indirect-threaded code), pero el enhebrado directo (direct-threaded) y la subrutina de Forth tambien han llegado a ser populares en tiempos modernos. Los mas rapidos Forth modernos usan enhebrado de subrutinas (subrutine threading), insertan palabras simples como macros, y realizan la optimizacion de peephole u otras estrategias de optimizacion para hacer el codigo mas peque\u00f1o y mas rapido.\u200b  Cuando una palabra es una variable u otro objeto de datos, el CF apunta al codigo de tiempo de ejecucion asociado con la definicion de la palabra que lo creo. Una palabra de definicion tiene un caracteristico \"comportamiento de definicion\" (creando una entrada de diccionario y posiblemente asignando e inicializando un espacio para los datos) y tambien especifica el comportamiento de una instancia de la clase de las palabras construidas por esta palabra de definicion. Los ejemplos incluyen:  Forth tambien proporciona una facilidad por la cual un programador puede definir las nuevas palabras de definicion especificas a una aplicacion, especificando tanto un comportamiento de la definicion (en tiempo de compilacion) como un comportamiento de la instancia (en tiempo de ejecucion). Algunos ejemplos incluyen buffers circulares, bits con nombres en puertos de E/S, y arreglos automaticamente indexados.  Los objetos de datos definidos por estas palabras y similares, son globales en alcance. La funcion para variables locales proporcionada en otros lenguajes, en Forth es proporcionada por la pila de datos (aunque Forth tambien tiene variables locales reales). Comparado con otros lenguajes, el estilo de programacion en Forth usa muy pocos objetos de datos con nombre; tales objetos de datos son usados tipicamente para contener datos que son usados por un numero de palabras o de tareas (en una implementacion multitarea).\u200b  Forth no hace cumplir la consistencia en el uso de tipos de datos; es responsabilidad del programador usar los operadores apropiados para leer (fetch) y para almacenar (store) los valores o para realizar otras operaciones con los datos.  Las palabras escritas en Forth son compiladas en una forma ejecutable. Las implementaciones clasicas de \"enhebrado indirecto\" (indirect threaded) compilan listas de las direcciones de las palabras a ser ejecutadas; muchos sistemas modernos generan codigo de maquina real (incluyendo llamadas a ciertas palabras y codigos externos para otros ampliados en el mismo lugar). Algunos sistemas tienen compiladores de optimizacion. Hablando en terminos generales, un programa Forth es guardado como la imagen de memoria del programa compilado con un solo comando (ej., RUN) que es ejecutado cuando es cargada la version compilada.  Durante el desarrollo, el programador usa al interpretador para ejecutar y probar cada peque\u00f1a pieza a medida que es desarrollada. Por lo tanto, la mayoria de los programadores Forth defienden un dise\u00f1o de arriba hacia abajo (top-down) flojo, y el desarrollo de abajo hacia arriba (bottom-up) con la prueba y la integracion continuos.\u200b  El dise\u00f1o de arriba hacia abajo es generalmente una separacion del programa en \"vocabularios\" que entonces son usados como conjuntos de herramientas de alto nivel para escribir el programa final. Un programa Forth bien dise\u00f1ado se lee como el lenguaje natural, e implementa no solo una sola simple solucion, sino tambien un conjunto de herramientas para atacar problemas relacionados.\u200b  Puesto que la maquina virtual del Forth es simple de implementar y no tiene ninguna referencia estandar de implementacion, hay una pletora de implementaciones del lenguaje. Ademas de soportar las variedades estandar de los sistemas de computadora de escritorio (POSIX, Microsoft Windows, Mac OS X), muchos de estos sistemas Forth tambien apuntan a una variedad de sistemas embebidos. Listados aqui estan algunos de los sistemas mas prominentes que se conforman al estandar ANS Forth 1994.  Cabe destacar tambien una implementacion en el mod de Minecraft, RedPower 2 como sistema de control. ","snippet":"Forth o FORTH es un lenguaje de programacion y un ambiente de programacion para computadores ideado por Charles H. Moore entre los a\u00f1os 1965 y 1970 en el National Radio Astronomy Observatory de Kitt P","enlaces_salientes":["Forth","Forth","Forth","Forth_(desambiguaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n","Computadora_electr%C3%B3nica","Charles_H._Moore","Arizona","IBM_1130","Astronom%C3%ADa","Pila_(inform%C3%A1tica)","C%C3%B3digo_enhebrado","Pila_(estructura_de_datos)","Open_Firmware","Proyecto_GNU","Subrutina","M%C3%A1quina_virtual","Runtime","Shell_de_UNIX","BBC_Micro","Apple_II","Firmware","Microcontrolador","Subrutina","Pila_(inform%C3%A1tica)","Variable_local","Par%C3%A1metro_(Ciencias_de_la_computaci%C3%B3n)","Lenguaje_C","Pila_de_llamadas","N%C3%BAcleo_(inform%C3%A1tica)","Notaci%C3%B3n_polaca_inversa","Dise%C3%B1o_asistido_por_computador","Portabilidad","RISC","M%C3%A1quina_de_pila","Open_Firmware","Booting","Apple_Inc.","IBM","Sun_Microsystems","OLPC_XO-1","BTX","FreeBSD","Charles_H._Moore","National_Radio_Astronomy_Observatory","IBM_1130","Lenguaje_de_Tercera_Generaci%C3%B3n","Intel_8086","Intel_8080","Motorola_6800","Zilog_Z80","MOS_6502","Instituto_Nacional_Estadounidense_de_Est%C3%A1ndares","Microcomputador","Computador_personal","Jupiter_Ace","ROM","Canon_Cat","Rockwell","Notaci%C3%B3n_polaca_inversa","Pila_(inform%C3%A1tica)","Notaci%C3%B3n_postfija","Hewlett-Packard","Notaci%C3%B3n_infija","Backus-Naur_form","Lenguaje_de_programaci%C3%B3n_C","Analizador_sint%C3%A1ctico","Gram%C3%A1tica","Analizador_sint%C3%A1ctico","Espacio_en_blanco","Ensamblador","Compilador","Sistema_operativo","Sistema_de_archivos","C%C3%B3digo_fuente","Kilobyte","Buffer_de_datos","Hash","Planificaci%C3%B3n_Round-robin","Intel_8051","Microsoft_Windows","N%C3%BAcleo_Linux","UNIX","Sistema_de_archivos","Sistema_de_ventanas","Bit","Sistema_embebido","Compilaci%C3%B3n_cruzada","Puerto_serial","Tecnolog%C3%ADa_TTL","Byte","%C3%81rbol_(inform%C3%A1tica)","Lista_(inform%C3%A1tica)","Espacio_de_nombres","Sobrecarga","Flag","C%C3%B3digo_de_m%C3%A1quina","CPU","Estructuras_de_control","Int%C3%A9rprete_(inform%C3%A1tica)","Flag","Lenguaje_de_programaci%C3%B3n_C","Lenguaje_de_m%C3%A1quina","C%C3%B3digo_enhebrado","Entrada/salida","POSIX","Microsoft_Windows","Mac_OS_X","Sistema_embebido","Proyecto_GNU","Open_Firmware","Cargador_de_arranque","BIOS","Wayback_Machine","Minecraft","Charles_H._Moore","M%C3%A1quina_de_pila","Lenguaje_de_programaci%C3%B3n_orientado_a_pila","C%C3%B3digo_enhebrado","Grandes_sistemas_de_Burroughs","Lenguaje_de_programaci%C3%B3n_Joy","Notaci%C3%B3n_polaca_inversa","1994","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","ISBN","19_de_diciembre","1990","ISBN","Wayback_Machine","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Diagrama_de_decisi%C3%B3n_binario","titulo":"Diagrama de decision binario","contenido":"En ciencias de la computacion, un diagrama de decision binario (DDB), tal como una forma normal de negacion (FNN) o un grafo aciclico dirigido proposicional (GADP), es una estructura de datos utilizada para representar una funcion booleana. A un nivel mas abstracto, los DDBs pueden ser considerados como una representacion comprimida de conjuntos o relaciones. A diferencia de otras representaciones comprimidas, las operaciones se realizan directamente en los DDB, sin necesidad de descomprimirlos.  Una funcion booleana puede representarse como un grafo aciclico dirigido con raiz, el cual posee nodos de decision y dos nodos terminales llamados terminal-0 y terminal-1. Cada nodo de decision esta etiquetado por una variable booleana (0 o 1) y tiene dos nodos hijos, llamados hijo menor e hijo mayor. La arista que une un nodo con un hijo menor (mayor) representa una asignacion de la variable con el valor 0 (1).  Un DDB esta ordenado si las distintas variables aparecen en el mismo orden para todos los caminos desde la raiz. Un DDB es reducido si se han aplicado las siguientes dos reglas a su grafo:  En el uso popular, el termino DDB tambien se refiere a Diagrama de decision binario reducido ordenado (DDBRO, mejor conocido en la literatura en ingles como ROBDD: Reduced Ordered Binary Decision Diagram).\u200b Una ventaja de un DDBRO es que es canonico (unico) para una funcion particular y un orden de variables.\u200b Esta propiedad es util por ejemplo en la verificacion de funciones de equivalencia.  Un camino desde el nodo raiz al terminal-1 representa una asignacion de variables (posiblemente parcial) para la cual la funcion booleana es verdadera. Si el camino desciende desde un nodo hasta un hijo menor (mayor), la variable del nodo adquiere el valor 0 (1).  La idea basica de donde proviene esta estructura de datos es la expansion de Shannon. Una funcion booleana se divide en dos sub-funciones (cofactores) mediante la incorporacion de una variable (cf. forma normal if-then-else). Si tal sub-funcion se considera como un sub-arbol, entonces se puede representar por un arbol de decision binario. Los diagramas de decision binarios fueron introducidos por Lee,\u200b y mas adelante estudiados y dados a conocer mejor por Akers\u200b y Boute.\u200b  El maximo potencial de esta estructura de datos para ser utilizada en la implementacion de algoritmos eficientes fue investigada por Randal Bryant en la Universidad Carnegie Mellon: su aporte clave fue el utilizar una ordenacion fija de variables (para lograr una representacion canonica) y sub-grafos compartidos (para mayor compresion). Aplicando ambos conceptos logro una estructura de datos y algoritmos eficientes para la representacion de conjuntos y relaciones.\u200b\u200b Asi se definio la estructura de datos Diagrama de decision binario reducido ordenado y compartido (en ingles \u00abShared Reduced Ordered Binary Decision Diagram\u00bb), que permite que un sub-grafo sea utilizado por varios DDBs.\u200b Actualmente, la nocion de DDB se utiliza generalmente para referirse a esta estructura de datos particular.  En su ponencia en video Fun With Binary Decision Diagrams (BDDs) (\u00abDiversion con los diagramas de decision binarios (DDBs)\u00bb), Donald Knuth se refiere a los DDBs como \u00abuna de las unicas estructuras de datos realmente fundamentales que han aparecido en los ultimos 25 a\u00f1os\u00bb, y destaca el hecho de que articulo de Bryant de 1986 fuese durante un tiempo uno de los articulos mas citados en ciencias de la computacion. ","snippet":"En ciencias de la computacion, un diagrama de decision binario (DDB), tal como una forma normal de negacion (FNN) o un grafo aciclico dirigido proposicional (GADP), es una estructura de datos utilizad","enlaces_salientes":["Diagrama_de_decisi%C3%B3n_binario","Diagrama_de_decisi%C3%B3n_binario","Diagrama_de_decisi%C3%B3n_binario","Ciencias_de_la_computaci%C3%B3n","Forma_normal_de_negaci%C3%B3n","Estructura_de_datos","Funci%C3%B3n_booleana","Compresi%C3%B3n_de_datos","Conjunto","Relaci%C3%B3n_matem%C3%A1tica","Funci%C3%B3n_booleana","Grafo_ac%C3%ADclico_dirigido","%C3%81rbol_(inform%C3%A1tica)","%C3%81rbol_(inform%C3%A1tica)","Isomorfismo","Equivalencia_din%C3%A1mica_y_formal","Funci%C3%B3n_booleana","C%C3%B3nfer","%C3%81rbol_(inform%C3%A1tica)","%C3%81rbol_de_decisi%C3%B3n","%C3%81rbol_binario","Universidad_Carnegie_Mellon","Donald_Knuth","Aprendizaje_basado_en_%C3%A1rboles_de_decisi%C3%B3n","Problema_de_satisfacibilidad_booleana","Estructura_de_datos","Model_checking","Forma_normal_negativa","Internet_Archive","Wayback_Machine","Bitwise","Control_de_autoridades","Gemeinsame_Normdatei"]}
{"url":"TDD","titulo":"Desarrollo guiado por pruebas","contenido":"Desarrollo guiado por pruebas de software, o Test-driven development (TDD) es una practica de ingenieria de software que involucra otras dos practicas: Escribir las pruebas primero (Test First Development) y Refactorizacion (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en ingles). En primer lugar, se escribe una prueba y se verifica que la nueva prueba falla. A continuacion, se implementa el codigo que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el codigo escrito. El proposito del desarrollo guiado por pruebas es lograr un codigo limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizara que el software cumple con los requisitos que se han establecido.  Para que funcione el desarrollo guiado por pruebas, el sistema que se programa tiene que ser lo suficientemente flexible como para permitir que sea probado automaticamente. Cada prueba sera suficientemente peque\u00f1a como para que permita determinar univocamente si el codigo probado pasa o no la verificacion que esta le impone. El dise\u00f1o se ve favorecido ya que se evita el indeseado \"sobre dise\u00f1o\" de las aplicaciones y se logran interfaces mas claras y un codigo mas cohesivo.  En primer lugar se debe definir una lista de requisitos y despues se ejecuta el siguiente ciclo:  Tener un unico repositorio universal de pruebas facilita complementar TDD con otra practica recomendada por los procesos agiles de desarrollo, la \"Integracion Continua\". Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda la bateria de pruebas y asi descubrir, si nuestra ultima version es compatible con el resto del sistema. Es recomendable y menos costoso corregir peque\u00f1os problemas cada pocas horas, que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.  Una caracteristica de esta forma de programacion es el evitar escribir codigo innecesario (\"You Ain't Gonna Need It\" (YAGNI)). Se intenta escribir el minimo codigo posible, y si el codigo pasa una prueba aunque sepamos que es incorrecto nos da una idea de que tenemos que modificar nuestra lista de requisitos agregando uno nuevo.  La generacion de pruebas para cada funcionalidad hace que el programador confie en el codigo escrito. Esto permite hacer modificaciones profundas del codigo (posiblemente en una etapa de mantenimiento del programa) pues sabemos que si luego logramos hacer pasar todas las pruebas tendremos un codigo que funcione correctamente.  Otra caracteristica del Test Driven Development es que requiere que el programador primero haga fallar los casos de prueba. La idea es asegurarse de que los casos de prueba realmente funcionen y puedan recoger un error.  Uno de los puntos mas delicados a la hora de aplicar TDD como herramienta de dise\u00f1o es en el paso en el que ya tenemos un test que falla y debemos crear la implementacion minima para que el test pase. Para ello Kent Beck expone un conjunto de estrategias que nos van a permitir avanzar en pasos peque\u00f1os hacia la solucion del problema.  Los programadores que utilizan el desarrollo guiado por pruebas en un proyecto virgen encuentran que en raras ocasiones tienen la necesidad de utilizar el depurador o debugger.  A pesar de los elevados requisitos iniciales de aplicar esta metodologia, el desarrollo guiado por pruebas (TDD) puede proporcionar un gran valor a\u00f1adido en la creacion de software, produciendo aplicaciones de mas calidad y en menos tiempo. Ofrece mas que una simple validacion del cumplimiento de los requisitos, tambien puede guiar el dise\u00f1o de un programa. Centrandose en primer lugar en los casos de prueba uno debe imaginarse como los clientes utilizaran la funcionalidad (en este caso, los casos de prueba). Por lo tanto, al programador solo le importa la interfaz y no la implementacion. Esta ventaja es similar al dise\u00f1o por convenio pero se parece a el por los casos de prueba mas que por las aserciones matematicas.  El poder del TDD radica en la capacidad de avanzar en peque\u00f1os pasos cuando se necesita. Permite que un programador se centre en la tarea actual y la primera meta es, a menudo, hacer que la prueba pase. Inicialmente no se consideran los casos excepcionales y el manejo de errores. Estos, se implementan despues de que se haya alcanzado la funcionalidad principal. Otra ventaja es que, cuando es utilizada correctamente, se asegura de que todo el codigo escrito esta cubierto por una prueba. Esto puede dar al programador un mayor nivel de confianza en el codigo.  El desarrollo guiado por pruebas requiere que las pruebas puedan automatizarse. Esto resulta complejo en los siguientes dominios: ","snippet":"Desarrollo guiado por pruebas de software, o Test-driven development (TDD) es una practica de ingenieria de software que involucra otras dos practicas: Escribir las pruebas primero (Test First Develop","enlaces_salientes":["Desarrollo_guiado_por_pruebas","Desarrollo_guiado_por_pruebas","Desarrollo_guiado_por_pruebas","Ingenier%C3%ADa_de_software","Refactorizaci%C3%B3n","Prueba_unitaria","Idioma_ingl%C3%A9s","Interfaz","Principio_KISS","Refactorizaci%C3%B3n","C%C3%B3digo_duplicado","Desarrollo_%C3%A1gil_de_software","Kent_Beck","Proyecto_Greenfield","Interfaz_gr%C3%A1fica_de_usuario","Bases_de_datos","Prueba_de_software","Caso_de_prueba","Prueba_unitaria","Filosof%C3%ADas_del_desarrollo_de_software","Control_de_autoridades"]}
{"url":"Tipado_fuerte","titulo":"Tipado fuerte","contenido":"Un lenguaje de programacion es fuertemente tipado si no se permiten violaciones de los tipos de datos, es decir, dado el valor de una variable de un tipo concreto, no se puede usar como si fuera de otro tipo distinto a menos que se haga una conversion. No hay una unica definicion de este termino. Un lenguaje que se dice que no esta tipado se refiere a que no esta fuertemente tipado.  Los lenguajes de programacion suelen contar con un sublenguaje de tipos para declarar variables. Este sublenguaje instruye al compilador respecto al tipo de valores que puede adoptar cada variable. Por ejemplo:  en el Lenguaje de programacion C significa \"la variable X adopta valores numericos enteros\".  Estos tipos tambien se declaran para todos los argumentos de procedimientos o subrutinas. Por ejemplo:  Este procedimiento acepta un numero en coma flotante (numero real) y le suma 1,5.  En los lenguajes fuertemente tipados, el compilador no permite que se use una variable como parametro de un procedimiento si sus tipos no coinciden exactamente. En el ejemplo anterior, no seria posible invocar la subrutina con la variable \"X\" si esta fuese de un tipo incompatible con float. Es decir, si X fuese de tipo entero, el compilador produce una conversion de int a float, y permite la llamada typecasting. En cambio si fuese de otro tipo, como puntero a char(char *), para el que no existe una conversion implicita a float, el compilador detectara el conflicto y producira un error.  Cuando un lenguaje es fuertemente tipado, el programador debe explicitamente convertir un tipo de datos en otro. Esto se conoce como conversion o moldeado de tipos (typecasting) y tambien debe estar soportado por el compilador. Por ejemplo:  Indica al compilador que no estamos cometiendo un error y realmente deseamos convertir la variable \"X\" (entera) en una variable de coma flotante para invocar a \"subrutina\".  Cada lenguaje de programacion puede ser mas o menos tipado segun en que casos exige el typecasting. Por ejemplo, la conversion automatica entre entero y coma flotante podria ser admitida, pero no al contrario. Si no es factible la conversion entre un tipo u otro, el compilador tambien emitira un error de compilacion al momento de ejecutarlo.  Es habitual que el lenguaje de programacion C se considere fuertemente tipado, lo cual es relativamente incorrecto. Los compiladores de C nos avisan cuando los tipos no se corresponden, lo que puede ser facilmente resuelto realizando un cast de la variable en cuestion. Sin embargo, tomando de nuevo la definicion, un lenguaje es fuertemente tipado \"si no se permiten violaciones de los tipos de datos\", pero en el caso de C si que se permite esto, dado que al efectuar un cast no estamos ante una conversion de tipo (no hay variacion alguna de la representacion del dato en memoria) sino ante un \"mensaje\" al compilador.  En la programacion a bajo nivel de C son comunes violaciones de tipo con las que el programador debe ser especialmente cuidadoso.  Un ejemplo de lenguaje fuertemente tipado, como es Python, no permite violacion de tipos. Esto se puede ver tratando de ejecutar una suma entre un string y un int.  Los lenguajes de programacion no tipados no controlan los tipos de las variables que declaran, de este modo, es posible usar variables de cualquier tipo en un mismo escenario. Por ejemplo, una funcion puede recibir como parametro un valor entero, cadena de caracteres, flotante, etc.  No hay que confundir el termino con los lenguajes de tipos dinamicos, en los que los tipos de las variables se deciden en tiempo de ejecucion, si bien es cierto que muchos lenguajes de programacion de tipos dinamicos (en los que no se declaran los tipos de datos) son tambien no tipados.  No son necesarias las conversiones de tipos, por lo tanto el siguiente ejemplo es correcto ","snippet":"Un lenguaje de programacion es fuertemente tipado si no se permiten violaciones de los tipos de datos, es decir, dado el valor de una variable de un tipo concreto, no se puede usar como si fuera de ot","enlaces_salientes":["Tipado_fuerte","Tipado_fuerte","Tipado_fuerte","Lenguaje_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n_C","Subrutina","Coma_flotante","Compilador","Tipado_din%C3%A1mico","Haskell","ML_(lenguaje_de_programaci%C3%B3n)","C_Sharp","Lenguaje_de_programaci%C3%B3n_Ada","Modula-2","Lenguaje_de_programaci%C3%B3n_Pascal","Lenguaje_de_programaci%C3%B3n_Java","C%2B%2B","Fortran","Objective-C","Go_(lenguaje_de_programaci%C3%B3n)","Rust_(lenguaje_de_programaci%C3%B3n)","Perl_6","TypeScript","Lua","Dart","Python","Lisp","Perl","PHP","Prolog","Basic","JavaScript","Control_de_autoridades"]}
{"url":"Interpretaci%C3%B3n_(l%C3%B3gica)","titulo":"Interpretacion (logica)","contenido":"En logica, una interpretacion semantica es asignar significados a las variables que constituyen las formulas bien formadas de un lenguaje formal.\u200b Como los lenguajes formales pueden definirse en terminos puramente sintacticos, sus formulas bien formadas pueden no ser mas que cadenas de simbolos sin ningun significado. Una interpretacion otorga significado a esas formulas. El estudio general de las interpretaciones de los lenguajes formales se llama semantica formal.\u200b  Una interpretacion muchas veces (pero no siempre) permite determinar el valor de verdad de las formulas bien formadas de un lenguaje.\u200b Si una interpretacion asigna el valor de verdad verdadero a una formula o a varias formulas, entonces se dice que la interpretacion es un modelo de esa formula o de esas formulas.\u200b ","snippet":"En logica, una interpretacion semantica es asignar significados a las variables que constituyen las formulas bien formadas de un lenguaje formal.\u200b Como los lenguajes formales pueden definirse en termi","enlaces_salientes":["Interpretaci%C3%B3n_(l%C3%B3gica)","Interpretaci%C3%B3n_(l%C3%B3gica)","Interpretaci%C3%B3n_(l%C3%B3gica)","L%C3%B3gica","Sem%C3%A1ntica","Significado","Variable_(matem%C3%A1ticas)","F%C3%B3rmula_bien_formada","Lenguaje_formal","Sintaxis","Cadena_de_caracteres","Sem%C3%A1ntica_formal","Valor_de_verdad","Teor%C3%ADa_de_modelos","Sem%C3%A1ntica_formal","Teor%C3%ADa_de_modelos","Cambridge_University_Press","Control_de_autoridades","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Compilaci%C3%B3n","titulo":"Compilador","contenido":"En informatica, un compilador es un programa que traduce codigo escrito en un lenguaje de programacion (llamado fuente) a otro lenguaje (conocido como objeto).\u200b En este tipo de traductor el lenguaje fuente es generalmente un lenguaje de alto nivel y el objeto un lenguaje de bajo nivel, como assembly o codigo maquina.\u200b Este proceso de traduccion se conoce como compilacion.\u200b  La construccion de un compilador involucra la division del proceso en una serie de fases que variara con su complejidad. Generalmente estas fases se agrupan en dos tareas: el analisis del programa fuente y la sintesis del programa objeto.\u200b:\u200a3  Alternativamente, las fases descritas para las tareas de analisis y sintesis se pueden agrupar en:  Esta division permite que el mismo generador se utilice para crear el codigo maquina de varios lenguajes de programacion distintos y que el mismo analizador que sirve para examinar el codigo fuente de un lenguaje de programacion concreto sirva para producir codigo maquina en varias plataformas.  En 1938, Konrad Zuse desarrollo la primera computadora digital electromecanica, denominada Z1 en Alemania, y posteriormente, en 1946, se desarrollo la primera computadora totalmente electronica ENIAC, sucedida principalmente por la EDVAC (1951), primera computadora electronica digital. En un principio, estas maquinas ejecutaban instrucciones consistentes en codigos numericos que se\u00f1alaban a los circuitos de la maquina los estados correspondientes a cada operacion, lo que se denomino lenguaje maquina.  Pronto los primeros usuarios de estos ordenadores descubrieron la ventaja de escribir sus programas mediante claves mas faciles de recordar que esos codigos; al final, todas esas claves juntas se traducian manualmente a lenguaje maquina. Estas claves constituyen los llamados lenguajes ensambladores.  Pese a todo, el lenguaje ensamblador seguia siendo el de una maquina, pero mas facil de manejar (las instrucciones de maquina se reemplazan por mnemonicos. Los trabajos de investigacion se orientaron hacia la creacion de un lenguaje que expresara las distintas acciones a realizar de una manera lo mas sencilla posible para una persona. El primer compilador fue escrito por Grace Hopper, en 1952 para el lenguaje de programacion A-0. En 1950 John Backus dirigio una investigacion en IBM sobre un lenguaje algebraico. En 1954 se empezo a desarrollar un lenguaje que permitia escribir formulas matematicas de manera traducible por un ordenador; le llamaron FORTRAN (FORmulae TRANslator). Fue el primer lenguaje de alto nivel y se introdujo en 1957 para el uso de la computadora IBM modelo 704.  Surgio asi por primera vez el concepto de un traductor como un programa que traducia un lenguaje a otro lenguaje. En el caso particular de que el lenguaje a traducir es un lenguaje de alto nivel y el lenguaje traducido de bajo nivel, se emplea el termino compilador.  El trabajo de realizar un compilador fue complicado de realizar. El primer compilador de FORTRAN tardo 18 a\u00f1os-persona en realizarse y era muy sencillo. Este desarrollo de FORTRAN estaba muy influenciado por la maquina objeto en la que iba a ser implementado. Como un ejemplo de ello tenemos el hecho de que los espacios en blanco fuesen ignorados, debido a que el periferico que se utilizaba como entrada de programas (una lectora de tarjetas perforadas) no contaba correctamente los espacios en blanco.  El primer compilador autocontenido, es decir, capaz de compilar su propio codigo fuente fue el creado para Lisp por Hart y Levin en el MIT en 1962. Desde 1970 se ha convertido en una practica comun escribir el compilador en el mismo lenguaje que este compila, aunque PASCAL y C han sido alternativas muy usadas.  Crear un compilador autocontenido genera un problema llamado bootstrapping, es decir el primer compilador creado para un lenguaje tiene que o bien ser compilado por un compilador escrito en otro lenguaje o bien compilado al ejecutar el compilador en un interprete.  Esta taxonomia de los tipos de compiladores no es excluyente, por lo que puede haber compiladores que se adscriban a varias categorias:  En las primeras epocas de la informatica, los compiladores eran considerados un software de los mas complejos existentes.[cita\u00a0requerida]  Los primeros compiladores se realizaron programandolos directamente en lenguaje maquina o en ensamblador. Una vez que se dispone de un compilador, se pueden escribir nuevas versiones del compilador (u otros compiladores distintos) en el lenguaje que compila ese compilador.  Existen herramientas que facilitan la tarea de escribir compiladores o interpretes informaticos. Estas herramientas permiten generar el esqueleto del analizador sintactico a partir de una definicion formal del lenguaje de partida, especificada normalmente mediante una gramatica formal y barata, dejando unicamente al programador del compilador la tarea de programar las acciones semanticas asociadas.  Es el proceso por el cual se traducen las instrucciones escritas en un determinado lenguaje de programacion a lenguaje maquina. Ademas de un traductor, se pueden necesitar otros programas para crear un programa objeto ejecutable. Un programa fuente se puede dividir en modulos almacenados en archivos distintos. La tarea de reunir el programa fuente a menudo se confia a un programa distinto, llamado preprocesador. El preprocesador tambien puede expandir abreviaturas, llamadas a macros, a proposiciones del lenguaje fuente.  Normalmente la creacion de un programa ejecutable (un tipico archivo .exe para Windows o DOS) conlleva dos pasos. El primer paso se llama compilacion (propiamente dicho) y traduce el codigo fuente escrito en un lenguaje de programacion almacenado en un archivo a codigo en bajo nivel (normalmente en codigo objeto, no directamente a lenguaje maquina). El segundo paso se llama enlazado en el cual se enlaza el codigo de bajo nivel generado de todos los ficheros y subprogramas que se han mandado a compilar y se a\u00f1ade el codigo de las funciones que hay en las bibliotecas del compilador para que el ejecutable pueda comunicarse directamente con el sistema operativo, traduciendo asi finalmente el codigo objeto a codigo maquina, y generando un modulo ejecutable.  Estos dos pasos se pueden hacer por separado, almacenando el resultado de la fase de compilacion en archivos objetos (un tipico.obj para Microsoft Windows, DOS o para Unix); para enlazarlos en fases posteriores, o crear directamente el ejecutable; con lo que la fase de compilacion se almacena solo temporalmente. Un programa podria tener partes escritas en varios lenguajes (por ejemplo C, C++ y Asm), que se podrian compilar de forma independiente y luego enlazar juntas para formar un unico modulo ejecutable.  El proceso de traduccion se compone internamente de varias etapas o fases, que realizan distintas operaciones logicas. Es util pensar en estas fases como en piezas separadas dentro del traductor, y pueden en realidad escribirse como operaciones codificadas separadamente aunque en la practica a menudo se integren juntas.  El analisis lexico constituye la primera fase, aqui se lee el programa fuente de izquierda a derecha y se agrupa en componentes lexicos (tokenes), que son secuencias de caracteres que tienen un significado. Ademas, todos los espacios en blanco, lineas en blanco, comentarios y demas informacion innecesaria se elimina del programa fuente. Tambien se comprueba que los simbolos del lenguaje (palabras clave, operadores, etc.) se han escrito correctamente.  Como la tarea que realiza el analizador lexico es un caso especial de coincidencia de patrones, se necesitan los metodos de especificacion y reconocimiento de patrones, se usan principalmente los automatas finitos que acepten expresiones regulares. Sin embargo, un analizador lexico tambien es la parte del traductor que maneja la entrada del codigo fuente, y puesto que esta entrada a menudo involucra un importante gasto de tiempo, el analizador lexico debe funcionar de manera tan eficiente como sea posible.  En esta fase los caracteres o componentes lexicos se agrupan jerarquicamente en frases gramaticales que el compilador utiliza para sintetizar la salida. Se comprueba si lo obtenido de la fase anterior es sintacticamente correcto (obedece a la gramatica del lenguaje). Por lo general, las frases gramaticales del programa fuente se representan mediante un arbol de analisis sintactico.  La estructura jerarquica de un programa normalmente se expresa utilizando reglas recursivas. Por ejemplo, se pueden dar las siguientes reglas como parte de la definicion de expresiones:  Las reglas 1 y 2 son reglas basicas (no recursivas), en tanto que la regla 3 define expresiones en funcion de operadores aplicados a otras expresiones.  La division entre analisis lexico y analisis sintactico es algo arbitraria. Un factor para determinar la division es si una construccion del lenguaje fuente es inherentemente recursiva o no. Las construcciones lexicas no requieren recursion, mientras que las construcciones sintacticas suelen requerirla. No se requiere recursion para reconocer los identificadores, que suelen ser cadenas de letras y digitos que comienzan con una letra. Normalmente, se reconocen los identificadores por el simple examen del flujo de entrada, esperando hasta encontrar un caracter que no sea ni letra ni digito, y agrupando despues todas las letras y digitos encontrados hasta ese punto en un componente lexico llamado identificador. Por otra parte, esta clase de analisis no es suficientemente poderoso para analizar expresiones o proposiciones. Por ejemplo, no podemos emparejar de manera apropiada los parentesis de las expresiones, o las palabras begin y end en proposiciones sin imponer alguna clase de estructura jerarquica o de anidamiento a la entrada.  La fase de analisis semantico revisa el programa fuente para tratar de encontrar errores semanticos y reune la informacion sobre los tipos para la fase posterior de generacion de codigo. En ella se utiliza la estructura jerarquica determinada por la fase de analisis sintactico para identificar los operadores y operandos de expresiones y proposiciones.  Un componente importante del analisis semantico es la verificacion de tipos. Aqui, el compilador verifica si cada operador tiene operandos permitidos por la especificacion del lenguaje fuente. Por ejemplo, las definiciones de muchos lenguajes de programacion requieren que el compilador indique un error cada vez que se use un numero real como indice de una matriz. Sin embargo, la especificacion del lenguaje puede imponer restricciones a los operandos, por ejemplo, cuando un operador aritmetico binario se aplica a un numero entero y a un numero real.\u200b Revisa que los arreglos tengan definido el tama\u00f1o correcto.  Consiste en generar el codigo objeto equivalente al programa fuente. Solo se generara codigo objeto cuando el programa fuente esta libre de errores de analisis.  El resultado puede ser lenguaje de maquina o codigo ensamblador.\u200b Las posiciones de memoria se seleccionan para cada una de las variables usadas por el programa. Despues, cada una de las instrucciones intermedias se traduce a una secuencia de instrucciones de maquina que ejecuta la misma tarea. Un aspecto decisivo es la asignacion de variables a registros.  Despues de los analisis sintactico y semantico, algunos compiladores generan una representacion intermedia explicita del programa fuente. Esta representacion intermedia debe tener dos propiedades importantes: debe ser facil de producir y facil de traducir al programa objeto.\u200b  La representacion intermedia puede tener diversas formas. Existe una forma intermedia llamada \u00abcodigo de tres direcciones\u00bb, similar al lenguaje ensamblador, en la que cada instruccion lleva a cabo una sola operacion. El codigo de tres direcciones consiste en una secuencia de instrucciones, cada una de las cuales tiene como maximo tres operandos. Esta representacion intermedia tiene varias propiedades:  La fase de optimizacion de codigo consiste en mejorar el codigo intermedio, de modo que resulte un codigo maquina mas rapido de ejecutar. Esta fase de la etapa de sintesis es posible sobre todo si el traductor es un compilador (dificilmente un interprete puede optimizar el codigo objeto). Hay mucha variacion en la cantidad de optimizacion de codigo que ejecutan los distintos compiladores. En los que hacen mucha optimizacion, llamados \u00abcompiladores optimizadores\u00bb, una parte significativa del tiempo del compilador se ocupa en esta fase. Sin embargo, hay optimizaciones sencillas que mejoran sensiblemente el tiempo de ejecucion del programa objeto sin retardar demasiado la compilacion.\u200b  La interaccion entre los algoritmos utilizados por las fases del compilador y las estructuras de datos que soportan estas fases es, naturalmente, muy fuerte. El escritor del compilador se esfuerza por implementar estos algoritmos de una manera tan eficaz como sea posible, sin aumentar demasiado la complejidad. De manera ideal, un compilador deberia poder compilar un programa en un tiempo proporcional al tama\u00f1o del mismo.  Cuando un analizador lexico reune los caracteres en un token, generalmente representa el token de manera simbolica, es decir, como un valor de un tipo de datos enumerado que representa el conjunto de tokens del lenguaje fuente. En ocasiones tambien es necesario mantener la cadena de caracteres misma u otra informacion derivada de ella, tal como el nombre asociado con un token identificador o el valor de un token de numero.  En la mayoria de los lenguajes el analizador lexico solo necesita generar un token a la vez. En este caso se puede utilizar una variable global simple para mantener la informacion del token. En otros casos (cuyo ejemplo mas notable es FORTRAN), puede ser necesario un arreglo (o vector) de tokenes.  Si el analizador sintactico genera un arbol sintactico, por lo regular se construye como una estructura estandar basada en un puntero que se asigna de manera dinamica a medida que se efectua el analisis sintactico. El arbol entero puede entonces conservarse como una variable simple que apunta al nodo raiz. Cada nodo en la estructura es un registro cuyos campos representan la informacion recolectada tanto por el analizador sintactico como, posteriormente, por el analizador semantico. Por ejemplo, el tipo de datos de una expresion puede conservarse como un campo en el nodo del arbol sintactico para la expresion.  En ocasiones, para ahorrar espacio, estos campos se asignan de manera dinamica, o se almacenan en otras estructuras de datos, tales como la tabla de simbolos, que permiten una asignacion y desasignacion selectivas. En realidad, cada nodo del arbol sintactico por si mismo puede requerir de atributos diferentes para ser almacenado, de acuerdo con la clase de estructura del lenguaje que represente. En este caso, cada nodo en el arbol sintactico puede estar representado por un registro variable, con cada clase de nodo conteniendo solamente la informacion necesaria para ese caso.  Esta estructura de datos mantiene la informacion asociada con los identificadores: funciones, variables, constantes y tipos de datos. La tabla de simbolos interactua con casi todas las fases del compilador: el analizador lexico, el analizador sintactico o el analizador semantico pueden introducir identificadores dentro de la tabla; el analizador semantico agregara tipos de datos y otra informacion; y las fases de optimizacion y generacion de codigo utilizaran la informacion proporcionada por la tabla de simbolos para efectuar selecciones apropiadas de codigo objeto.  Puesto que la tabla de simbolos tendra solicitudes de acceso con tanta frecuencia, las operaciones de insercion, eliminacion y acceso necesitan ser eficientes, preferiblemente operaciones de tiempo constante. Una estructura de datos estandar para este proposito es la tabla de dispersion o de calculo de direccion, aunque tambien se pueden utilizar diversas estructuras de arbol. En ocasiones se utilizan varias tablas y se mantienen en una lista o pila.  La busqueda y la insercion rapida son esenciales tambien para la tabla de literales, la cual almacena constantes y cadenas utilizadas en el programa. Sin embargo, una tabla de literales necesita impedir las eliminaciones porque sus datos se aplican globalmente al programa y una constante o cadena aparecera solo una vez en esta tabla. La tabla de literales es importante en la reduccion del tama\u00f1o de un programa en la memoria al permitir la reutilizacion de constantes y cadenas. Tambien es necesaria para que el generador de codigo construya direcciones simbolicas para las literales y para introducir definiciones de datos en el archivo de codigo objeto.  De acuerdo con la clase de codigo intermedio (por ejemplo, codigo de tres direcciones o codigo P) y de las clases de optimizaciones realizadas, este codigo puede conservarse como un arreglo de cadenas de texto, un archivo de texto temporal o bien una lista de estructuras ligadas. En los compiladores que realizan optimizaciones complejas debe ponerse particular atencion a la seleccion de representaciones que permitan una facil reorganizacion.  La fase de optimizacion de codigo trata de mejorar el codigo intermedio de modo que resulte un codigo de maquina mas rapido de ejecutar. Algunas optimizaciones son triviales. Por ejemplo, un algoritmo natural genera el codigo intermedio (2) utilizando una instruccion para cada operador de la representacion del arbol despues del analisis semantico, aunque hay una forma mejor de realizar los mismos calculos usando las dos instrucciones  Este sencillo algoritmo no tiene nada de malo, puesto que el problema se puede solucionar en la fase de optimizacion de codigo. Esto es, el compilador puede deducir que la conversion de 60 de entero a real se puede hacer de una vez por todas en el momento de la compilacion, de modo que la operacion \"entreal( )\" se puede eliminar. Ademas, temp3 se usa solo una vez, para transmitir su valor a id1. Entonces resulta seguro sustituir a id1 por temp3, a partir de lo cual la ultima proposicion de (2) no se necesita y se obtiene el codigo de (3).  Hay muchas variaciones en la cantidad de optimizacion de codigo que ejecutan los distintos compiladores. En lo que hacen mucha optimizacion llamados \u00abcompiladores optimizadores\u00bb, una parte significativa del tiempo del compilador se ocupa en esta fase. Sin embargo, hay optimizaciones sencillas que mejoran sensiblemente el tiempo de ejecucion del programa objeto sin retardar demasiado la compilacion.  Al principio las computadoras no tenian la suficiente memoria para guardar un programa completo durante la compilacion. Este problema se resolvio mediante el uso de archivos temporales para mantener los productos de los pasos intermedios durante la traduccion o bien al compilar \u00abal vuelo\u00bb, es decir, manteniendo solo la informacion suficiente de las partes anteriores del programa fuente que permita proceder a la traduccion.  Las limitaciones de memoria son ahora un problema mucho menor, y es posible requerir que una unidad de compilacion entera se mantenga en memoria, en especial si se dispone de la compilacion por separado en el lenguaje. Con todo, los compiladores ocasionalmente encuentran util generar archivos intermedios durante alguna de las etapas del procesamiento. Algo tipico de estos es la necesidad de direcciones de correccion hacia atras durante la generacion de codigo. ","snippet":"En informatica, un compilador es un programa que traduce codigo escrito en un lenguaje de programacion (llamado fuente) a otro lenguaje (conocido como objeto).\u200b En este tipo de traductor el lenguaje f","enlaces_salientes":["Compilador","Compilador","Compilador","Recopilaci%C3%B3n","Inform%C3%A1tica","Programa_inform%C3%A1tico","Lenguaje_de_programaci%C3%B3n","C%C3%B3digo_fuente","C%C3%B3digo_objeto","Lenguaje_de_alto_nivel","Lenguaje_de_bajo_nivel","Lenguaje_ensamblador","Lenguaje_de_m%C3%A1quina","An%C3%A1lisis_de_algoritmos","Lenguaje_formal","Analizador_l%C3%A9xico","Analizador_sint%C3%A1ctico","S%C3%ADntesis","C%C3%B3digo_objeto","Compilador_optimizador","Teor%C3%ADa_de_la_complejidad_computacional","Complejidad_de_Kolmog%C3%B3rov","C%C3%B3digo_fuente","Tabla_de_s%C3%ADmbolos_(compilador)","C%C3%B3digo_m%C3%A1quina","Lenguajes_de_programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n","C%C3%B3digo_m%C3%A1quina","Historia_de_la_construcci%C3%B3n_de_los_compiladores","Konrad_Zuse","Z1","ENIAC","EDVAC","Lenguaje_m%C3%A1quina","Lenguaje_ensamblador","Mnem%C3%B3nico","Grace_Hopper","John_Backus","FORTRAN","Int%C3%A9rprete_(inform%C3%A1tica)","Compilador_cruzado","Compilador_optimizador","Compilaci%C3%B3n_en_tiempo_de_ejecuci%C3%B3n","Int%C3%A9rprete_(inform%C3%A1tica)","Inform%C3%A1tica","Lenguaje_m%C3%A1quina","Ensamblador","Int%C3%A9rprete_(inform%C3%A1tica)","Analizador_sint%C3%A1ctico","Gram%C3%A1tica_formal","Preprocesador","Ejecutable","Microsoft_Windows","DOS","Lenguaje_de_programaci%C3%B3n","Enlazador","C%C3%B3digo_objeto","C%C3%B3digo_m%C3%A1quina","Unix","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Lenguaje_ensamblador","Ejecutable","Analizador_l%C3%A9xico","Token_(programaci%C3%B3n)","Palabra_clave","Operador","Aut%C3%B3mata_finito","Expresi%C3%B3n_regular","Analizador_sint%C3%A1ctico","Recursividad","Identificador","N%C3%BAmero_real","Matriz_(programaci%C3%B3n)","C%C3%B3digo_objeto","Registro_(hardware)","C%C3%B3digo_de_tres_direcciones","Lenguaje_ensamblador","Compilador_optimizador","Int%C3%A9rprete_(inform%C3%A1tica)","Estructura_de_datos","Algoritmo","Token","Cadena_de_caracteres","FORTRAN","Vector_(programaci%C3%B3n)","Puntero_(programaci%C3%B3n)","Nodo_(inform%C3%A1tica)","Funci%C3%B3n_(programaci%C3%B3n)","Variable_(programaci%C3%B3n)","Constante_(programaci%C3%B3n)","Tipo_de_dato","Lista_(estructura_de_datos)","Pila_(estructura_de_datos)","Generador_de_c%C3%B3digo","BlueJ","Lenguaje_de_programaci%C3%B3n","Lenguaje_ensamblador","Ensamblador","Desensamblador","Decompilador","Int%C3%A9rprete_(inform%C3%A1tica)","Depurador","Lenguaje_de_alto_nivel","Lenguaje_de_bajo_nivel","Lenguaje_de_m%C3%A1quina","Historia_de_la_construcci%C3%B3n_de_los_compiladores","Principles_of_Compiler_Design","ISBN","ISBN","ISBN","Digital_object_identifier","ISBN","Digital_object_identifier","ISBN","ISBN","OCLC","ISBN","OCLC","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Espa%C3%B1a","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"C%C3%B3digo_objeto","titulo":"Codigo objeto","contenido":"En programacion, se llama codigo objeto al codigo que resulta de la compilacion del codigo fuente.\u200b Puede ser en lenguaje maquina o bytecode, y puede distribuirse en varios archivos que corresponden a cada codigo fuente compilado. Luego un enlazador  (linker) se encarga de juntar todos los archivos de codigo objeto para obtener el programa ejecutable. Codigo objeto: Conjunto de instrucciones y datos escritos en un lenguaje que entiende el ordenador directamente: binario o codigo maquina. Provienen de la traduccion de cierto codigo fuente, es un fragmento del programa final y es especifico de la plataforma de ejecucion.  Consiste en lenguaje maquina o bytecode y se distribuye en varios archivos que corresponden a cada codigo fuente compilado. Para obtener un programa ejecutable se han de enlazar todos los archivos de codigo objeto con un programa llamado enlazador (linker).  Un claro ejemplo de lenguaje de programacion que usa codigo objeto en sus bibliotecas es Pascal. Esto le permite aumentar la velocidad de compilacion de los programas y reducir su tama\u00f1o (ya que cada biblioteca objeto puede ser comprimida), tambien permite a programadores compartir sus bibliotecas y funciones sin tener la necesidad de liberar su codigo fuente original. Incluso puede permitir a distintos lenguajes de programacion compartir funciones sin necesidad de tener que reescribir el codigo plano a sus respectivas sintaxis.  Los archivos de codigo objeto pueden ser muy utiles en muchas situaciones y que nos pueden facilitar el trabajo diario, sin embargo consigo traen problemas que pueden generar errores muy dificiles de corregir, por ejemplo cuando un objeto importa funciones de otro archivo de codigo objeto que ha sido modificado, el intento de la biblioteca o el programa que importo tal biblioteca de ejecutar el codigo con parametros incorrectos o inexistentes puede generar un error que generalmente el compilador no detecta, ya que el codigo objeto no es verificado, unicamente enlazado. Este tipo de error se puede solucionar reescribiendo el codigo de manera correcta y re compilarlo a codigo objeto.   ","snippet":"En programacion, se llama codigo objeto al codigo que resulta de la compilacion del codigo fuente.\u200b Puede ser en lenguaje maquina o bytecode, y puede distribuirse en varios archivos que corresponden a","enlaces_salientes":["C%C3%B3digo_objeto","C%C3%B3digo_objeto","C%C3%B3digo_objeto","Programaci%C3%B3n","Compilaci%C3%B3n","C%C3%B3digo_fuente","Lenguaje_m%C3%A1quina","Bytecode","Ejecutable","Enlazador","Pascal_(lenguaje_de_programaci%C3%B3n)","Wikcionario","Control_de_autoridades"]}
{"url":"Aplicaci%C3%B3n_web","titulo":"Aplicacion web","contenido":"En la ingenieria de software se denomina aplicacion web o software web a aquella herramienta que los usuarios pueden utilizar accediendo a un servidor web a traves de internet o de una intranet mediante un navegador. En otras palabras, es un programa que se codifica en un lenguaje interpretable por los navegadores web en la que se confia la ejecucion al navegador.  Cuando hablamos de software web nos referimos a aplicaciones que se instalan en servidores (propios o de alguna empresa que provea servicios de hosting), ordenadores dedicados a proveer servicios, realizar tareas, ante peticiones de otros ordenadores. Estas aplicaciones web o softwares web son desarrollados por programadores que utilizan entornos de programacion Fontend y Backend.  En este caso, los datos y la logica de negocio quedan centralizados en el propio servidor y los usuarios podran acceder a ellos por medio de sus propios navegadores web.  Las aplicaciones web son populares debido a lo practico del navegador web como cliente ligero, a la independencia del sistema operativo, asi como a la facilidad para actualizar y mantener aplicaciones web sin distribuir e instalar software a miles de usuarios potenciales. Existen aplicaciones como los correos web, wikis, blogs, tiendas en linea y la propia Wikipedia que son ejemplos bastante conocidos de aplicaciones web.  Es importante mencionar que una pagina web puede contener elementos que permiten una comunicacion activa entre el usuario y la informacion. Esto permite que el usuario acceda a los datos de modo interactivo, gracias a que la pagina respondera a cada una de sus acciones, como por ejemplo rellenar y enviar formularios, participar en juegos diversos y acceder a gestores de base de datos de todo tipo.  En los primeros tiempos de la computacion cliente-servidor, cada aplicacion tenia su propio programa cliente que servia como interfaz de usuario que tenia que ser instalado por separado en cada computadora personal de cada usuario. El cliente realizaba peticiones a otro programa \u2014el servidor\u2014 que le daba respuesta. Una mejora en el servidor, como parte de la aplicacion, requeria normalmente una mejora de los clientes instalados en cada computadora personal, a\u00f1adiendo un coste de soporte tecnico y disminuyendo la productividad.  A diferencia de lo anterior, las aplicaciones web generan dinamicamente una serie de paginas en un formato estandar, como HTML o XHTML, soportados por los navegadores web comunes. Se utilizan lenguajes interpretados en el lado del cliente, directamente o a traves de plugins tales como JavaScript, Java, Flash, etc., para a\u00f1adir elementos dinamicos a la interfaz de usuario. Generalmente cada pagina web en particular se envia al cliente como un documento estatico, pero la secuencia de paginas ofrece al usuario una experiencia interactiva. Durante la sesion, el navegador web interpreta y muestra en pantalla las paginas, actuando como cliente para cualquier aplicacion web.  Aunque existen muchas variaciones posibles, una aplicacion web esta normalmente estructurada como una aplicacion de tres-capas. En su forma mas comun, el navegador web ofrece la primera capa, interpretando el codigo. El servidor que ofrece este codigo y toda la informacion es la segunda capa. Por ultimo, una base de datos constituye la tercera y ultima capa.  El navegador web manda peticiones a la capa intermedia, la cual ofrece servicios valiendose de consultas y actualizaciones a la base de datos, y, a su vez, proporciona una interfaz de usuario.  Son muy utilizados lenguajes o arquitecturas que no son propiamente lenguajes de programacion, como HTML o XML. Se utilizan para servir los datos adecuados a las necesidades del usuario, en funcion de como hayan sido definidos por el due\u00f1o de la aplicacion.  Los desarrolladores web generalmente utilizan lenguajes interpretados (scripts) en el lado del cliente para a\u00f1adir mas funcionalidades, especialmente para ofrecer una experiencia interactiva que no requiera recargar la pagina cada vez (lo que suele resultar molesto a los usuarios). Se han desarrollado tecnologias para coordinar estos lenguajes con las tecnologias en el lado del servidor. Por ejemplo, AJAX es una tecnica de desarrollo web que usa una combinacion de varias tecnologias.  Existen numerosos lenguajes de programacion empleados para el desarrollo de aplicaciones web en el servidor, entre los que destacan:  Los datos se almacenan en alguna base de datos estandar.  Una ventaja significativa es que las aplicaciones web deberian funcionar igual independientemente de la version del sistema operativo instalado en el cliente. En vez de crear clientes para Windows, Mac OS X, GNU/Linux y otros sistemas operativos, la aplicacion web se escribe una vez y se ejecuta igual en todas partes. Sin embargo, hay aplicaciones inconsistentes escritas con HTML, CSS, DOM y otras especificaciones estandar para navegadores web que pueden causar problemas en el desarrollo y soporte de estas aplicaciones, principalmente debido a la falta de adhesion de los navegadores a dichos estandares web (especialmente versiones de Internet Explorer anteriores a la 7). Adicionalmente, la posibilidad de los usuarios de personalizar muchas de las caracteristicas de la interfaz (tama\u00f1o y color de fuentes, tipos de fuentes, inhabilitar Javascript) puede interferir con la consistencia de la aplicacion web.  Hasta la popularizacion de HTML5, otra opcion era utilizar Adobe Flash Player o los applets de Java para desarrollar parte o toda la interfaz de usuario. Como casi todos los navegadores incluian soporte para estas tecnologias (usualmente por medio de complementos), las aplicaciones basadas en Flash o Java podian ser implementadas con aproximadamente la misma facilidad.  Las aplicaciones web se ejecutan nativamente desde el navegador, pero existen algunas aplicaciones que funcionan desde el navegador y, ademas, requieren la instalacion de un programa en la computadora para poder utilizarse. Estas aplicaciones se denominan aplicaciones de internet enriquecidas. El motivo de usar este software adicional es que habia muchas funcionalidades que los navegadores no podian ofrecer, y estas tecnologias enriquecian las aplicaciones web.  Una estrategia que esta emergiendo para las empresas proveedoras de software consiste en proveer acceso via web a la aplicacion. Para aquellas previamente distribuidas, como los programas de escritorio, se puede optar por desarrollar una aplicacion totalmente nueva o simplemente por adaptar la aplicacion para ser usada con una interfaz web. Estos ultimos programas permiten al usuario pagar una cuota mensual o anual para usar la aplicacion, sin necesidad de instalarla en la computadora del usuario. A esta estrategia de uso se la denomina Software como servicio y a las compa\u00f1ias desarrolladoras se les denomina proveedores de servicios de aplicacion (ASP), un modelo de negocio que esta atrayendo la atencion de la industria del software.  \u00b7     2. Niebla Informatica (s.f). Fecha de Consulta: 16 de mayo de 2022. Disponible en: https://www.niebla.com/blog/software-web-o-software-de-escritorio","snippet":"En la ingenieria de software se denomina aplicacion web o software web a aquella herramienta que los usuarios pueden utilizar accediendo a un servidor web a traves de internet o de una intranet median","enlaces_salientes":["Aplicaci%C3%B3n_web","Aplicaci%C3%B3n_web","Aplicaci%C3%B3n_web","Horde_(software)","Groupware","Ingenier%C3%ADa_de_software","Aplicaci%C3%B3n_inform%C3%A1tica","Servidor_web","Internet","Intranet","Navegador_web","Navegador_web","Cliente_ligero","Webmail","Blog","Tienda_en_l%C3%ADnea","Cliente-servidor","Computadora_personal","HTML","XHTML","Lenguaje_interpretado","Plugin","JavaScript","HTML","XML","Lenguaje_interpretado","AJAX","HTML","CSS","JavaScript","PHP","Lenguaje_de_programaci%C3%B3n_Java","Java_Servlet","Java_Server_Pages","JavaScript","Perl","Ruby","Python","Node.js","C_Sharp","Visual_Basic","Active_Server_Pages","ASP.NET","Base_de_datos","Windows","Mac_OS_X","GNU/Linux","HTML","Hojas_de_estilo_en_cascada","Document_Object_Model","Internet_Explorer","HTML5","Adobe","Flash_Player","Applets","Lenguaje_de_programaci%C3%B3n_Java","Complemento_(inform%C3%A1tica)","Rich_Internet_application","SaaS","Application_Service_Provider","Malware","Hojas_de_estilo_en_cascada","Rich_Internet_Applications","DHTML","LAMP","Servicio_web","World_Wide_Web_Consortium","AJAX","JSON","Dojo_toolkit","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Dialecto","titulo":"Dialecto","contenido":"En linguistica, la palabra dialecto geografico[n 1]\u200b, geolecto o variedad diatopica hace referencia a una de las posibles variedades de una lengua;[n 2]\u200b frecuentemente se usa el termino dialecto para referirse a una variante geografica de una lengua asociada con una determinada zona (de ahi que tambien se use como termino sinonimo la palabra geolecto o, en terminologia de Eugenio Coseriu, las expresiones variedad sintopica y norma espacial).[cita\u00a0requerida] El numero de hablantes y el tama\u00f1o de la zona dialectal pueden ser variables y un dialecto puede estar, a su vez, dividido en subdialectos (o hablas).[cita\u00a0requerida]  Para el academico y profesor visitante en la Universidad de California, Manuel Alvar, considerado uno de los expertos en \u00abgeografia linguistica\u00bb,\u200b alejandose de asociacion de \u00abhechos politicos con hechos linguisticos\u00bb busca criterios cientificos\u200b por los cuales considera, tras una larga argumentacion, que, a este respecto, es procedente definir varios conceptos que no deben confundirse. A saber:\u200b  Independientemente de la antiguedad del termino, su uso linguistico se inicia a finales del siglo\u00a0XIX cuando la linguistica historica dio paso a la aparicion de la dialectologia como disciplina linguistica dedicada especificamente a las variedades geograficas de las lenguas.  Los dialectos han de ser entendidos como variantes geograficas condicionadas historicamente, esto es, la historia de los contactos linguisticos es el factor que determina la diferenciacion dialectal. Como causas de la variacion dialectal se se\u00f1alan, habitualmente, las siguientes:  Con todo, la delimitacion del concepto de dialecto es un proceso delicado en linguistica, porque exige una adecuada caracterizacion de la lengua del territorio, la precision de su filiacion historica y unos rigurosos analisis sociolinguisticos y estudios de actitudes linguisticas por parte de los hablantes.[n 3]\u200b Ademas, obliga a manejar tambien un determinado concepto de lengua, respecto del que se define el primero, algo que no esta tampoco exento de dificultades.  Como elemento a\u00f1adido a la hora de dificultar la precision conceptual de ambos terminos, historicamente, la politica linguistica de determinadas comunidades ha podido usar la palabra dialecto con un valor peyorativo, con el objeto de privilegiar como vehiculo de expresion oficial a una determinada lengua en perjuicio de otra u otras a las que, como forma de descalificacion, se les ha aplicado dicho termino; en este otro sentido de la palabra, dialecto haria referencia a un sistema linguistico que no alcanza la categoria de lengua.\u200b  Al igual que ocurre con el caso de lengua, las definiciones del termino dialecto no son muchas veces coincidentes entre los especialistas.  Con todo, se asume como principio basico que, linguisticamente, no hay justificacion para una distincion entre las realidades a las que ambos hacen referencia; esto es, tanto un dialecto como una lengua son \u00ablenguas\u00bb, en el sentido de sistemas de comunicacion verbales,\u200b por lo que la explicacion y justificacion de ambos conceptos debe hacerse teniendo en cuenta criterios extralinguisticos. Un dialecto, por tanto, seria una variedad regional derivada de otra lengua matriz. El castellano, gallego o catalan serian, por tanto, dialectos del latin independientemente de su categorizacion como lenguas. El andaluz o murciano serian dialectos meridionales del castellano, en cuanto derivan y son variantes linguisticas del idioma castellano sin llegar a tener el rango necesario para considerarse lenguas independientes del espa\u00f1ol.  Manuel Alvar, con todo, reconoce como posible esta acepcion de dialecto, que seria la de sistema linguistico que no alcanza la categoria de lengua; a tal efecto, previamente identifica las lenguas con sistemas bien diferenciados y nivelados en su norma de su uso, y que poseen una tradicion literaria relevante. Por lo demas, por debajo del dialecto estarian conceptos mas especificos como habla regional (peculiaridades expresivas de una zona sin la coherencia del dialecto) y habla local (un conjunto de rasgos poco diferenciados pero caracteristicos de una muy concreta zona geografica).  El estudio de la evolucion de las lenguas a lo largo del tiempo, conocido como linguistica historica, permitio descubrir que las lenguas modernas emparentadas provienen, a su vez, de otras lenguas que tambien se habian desarrollado a partir de la fragmentacion de alguna lengua mas antigua.  En este sentido, cualquier lengua no deja de ser, en si misma, un dialecto, en tanto que todas las lenguas provienen de otras, de las que han sido o son variantes en una geografia determinada. Esta otra acepcion de dialecto se considera, en ocasiones tan importante como la de \u00abvariante geografica\u00bb:  Mas especificamente una lengua historica, documentada durante milenios en general consiste en diferentes estadios historicos, que linguisticamente difieren entre si en fonologia, gramatica y lexico. Cada uno de esos estadios se denomina variedad diacronica de la lengua.  La historia de las lenguas explica tambien que  Este devenir historico es, la mayor parte de las veces, el responsable de la ambiguedad con que se suelen utilizar, al menos popularmente, los terminos de lengua y dialecto: hay casos en que un dialecto en origen termina por ser considerado lengua por una decision politico-social (tal podria ser el caso del valenciano) y, de igual modo, una lengua en origen (el gallego, por ejemplo), estuvo durante siglos (los llamados Seculos escuros) estigmatizada con su consideracion como dialecto.  En este sentido, el aforismo atribuido a Max Weinreich que dice que \u00abUna lengua es un dialecto con un ejercito y una marina\u00bb,\u200b seria un reflejo sintetico de esa apreciacion.  La endeblez cientifica de una distincion basada en aspectos de ese tipo se comprueba si se piensa en que las fronteras politicas no delimitan las lineas del uso de la lengua ni de su comprensibilidad.  El ingles y el serbocroata son un buen ejemplo de esto. Estos idiomas tienen tres variantes principales consideradas como estandares: el ingles de Reino Unido, Estados Unidos y Australia (otras variantes, como el ingles de Belice, Nigeria e India son llamadas \u00abvariantes indigenas\u00bb). El serbio y el croata por otra, junto con otras variedades no tan habladas, son mutuamente inteligibles. Por razones politicas, analizar estas variedades como \u00ablenguas\u00bb o \u00abdialectos\u00bb produce resultados inconsistentes: el ingles britanico y el ingles americano, hablados por grandes aliados politicos y militares, son considerados casi universalmente como dialectos del ingles. Sin embargo, los idiomas estandar de Serbia y Croacia, cuyas diferencias son comparables en numero con las diferencias entre el ingles britanico y el ingles americano, son considerados por muchos linguistas de la region como idiomas diferenciados, aduciendo entre otras razones que usan alfabetos distintos; pero en buena parte se debe a que la relacion entre ambos paises es conflictiva, teniendo en la religion (catolica entre los croatas, ortodoxa entre los serbios) un signo de identidad diferenciada.  Existen discrepancias sobre si el idioma macedonio es un idioma o un dialecto, hay quien lo considera mutuamente inteligible con el bulgaro. Es considerado un dialecto del bulgaro principalmente en Bulgaria y un idioma independiente principalmente en la propia Macedonia del Norte.  En el Libano, el partido politico Guardianes de los Cedros, que se opone a los lazos que unen el pais con el mundo arabe, se esta movilizando para que el \u00ablibanes\u00bb sea considerado como una lengua distinta del arabe, y no un simple dialecto, e incluso pretende reemplazar la escritura arabe por una resurreccion del antiguo alfabeto fenicio.  En Espa\u00f1a, algunas organizaciones valencianas y baleares consideran sus respectivas lenguas como diferentes del catalan, a pesar de que existe un reconocimiento institucional y academico con relacion a que tanto el valenciano como el balear son variedades del occitanorromance. El caracter altamente politico de estas discusiones no es nuevo:  A lo largo de la historia, han surgido casos de alteraciones de variedades del habla por razones politicas. En el siglo\u00a0XIX, por ejemplo, los nacionalistas noruegos crearon el nynorsk a partir de un conjunto de dialectos seleccionados en el oeste del pais y menos influidos que los dialectos orientales por el danes y el sueco durante la ocupacion danesa y sueca.  Cuando la disputa se da entre dialectos del mismo idioma, surge el concepto de dialecto de prestigio (o variedad de prestigio), que es la que se asocia en una comunidad que tenga mas de un dialecto, con aquel empleado por grupos de hablantes que ocupan una posicion socialmente prestigiosa (elites economicas, culturales, sociales). En consecuencia, de esta condicion social, el dialecto de prestigio suele emplearse en las situaciones formales, como la diplomacia, como tambien es, por su asociacion con las elites, el dialecto que mas influencia ejerce en la definicion de la lengua estandar. Dicho dialecto de prestigio suele basarse o estar influido por producciones escritas reconocidas dentro de la comunidad, como es el caso del Coran para el arabe o la traduccion de la Biblia de Lutero para el aleman.  En contraposicion a este dialecto de prestigio existe el llamado dialecto vernaculo, que es el lenguaje \u00abhablado en casa\u00bb. Segun la impronta de la vida publica en la vida privada en una sociedad, este dialecto vernaculo sera mas cercano o lejano al dialecto estandar. En los paises arabes, por lo general, el dialecto estandar no es hablado por casi nadie en el ambiente domestico. En los paises nordicos el vernaculo y el estandar son casi identicos en las capitales (Oslo o Estocolmo) y muy distintos en la provincia (en Troms\u00f8 o Malmo).  A veces los dialectos hablados por diferentes estratos sociales, puede diferir notoriamente, y en ese caso se usa el termino sociolecto o variedad diastratica, para nombrar a cada uno de los dialectos empleados por diferentes clases o estratos sociales.  Esta vaguedad conceptual, por lo menos en un ambito no especializado, tiene tambien parte de su origen en que, etimologicamente, la palabra dialecto no mantiene vinculo alguno con cuestiones geograficas:  La explicacion historica, que en si misma refleja la dificultad del problema terminologico, es que la lengua griega de la antiguedad era, en realidad, un grupo de variedades locales distintas (jonico, dorico y atico) que evolucionaron de forma divergente desde una misma lengua comun originaria, llegando a tener cada una de ellas su propia tradicion literaria y sus propios contextos culturales de uso: el jonico para la historiografia, el dorico para las obras corales y liricas, y el atico para la tragedia. Con el tiempo, el griego de la gran metropolis, Atenas, se convirtio en la koine o lengua \u00abcomun\u00bb, esto es, en la norma de la lengua hablada, como una sintesis de las distintas variedades que terminaron por converger en el dialecto del centro administrativo y cultural mas importante. Asi, pues, esa situacion se convirtio en un modelo para la ambigua utilizacion de los terminos lengua y dialecto: lengua como la norma linguistica o grupo de normas relacionadas y dialecto como cada una de esas normas de forma independiente.\u200b  Consecuentemente, en la actualidad la palabra dialecto se puede encontrar aplicada a cualquier variedad de lengua. En frances, por ejemplo, se distingue entre dialecte y patois, el primero con el sentido de variedad regional asociada a una tradicion literaria y el segundo a aquella variedad de ese tipo, pero sin tradicion literaria, con un uso habitual de tipo peyorativo, esto es, con una valoracion inherente de inferioridad. Por lo demas, el frances estandar no se ve como dialecto del frances, cosa que si ocurre en ingles. No obstante, en esta lengua, los sentidos de la palabra dialecto se diversifican: dialect sirve tanto para referirse a las variedades locales del ingles, como para los distintos tipos de habla informal, de clase baja o rural. En otras ocasiones, incluso, puede referirse a una variedad no estandar o, a veces, subestandar, con valores de inferioridad. En este sentido, lengua y dialecto pueden ser casi intercambiables.\u200b  Este uso popular de los terminos cuenta tambien, a veces, con el refrendo del uso por parte de linguistas que, con el deseo de subrayar las relaciones entre todas las variedades de una lengua, utilizan el termino dialecto para referirse tanto a los dialectos geograficos o espaciales, como a los dialectos sociales u otros (los llamados sociolectos).[n 4]\u200b No obstante, las obras generales de dialectologia abordan exclusivamente el dialecto como variante geografica, siguiendo la opinion de Eugenio Coseriu y otros linguistas que reservan ese termino solo para esa variedad, al destacar la relevancia de las variedades geograficas de una lengua frente a otro tipo de variedades (sociales y comunicativas), por cuanto un dialecto asi entendido constituye un sistema linguistico completo (desde el punto de vista gramatical), frente a la parcialidad o asistematicidad de los niveles y registros de una lengua.\u200b  En todo caso, y aunque se ha llegado, incluso, a negar la legitimidad del concepto de dialecto por la dificultad de marcar las fronteras de uso, generalmente se considera que la vinculacion a una geografia determinada es un factor que permite diferenciar variedades dentro de una lengua, por lo que el termino dialecto es el que se suele usar en linguistica para tal concepto.  Simultaneo a este factor, el concepto de dialecto lleva aparejado un factor de \u00abconcienciacion\u00bb, en el sentido de que los hablantes suelen tener una percepcion mas o menos clara respecto de la variedad que usan; esta percepcion de los hablantes, unida a unas caracteristicas linguisticas determinadas, permite a la sociolinguistica identificar a los dialectos como realidades linguisticas distinguibles de otras. En consecuencia, es preciso recordar que  Por ultimo, en la lengua habitual el termino aparece muchas veces connotado con valores peyorativos.  Se trata, en cualquier caso, de rasgos extralinguisticos que pueden explicar la importancia social, cultural o politica que se le pueda conceder a los dialectos, pero no de rasgos que permitan poner en duda el caracter de sistemas linguisticos plenos de los mismos o que puedan sustituir la evidencia linguistica que los situe como variedad de otra lengua o no.  Dado que cualquier dialecto lo es siempre de una lengua, es necesario manejar algun tipo de criterio para adscribir los dialectos a las lenguas que les corresponden, algo que no siempre es facil. Historicamente, se han manejado los siguientes criterios para decidir si dos sistemas linguisticos son dialectos de la misma lengua:\u200b  El primero de estos criterios pretende tener una base linguistica objetiva, sin embargo, al ser la inteligibilidad una cuestion de grados no permite en todos los casos una clasificacion adecuada de los dialectos. Por el contrario, el segundo criterio es de tipo politico mas que linguistico, mientras que el tercero se refiere a factores culturales e historicos accidentales que no tienen por que reflejar criterios linguisticos.  Asi las cosas, no existen criterios cientificos universalmente aceptados para distinguir las \u00ablenguas\u00bb de los dialectos, aunque existen varios criterios que presentan en ocasiones resultados contradictorios.  La diferencia exacta es por tanto subjetiva y extralinguistica, dependiendo del marco contextual del usuario. En el uso informal se habla de dialectos y de lenguas de acuerdo con los contextos sociopoliticos. Algunas variedades de lenguaje son frecuentemente denominadas dialectos por alguna de estas razones:  El criterio de inteligibilidad mutua tampoco es una buena guia para predecir cuando una variedad sera calificada de dialecto o de lengua. Lo que comunmente se llama idioma chino tiene diversos dialectos principales, como el chino mandarin y el chino cantones, los cuales no son inteligibles entre si, pero aun asi se los califica de dialectos de la misma lengua; en este caso se aduce que el sistema de escritura es comun. Por el contrario, el sueco, el noruego y el danes son consideradas lenguas independientes y no dialectos, aun cuando sus hablantes se comunican entre si con poca dificultad. A esto hay que agregar que muchos idiomas nativos americanos no se consideran lenguas, sino dialectos, por una discriminacion tradicional, en que se considera lenguas a las formas europeas y dialectos a las americanas. Sin embargo, el nahuatl es una lengua, en tanto que el nahuatl de Cholula, el nahuatl del sur de Veracruz o el nahuatl del norte de Puebla son algunas de sus variantes dialectales. Esto mismo puede aplicarse a otras lenguas americanas como el quechua, el maya yucateco, el aymara o el otomi.  La sociolinguistica moderna considera que el estado de la lengua no esta solamente determinado por criterios linguisticos, sino que tambien es el resultado de un desarrollo historico y politico. El romanche fue reconocido como lengua al desarrollar su propia escritura, a pesar de ser muy cercano a los dialectos alpinos del lombardo. Un caso contrario es el del idioma chino, cuyas variantes son generalmente consideradas dialectos y no lenguas, a pesar de que los hablantes no puedan entenderse entre ellos, porque comparten una escritura comun. ","snippet":"En linguistica, la palabra dialecto geografico[n 1]\u200b, geolecto o variedad diatopica hace referencia a una de las posibles variedades de una lengua;[n 2]\u200b frecuentemente se usa el termino dialecto para","enlaces_salientes":["Dialecto","Dialecto","Dialecto","Dialecto_(programaci%C3%B3n)","Ling%C3%BC%C3%ADstica","Variedad_ling%C3%BC%C3%ADstica","Eugenio_Coseriu","Real_Academia_Espa%C3%B1ola","Universidad_de_California_en_Santa_B%C3%A1rbara","Manuel_Alvar","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Dialectolog%C3%ADa","Pol%C3%ADtica_ling%C3%BC%C3%ADstica","Manuel_Alvar","Ling%C3%BC%C3%ADstica_hist%C3%B3rica","Variedad_diacr%C3%B3nica","Idioma_valenciano","Aforismo","Max_Weinreich","Una_lengua_es_un_dialecto_con_un_ej%C3%A9rcito_y_una_marina","Idioma_ingl%C3%A9s","Idioma_serbocroata","Idioma_serbio","Idioma_croata","Serbia","Croacia","Iglesia_cat%C3%B3lica","Iglesia_ortodoxa","Idioma_macedonio","Idioma_b%C3%BAlgaro","Bulgaria","Macedonia_del_Norte","L%C3%ADbano","Guardianes_de_los_Cedros","Mundo_%C3%A1rabe","Idioma_%C3%A1rabe","Alfabeto_%C3%A1rabe","Alfabeto_fenicio","Espa%C3%B1a","Comunidad_Valenciana","Islas_Baleares","Idioma_catal%C3%A1n","Idioma_valenciano","Balear","Lenguas_occitanorromances","Noruega","Nynorsk","Idioma_dan%C3%A9s","Idioma_sueco","Dinamarca","Suecia","Dialecto_de_prestigio","Lengua_est%C3%A1ndar","Cor%C3%A1n","Idioma_%C3%A1rabe","Biblia_de_Lutero","Oslo","Estocolmo","Troms%C3%B8","Malm%C3%B6","Sociolecto","J%C3%B3nico_(dialecto)","D%C3%B3rico_(dialecto)","%C3%81tico_(dialecto)","Historiograf%C3%ADa","Tragedia","Atenas","Koin%C3%A9","Norma_ling%C3%BC%C3%ADstica","Idioma_franc%C3%A9s","Sociolecto","Dialectolog%C3%ADa","Inteligibilidad_mutua","Una_lengua_es_un_dialecto_con_un_ej%C3%A9rcito","Max_Weinreich","Inteligibilidad_mutua","Idioma_chino","Chino_mandar%C3%ADn","Chino_canton%C3%A9s","Idioma_sueco","Idioma_noruego","Idioma_dan%C3%A9s","Lenguas_ind%C3%ADgenas_de_Am%C3%A9rica","N%C3%A1huatl","Lenguas_quechuas","Maya_yucateco","Aymara","Idioma_otom%C3%AD","Socioling%C3%BC%C3%ADstica","Romanche","Idioma_chino","Cultismo","Idioma_griego","Lat%C3%ADn","Socioling%C3%BC%C3%ADstica","Charles_F._Hockett","Idiolecto","Ling%C3%BC%C3%ADstica_antropol%C3%B3gica","ISSN","Manuel_Alvar","ISSN","Digital_object_identifier","Manuel_Alvar","ISBN","OCLC","ISBN","OCLC","ISBN","OCLC","ISBN","OCLC","ISBN","OCLC","ISBN","OCLC","ISBN","OCLC","Wikcionario","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Lenguaje_espec%C3%ADfico_de_dominio","titulo":"Lenguaje especifico de dominio","contenido":"En desarrollo de software e ingenieria de dominio, un lenguaje especifico de dominio, o \"lenguaje especifico del dominio\", (en ingles domain-specific language, DSL) es un lenguaje de programacion o especificacion dedicado a resolver un problema en particular, representar un problema especifico y proveer una tecnica para solucionar una situacion particular. El concepto no es nuevo pero se ha vuelto mas popular debido al aumento del uso de modelaje especifico del dominio.\u200b  Ejemplos de lenguajes especificos del dominio incluyen, Logo para ni\u00f1os, Verilog y VHSIC, R y S para estadisticas, Mata para programacion matricial, Mathematica y Maxima para matematicas, formulas de hojas de calculo y macros, SQL para consultas a bases de datos relacionales, Yacc para crear parseadores, expresiones regulares para crear analisis lexico, Generic Eclipse Modeling System para crear lenguajes con el objetivo de diagramar, Csound un lenguaje para sintesis digital, y los lenguajes de entrada de GraphViz y GrGen, paquetes de software usados para graficar y reescribir graficas.  Lo opuesto es:  Crear un lenguaje especifico del dominio (con software que lo soporte) vale la pena cuando permite que un tipo particular de problemas o soluciones puedan ser expresadas mas claramente que con otros lenguajes existentes, y el tipo de problema en cuestion reaparece lo suficiente. La programacion orientada a lenguajes considera la creacion de lenguajes especificos para expresar problemas una parte estandar para el proceso de solucionar el problema.  En los DSL, la semantica del lenguaje esta muy cercana al dominio del problema para el cual se dise\u00f1a. Tienen un alto nivel de abstraccion al usuario, por tanto, estan dirigidos a expertos en el dominio.  Metamodelado es el analisis, dise\u00f1o y construccion de los metamodelos necesarios para cubrir un determinado tipo de problemas, asi como las reglas y restricciones aplicables.   Metamodelo: conjunto de conceptos del dominio a modelar (metaclases) y las relaciones entre ellos (metasociaciones).  Tendremos que elegir, segun el problema a resolver, cual es el formato de representacion mas adecuado para nuestro DSL. \u00bfCual es el tipo de problema que queremos modelar? \u00bfQuienes seran los usuarios del lenguaje?  Dos tipos de DSL:  Existen varios tipos de transformaciones:  El Eclipse Modeling Project centra la evolucion y promocion del desarrollo de tecnologias basadas en modelos dentro de la comunidad Eclipse, proveyendo un conjunto unificado de frameworks para el modelaje, herramientas e implementacion de estandares. ","snippet":"En desarrollo de software e ingenieria de dominio, un lenguaje especifico de dominio, o \"lenguaje especifico del dominio\", (en ingles domain-specific language, DSL) es un lenguaje de programacion o es","enlaces_salientes":["Lenguaje_espec%C3%ADfico_de_dominio","Lenguaje_espec%C3%ADfico_de_dominio","Lenguaje_espec%C3%ADfico_de_dominio","Desarrollo_de_software","Lenguaje_de_programaci%C3%B3n","Verilog","Very_High_Speed_Integrated_Circuit","Mathematica","SQL","Yacc","Parseador","Expresi%C3%B3n_regular","C_(lenguaje_de_programaci%C3%B3n)","Java_(lenguaje_de_programaci%C3%B3n)","UML","Metamodelado","Framework","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Common_Lisp","titulo":"Common Lisp","contenido":"Common Lisp es un [[lenguaje de programacion Common Lisp es un lenguaje de programacion que pertenece a la familia de lenguajes Lisp. Se encuentra descrito en el documento estandar ANSI INCITS 226-1994 (R2004) del ANSI, (antes X3.226-1994 (R1999)).\u200b Desarrollado para estandarizar las variantes divergentes del Lisp (aunque principalmente las variantes de MacLisp) que lo precedio, no es una implementacion sino una especificacion del lenguaje. Estan disponibles varias implementaciones del estandar de Common Lisp, incluyendo la de software libre y de codigo abierto y productos propietarios.  Common Lisp es un lenguaje multi paradigma de propositos generales. Soporta una combinacion de paradigmas de programacion como procedimental (imperativo), funcional, y orientada al objeto. Como un lenguaje de programacion dinamica, facilita el desarrollo de software de una manera evolutiva e incremental, con la compilacion iterativa en programas eficientes en tiempo de ejecucion.]] que pertenece a la familia de lenguajes Lisp. Se encuentra descrito en el documento estandar ANSI INCITS 226-1994 (R2004) del ANSI, (antes X3.226-1994 (R1999)).\u200b Desarrollado para estandarizar las variantes divergentes del Lisp (aunque principalmente las variantes de MacLisp) que lo precedio, no es una implementacion sino una especificacion del lenguaje. Estan disponibles varias implementaciones del estandar de Common Lisp, incluyendo la de software libre y de codigo abierto y productos propietarios.  Common Lisp es un lenguaje multi paradigma de propositos generales. Soporta una combinacion de paradigmas de programacion como procedimental (imperativo), funcional, y orientada al objeto. Como un lenguaje de programacion dinamica, facilita el desarrollo de software de una manera evolutiva e incremental, con la compilacion iterativa en programas eficientes en tiempo de ejecucion.  Common Lisp incluye al CLOS, un sistema de objetos que soporta multimetodos y combinaciones de metodos. Es extensible a traves de del MetaObject Protocol. Common Lisp es extensible usando las caracteristicas estandar tales como macros de Lisp (rearreglo del codigo en tiempo de compilacion logrado por el programa en si mismo) y macros de lectura (extension de la sintaxis para dar un significado especial a los caracteres reservados para los usuarios con este proposito).  == Sintaxis ==Common Lisp es un dialecto de Lisp; usa expresiones S para denotar tanto el codigo como la estructura de datos. Las funciones y la llamadas a macros son escritas como listas, con el nombre de la funcion primero, como en estos ejemplos:  Common Lisp es un dialecto de Lisp; usa expresiones S para denotar tanto el codigo como la estructura de datos. Las funciones y la llamadas a macros son escritas como listas, con el nombre de la funcion primero, como en estos ejemplos:  Common Lisp tiene muchos tipos de datos, por ejemplo: Integers, Ratios, Complex Numbers, Stings, Arrays, Vectors, Hash Tables, Funciones, Streams.  === Tipos escalares ===Common Lisp tiene muchos tipos de datos, por ejemplo: Integers, Ratios, Complex Numbers, Stings, Arrays, Vectors, Hash Tables, Funciones, Streams.  Los tipos numericos incluyen numeros enteros, cocientes, numeros de punto flotante, y numeros complejos.\u200b Common Lisp usa bignums para representar valores numericos de tama\u00f1o y precision arbitrarios. El tipo cociente representa fracciones exactamente, una facilidad no disponible en muchos lenguajes. Common Lisp fuerza automaticamente a los valores numericos entre estos tipos a medida que sean apropiados.  El tipo caracter de Common Lisp no se limita a los caracteres ASCII. La mayoria de las implementaciones modernas permiten los caracteres de Unicode.\u200b  El tipo simbolo es comun a los lenguajes Common Lisp, pero largamente desconocido fuera de ellos. Un simbolo es un unico, objeto de datos con nombre que tiene varias partes: nombre, valor, funcion, lista y paquete. De estos, la celda del valor y la celda de la funcion son los mas importantes. Los simbolos en Lisp son frecuente usados similarmente a los identificadores en otros lenguajes: para contener el valor de una variable; sin embargo, hay muchas otros usos. Normalmente, cuando un simbolo es evaluado, su valor es retornado. Algunos simbolos se evaluan a si mismos, por ejemplo todos los simbolos en un paquete de palabra clave son autoevaluados. Los valores boleano en Common Lisp son representados por los simbolos autoevaluantes T y NIL. Common Lisp tiene espacios de nombres para simbolos, llamados \"paquetes\u201d.  Los tipos de secuencia en Common Lisp incluye listas, vectores, vectores-bit, y strings. Hay muchas operaciones que pueden trabajar en cualquier tipo de secuencia.  Como en casi todos los otros dialectos Lisp, las listas en Common Lisp estan compuestas de conses, a veces llamados celdas cons o pares. Una celda cons es una estructura de datos con dos slots, llamados sus car y cdr. Una lista es bien formada una cadena enlazada de celdas cons. Cada car del cons refiere a un miembro de la lista (posiblemente otra lista). Cada cdr del cons refiere al cons siguiente -- a excepcion del ultimo cons, cuyo cdr refiere al valor nil. Nil tambien representa una lista vacia. Los conses tambien pueden facilmente usarse para implementar arboles y otras estructuras de datos complejas; aunque generalmente es aconsejado usar instancias de clases y estructuras. Tambien es posible crear estructuras de datos circulares con los conses.  Common Lisp soporta arreglos multidimensionales, y puede redimensionar los arreglos dinamicamente si fuera necesario. Los arreglos multidimensionales pueden ser usados para matematica de matrices. Un vector es un arreglo unidimensional. Los arreglos pueden tener cualquier tipo como miembros (incluso tipos mezclados en el mismo arreglo) o pueden estar especializados para contener un tipo especifico de miembros, como en un vector de enteros. Muchas implementaciones pueden optimizar funciones de arreglo cuando el arreglo usado es de un tipo especifico. Dos tipos de arreglo estan estandarizados: un string es un vector de caracteres, mientras que un vector-bit es un vector de bits.  Las tablas hash almacenan asociaciones entre objetos de datos. Cualquier objeto puede ser usado como clave o valor. Las tablas de hash, al igual que los arreglos, son redimensionadas automaticamente a medida que se necesite.  Los paquetes son colecciones de simbolos, usados principalmente para separar las partes de un programa en espacios de nombres. Un paquete puede exportar algunos simbolos, marcandolos como parte de una interface publica. Los paquetes pueden usar otros paquetes.  Las estructuras, similares en uso a los structs de C y a los records de Pascal, representan estructuras de datos arbitrariamente complejas con cualquier numero y tipo de campos (llamados slots). Las estructuras permiten herencia simple.  Las clases son similares a las estructuras, pero ofrecen caracteristicas mas dinamicas y herencia multiple. (Ver CLOS). Las clases han sido agregadas tarde al Common Lisp y hay un cierto solapamiento conceptual con las estructuras. Los objetos creados de clases son llamados instancias. Un caso especial son las funciones genericas. Las funciones genericas son tanto funciones como instancias.  === Funciones ===Los tipos numericos incluyen numeros enteros, cocientes, numeros de punto flotante, y numeros complejos.\u200b Common Lisp usa bignums para representar valores numericos de tama\u00f1o y precision arbitrarios. El tipo cociente representa fracciones exactamente, una facilidad no disponible en muchos lenguajes. Common Lisp fuerza automaticamente a los valores numericos entre estos tipos a medida que sean apropiados.  El tipo caracter de Common Lisp no se limita a los caracteres ASCII. La mayoria de las implementaciones modernas permiten los caracteres de Unicode.\u200b  El tipo simbolo es comun a los lenguajes Common Lisp, pero largamente desconocido fuera de ellos. Un simbolo es un unico, objeto de datos con nombre que tiene varias partes: nombre, valor, funcion, lista y paquete. De estos, la celda del valor y la celda de la funcion son los mas importantes. Los simbolos en Lisp son frecuente usados similarmente a los identificadores en otros lenguajes: para contener el valor de una variable; sin embargo, hay muchas otros usos. Normalmente, cuando un simbolo es evaluado, su valor es retornado. Algunos simbolos se evaluan a si mismos, por ejemplo todos los simbolos en un paquete de palabra clave son autoevaluados. Los valores boleano en Common Lisp son representados por los simbolos autoevaluantes T y NIL. Common Lisp tiene espacios de nombres para simbolos, llamados \"paquetes\u201d.  En Common Lisp las funciones son objetos de primera clase por lo que es posible escribir funciones que toman otras funciones como argumentos o tambien retornen funciones.  Un ejemplo de la utilidad de tener funciones como parameteros de funciones se ve en la funcion sort toma un operador relacional como un argumento y una funcion clave como un argumento opcional de palabra clave. Esto puede ser usado no solo para clasificar cualquier tipo de datos, pero tambien para clasificar las estructuras de datos de acuerdo a una clave.  El modelo de evaluacion para las funciones es muy simple. Cuando el evaluador encuentra una forma (F A1 A2\u2026) entonces se asume que el simbolo nombrado F es uno de los siguientes:  Si F es el nombre de una funcion, despues las argumentos A1, A2,\u2026, son evaluados en orden de izquierda a derecha, y la funcion es encontrada e invocada con esos valores suministrados como parametros.  Como en los programas en muchos otros lenguajes de programacion, Los programas Common Lisp hacen uso de nombres para referirse a las variables, funciones, y a muchas otras clases de entidades. Las referencias de nombres estan conforme a un ambito.  La asociacion entre un nombre y la entidad a la que el nombre se refiere se llama binding (enlace, enlazamiento).  El ambito se refiere al conjunto de las circunstancias en las cuales un nombre es determinado para tener un enlace particular.  === Determinantes del ambito ===Los tipos de secuencia en Common Lisp incluye listas, vectores, vectores-bit, y strings. Hay muchas operaciones que pueden trabajar en cualquier tipo de secuencia.  Como en casi todos los otros dialectos Lisp, las listas en Common Lisp estan compuestas de conses, a veces llamados celdas cons o pares. Una celda cons es una estructura de datos con dos slots, llamados sus car y cdr. Una lista es bien formada una cadena enlazada de celdas cons. Cada car del cons refiere a un miembro de la lista (posiblemente otra lista). Cada cdr del cons refiere al cons siguiente -- a excepcion del ultimo cons, cuyo cdr refiere al valor nil. Nil tambien representa una lista vacia. Los conses tambien pueden facilmente usarse para implementar arboles y otras estructuras de datos complejas; aunque generalmente es aconsejado usar instancias de clases y estructuras. Tambien es posible crear estructuras de datos circulares con los conses.  Common Lisp soporta arreglos multidimensionales, y puede redimensionar los arreglos dinamicamente si fuera necesario. Los arreglos multidimensionales pueden ser usados para matematica de matrices. Un vector es un arreglo unidimensional. Los arreglos pueden tener cualquier tipo como miembros (incluso tipos mezclados en el mismo arreglo) o pueden estar especializados para contener un tipo especifico de miembros, como en un vector de enteros. Muchas implementaciones pueden optimizar funciones de arreglo cuando el arreglo usado es de un tipo especifico. Dos tipos de arreglo estan estandarizados: un string es un vector de caracteres, mientras que un vector-bit es un vector de bits.  Las tablas hash almacenan asociaciones entre objetos de datos. Cualquier objeto puede ser usado como clave o valor. Las tablas de hash, al igual que los arreglos, son redimensionadas automaticamente a medida que se necesite.  Los paquetes son colecciones de simbolos, usados principalmente para separar las partes de un programa en espacios de nombres. Un paquete puede exportar algunos simbolos, marcandolos como parte de una interface publica. Los paquetes pueden usar otros paquetes.  Las estructuras, similares en uso a los structs de C y a los records de Pascal, representan estructuras de datos arbitrariamente complejas con cualquier numero y tipo de campos (llamados slots). Las estructuras permiten herencia simple.  Las clases son similares a las estructuras, pero ofrecen caracteristicas mas dinamicas y herencia multiple. (Ver CLOS). Las clases han sido agregadas tarde al Common Lisp y hay un cierto solapamiento conceptual con las estructuras. Los objetos creados de clases son llamados instancias. Un caso especial son las funciones genericas. Las funciones genericas son tanto funciones como instancias.  Las circunstancias que determinan el ambito en Common Lisp incluyen:  Para entender a lo que hace referencia un simbolo, el programador de Common Lisp debe saber que tipo de referencia esta siendo expresada, que tipo de ambito es usado en caso de ser una referencia variable (ambito dinamico versus lexico), y tambien la situacion en tiempo de ejecucion: en que ambiente es resuelta la referencia, donde estaba el binding introducido en el ambiente, etcetera.  En Lisp un macro se asemeja superficialmente a una funcion en uso. Sin embargo, en vez de representar una expresion que es evaluada, representa una transformacion del codigo fuente del programa.  A continuacion un ejemplo de un macro que proporciona la forma de iteracion until, que puede ser familiar para lenguajes como Perl:  Todos los macros deben ser expandidos antes de que el codigo fuente que los contiene pueda ser evaluado o compilado normalmente. Las macros pueden ser considerados como funciones que aceptan y retornan arboles de sintaxis abstracta (expresiones-S de Lisp). Estas funciones son invocadas antes del evaluador o del compilador para producir el codigo fuente final. Los macros son escritos en Common Lisp normal, y pueden usar cualquier operador disponible en Common Lisp (o de terceros). La notacion de backquote usada arriba es proporcionada por Common Lisp especificamente para simplificar el caso comun de la substitucion en una plantilla de codigo.  Common Lisp soporta el paradigma de programacion orientada a objetos al traves del CLOS (Common Lisp Object System), que es uno de los sistemas de objetos mas poderosos disponible en cualquier lenguaje[cita\u00a0requerida]. Originalmente propuesto como un add-on[cita\u00a0requerida], el CLOS fue adoptado como parte del estandar ANSI de Common Lisp. CLOS es un sistema de objetos dinamico con despacho multiple y herencia multiple, y se diferencia radicalmente de las facilidades de programacion orientada a objetos a traves del envio de mensajes encontradas en lenguajes.como Smalltalk, C++ o Java. Como sistema de objetos dinamico, CLOS permite cambios en tiempo de ejecucion a las funciones y clases genericas. Los metodos pueden ser agregados y removidos, las clases pueden ser agregadas y redefinidas, los objetos pueden ser actualizados para los cambios de la clase y la clase de objetos puede ser cambiada.  El CLOS se ha integrado en el ANSI Common Lisp. Las funciones genericas pueden ser usadas como las funciones normales y son un objeto de primera clase. Cada clase del CLOS esta integrada en el sistema de tipos de Common Lisp. Mucho tipos de Common Lisp tienen una clase correspondiente. Hay mas uso potencial del CLOS para Common Lisp. La especificacion no dice si las condiciones son implementadas con el CLOS. Los pathnames (nombres de ruta) y los streams (flujos) pueden ser implementados con el CLOS. Estas futuras posibilidades del uso de CLOS para el ANSI Common Lisp no son parte del estandar. Las implementaciones reales de Common Lisp estan usando el CLOS para los pathnames, streams, condiciones de entrada/salida, la implementacion del CLOS en si mismo y mas.  == Implementaciones ==Como en los programas en muchos otros lenguajes de programacion, Los programas Common Lisp hacen uso de nombres para referirse a las variables, funciones, y a muchas otras clases de entidades. Las referencias de nombres estan conforme a un ambito.  La asociacion entre un nombre y la entidad a la que el nombre se refiere se llama binding (enlace, enlazamiento).  El ambito se refiere al conjunto de las circunstancias en las cuales un nombre es determinado para tener un enlace particular.  Common Lisp es usado para desarrollar aplicaciones de investigacion, frecuentemente en inteligencia artificial, en el desarrollo rapido de prototipos o para desplegar aplicaciones.  Common Lisp es usado en muchas aplicaciones comerciales, incluyendo el sitio de comercio web Yahoo! Store, que originalmente implico a Paul Graham y fue posteriormente reescrito en C++ y el Perl.\u200b Otros ejemplos notables incluyen:  Tambien existen aplicaciones de fuente abierta escritas en Common Lisp, como por ejemplo:  == Vease tambien ==Las circunstancias que determinan el ambito en Common Lisp incluyen:  La localizacion de una referencia dentro de una expresion. Si es la posicion extrema izquierda de una composicion, se refiere a un enlace (binding) de un operador especial o un macro o una funcion, si no a un enlace de variable o alguna otra cosa. La clase de expresion en la cual la referencia ocurre. Por ejemplo, (GO X) significa transferir el control a la etiqueta X, mientras que (PRINT X) se refiere a la variable X. Ambos ambitos de X pueden estar activos en la misma region del texto del programa, puesto que las etiquetas tagbody estan en un espacio de nombre separado de los nombres de variables. Una forma especial o la forma de macro tiene completo control sobre los significados de todos los simbolos en su sintaxis. Por ejemplo en (defclass x (a b) ()), una definicion de clase, el (a b) es una lista de clases base, asi que estos nombres son buscados en el espacio de nombres de clases, y x no es una referencia a un binding (enlace) existente, sino el nombre de una nueva clase que es derivada de a y b. Estos hechos emergen puramente de la semantica de defclass. El unico hecho generico sobre esta expresion es que los defclass se refieren a un enlace (binding) de macro; todo lo demas es dejado a defclass. La localizacion de la referencia dentro del texto del programa. Por ejemplo, si una referencia a la variable X es envuelta en una construccion binding como un LET que define un binding para X, entonces la referencia esta en el ambito creado por ese binding. Para una referencia de variable, independientemente de si el simbolo de variable ha sido local o globalmente declarado como especial. Esto determina si la referencia esta resuelta dentro de un ambiente lexico, o dentro de un ambiente dinamico. La instancia especifica del ambiente en el cual la referencia es resuelta. Un ambiente es un diccionario de tiempo de ejecucion (run-time) que mapea los simbolos con los enlaces (bindings). Cada tipo de referencia usa sus propio tipo de ambiente. Las referencias a las variables lexicas son resueltas en un ambiente lexico, etcetera. Mas de un ambiente puede estar asociado con la misma referencia. Por ejemplo, gracias a la recursion o al uso de multiples hilos (multithreads), pueden existir al mismo tiempo multiples activaciones de la misma funcion. Estas activaciones comparten el mismo texto del programa, pero cada una tiene su propia instancia de ambiente lexico. Para entender a lo que hace referencia un simbolo, el programador de Common Lisp debe saber que tipo de referencia esta siendo expresada, que tipo de ambito es usado en caso de ser una referencia variable (ambito dinamico versus lexico), y tambien la situacion en tiempo de ejecucion: en que ambiente es resuelta la referencia, donde estaba el binding introducido en el ambiente, etcetera.  == Enlaces externos ==En Lisp un macro se asemeja superficialmente a una funcion en uso. Sin embargo, en vez de representar una expresion que es evaluada, representa una transformacion del codigo fuente del programa.  A continuacion un ejemplo de un macro que proporciona la forma de iteracion until, que puede ser familiar para lenguajes como Perl: ","snippet":"Common Lisp es un [[lenguaje de programacion Common Lisp es un lenguaje de programacion que pertenece a la familia de lenguajes Lisp. Se encuentra descrito en el documento estandar ANSI INCITS 226-199","enlaces_salientes":["Common_Lisp","Common_Lisp","Common_Lisp","Lisp","Software_libre_y_de_c%C3%B3digo_abierto","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_procedimental","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_funcional","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_din%C3%A1mica_(inform%C3%A1tica)","Compilaci%C3%B3n","Tiempo_de_ejecuci%C3%B3n","Common_Lisp_Object_System","Programaci%C3%B3n_orientada_a_objetos","Expresi%C3%B3n_S","Estructura_de_datos","N%C3%BAmero_entero","Raz%C3%B3n_aritm%C3%A9tica","Punto_flotante","N%C3%BAmeros_complejos","Precisi%C3%B3n_arbitraria","Car%C3%A1cter_(computaci%C3%B3n)","ASCII","Unicode","Boleano","Espacio_de_nombres","CAR_y_CDR","CAR_y_CDR","Bit","Tabla_hash","Espacio_de_nombres","Lenguaje_de_programaci%C3%B3n_C","Lenguaje_de_programaci%C3%B3n_Pascal","CLOS","Binding","Perl","%C3%81rbol_de_sintaxis_abstracta","Common_Lisp_Object_System","Programaci%C3%B3n_orientada_a_objetos","Common_Lisp_Object_System","Expansi%C3%B3n_(videojuegos)","Herencia_m%C3%BAltiple","Smalltalk","C%2B%2B","Lenguaje_de_programaci%C3%B3n_Java","CLISP","Yahoo!","Paul_Graham","DARPA","Serie_Jak_and_Daxter","American_Airlines","Continental_Airlines","US_Airways","ACL2","Demostraci%C3%B3n_autom%C3%A1tica_de_teoremas","Maxima","Sistema_algebraico_computacional","Python","Gestor_de_ventanas#Gestores_de_ventanas_de_mosaico","X11","Lisp","Scheme","CLOS","Wayback_Machine","Paul_Graham","Software_libre_y_de_c%C3%B3digo_abierto","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Expresi%C3%B3n_S","titulo":"Expresion S","contenido":"Una expresion-S, S-expresion o sexp (de Expresion Simbolica) es una notacion en forma de texto, para representar una estructura de datos de arbol, basada en listas anidadas, en donde cada sublista es un subarbol. Las S-expresiones son, probablemente, mejor conocidas por su uso en la familia de lenguajes de programacion Lisp. Su representacion textual habitual son secuencias de cadenas de caracteres, delimitadas por parentesis, y separadas por espacios, como en (= 4 (+ 2 2)), que representa la expresion logica escrita en C y en otros lenguajes relacionados, 4==2+2.  En notacion polaca o prefija (la cual Lisp usa), el primer elemento de una S-expresion es un operador (un primitivo) y el resto de elementos, los operandos (los datos). Debido a la estrecha relacion entre las expresiones-S y su representacion textual, el termino es usado informalmente tambien para referirse a su escritura.  Otros usos de las expresiones-S en los lenguajes de programacion derivados de Lisp, como DSSSL, y como base para protocolos como IMAP y el CBCL de John McCarthy. Sin embargo, los detalles de la sintaxis y los tipos de datos soportados varian entre los diferentes lenguajes.  Actualmente, en Lisp, las expresiones-S son usadas tanto para almacenar el codigo fuente y los datos (ver McCarthy Recursive Functions of Symbolic Expressions). Sin embargo originalmente solo fueron concebidas para datos que serian manipulados por expresiones-M, pero la primera implementacion de Lisp fue un interprete de una codificacion de expresiones-M usando expresiones-S, y los programadores Lisp pronto prefirieron usar expresiones-S tanto para el codigo como para los datos.  Las expresiones-S se definen, recursivamente como:  En Lisp, estas listas se construyen a partir de un tipo de dato mas basico llamado cons pair, escrito como (x . y). El primer elemento del cons es el primer elemento de la lista, y el segundo elemento es el resto de la lista; las listas, por tanto, se forman anidando cons, por ejemplo: (1 . (2 . (3 . nil))). El simbolo especial nil marca el final de una lista. Sin embargo, normalmente se usa la notacion (1 2 3), por ser mas compacta. Las listas anidadas tambien se pueden escribir como expresiones-S:  ((leche zumo) (miel mermelada))  Es una lista de dos elementos; cada elemento de la lista tambien es, una expresion-S.  Esto es una gramatica simple, escrita como una expresion-S (Gazdar/Melish, Natural Language Processing in Lisp):  El codigo fuente de los programas puede ser escrito como expresiones-S, normalmente usando notacion prefija. Como en el siguiente ejemplo en Common Lisp:  Las expresiones-S pueden ser leidas en Lisp usando la funcion READ. Esta funcion lee la representacion textual de una expresion-S y devuelve como dato Lisp.  La funcion PRINT puede ser usada para escribir la representacion textual de los datos a expresiones-S. Lisp tiene una representacion leible para numeros, cadenas, simbolos, listas y otros tipos de datos; esto significa que estructuras de datos formadas por estos tipos y escritas con PRINT, pueden ser leidas de nuevo con READ. El codigo fuente de los programas puede ser formateado mas elegantemente usando la funcion PPRINT.  Los programas Lisp son expresiones-S validas, pero no toda expresion-S valida es un programa Lisp; por ejemplo:  (1.0 + 3.1)  no es programa Lisp valido, porque no usa notacion prefija.  Una expresion-S precedida por una comilla simple, como en 'x, es un azucar sintactico para una expresion-S citada, en este caso, (quote x); a estos se les conoce como simbolos.  Los estandares para algunos lenguajes de programacion derivados del Lisp incluyen una especificacion para su sintaxis expresion S. Estos incluyen el Common Lisp (ANSI standard document ANSI INCITS 226-1994 (R2004)), Scheme (R5RS y R6RS\u200b) y el ISLISP.  En mayo de 1997, Ron Rivest presento un borrador de Internet\u200b para ser considerado para su publicacion como un RFC. El borrador define una sintaxis basada en expresiones S del Lisp pero dise\u00f1ado para almacenamiento e intercambio de datos de proposito general (similar a XML), en vez de especificamente para la programacion. Nunca fue aprobado como un RFC, pero desde entonces ha sido citado y usado por otros RFCs (ej. RFC 2693) y varias otras publicaciones.\u200b Originalmente fue pensado para uso en SPKI.  El formato de Rivest define una S-expresion como una cadena de octetos (una serie de bytes) o una lista finita de otras S-expresiones. Describe tres formatos de intercambio para expresar esta estructura. Uno es el \"transporte avanzado\", que es muy flexible en cuanto a formato y es sintacticamente similar a las expresiones al estilo Lisp, pero no son identicos. El transporte avanzado, por ejemplo, permite a las cadenas de octetos ser representadas textualmente (con la longitud de la cadena seguida de dos puntos y luego la cadena), una forma con comillas permitiendo caracteres de escape, hexadecimales, Base64, o directamente como un \"token\" si cumple con ciertas condiciones. (Los tokens de Rivest se diferencian de los tokens de Lisp porque los primeros son solo por conveniencia y estetica y tratados exactamente igual que otras cadenas, mientras que los ultimos tienen significado sintactico especifico). Otro formato de intercambio, pensado para ser mas compacto, mas facil de analizar y unico para cualquier S-expresion abstracta, es la \"representacion canonica\" que solo permite cadenas literales y prohibe el espacio en blanco como formateo de cadenas exteriores. Finalmente, existe la \"representacion de transporte basico\", que es la forma canonica o el mismo codificado como Base64 y rodeado de llaves, este ultimo destinado a transportar de manera segura una expresion S canonicamente codificada en un sistema que podria cambiar el espaciado (ej. un sistema de correo electronico que tiene lineas de 80 caracteres de ancho y continua en la linea siguiente con cualquier cosa mas larga que eso).  Este formato no ha sido ampliamente adaptado para su uso fuera del SPKI. La pagina web de la S-expresiones de Rivest proporciona el codigo fuente de C para un parser y generador (disponible bajo la licencia MIT, que podia ser adaptado y empotrado en otros programas. Ademas, no existen restricciones sobre implementar independientemente el formato.  Implementaciones en software libre: ","snippet":"Una expresion-S, S-expresion o sexp (de Expresion Simbolica) es una notacion en forma de texto, para representar una estructura de datos de arbol, basada en listas anidadas, en donde cada sublista es ","enlaces_salientes":["Expresi%C3%B3n_S","Expresi%C3%B3n_S","Expresi%C3%B3n_S","%C3%81rbol_(estructura_de_datos)","Notaci%C3%B3n_de_infijo","Estructura_de_datos","%C3%81rbol_(estructura_de_datos)","Lista_(estructura_de_datos)","Lisp","C_(lenguaje_de_programaci%C3%B3n)","Notaci%C3%B3n_polaca","Tipo_de_dato_elemental","DSSSL","Internet_Message_Access_Protocol","John_McCarthy_(cient%C3%ADfico)","Common_Lisp","Scheme","Ron_Rivest","Borrador_de_Internet","Request_For_Comments","XML","Bytes","Wayback_Machine","CAR_y_CDR","XML","Software_libre","Control_de_autoridades"]}
{"url":"Racket_(lenguaje_de_programaci%C3%B3n)","titulo":"Racket (lenguaje de programacion)","contenido":"Racket es un lenguaje de programacion  de amplio espectro de la familia de Lisp y Scheme. Es multiparadigma asi como de proposito general. Uno de sus principales objetivos tras su dise\u00f1o es posibilitar la creacion de nuevos lenguajes o dialectos.\u200b El lenguaje es usado en una variedad de entornos tales como scripting, ense\u00f1anza en ingenieria informatica o la investigacion.  La plataforma nos ofrece la herramienta DrRacket, un entorno de desarrollo integrado programado en Racket, que nos facilitara la tarea de programar en Racket. Tambien nos ofrece raco, un herramienta para la linea de comandos que nos permitira instalar paquetes o compilar librerias.\u200b  La plataforma se adhiere a la iniciativa Software libre, y esta liberada bajo una licencia LGPL.  En enero de 1994, PLT (fundada por Matthias Felleisen) decidio crear un entorno de programacion pedagogico basado en Scheme, y se creo MrEd, la primera maquina virtual para Racket. Mas tarde desarrollaron DrScheme, con PLT Scheme como principal lenguaje de desarrollo. En los siguientes a\u00f1os se fueron a\u00f1adiendo una serie de caracteristicas que lo consolidaron como entorno de desarrollo pedagogico.  El primer grupo de actualizaciones de PLT Scheme facilitaron la creacion de programas de gran escala al introducir modulos y clases. El sistema de clases obtuvo nuevas caracteristicas, como las interfaces o la herencia multiple. La siguiente gran actualizacion modifico el sistema de modulos alrededor de las macros, separando la ejecucion de la compilacion. Esto permitio a los desarrolladores ampliar la plataforma mediante el uso de extensiones en distintos lenguajes, formado una \"torre de lenguajes\".\u200b Versiones posteriores introdujeron soporte para Unicode, refinamientos del sistema de clases y se mejoro el rendimiento del lenguaje mediante el uso de un  compilador JIT. En la ultima actualizacion bajo el nombre de PLT Scheme se introdujo la etiqueta #lang para especificar el lenguaje de un modulo, pares inmutables, listas, soporte para paralelismo y dialectos de  tipado estatico.\u200b  El 7 de junio de 2010, coincidiendo con la salida de la version 5.0, se le cambio el nombre a PTL Scheme por Racket, asi como el nombre de DrScheme a DrRacket.\u200b La interfaz grafica, que estaba escrita en C++, fue reescrita en Racket usando toolkits nativos en cada plataforma.\u200b  Racket es altamente flexible, incluso sin el uso de dialectos. Caracteristicas tales como el uso de macros, modulos,  clausuras,  recursion en cola, y mucho mas, le permiten ser usado para la realizacion de todo tipo de tareas, desde generacion de graficos a  web scrapers. Ademas, el potente sistema de macros permite a los desarrolladores controlar todos los aspectos de un lenguaje, una de las principales metas tras su dise\u00f1o. El framework viene con un gestor de paquetes llamado PLaneT integrado con el sistema de modulos, lo que permite a los usuarios importar y usar librerias de terceros de forma totalmente transparente.\u200b  La principal caracteristica de Racket es la capacidad de crear y extender nuevos lenguajes. Esto es posible gracias a una serie de componentes:  El primer punto, el sistema de modulos, es el encargado de hacer posible muchas de estas caracteristicas, permite el uso de una gran cantidad de modulos conjuntamente, donde cada uno de ellos puede estar escrito en un lenguaje distinto.  Implementar un nuevo lenguaje en Racket es tan sencillo que muchos de ellos tienen muy pocos usos, ya que fueron concebidos con un objetivo muy concreto.  Typed Racket, definido por la etiqueta #lang typed/racket es una variante de Racket con tipado estatico, lo que permite a los programas madurar, ya que el tipado estatico puede ayudar en el mantenimiento de una aplicacion de gran tama\u00f1o. Entre los objetivos de este dialecto se encuentra el permitir la escritura de codigo mas expresivo. Otra caracteristica es la inclusion de codigo tipado en programas no tipados, lo que permitiria llamar a modulos escritos en Typed Racket.  El siguiente fragmento de codigo define una lista cuyos elementos son del tipo Str-or-Num (definido previamente).  Otro ejemplo de las posibilidades que ofrece Racket es la implementacion de evaluacion perezosa (del ingles lazy evaluation), no estando esta caracteristica en el nucleo principal del lenguaje. El siguiente ejemplo muestra como se definiria una lista de Fibonacci infinita cuyos elementos solo son calculados cuando es necesario.\u200b  Scribble es la familia de dialectos de Racket usados para escribir prosa. Su principal eso es el de actuar como sistema de documentacion de Racket, pero puede ser usado para mucho mas, como la escritura de libros o articulos. Cada uno de los dialectos es usado para diferentes propositos.\u200b  El lenguaje trabaja en modo texto por defecto (todo lo que escribamos formara parte del fichero final), y utiliza el caracter @ para hacer llamadas a las distintas funciones ofrecidas. En el siguiente ejemplo podemos ver el uso de la funcion title, asi como una muestra del uso del modo texto. Si guardamos el archivo como raton.scrbl y ejecutamos scribble --pdf raton.scrbl generaremos un fichero pdf con los contenidos especificados.  Racket ofrece una variedad de caracteristicas orientadas a la mejora del rendimiento en tiempo de ejecucion.  Racket puede ser usado con tres  recolectores de basura distintos:  Racket posee una interfaz de sistema con  entrada salida  asincrona no bloqueante,  hilos de ejecucion verdes, canales de sincronizacion,  semaforos, subprocesos, y  sockets TCP. Esto nos permite realizar todo tipo de accesos a las funciones ofrecidas por el sistema operativo. Por ejemplo, en el siguiente ejemplo lanzamos un proceso que maneja conexiones entrantes en el puerto 12345:  Gracias a la extensibilidad de Racket encontramos que cierto tipo de tareas resultan extremadamente sencillas. Por ejemplo, el siguiente programa hace uso del dialecto web-server/insta para crear un servidor web en solo dos lineas:  Ademas, Racket incluye todas las funciones necesarias para crear  scrapers o  ara\u00f1as web. El siguiente ejemplo obtiene los resultados de Google dada una cadena de busqueda:  En Racket las imagenes son variables, al igual que los son los numeros o las cadenas de texto, por lo que podemos crear programas que generen imagenes, y el editor nos las mostrara. Para hacer esto posible tenemos una variedad de librerias graficas en Racket que nos permiten generar imagenes a traves de las funciones que nos ofrece. Por ejemplo, la libreria 2htdp/image nos permite generar imagenes sin mucha complicacion, por lo que es usada en entornos educativos. El siguiente ejemplo genera un Triangulo de Sierpinski de nivel 8:  Si enfocamos hacia el mundo academico, podemos encontrar la libreria plot, que nos permite generar  graficas. Esta libreria nos permite exportar nuestros resultados como archivos PNG, PDF, PostScript y SVG ademas de mostrarlos en el editor.  Una de las librerias ofrecidas por Racket nos permite la creacion de  interfaces graficas, ya sea a mano posicionando linea a linea los elementos, o mediante el uso de editores presentes en PLaneT. La libreria esta implementada mediante el uso de llamadas a la API nativa en Windows, con Cocoa en Mac OS X, y con Gtk en Linux. El siguiente ejemplo genera una ventana con una serie de botones con numeros, y el programa nos hace adivinar cual de ellos es el correcto: ","snippet":"Racket es un lenguaje de programacion  de amplio espectro de la familia de Lisp y Scheme. Es multiparadigma asi como de proposito general. Uno de sus principales objetivos tras su dise\u00f1o es posibilita","enlaces_salientes":["Racket_(lenguaje_de_programaci%C3%B3n)","Racket_(lenguaje_de_programaci%C3%B3n)","Racket_(lenguaje_de_programaci%C3%B3n)","Extensi%C3%B3n_de_archivo","Sistema_de_tipos","Tipado_din%C3%A1mico","Tipado_fuerte","Sistema_de_tipificaci%C3%B3n#Tipado_est\u00e1tico","Scheme","Sistema_operativo","Multiplataforma","Licencia_de_software","GNU_Lesser_General_Public_License","Lenguaje_de_programaci%C3%B3n","Lisp","Scheme","Entorno_de_desarrollo_integrado","Software_libre","LGPL","Unicode","Compilaci%C3%B3n_en_tiempo_de_ejecuci%C3%B3n","Paralelismo_(inform%C3%A1tica)","Sistema_de_tipificaci%C3%B3n#Tipado_est\u00e1tico","Macros","Clausura_(inform%C3%A1tica)","Recursi%C3%B3n_(ciencias_de_computaci%C3%B3n)#Funciones_de_recursi.C3.B3n_de_cola","Web_scraping","Espacio_de_nombres","Tiempo_de_ejecuci%C3%B3n","Analizador_sint%C3%A1ctico","Evaluaci%C3%B3n_perezosa","Recolector_de_basura","Servidor_web","Memory_leak","Depuraci%C3%B3n_de_programas","Memory_leak","Entrada/salida","Asincron%C3%ADa","Hilo_de_ejecuci%C3%B3n","Sem%C3%A1foro_(programaci%C3%B3n)","Sockets_tcp","Sistema_operativo","Ara%C3%B1a_web","Tri%C3%A1ngulo_de_Sierpinski","Gr%C3%A1fica","PNG","PDF","PostScript","Scalable_Vector_Graphics","Interfaz_gr%C3%A1fica","API","Windows","Cocoa","Mac_OS_X","Gtk","Linux","Wayback_Machine","Wayback_Machine","ISBN","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Clojure","titulo":"Clojure","contenido":"Clojure es un lenguaje de programacion de proposito general dialecto de Lisp. Hace un enfasis especial en el paradigma  funcional, con el objetivo (entre otros) de eliminar la complejidad asociada a la programacion concurrente. Clojure puede ser ejecutado sobre la Maquina Virtual de Java y la maquina virtual de la plataforma .NET, asi como compilado a JavaScript.  Rich Hickey describe el desarrollo de Clojure como la busqueda de un lenguaje que no pudo encontrar: un lisp funcional por defecto, integrado sobre un entorno robusto en lugar de ser su propia plataforma, y con la programacion concurrente en mente.\u200b  Asimismo, en principio se rechaza la orientacion a objetos, ofreciendo un enfoque en el que los programas se expresan como la aplicacion de funciones sobre datos, mas que como la interaccion entre entidades mutables que mezclan representacion de datos, y comportamiento. Por otra parte, caracteristicas tales como instanciabilidad, polimorfismo e interfaces son efectivamente parte del lenguaje.  Como el resto de la familia Lisp, la sintaxis de Clojure esta construida sobre expresiones simbolicas que son convertidas en estructuras de datos por un lector antes de ser compiladas. Las expresiones se caracterizan por estar delimitadas por parentesis, y por su notacion prefija, por la que se llama al primer miembro de cada lista como funcion, pasandole el resto de miembros como argumentos.  Esta peculiaridad, extra\u00f1a para los habituados a los lenguajes mas populares basados en la sintaxis del lenguaje de programacion C es la base de su flexibilidad. Estructuras de datos tales como mapas, conjuntos y vectores tienen una expresion literal; no requieren transformacion alguna a la hora de incorporarse al arbol sintactico generado por el compilador. Clojure es un Lisp-1 y no esta particularmente dise\u00f1ado para ser compatible con otros lisps.  Un macro es un fragmento de codigo que acepta como argumentos otras expresiones, sin evaluar, transformandolas previamente a su evaluacion. Esto permite la aparicion de \"programas que crean programas\": incorporaciones al lenguaje -estructuras de control de flujo- o creacion de un lenguaje especifico del dominio. Posibilidades en principio no alcanzables en otras familias de lenguajes sin recurrir al desarrollo de un compilador.  El sistema de macros de Clojure es muy similar al de Common Lisp con la excepcion de que la version de Clojure de la comilla inversa (llamada \"comilla sintactica\") cualifica los simbolos con el espacio de nombres al que pertenece. Asi se ayuda a prevenir la captura no intencionada ya que estan prohibidos los bindings con nombres cualificados. Es posible forzar la expansion de una macro que las capture pero debe hacerse explicitamente. Clojure prohibe tambien re-enlazar nombres globales en otros espacios de nombres que hayan sido importados en el actual.  Otra caracteristica de la comilla sintactica es que permite un sistema de templating, en el que se puede especificar que miembros de una lista deben evaluarse mediante los operadores unquote (~) y unquote-splice (~@), dando lugar a macros mas concisas y manejables.  Hola mundo. Notese que dada la naturaleza del REPL, no es necesaria una orden de impresion.  Un generador de numeros unicos y consecutivos que soporta llamadas concurrentes:  Una subclase anonima de java.io.Writer que no escribe en ningun sitio y una macro que lo usa para silenciar todas las expresiones evaluadas con ella.  En este ejemplo diez hilos manipulan una estructura de datos compartida, que consiste en cien vectores que contienen diez numeros unicos al inicio secuenciales. Cada hilo elige dos posiciones aleatorias en dos vectores aleatorios y los intercambia. Todos los cambios en los vectores se hacen dentro de transacciones usando el sistema de memoria transaccional por software de Clojure. Es por eso que incluso despues de mil iteraciones no se pierde ningun numero.  Salida del ejemplo anterior: ","snippet":"Clojure es un lenguaje de programacion de proposito general dialecto de Lisp. Hace un enfasis especial en el paradigma  funcional, con el objetivo (entre otros) de eliminar la complejidad asociada a l","enlaces_salientes":["Clojure","Clojure","Clojure","Richard_Hickey","Extensi%C3%B3n_de_archivo","Paradigma_de_programaci%C3%B3n","Paradigma_funcional","Sistema_de_tipos","Tipado_din%C3%A1mico","Tipado_fuerte","JVM","CLR","Lisp","Haskell","Erlang","Prolog","Sistema_operativo","Multiplataforma","Licencia_de_software","Eclipse_Public_License","Lenguaje_de_programaci%C3%B3n","Lisp","Programaci%C3%B3n_funcional","Programaci%C3%B3n_concurrente","M%C3%A1quina_Virtual_de_Java","Common_Language_Runtime","JavaScript","Programaci%C3%B3n_concurrente","Lenguaje_de_programaci%C3%B3n_C","Tabla_hash","Conjunto","Vector_(inform%C3%A1tica)","Lenguaje_espec%C3%ADfico_del_dominio","Compilador","Common_Lisp","Recursi%C3%B3n","Iteraci%C3%B3n","Efecto_secundario_(inform%C3%A1tica)","Evaluaci%C3%B3n_perezosa","Persistencia_de_objetos","Lenguaje_de_programaci%C3%B3n_Java","Bytecode","JVM","Hola_mundo","ISBN","ISBN","Manning","ISBN","Manning","ISBN","Wayback_Machine","Control_de_autoridades","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Open_Hub"]}
{"url":"Arte_ASCII","titulo":"Arte ASCII","contenido":"El Arte ASCII (pronunciado arte aski) es un medio artistico que utiliza recursos computarizados fundamentados en los caracteres de impresion del Codigo Estandar Estadounidense de Intercambio de Informacion. Hoy dia puede crearse con cualquier editor de textos, aunque en la decada previa al advenimiento del computador personal de escritorio (IBM PC, 1981), algunos artistas lo utilizaban de manera experimental (ver articulo: Angel Luis Arambilet Alvarez) y como medio alternativo de arte grafico, utilizando tarjetas perforadas de 80 y 96 columnas, asi como diversos programas compiladores o utilitarios (COBOL, RPG, IBM DITTO), combinado a impresoras de matriciales de alta velocidad para fines de presentacion.  El arte ASCII se ha utilizado cuando no es posible la transmision o la impresion de imagenes en las configuraciones de equipos computarizados, tales como maquinillas, teletipos y equipos de visualizacion (consolas y terminales) que no cuentan con tarjetas de proceso grafico. El arte ASCII ha servido como lenguaje fuente para representar logos de compa\u00f1ias y productos, para crear diagramas procedimentales de flujo de operaciones y tambien en el dise\u00f1o de los primeros videojuegos. Programas editores de texto especializados tal como IMG2TXT o JPG2TXT estan dise\u00f1ados para dibujar figuras geometricas y rellenar areas de luz y sombra con una combinacion de caracteres basandose en algoritmos matematicos.  ASCII, pronunciado [\u02c8\u00e6ski], es un conjunto de 95 caracteres basado en el alfabeto latino que se utiliza en los lenguajes de Europa-Oeste y en el ingles moderno. Su mayor aplicacion se concentra en la operacion de equipos computarizados y de comunicacion para representar caracteres de texto o identificar dispositivos de control computarizado que trabajan exclusivamente con texto y no tienen capacidad de procesamiento de imagenes. Fue un elemento fundamental en la arquitectura de las primeras redes de computadoras de correo electronico y medios de noticias de las decadas 1960-1970.  Desde el punto de vista de evolucion de la grafica computarizada, el Arte ASCII replantea la observacion tradicional de una imagen en base al conjunto de elementos pictoricos que la conforman (ver: pixel), un efecto optico similar al del puntillismo. Asi pues, a una mayor distancia del observador, la imagen hecha en Arte ASCII adquiere mayor definicion; exactamente lo opuesto a lo que sucede cuando, al observar con lupa una imagen impresa en un diario, la distancia entre los pixeles que la conforman se hace evidente y la imagen se desvirtua.  Leon confeccionado en caracteres ASCII.  Logo de Wikipedia en ASCII  Conjunto de Mandelbrot usando caracteres ASCII.  Captura de pantalla de un boletin universitario en donde el logotipo de la universidad esta hecho con caracteres ASCII.  Imagen de una flor usando caracteres ASCII en un bloc de notas.  Pantalla de inicio de un videojuego en ruso, en donde el fondo del juego es un dibujo hecho con caracteres ASCII.  Arte ASCII japones. ","snippet":"El Arte ASCII (pronunciado arte aski) es un medio artistico que utiliza recursos computarizados fundamentados en los caracteres de impresion del Codigo Estandar Estadounidense de Intercambio de Inform","enlaces_salientes":["Arte_ASCII","Arte_ASCII","Arte_ASCII","ASCII","IBM","Computadora_personal","%C3%81ngel_Luis_Arambilet_%C3%81lvarez","COBOL","Lenguaje_de_programaci%C3%B3n_RPG","ASCII","Terminal_de_computadora","Videojuegos","ASCII","Alfabeto_latino","P%C3%ADxel","Puntillismo","Letra","Conjunto_de_Mandelbrot","Bloc_de_notas","Idioma_ruso","Jap%C3%B3n","Alemania","Otto_von_Bismarck","M%C3%A1quina_de_escribir","Control_de_autoridades"]}
{"url":"C%C3%B3digo_ofuscado","titulo":"Ofuscacion","contenido":"La ofuscacion se refiere a encubrir el significado de una comunicacion haciendola mas confusa y complicada de interpretar.  En computacion, la ofuscacion se refiere al acto deliberado de realizar un cambio no destructivo, ya sea en el codigo fuente de un programa informatico, en el codigo intermedio (bytecodes) o en el codigo maquina cuando el programa esta en forma compilada o binaria. Es decir, se cambia el codigo se \"enrevesa\" manteniendo el funcionamiento original, para dificultar su entendimiento. De esta forma se dificulta los intentos de ingenieria inversa y desensamblado que tienen la intencion de obtener una forma de codigo fuente cercana a la forma original.  A las herramientas que realizan procesos de ofuscacion se les llama ofuscadores. Los ofuscadores pueden actuar sobre el codigo fuente, sobre el codigo objeto o sobre ambos.  Como un efecto lateral, la ofuscacion, en ocasiones, hace que los programas resultantes sean mas peque\u00f1os (aunque puede hacer que los programas sean mas grandes en otros casos).  Algunos lenguajes tienden mas a la ofuscacion que otros. C, C++ y Perl son los mas citados como facilmente ofuscables. Las macros de preprocesador son usadas a menudo para crear codigo complicado de leer enmascarando la gramatica y sintaxis estandar del lenguaje del cuerpo principal de codigo.  Ademas, a veces, tambien se puede buscar que el codigo fuente resulte una obra de ascii art. Existen otros programas ofuscados llamados quine que al ejecutarse la salida debe ser el codigo fuente del programa.  La motivacion inmediata de la ofuscacion es dificultar el entendimiento del codigo y por tanto dificultar la ingenieria inversa. El motivo original puede ser por:\u200b  Un ejemplo simple de ofuscacion es llamar a las variables o funciones con palabras reservadas del lenguaje a\u00f1adiendo algun simbolo  Con esta linea se define una variable de tipo entero.  Con esta linea definimos una funcion con un parametro entero que devuelve un valor long int, que por otra parte siempre sera 0.  Esto equivale a poner 0.  Esto equivale a poner 1.  Esto equivale a poner 10.  Hay distintas tecnicas para realizar ofuscacion. Estas tecnicas se pueden clasificar segun se aplican al dise\u00f1o, a datos, a instrucciones o al flujo de control del programa.\u200b\u200b  Algunas de las tecnicas de ofuscacion de dise\u00f1o son:  Estas tecnicas se basan en aplicar diversas transformaciones a las variables, las constantes y las estructuras que forman parte de un programa.\u200b Algunas de las ofuscaciones de datos son:  Consisten en una serie de transformaciones que alteran el flujo de ejecucion de un programa. El flujo de ejecucion de un programa se puede representar por un grafo de control de flujo (CFG), en el que los nodos son los bloques basicos de ejecucion del programa, y las aristas son los saltos entre bloques basicos de ejecucion (conjuntos de instrucciones que se ejecutan secuencialmente, en los que la primera instruccion es el unico acceso al bloque y la ultima instruccion es la unica de salida).\u200b  Algunas de las ofuscaciones de control de flujo son:  Consiste en sustituir la instruccion original por otra serie de instrucciones equivalentes mas complicadas, generalmente mediante el uso de operaciones matematicas. Por ejemplo Obfuscator-LLVM es una suit de compilacion sobre LLVM que permite ofuscar el programa.\u200b  Buscan oscurecer y alterar la estructura lexica del software introduciendo cambios en el formato del codigo fuente. Por ejemplo renombrando variables o borrando informacion del debugger.\u200b  La virtualizacion de codigo, o ofuscacion basada en maquina virtual (en ingles obfuscation VM-based), es un metodo para la ofuscacion.\u200b La tecnica consiste en reemplazar instrucciones del programa con instrucciones virtuales con las que el atacante no esta familiarizado. Posteriormente estas instrucciones seran traducidos a codigo de la maquina nativa en tiempo de ejecucion para ser ejecutado por el hardware\u200b  La ofuscacion de codigo basada en maquinas virtuales de proceso se esta convirtiendo en una tecnica muy utilizada.\u200b Se han creado varias herramientas que utilizan este tipo de ofuscacion, como por ejemplo VMProtect, WProtect,\u200b Code Virtualizer y Themida.\u200b En estas herramientas es frecuente que el codigo se ejecute en una maquina virtual que sea marcadamente diferente de las CPU tradicionales, y en las que el conjunto de comandos es diferente para cada archivo protegido.\u200b\u200b\u200b  Algunos lenguajes, como por ejemplo Java, compilan a un lenguaje intermedio de bytecodes. Este codigo intermedio pueden ser facilmente decompilado para asi obtener casi el mismo codigo fuente original. Por diferentes motivos (ingenieria inversa, sabotajes, pirateria de software....) a veces es necesario ofuscar el codigo intermedio para impedir la decompilacion o hacer que esta obtenga un codigo incomprensible.\u200b  Por ejemplo para los bytecodes de Java se usa las siguientes tecnicas de ofuscacion:\u200b  Las tecnicas de ofuscacion tambien pueden servir para dar seguridad. Por ejemplo, PointGuard es una extension de GCC para proteger punteros. PointGuard cifra los valores de los punteros cuando estos estan en memoria aplicando una XOR con una clave generada aleatoriamente cuando el proceso del programa arranca. Cuando un puntero se va a desreferenciar se descifra el valor del puntero, de esta forma, si un atacante consigue sobrescribir el valor del puntero, cuando este se desreferencie y por PointGuard se descifre, el atacante estara accediendo a una direccion de memoria aleatoria, y muy posiblemente si el acceso no es valido hara que el programa falle, frustrando asi la explotacion del programa.\u200b  Hay multitud de herramientas para ofuscar, cada una aplicable a un lenguaje distintos. Ejemplos de este tipo de herramientas son:  La ofuscacion puede servir para otros propositos. Los medicos han sido acusados de usar una jerga para encubrir hechos desagradables de un paciente. El autor y doctor Michael Crichton ha afirmado que la escritura medica es un \"intento altamente capacitado y calculado de confundir al lector\".  De forma similar, el lenguaje basado en texto, como gyaru-moji y algunas formas de leet speak es ofuscado para hacerlo incomprensible a terceras personas. ","snippet":"La ofuscacion se refiere a encubrir el significado de una comunicacion haciendola mas confusa y complicada de interpretar.  En computacion, la ofuscacion se refiere al acto deliberado de realizar un c","enlaces_salientes":["Ofuscaci%C3%B3n","Ofuscaci%C3%B3n","Ofuscaci%C3%B3n","Computaci%C3%B3n","C%C3%B3digo_fuente","Programa_inform%C3%A1tico","Bytecode","C%C3%B3digo_m%C3%A1quina","Compilador","Ingenier%C3%ADa_inversa","Desensamblado","C%C3%B3digo_fuente","C%C3%B3digo_fuente","C%C3%B3digo_objeto","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Perl","Ascii_art","Quine_(programa)","Ingenier%C3%ADa_inversa","Seguridad_por_oscuridad","Malware","Antivirus","Propiedad_intelectual","Lenguaje_de_programaci%C3%B3n","Brainfuck","Decompilador","Lenguaje_intermedio","Ingenier%C3%ADa_inversa","Base64","ROT13","Grafo_de_control_de_flujo","Predicado_opaco","Tiempo_de_compilaci%C3%B3n","LLVM","M%C3%A1quina_virtual#M\u00e1quinas_virtuales_de_proceso","Ingenier%C3%ADa_inversa","Direcci%C3%B3n_de_memoria","Jerga","Michael_Crichton","Gyaru-moji","Leet_speak","Internet_Archive","Control_de_autoridades"]}
{"url":"Microsoft_Windows","titulo":"Microsoft Windows","contenido":"Windows es el nombre de una familia de distribuciones de software para PC, servidores, sistemas empotrados y antiguamente telefonos inteligentes desarrollados y vendidos por Microsoft y disponibles para multiples arquitecturas, tales como x86, x86-64 (x64) y ARM.  Desde un punto de vista tecnico, no son sistemas operativos, sino que contienen uno (tradicionalmente MS-DOS o el mas actual cuyo nucleo es Windows NT) junto con una amplia variedad de software; no obstante, es usual (aunque no necesariamente correcto) denominar al conjunto como sistema operativo en lugar de distribucion. Microsoft introdujo un entorno operativo denominado Windows el 20 de noviembre de 1985 como un complemento para MS-DOS en respuesta al creciente interes en las interfaces graficas de usuario (GUI).\u200b Microsoft Windows llego a dominar el mercado mundial de computadoras personales, con mas del 70\u00a0% de la cuota de mercado, superando a Mac OS, que habia sido introducido en 1984.  La version mas reciente de Windows es Windows 11 para equipos de escritorio, Windows Server 2022 para servidores y Windows 10 Mobile para dispositivos moviles. La primera version en espa\u00f1ol fue Windows 2.1.  La primera version se lanzo en 1985 y comenzo a utilizarse de forma generalizada gracias a su interfaz grafica de usuario (GUI, Graphical User Interface) basada en ventanas. Hasta ese momento (y hasta mucho despues como corazon de Windows), el sistema operativo mas extendido era MS-DOS (Microsoft Disk Operating System), que por aquel entonces contaba con una interfaz basada en linea de comandos.  Windows 10 llego de forma oficial y gratuita a usuarios con licencia genuina de Windows 7, Windows 8 y Windows 8.1 el 29 de julio de 2015. Fue la primera version que busco la unificacion de dispositivos (escritorio, portatiles, telefonos inteligentes, tabletas y videoconsolas) bajo una experiencia comun. Su sucesor, Windows 11, se lanzo oficialmente el 5 de octubre de 2021 como una actualizacion gratuita a traves de Windows Update de Windows 10, para aquellos equipos que cumpla con ciertas especificaciones tecnicas compatibles del nuevo sistema. Microsoft promovio que Windows 11 habria mejorado el rendimiento y la facilidad de uso sobre Windows 10, contando con cambios importantes en el Shell de Windows influenciados por el cancelado Windows 10X, incluido un menu Inicio redise\u00f1ado, asi como la incompatibilidad con la arquitectura x86 de 32 bits o los sistemas que usan firmware del BIOS.  La primera version de Microsoft Windows, version 1.0, presentada en diciembre de 1985, compitio con el sistema operativo de Apple. Carecia de un cierto grado de funcionalidad y logro muy poca popularidad. Windows 1.0 no era un sistema operativo completo; mas bien era una extension grafica de MS-DOS.  La segunda version (Windows 2.x) se lanzo en noviembre de 1987 y fue un poco mas popular que su predecesor. Windows 2.03 (lanzado en enero de 1988) incluyo por primera vez ventanas que podian solaparse unas a otras. El resultado de este cambio llevo a Apple a presentar una demanda contra Microsoft, debido a que infringian derechos de autor.  Windows 3.0, lanzado en 1990, fue la primera version de Microsoft Windows que consiguio un amplio exito comercial, vendiendo 2 millones de copias en los primeros seis meses. Presentaba mejoras en la interfaz de usuario y en la multitarea. Recibio un lavado de cara en Windows 3.1, que se hizo disponible para el publico en general el 1 de marzo de 1992. El soporte de Windows 3.1 termino el 31 de diciembre de 2001.  El 24 de agosto de 1995, Microsoft lanzo Windows 95, una nueva version del sistema operativo Windows destinada al mercado de consumo pensada para sustituir a Windows 3.1 como interfaz grafica y a MS-DOS como sistema operativo. En esta edicion se introdujeron mejoras muy significativas con respecto a sus antecesores entre las cuales se pueden mencionar los profundos cambios realizados a la interfaz grafica de usuario de Windows, que era completamente distinta a las de versiones anteriores, y el pasar de usar una arquitectura multitarea cooperativa de 16 bits a usar una arquitectura multitarea apropiativa de 32 bits.  Windows 95 fue la primera version de Windows en incluir la barra de tareas y el boton Inicio, los cuales siguieron incluyendose en versiones posteriores de Windows, ademas de ser la primera version en soportar la funcion de Plug and Play.  Acompa\u00f1ado por una extensa y millonaria campa\u00f1a de marketing, Windows 95 fue un gran exito en el mercado en el momento de su lanzamiento y en breve se convirtio en uno de los sistemas operativos de escritorio mas populares.  El siguiente para la linea del usuario fue lanzado el 25 de junio de 1998, Microsoft Windows 98. Sustancialmente fue criticado por su lentitud y por su falta de fiabilidad en comparacion con Windows 95, pero muchos de sus problemas basicos fueron posteriormente rectificados con el lanzamiento de Windows 98 Second Edition en 1999. El soporte estandar para Windows 98 termino el 30 de junio de 2002, y el soporte ampliado para Windows 98 termino el 11 de julio de 2006.  Como parte de su linea \u00abprofesional\u00bb, Microsoft lanzo Windows 2000 en febrero de 2000. La version de consumidor tras Windows 98 fue Windows Me (Windows Millennium Edition). Windows Me implementaba una serie de nuevas tecnologias para Microsoft: en particular fue el \u00abUniversal Plug and Play\u00bb. Durante el 2004 parte del codigo fuente de Windows 2000 se filtro en internet, esto era malo para Microsoft porque el mismo nucleo utilizado en Windows 2000 se utilizo en Windows XP.  En octubre de 2001, Microsoft lanzo Windows XP, una version que se construyo en el kernel de Windows NT que tambien conserva la usabilidad orientada al consumidor de Windows 95 y sus sucesores. En dos ediciones distintas, \u00abHome\u00bb y \u00abProfessional\u00bb, el primero carece en gran medida de la seguridad y caracteristicas de red de la edicion Professional. Ademas, la primera edicion \u00abMedia Center\u00bb fue lanzada en 2004, con enfasis en el apoyo a la funcionalidad de DVD y TV, por lo que incluia grabacion de TV y un control remoto. A principios de la decada de los 2000, Windows se empezaba a posicionar como el innovador en el mercado, pero su posicion fue en declive.  El 30 de enero de 2007, Microsoft lanzo Windows Vista. Contiene un sinnumero de caracteristicas nuevas, a partir de un shell redise\u00f1ado, y la interfaz de usuario ofrece importantes cambios tecnicos de envergadura, con especial atencion a las caracteristicas de seguridad. Esta disponible en seis ediciones diferentes.  El 22 de octubre de 2009, Microsoft lanzo Windows 7. A diferencia de su predecesor, Windows Vista, que introdujo a un gran numero de nuevas caracteristicas, Windows 7 pretendia ser una actualizacion incremental, enfocada a la linea de Windows, con el objetivo de ser compatible con aplicaciones y hardware con los que Windows Vista no era compatible. Windows 7 tiene soporte multi-touch, un Windows shell redise\u00f1ado con una nueva barra de tareas, conocido como Superbar, un sistema red llamado HomeGroup, y mejoras en el rendimiento sobre todo en velocidad y en menor consumo de recursos.  El 26 de octubre de 2012, Microsoft lanzo Windows 8. El mayor cambio introducido es el reemplazo del Menu Inicio por una pantalla de Inicio de tama\u00f1o completo, la cual incluye nuevas aplicaciones. Su uso esta enfatizado para dispositivos con pantallas tactiles, aunque puede ser utilizado con raton y teclado. Por primera vez desde Windows 95, el boton de Inicio desaparece de la barra de tareas. El escritorio presenta una nueva interfaz y el explorador de Windows incluye la apariencia \"Ribbon\" de Microsoft Office. Una actualizacion masiva del sistema, Windows 8.1, fue lanzada el 17 de octubre de 2013 con nuevas mejoras de personalizacion, rendimiento y un boton para la pantalla de inicio, cuya ausencia en Windows 8 fue criticada.  El 29 de julio de 2015, Microsoft lanzo Windows 10. Presenta un conjunto de aplicaciones y una interfaz que permite utilizarse en computadoras personales y dispositivos moviles. Visualmente es parecido a su predecesor, sin embargo, el Menu Inicio regresa en esta version. Windows 10 introduce un nuevo navegador: Microsoft Edge, y un asistente de voz personal: Cortana, junto con una interfaz de sistema minimalista. Se trata de un sistema que a diferencia de sus predecesores, lanzara actualizaciones masivas periodicamente para convertirse en un sistema de servicio. Hasta el 29 de julio de 2016, Microsoft ofrecio gratuitamente una actualizacion a Windows 10 desde una PC con Windows 7 o Windows 8.1.  El 24 de junio de 2021, Microsoft anuncio y confirmo Windows 11, el cual se lanzo oficialmente el 5 de octubre de 2021. Incorpora una interfaz de usuario basada en Fluent Design incluyendo transparencias, sombras, iconos redondeados en todo el sistema. El menu Inicio sufre un redise\u00f1o que elimina los tiles del lateral. Los iconos de la barra de tareas incluyendo en boton Inicio aparecen centrados en la mitad de la pantalla, un dise\u00f1o que ha sido comparado al del dock de macOS.  Las versiones Beta, Alpha o de pruebas, son versiones gratuitas que se crean como base para el proximo sistema operativo de Windows a lanzar. En ellas se colocan algunas funciones que Microsoft ha puesto por defecto y que las lanza al publico para demostrarles a los usuarios como puede ser la futura version de Windows. Mientras estas versiones esten activas, los usuarios pueden reportar errores que se encuentren en el sistema operativo, (ya que no tienen soporte para actualizaciones) y si el reporte es solucionado, Microsoft le dara una cantidad de dinero al usuario que ha reportado dicho error.  Las versiones de prueba son muy diferentes a las originales, puesto que no se comercializan y que tienen nombres distintos. Por ejemplo, la version que se utilizo para crear Windows 95, fue nominada \"Chicago\". Estos nombres tambien se suelen llamar \"Codenames\". En algunas versiones de prueba (como Windows 8 BETA), no llevan un respectivo codename, y por este motivo llevan el nombre de la proxima version de Windows de la respectiva version de pruebas, junto a su indicador \"Beta\".  5 a\u00f1os y 10 meses  Una de las principales criticas que reciben los sistemas operativos Windows es la debilidad del sistema en lo que a seguridad se refiere y el alto indice de vulnerabilidades criticas. El propio Bill Gates, fundador de Microsoft, ha asegurado en repetidas ocasiones que la seguridad es objetivo primordial para su empresa.\u200b  Partiendo de la base de que no existe un sistema completamente libre de errores, las criticas se centran en la lentitud con la que la empresa reacciona ante un problema de seguridad que puede llegar a meses\u200b\u200b\u200b\u200b o incluso a\u00f1os\u200b\u200b de diferencia desde que se avisa de la vulnerabilidad hasta que se publica un parche.  En algunos casos la falta de respuesta por parte de Microsoft\u200b\u200b ha provocado que se desarrollen parches que arreglan problemas de seguridad hechos por terceros.\u200b  Uno de los pilares en que se basa la seguridad de los productos Windows es la seguridad por ocultacion, en general, un aspecto caracteristico del software propietario que sin embargo parece ser uno de los responsables de la debilidad de este sistema operativo ya que, la propia seguridad por ocultacion, constituye una infraccion del principio de Kerckhoff, el cual afirma que la seguridad de un sistema reside en su dise\u00f1o y no en una supuesta ignorancia del dise\u00f1o por parte del atacante.\u200b  El 6 de enero de 2005, Microsoft lanzo una version Beta de Microsoft AntiSpyware, basado en Giant AntiSpyware publicado anteriormente. El 14 de febrero de 2006, Microsoft AntiSpyware se convirtio en Windows Defender con el lanzamiento de la Beta 2. Windows Defender era un programa dise\u00f1ado para proteger contra programas espia y otro software no deseado. Los usuarios de Windows XP y Windows Server 2003 que tienen copias originales de Microsoft Windows pueden descargar libremente el programa desde el sitio web de Microsoft y Windows Defender se suministra como parte de Windows Vista y Windows 7. Windows Defender y Microsoft Security Essentials se han combinado en un solo programa, denominado Windows Defender. Sus caracteristicas y la interfaz de usuario se basan en Microsoft Security Essentials. Asi mismo, Windows Defender se transformo en un programa antivirus y Spyware. A pesar de que esta activada de forma predeterminada, se puede desactivar para utilizar otra solucion antivirus.  En todas las versiones de Windows con NT 3 se han basado en un sistema de permisos de sistema de archivos denominado AGDLP (cuentas, Global, Local, permisos) AGLP que en esencia donde se aplican los permisos de archivo a la carpeta en forma de un grupo local que luego tiene otros 'grupos globales' como miembros. Estos grupos globales mantienen otros grupos o a usuarios segun las diferentes versiones de Windows que utiliza. Este sistema varia de otros productos de proveedores tales como Linux y NetWare debido a la 'estatica' asignacion de permiso se aplica directorio para el archivo o carpeta. Sin embargo con este proceso de AGLP/AGDLP/AGUDLP permite a un peque\u00f1o numero de permisos estaticos para aplicarse y permite cambios faciles a los grupos de cuentas sin volver a aplicar los permisos de archivo de los archivos y carpetas.  Las siguientes aplicaciones son las que trae pre-instaladas los sistemas operativos Windows 10 y Windows 11.  Microsoft fue demandado por el gobierno de Estados Unidos durante el a\u00f1o 1998 por competencia desleal, y especialmente por la inclusion del navegador Internet Explorer en su version Windows 95.\u200b Tras esta denuncia, la pena le conllevo a Microsoft lanzar una version de Windows 95 sin su navegador de Internet.  En 2000 Windows ME se convirtio en un blanco de criticas debido a sus constantes fallos del sistema, que terminaban con un pantallazo azul en la mayoria de los casos, ademas de consumir mayores recursos de lo que se decia. PC World incluso posiciono a Windows ME el cuarto \"peor producto tecnologico\" de la historia en el articulo \u00abTop 25 de los peores productos tecnologicos\u00bb.  En 2004 Microsoft lanzo una campa\u00f1a, llamada \u00abVayamos a los hechos\u00bb, en la que mostraba cientos de empresas conocidas que migraron de GNU/Linux a Windows Server y aumentaron su productividad y otro tipo de comparativas,\u200b aunque la cerro poco despues, en 2007.\u200b Los defensores de GNU/Linux desarrollaron su propio estudio argumentando que, en contra de uno de los reclamos de Microsoft, GNU/Linux tiene menores costos administrativos que servidores basados en Windows.\u200b Otro estudio realizado por el Yankee Group afirma que la actualizacion desde una version de Windows Server a otra plataforma tiene un costo inferior al de cambiar de GNU/Linux a Windows Server.\u200b\u200b  Contenido relacionado: ","snippet":"Windows es el nombre de una familia de distribuciones de software para PC, servidores, sistemas empotrados y antiguamente telefonos inteligentes desarrollados y vendidos por Microsoft y disponibles pa","enlaces_salientes":["Microsoft_Windows","Microsoft_Windows","Microsoft_Windows","Windows_(desambiguaci%C3%B3n)","Windows_NT","Sistema_operativo","Desarrollador_de_software","Microsoft","Ingenier%C3%ADa_de_software","Software_propietario","Shared_Source","Licencia_de_software","EULA","Idioma","Multiling%C3%BCe","Lenguaje_de_programaci%C3%B3n","C_(lenguaje_de_programaci%C3%B3n)","C%2B%2B","Lenguaje_ensamblador","N%C3%BAcleo_monol%C3%ADtico","MS-DOS","N%C3%BAcleo_h%C3%ADbrido","Windows_NT","Plataforma_(inform%C3%A1tica)","Arquitectura_ARM","Arquitectura_Intel_Itanium","MIPS_(procesador)","DEC_Alpha","PowerPC","X86","Interfaz_gr%C3%A1fica_de_usuario","Windows_Shell","CShell","Parche_(inform%C3%A1tica)","Windows_Update","Microsoft_Store_(software)","WSUS","Ciclo_de_vida_del_lanzamiento_de_software","Windows_11","Ciclo_de_vida_del_lanzamiento_de_software","4_de_abril","2019","Windows_NT","MS-DOS","Distribuci%C3%B3n_de_software","Software","Computadora_personal","Servidores","Sistemas_empotrados","Tel%C3%A9fono_inteligente","Microsoft","X86","X86-64","X64","Arquitectura_ARM","Sistemas_operativos","MS-DOS","Windows_NT","Software","Sistema_operativo","Distribuci%C3%B3n_de_software","1985","MS-DOS","GUI","Computador","Mac_OS","1984","Windows_11","Computadora_de_escritorio","Windows_NT","Windows_10_Mobile","Dispositivos_m%C3%B3viles","Windows_2.1x","1985","Interfaz_gr%C3%A1fica_de_usuario","MS-DOS","L%C3%ADnea_de_comandos","Windows_10","Windows_7","Windows_8","Windows_8.1","Windows_11","Windows_Update","Windows_10X","BIOS","1985","Apple","1988","Apple_Inc.","1990","1995","Windows_95","Windows_3.1","MS-DOS","1998","Windows_98","1999","Windows_2000","2000","Windows_XP","DVD","Windows_Vista","Windows_7","Windows_8","Microsoft_Office","Windows_10","Microsoft_Edge","Microsoft_Cortana","Windows_7","Windows_8.1","Windows_11","Fluent_Design","Men%C3%BA_Inicio","Barra_de_tareas","MacOS","Fases_del_desarrollo_de_software","Windows_11","Windows_1.0","Windows_2.0","Windows_3.0","Windows_3.x","Windows_95","Windows_98","Windows_2000","Windows_Me","Windows_XP","Windows_Vista","Windows_7","Windows_8","Windows_8.1","Windows_10","Windows_11","Seguridad_inform%C3%A1tica","Agujero_de_seguridad","Bill_Gates","Error_de_software","Parche_(inform%C3%A1tica)","Seguridad_por_ocultaci%C3%B3n","Software_propietario","Principio_de_Kerckhoff","Windows_Defender","Windows_Defender","Programa_esp%C3%ADa","Windows_XP","Windows_Server_2003","Windows_Vista","Windows_7","Microsoft_Security_Essentials","Windows_10","Windows_11","Calculadora_(Windows)","Microsoft_Cortana","Groove_M%C3%BAsica","Reproductor_multimedia_(Windows_11)","Mapas","Microsoft_Edge","Microsoft_Store_(software)","OneDrive","Microsoft_OneNote","Paint_3D","Pel%C3%ADculas_y_programas_de_TV_de_Microsoft","Skype","Xbox_(marca)","Bloc_de_notas","Internet_Explorer","Navegador_web","Internet","Microsoft","Windows","1995","Mosaic","Spyglass","Netscape_Navigator","JavaScript","Windows","Microsoft","Monopolio","Microsoft_Edge","Navegador_web","Internet","Microsoft","Windows","Chromium_(navegador)","Google","Open_Source","Mapa_de_caracteres_(Windows)","Microsoft_Paint","Microsoft","Windows_1.0","Windows_3.11","Microsoft","Windows","Windows_95","Paint_3D","Windows_10","Reproductor_de_Windows_Media","Windows_Media_Player_12","Windows","Windows","Windows_8.1","Windows_Journal","WordPad","Microsoft_Works","Microsoft_Word","Internet_Explorer","Windows_95","Windows_ME","Pantalla_azul_de_la_muerte","PC_World","GNU/Linux","Computadora","Sistema_operativo","Microsoft","Arquitectura_de_Windows_NT","Explorador_de_Windows","Microsoft_Surface","Windows_Genuine_Advantage","Windows_Media","Windows_Phone","Wintel","Microsoft","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","Biblioteca_Nacional_de_Francia","Biblioteca_de_Catalu%C3%B1a","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","BIBSYS","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Paradigma_de_programaci%C3%B3n","titulo":"Paradigma de programacion","contenido":"Se denominan paradigmas de programacion a las formas de clasificar los lenguajes de programacion en funcion de sus caracteristicas. Los idiomas se pueden clasificar en multiples paradigmas.  Algunos paradigmas se ocupan principalmente de las implicancias para el modelo de ejecucion del lenguaje, como permitir efectos secundarios o si la secuencia de operaciones esta definida por el modelo de ejecucion. Otros paradigmas se refieren principalmente a la forma en que se organiza el codigo, como agrupar un codigo en unidades junto con el estado que modifica el codigo. Sin embargo, otros se preocupan principalmente por el estilo de la sintaxis y la gramatica.  Los paradigmas de programacion comunes incluyen:\u200b\u200b\u200b  Las tecnicas simbolicas como la reflexion, que permiten que el programa se refiera a si mismo, tambien pueden ser consideradas como un paradigma de programacion. Sin embargo, esto es compatible con los principales paradigmas y, por lo tanto, no es un paradigma real por derecho propio.  Por ejemplo, los lenguajes que caen en el paradigma imperativo tienen dos caracteristicas principales: establecen el orden en el que ocurren las operaciones, con construcciones que controlan explicitamente ese orden, y permiten efectos secundarios, en los que el estado puede modificarse en un momento determinado, dentro de una unidad de codigo, y luego leer en un momento diferente dentro de una unidad de codigo diferente. La comunicacion entre las unidades de codigo no es explicita. Mientras tanto, en la programacion orientada a objetos, el codigo se organiza en objetos que contienen un estado que solo es modificado por el codigo que forma parte del objeto. La mayoria de los lenguajes orientados a objetos tambien son lenguajes imperativos. Por el contrario, los lenguajes que se ajustan al paradigma declarativo no indican el orden en el que ejecutar las operaciones. En su lugar, proporcionan una serie de operaciones disponibles en el sistema, junto con las condiciones en las que se permite que se ejecute cada una. La implementacion del modelo de ejecucion del lenguaje rastrea que operaciones son libres de ejecutar y elige el orden en forma independiente. Mas en Comparacion de lenguajes de programacion de multiples paradigmas.  El desarrollo de lenguajes procedurales dio lugar a lenguajes sirven de vocabulario relacionado con el problema a resolver. Ejemplos de estos lenguajes son:  Todos estos lenguajes siguen un paradigma procedural. Describen, paso a paso, exactamente el proceso que debe seguirse para resolver un problema especifico. La eficacia y eficiencia de cada solucion dependen de la experiencia, la inventiva y la habilidad del programador.  Algunos investigadores de lenguajes de programacion critican la nocion de paradigmas como clasificacion de los lenguajes de programacion, por ejemplo Harper,\u200b y Krishnamurthi.\u200b Sostienen que muchos lenguajes de programacion no pueden clasificarse estrictamente en un paradigma, sino que incluyen caracteristicas de varios paradigmas.  A lo largo del tiempo se han desarrollado diferentes enfoques de programacion, que se han identificado como tales en su momento o retrospectivamente. Uno de los primeros enfoques conscientemente identificado como tal es la programacion estructurada, defendida desde mediados de la decada de 1960. El concepto de \"paradigma de programacion\" como tal data al menos de 1978, en la conferencia Premio Turing de Robert W. Floyd, titulada Los paradigmas de la programacion, que cita la nocion de paradigma utilizada por Thomas Kuhn en su La estructura de las revoluciones cientificas (1962).\u200b Los primeros lenguajes de programacion no tenian paradigmas de programacion claramente definidos y a veces los programas hacian un uso extensivo de las sentencias goto, el uso liberal de estas sentencias conducia a \"codigo espagueti\" con el que era dificil trabajar. Esto llevo al desarrollo de paradigmas de programacion estructurados que no permitian el uso de sentencias goto y solo permitian el uso de construcciones de programacion claramente definidas.\u200b  Los paradigmas de programacion de nivel mas bajo son el codigo maquina, que representa directamente el instrucciones (el contenido de la memoria del programa) como una secuencia de numeros, y el lenguaje ensamblador, en el que las instrucciones de la maquina se representan mediante mnemonicos y las  direcciones de memoria pueden recibir etiquetas simbolicas. A veces se denominan primera generacion y segunda generacion.  En la decada de 1960, los lenguajes ensambladores se desarrollaron para soportar COPIADO de bibliotecas y capacidades de generacion y preprocesamiento de macros condicionales bastante sofisticadas, LLAMADAS a (subrutinas), variables externas y secciones comunes (globales), permitiendo una reutilizacion significativa del codigo y el aislamiento de las especificidades del hardware mediante el uso de operadores logicos como READ/WRITE/GET/PUT. El ensamblador se utilizaba, y aun se utiliza, en sistemas en los que el tiempo es un factor critico y, a menudo, en sistemas embebidos, ya que ofrece el control mas directo de lo que hace la maquina.  Tras el uso generalizado de los lenguajes procedimentales, se crearon los lenguajes de programacion orientada a objetos (POO), como Simula, Smalltalk, C++, Eiffel, Python, PHP, Java, y C#. En estos lenguajes, los datos y los metodos para manipularlos se mantienen como una unidad llamada object.  Con una perfecta encapsulacion, una de las caracteristicas distintivas de la programacion orientada a objetos, la unica forma de que otro objeto o usuario pueda acceder a los datos es a traves de los  metodos del objeto. Asi, el funcionamiento interno de un objeto puede ser cambiado sin afectar a ningun codigo que utilice el objeto. Todavia existe cierta controversia planteada por Alexander Stepanov, Richard Stallman\u200b y otros programadores, sobre la eficacia del paradigma de programacion orientada a objetos frente al paradigma procedimental. La necesidad de que cada objeto tenga metodos asociativos lleva a algunos escepticos a asociar la POO con hinchazon del software; un intento de resolver este dilema llego a traves del polimorfismo.  Dado que la programacion orientada a objetos se considera un paradigma, no un lenguaje, es posible crear incluso un lenguaje ensamblador orientado a objetos. Ensamblador de alto nivel (HLA) es un ejemplo de esto que soporta completamente tipos de datos avanzados y programacion en lenguaje ensamblador orientada a objetos\u00a0\u2013  a pesar de sus origenes tempranos. Por lo tanto, los diferentes paradigmas de programacion pueden verse mas bien como  memes motivacionales de sus defensores, en lugar de representar necesariamente el progreso de un nivel al siguiente. Las comparaciones precisas de la eficacia de los paradigmas en competencia a menudo son mas dificiles debido a la terminologia nueva y diferente aplicada a entidades y procesos similares, junto con numerosas distinciones de implementacion entre idiomas.  La programacion literaria, como una forma de programacion imperativa, estructura los programas como una red centrada en el ser humano, como en un ensayo de hipertexto: la documentacion es parte integral del programa, y el programa se estructura siguiendo la logica de la exposicion en prosa, en lugar de la conveniencia del compilador.  Independientemente de la rama imperativa, se desarrollaron paradigmas de programacion declarativa. En estos lenguajes, se le dice al ordenador cual es el problema, no como resolverlo\u00a0\u2013  el programa se estructura como un conjunto de propiedades a encontrar en el resultado esperado, no como un procedimiento a seguir. Dada una base de datos o un conjunto de reglas, el ordenador intenta encontrar una solucion que cumpla todas las propiedades deseadas. Un arquetipo de lenguaje declarativo es el lenguaje de cuarta generacion SQL. SQL, y la familia de los lenguajes funcionales y la programacion logica.  La programacion funcional es un subconjunto de la programacion declarativa. Los programas escritos con este paradigma utilizan funciones, bloques de codigo destinados a comportarse como  funciones matematicas. Los lenguajes funcionales desalientan los cambios en el valor de las variables a traves de asignacion, haciendo un gran uso de  recursion en su lugar.  El paradigma de programacion logica considera la computacion como razonamiento automatizado sobre un cuerpo de conocimiento. Los hechos sobre el dominio del problema se expresan como formulas logicas, y los programas se ejecutan aplicando reglas de inferencia sobre ellas hasta que se encuentra una respuesta al problema, o se demuestra que el conjunto de formulas es inconsistente.  La programacion simbolica es un paradigma que describe programas capaces de manipular formulas y componentes del programa como datos.\u200b Los programas pueden modificarse a si mismos y parecer que \"aprenden\", lo que los hace adecuados para aplicaciones como la inteligencia artificial, los  sistemas expertos, el procesamiento del lenguaje natural y los juegos de ordenador.  Los lenguajes que soportan este paradigma incluyen Lisp y Prolog.\u200b  La programacion diferenciable estructura los programas para que puedan ser diferenciados en todo momento, normalmente mediante diferenciacion automatica.\u200b\u200b  La mayoria de lenguajes de programacions soportan mas de un paradigma de programacion para permitir a los programadores utilizar el estilo de programacion mas adecuado y las construcciones del lenguaje asociadas para un trabajo determinado.\u200b  Asi como la ingenieria de software (como proceso) se define mediante diferentes metodologias, los lenguajes de programacion (como modelos de computacion) se definen mediante diferentes paradigmas. Algunos lenguajes estan dise\u00f1ados para admitir un paradigma (Smalltalk admite programacion orientada a objetos, Haskell admite programacion funcional), mientras que otros lenguajes de programacion admiten multiples paradigmas (como Object Pascal, C++, Java, JavaScript, C#, Scala, Visual Basic, Common Lisp, Scheme, Perl, PHP, Python, Ruby, Oz y F# ). Por ejemplo, los programas escritos en C ++, Object Pascal o PHP pueden ser puramente procedimentales, puramente orientados a objetos o pueden contener elementos de ambos u otros paradigmas. Los dise\u00f1adores y programadores de software deciden como utilizar esos elementos paradigmaticos.  En la programacion orientada a objetos, los programas se tratan como un conjunto de objetos que interactuan. En la programacion funcional, los programas se tratan como una secuencia de evaluaciones de funciones sin estado. Cuando se programan computadoras o sistemas con muchos procesadores, en la programacion orientada a procesos, los programas se tratan como conjuntos de procesos concurrentes que actuan sobre estructuras de datos compartidas logicas.  Muchos paradigmas de programacion son tan conocidos por las tecnicas que prohiben como por las que habilitan. Por ejemplo, la programacion funcional pura no permite el uso de efectos secundarios, mientras que la programacion estructurada no permite el uso de la instruccion \"go to\". En parte por esta razon, los nuevos paradigmas a menudo son considerados doctrinarios o demasiado rigidos por quienes estan acostumbrados a estilos anteriores.\u200b Sin embargo, evitar ciertas tecnicas puede facilitar la comprension del comportamiento del programa y demostrar teoremas sobre la correccion del programa.  Los paradigmas de programacion tambien se pueden comparar con modelos de programacion, lo que permite invocar un modelo de ejecucion utilizando solo una API. Los modelos de programacion tambien se pueden clasificar en paradigmas segun las caracteristicas del modelo de ejecucion.  Para la computacion paralela, es comun usar un modelo de programacion en lugar de un lenguaje. La razon es que los detalles del hardware paralelo se filtran en las abstracciones utilizadas para programar el hardware. Esto hace que el programador tenga que mapear patrones en el algoritmo sobre patrones en el modelo de ejecucion (que se han insertado debido a una fuga de hardware en la abstraccion). Como consecuencia, ningun lenguaje de programacion paralelo se adapta bien a todos los problemas de calculo. Por lo tanto, es mas conveniente utilizar un lenguaje secuencial base e insertar llamadas a la API en modelos de ejecucion paralela a traves de un modelo de programacion. Dichos modelos de programacion paralela se pueden clasificar de acuerdo con abstracciones que reflejan el hardware, como la memoria compartida, la memoria distribuida con paso de mensajes, nociones de lugar visibles en el codigo, etc. Estos pueden considerarse sabores del paradigma de programacion que se aplican solo a lenguajes y modelos de programacion paralelos. ","snippet":"Se denominan paradigmas de programacion a las formas de clasificar los lenguajes de programacion en funcion de sus caracteristicas. Los idiomas se pueden clasificar en multiples paradigmas.  Algunos p","enlaces_salientes":["Paradigma_de_programaci%C3%B3n","Paradigma_de_programaci%C3%B3n","Paradigma_de_programaci%C3%B3n","Lenguajes_de_programaci%C3%B3n","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_por_procedimientos","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_declarativa","Programaci%C3%B3n_funcional","Programaci%C3%B3n_l%C3%B3gica","COBOL","Fortran","ALGOL","PL/I","BASIC","Lenguaje_C","Eficacia","Eficiencia_algor%C3%ADtmica","Programaci%C3%B3n_estructurada","Premio_Turing","Robert_W._Floyd","Thomas_Kuhn","La_estructura_de_las_revoluciones_cient%C3%ADficas","C%C3%B3digo_espagueti","Lenguaje_de_bajo_nivel","C%C3%B3digo_m%C3%A1quina","Conjunto_de_instrucciones","Lenguaje_ensamblador","Direcci%C3%B3n_de_memoria","Subrutina","Sistemas_embebidos","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_orientada_a_objetos","Simula","Smalltalk","C%2B%2B","Eiffel_(lenguaje_de_programaci%C3%B3n)","Python_(lenguaje_de_programaci%C3%B3n)","PHP","Java_(lenguaje_de_programaci%C3%B3n)","C_Sharp","Datos","Objeto_(inform%C3%A1tica)","Encapsulamiento_(inform%C3%A1tica)","M%C3%A9todo_(inform%C3%A1tica)","Programaci%C3%B3n_orientada_a_objetos#Cr\u00edtica","Richard_Stallman","Software_inflado","Polimorfismo_(inform%C3%A1tica)","Ensamblador_de_alto_nivel","Meme_(cultura)","Programaci%C3%B3n_literaria","Programaci%C3%B3n_imperativa","Hipertexto","Programaci%C3%B3n_declarativa","SQL","SQL","Programaci%C3%B3n_funcional","Subrutinas","Funci%C3%B3n_(matem%C3%A1tica)","Recursi%C3%B3n_(ciencias_de_computaci%C3%B3n)","Programaci%C3%B3n_l%C3%B3gica","Razonamiento_automatizado","Reglas_de_inferencia","Inteligencia_artificial","Sistema_experto","Procesamiento_del_lenguaje_natural","Prolog","Derivada","Diferenciaci%C3%B3n_autom%C3%A1tica","Lenguajes_de_programaci%C3%B3n","Ingenier%C3%ADa_de_software","Lenguajes_de_programaci%C3%B3n","Smalltalk","Haskell","Object_Pascal","C%2B%2B","Java_(lenguaje_de_programaci%C3%B3n)","JavaScript","C_Sharp","Scala_(lenguaje_de_programaci%C3%B3n)","Visual_Basic","Common_Lisp","Scheme","Perl","PHP","Python","Ruby","Oz_(lenguaje_de_programaci%C3%B3n)","F","Paso_de_mensajes","Semantic_Scholar","Digital_object_identifier","Digital_object_identifier","ISBN","Mozilla_Foundation","ISBN","Semantic_Scholar","Digital_object_identifier","Programaci%C3%B3n","Lenguaje_de_programaci%C3%B3n","Control_de_autoridades","Gemeinsame_Normdatei"]}
{"url":"Programaci%C3%B3n_visual","titulo":"Programacion visual","contenido":"El termino programacion visual (Visual programming language, VPL) refiere a la programacion en la que se utiliza mas de una dimension para expresar la semantica.\u200b Los lenguajes de programacion visual permiten a los usuarios crear programas mediante la manipulacion de elementos graficos, en lugar de especificarlos exclusivamente de manera textual.\u200b Este tipo de lenguajes son muy utilizados en ambitos educativos\u200b a traves de los denominados entornos de programacion por bloques (entre los que se destaca Scratch) que permiten reducir las dificultades que enfrentan los principiantes cuando empiezan a programar. HyperCard de Apple fue probablemente el primer ejemplo de un entorno de programacion visual.\u200b  Este estilo de programacion presenta las siguientes caracteristicas:  Los programadores suelen utilizar elementos de programacion ya definidos, segun el lenguaje de programacion visual que utilicen. Los elementos de programacion estan dise\u00f1ados para encajar como las piezas de un puzle. Si los elementos no encajan logicamente, el editor lo detecta. Los elementos de programacion suelen agruparse en grupos de colores, lo que orienta al usuario a la hora de elegirlos.  Estos pueden registrar textos e imagenes, organizarlos de forma logica y modificar su apariencia o su expresion. Los elementos de control permiten insertar acciones que dependen de ciertas condiciones.\u200b  La programacion por bloques o programacion orientada a bloques usa una metafora de \"primitiva de programacion como pieza de rompecabezas\" como una forma de dar indicios visuales al usuario acerca de como y donde pueden ser usadas las instrucciones del lenguaje. Escribir un programa en un entorno basado en bloques consiste entonces en arrastrar y soltar las instrucciones una junto a otra. Si las dos instrucciones no pueden unirse en una declaracion valida, entonces el entorno evita que puedan encastrar juntas. De esta forma, los entornos de programacion por bloques pueden prevenir errores de sintaxis reteniendo la practica de crear programas ensamblando las instrucciones una por una.\u200b  En estos ambientes predomina el uso del raton, que se usa para encastrar las instrucciones con otras. Generalmente se da un feedback visual o auditivo informando al usuario si la construccion es valida. Ademas, hay indicios visuales de como usar el bloque: la forma sugiere donde puede encajar (al principio, dentro de otro, etc), el color indica la categoria de bloque (por ejemplo en Scratch: control, movimiento, etc) y a veces se cuenta con una etiqueta en lenguaje natural que indica que hace el bloque.\u200b  Existen librerias como Blockly que permiten la creacion de herramientas de edicion de codigo por bloques. No deben confundirse con los lenguajes de programacion por bloques, ya que las librerias son las que aportan la funcionalidad para editar, mientras que los lenguajes definen el conjunto de instrucciones posibles, su sintaxis, etc.  Los editores por bloques son un subconjunto de los llamados \"editores estructurados\", donde la unidad de trabajo minima es un nodo del arbol de sintaxis del lenguaje. Esto brinda mas flexibilidad que usar bloques funcionales completos y es menos proclive a errores que operar con unidades menores como caracteres.\u200b  Algunos entornos de programacion por bloques que tienen sus propios lenguajes son Scratch, Scratch Jr, Snap!\u200b y StarLogo\u200b.  Otros editores ayudan a la generacion de codigo para hacer mas accesibles plataformas como Android (App Inventor) o Arduino (Hello Blocks!\u200b, Ardublock\u200b, ArduinoBlocks\u200b). Open Roberta permite generar codigo para multiples plataformas de programacion de robots (Arduino, Lego Mindstorms, Micro Bit).  Otra libreria de programacion por bloques, basada en Blockly, es Roboblocks\u200b, un repositorio de bloques para hacer editores de Arduino.  En un curso de programacion, el objetivo es desarrollar habilidades de resolucion de problemas usando programacion. Sin embargo, los estudiantes suelen presentar grandes dificultades para entender y aplicar conceptos abstractos en problemas concretos.  Algunas de las razones son las siguientes:\u200b  La programacion basada en bloques fue creada para evitar estos problemas en el aprendizaje, ya que evitan los errores sintacticos, permiten al estudiante desarrollar pensamiento logico y creativo a traves de diversas actividades (juegos, musica), y permiten la visualizacion de la ejecucion de los algoritmos.\u200b  Existen entornos completos que favorecen el aprendizaje acompa\u00f1ado por secuencias didacticas, como PilasBloques.\u200b  La programacion por bloques es un desafio que se ha usado como tema para videojuegos de logica, como es el caso de Human Resource Machine, y su secuela 7 Billion Humans de Tomorrow Corporation.  En los juegos mencionados se requiere resolver desafios en una version en bloques de un lenguaje similar al lenguaje ensamblador que se usa para programar procesadores, en una empresa donde los robots hacen trabajar a los humanos siguiendo instrucciones.\u200b    ","snippet":"El termino programacion visual (Visual programming language, VPL) refiere a la programacion en la que se utiliza mas de una dimension para expresar la semantica.\u200b Los lenguajes de programacion visual ","enlaces_salientes":["Programaci%C3%B3n_visual","Programaci%C3%B3n_visual","Programaci%C3%B3n_visual","Programaci%C3%B3n","Sem%C3%A1ntica","Lenguaje_de_programaci%C3%B3n","Programa_inform%C3%A1tico","Scratch_(lenguaje_de_programaci%C3%B3n)","HyperCard","Apple","Rompecabezas","Clase_(inform%C3%A1tica)","Objeto_(programaci%C3%B3n)","Programaci%C3%B3n_orientada_a_objetos","Lenguaje_Unificado_de_Modelado","Visual_Basic","Borland_Delphi","Scratch_Jr","Instrucci%C3%B3n_(inform%C3%A1tica)","Arrastrar_y_soltar","Rat%C3%B3n_(inform%C3%A1tica)","Scratch_(lenguaje_de_programaci%C3%B3n)","Scratch_(lenguaje_de_programaci%C3%B3n)","Blockly","Arbol_de_sintaxis","Subrutina","Scratch_(lenguaje_de_programaci%C3%B3n)","Scratch_Jr","Android","App_Inventor","Arduino","Open_Roberta","Lego_Mindstorms","Micro_Bit","Ministerio_de_Educaci%C3%B3n_(Argentina)","Secuencia_did%C3%A1ctica","Videojuego_de_l%C3%B3gica","7_Billion_Humans","Lenguaje_ensamblador","Procesador_(informatica)","Diagrama_de_flujo","Gambas","Lenguaje_Unificado_de_Modelado","VisSim","ISBN","Digital_object_identifier","ISSN","Digital_object_identifier","ISSN","Digital_object_identifier","ISBN","Digital_object_identifier","ISSN","Digital_object_identifier","Control_de_autoridades","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Programaci%C3%B3n_modular","titulo":"Programacion modular","contenido":"La programacion modular es un paradigma de programacion que consiste en dividir un programa en modulos o subprogramas con el fin de hacerlo mas legible y manejable  Se presenta historicamente como una evolucion de la programacion estructurada para solucionar problemas de programacion mas grandes y complejos de lo que esta puede resolver.  Al aplicar la programacion modular, un problema complejo debe ser dividido en varios subprogramas mas simples, y estos a su vez en otros subprogramas mas simples aun. Esto debe hacerse hasta obtener subprogramas lo suficientemente simples como para poder ser resueltos facilmente con algun lenguaje de programacion. Esta tecnica se llama refinamiento sucesivo, divide y venceras o analisis descendente (Top-Down).  Un 'modulo' es cada una de las partes de un programa que resuelve uno de los subproblemas en que se divide el problema complejo original. Cada uno de estos modulos tiene una tarea bien definida y algunos necesitan de otros para poder operar. En caso de que un modulo necesite de otro, puede comunicarse con este mediante una interfaz de comunicacion que tambien debe estar bien definida.  Si bien un modulo puede entenderse como una parte de un programa en cualquiera de sus formas y variados contextos, en la practica se los suele tomar como sinonimos de procedimientos y funciones. Pero no necesaria ni estrictamente un modulo es una funcion o un procedimiento, ya que el mismo puede contener muchos de ellos. No debe confundirse el termino \"modulo\" (en el sentido de programacion modular) con terminos como \"funcion\" o \"procedimiento\", propios del lenguaje que lo soporte. ","snippet":"La programacion modular es un paradigma de programacion que consiste en dividir un programa en modulos o subprogramas con el fin de hacerlo mas legible y manejable  Se presenta historicamente como una","enlaces_salientes":["Programaci%C3%B3n_modular","Programaci%C3%B3n_modular","Programaci%C3%B3n_modular","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n_estructurada","Algoritmo_divide_y_vencer%C3%A1s","Subrutina","Funci%C3%B3n_(programaci%C3%B3n)","M%C3%B3dulo_(programaci%C3%B3n)","Modularidad","Dise%C3%B1o_estructurado","Programaci%C3%B3n_estructurada","Programaci%C3%B3n_por_procedimientos","Programaci%C3%B3n_orientada_a_objetos","Programaci%C3%B3n_orientada_a_aspectos","Ingenier%C3%ADa_de_software_basada_en_componentes","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_Israel"]}
{"url":"Programaci%C3%B3n_orientada_a_aspectos","titulo":"Programacion orientada a aspectos","contenido":"La Programacion Orientada a Aspectos o POA (en ingles: aspect-oriented programming) es un paradigma de programacion que permite una adecuada modularizacion de las aplicaciones y posibilita una mejor separacion de responsabilidades  (Obligacion o correspondencia de hacer algo).  Gracias a la POA se pueden encapsular los diferentes conceptos que componen una aplicacion en entidades bien definidas, eliminando las dependencias entre cada uno de los modulos. De esta forma se consigue razonar mejor sobre los conceptos, se elimina la dispersion del codigo y las implementaciones resultan mas comprensibles, adaptables y reusables. Varias tecnologias con nombres diferentes se encaminan a la consecucion de los mismos objetivos y asi, el termino POA es usado para referirse a varias tecnologias relacionadas como los metodos adaptativos, los filtros de composicion, la programacion orientada a sujetos o la separacion multidimensional de competencias.  El principal objetivo de la POA es la separacion de las funcionalidades dentro del sistema:  Cada funcionalidad comun se encapsulara en una entidad.  Muchas veces nos encontramos, a la hora de programar, con problemas que no podemos resolver de una manera adecuada con las tecnicas habituales usadas en la programacion imperativa o en la programacion orientada a objetos. Con estas, nos vemos forzados a tomar decisiones de dise\u00f1o que repercuten de manera importante en el desarrollo de la aplicacion y que nos alejan con frecuencia de otras posibilidades.  A menudo, hace falta escribir lineas de codigo que estan distribuidas por toda o gran parte de la aplicacion, para definir la logica de cierta propiedad o comportamiento del sistema, con las consecuentes dificultades de mantenimiento y desarrollo. En ingles este problema se conoce como scattered code, que podriamos traducir como codigo disperso. Otro problema que puede aparecer, es que un mismo modulo implemente multiples comportamientos o aspectos del sistema de forma simultanea. En ingles este problema se conoce como tangled code, que podriamos traducir como codigo enmara\u00f1ado. El hecho es que hay ciertas decisiones de dise\u00f1o que son dificiles de capturar, debido a que determinados problemas no se pueden encapsular claramente de igual forma que los que habitualmente se resuelven con funciones u objetos.  AspectC++ es un compilador que permite desarrollar aspectos en C++.  AspectJ es una extension Java del proyecto Eclipse para ayudar en el desarrollo orientado a aspectos.  Aspect, un modulo Perl disponible en CPAN para la Programacion Orientada a Aspectos (en ingles).  PHP-AOP (AOP.io) es una lib que proporciona todo el paradigma de la POA en PHP.  phpAspect es una extension PHP para implementar el paradigma de la POA, que, mediante arboles de decision XML, realiza el weaving del software para ser ejecutado como PHP estandar.  FLOW3 es un framework MVC de PHP incluye un modulo para poder realizar Programacion orientada a Aspectos en nuevos desarrollos.  AOP con SpringFramework 2.5 es un Framework de Java que permite programar en el paradigma de Aspectos utilizando Anotacion Java.  Aspyct AOP es un modulo de Python que permite incluir Programacion orientada a Aspectos a programas ya existentes escritos en Python o a nuevos desarrollos.  Paginas de personas involucradas en la investigacion de la POA: ","snippet":"La Programacion Orientada a Aspectos o POA (en ingles: aspect-oriented programming) es un paradigma de programacion que permite una adecuada modularizacion de las aplicaciones y posibilita una mejor s","enlaces_salientes":["Programaci%C3%B3n_orientada_a_aspectos","Programaci%C3%B3n_orientada_a_aspectos","Programaci%C3%B3n_orientada_a_aspectos","Idioma_ingl%C3%A9s","Paradigma_de_programaci%C3%B3n","Programaci%C3%B3n","Programaci%C3%B3n_imperativa","Programaci%C3%B3n_orientada_a_objetos","Idioma_ingl%C3%A9s","Lenguaje_de_programaci%C3%B3n_C%2B%2B","AspectJ","Lenguaje_de_programaci%C3%B3n_Java","Eclipse_(software)","Perl","CPAN","Framework","PHP","Framework","Lenguaje_de_programaci%C3%B3n_Java","Anotaci%C3%B3n_Java","Python","Python","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel"]}
{"url":"Programaci%C3%B3n_a_nivel_funcional","titulo":"Programacion a nivel funcional","contenido":"La programacion a nivel funcional es uno de los dos paradigmas contrastantes identificados por John Backus en su trabajo sobre los programas como objetos matematicos, siendo el otro la programacion a nivel de valores.  En su discurso de aceptacion del Premio Turing en 1977, Backus describio lo que considera como la necesidad de un cambio a una filosofia diferente en el dise\u00f1o de lenguajes de programacion:  El lenguaje de programacion FP fue el primer lenguaje dise\u00f1ado especificamente para dar soporte al estilo de programacion a nivel funcional.  Un programa de nivel funcional no necesita la nocion de variable, dado que las variables, que son elemento esencial en las definiciones a nivel de valores, no hacen falta en el nivel funcional.  En el estilo de programacion de nivel funcional los programas se escriben como combinacion de otros programas con la ayuda de los operaciones de construccion de programas o funcionales.  Bajo este enfoque los programas, con los funcionales como operadores, forman un espacio matematico.  Otra ventaja potencial de este enfoque es la posibilidad de restringirse unicamente a las funciones estrictas y asociarles un mecanismo de evaluacion por valor. que es el mas sencillo de implementar. Otra ventaja es la existencia de definiciones de nivel funcional que no son simplemente el correspondiente de una definicion de nivel de valores. Estas definiciones, a veces un poco cripticas por lo concisas representan un estilo de programacion muy poderoso.  Si bien la propuesta de Backus data de los a\u00f1os 70, su adopcion por la comunidad de programacion funcional ha sido limitada, al gozar de mayor popularidad el calculo Lambda.  La programacion a nivel funcional en el estilo de FP tiene una fuerte relacion con la logica combinatoria de Haskell Curry, con los lenguajes de combinadores, antecesores de Miranda y Haskell, asi como con las categorias cartesianas cerradas, teoria que dio origen al lenguaje CAML (Categorical Abstract Machine Languaje), antecesor del lenguaje Ocaml. ","snippet":"La programacion a nivel funcional es uno de los dos paradigmas contrastantes identificados por John Backus en su trabajo sobre los programas como objetos matematicos, siendo el otro la programacion a ","enlaces_salientes":["Programaci%C3%B3n_a_nivel_funcional","Programaci%C3%B3n_a_nivel_funcional","Programaci%C3%B3n_a_nivel_funcional","Paradigma_de_programaci%C3%B3n","John_Backus","Programas_como_objetos_matem%C3%A1ticos","Programaci%C3%B3n_a_nivel_de_valores","Premio_Turing","1977","Lenguaje_de_programaci%C3%B3n","FP_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n","Variable","Programas_como_objetos_matem%C3%A1ticos","A%C3%B1os_1970","Programaci%C3%B3n_funcional","C%C3%A1lculo_Lambda","L%C3%B3gica_combinatoria","Haskell_Curry","Miranda_(lenguaje_de_programaci%C3%B3n)","Haskell","Categor%C3%ADa_cartesiana_cerrada","Programaci%C3%B3n_a_nivel_de_valores","Programaci%C3%B3n_funcional","Paradigma_de_programaci%C3%B3n","Control_de_autoridades"]}
{"url":"Programaci%C3%B3n_a_nivel_de_valores","titulo":"Programacion a nivel de valores","contenido":"La programacion a nivel de valores es unos de los dos paradigmas contrastantes identificados por John Backus en su trabajo sobre los Programas como objetos matematicos, siendo el otro la programacion a nivel funcional. El termino inicialmente utilizado por Backus fue el de programacion a nivel de objetos, pero en la actualidad ese termino traeria confusion con la programacion orientada a objetos.  Los programas a nivel de valores describen como combinar diferentes valores (por ejemplo, numeros, caracteres, etc.) para formar nuevos valores hasta obtener el resultado final. Los nuevos valores se obtienen como resultado de la aplicacion de operaciones que transforman valores en otros valores, como por ejemplo, la suma, la concatenacion, la inversion de matrices, etc.  Los lenguajes que siguen el estilo de von Neumann son de nivel de valores: las expresiones a la derecha de una asignacion tienen por objeto la creacion del nuevo valor a asignar.  El enfoque de programacion a nivel de valores o imperativa se presta para el estudio de los valores bajo las operaciones de formacion de valores y de sus propiedades algebraicas.  Segun este punto de vista, los lenguajes basados en el calculo lambda (tales como Lisp, ISWIM, y Scheme) son lenguajes a nivel de valores, si bien su dise\u00f1o no los restringe a ello.  Por ejemplo, en una definicion tipica en el calculo lambda de la forma f = \u03bbx.E la variable x asi como la expresion E denotan valores. Tipicamente, E es una expresion que aplica funciones de formacion de valores a variables y constantes.  Por su parte, los partidarios de la programacion funcional consideran a los lenguajes basados en el calculo lambda como contentivos de ambos paradigmas, dado que tanto las operaciones de formacion de valores como las operaciones de construccion de programas se expresan en el mismo formalismo, dejando al usuario escoger que partes de su programa deben ser escritas en un paradigma o en el otro.  Vease tambien: ","snippet":"La programacion a nivel de valores es unos de los dos paradigmas contrastantes identificados por John Backus en su trabajo sobre los Programas como objetos matematicos, siendo el otro la programacion ","enlaces_salientes":["Programaci%C3%B3n_a_nivel_de_valores","Programaci%C3%B3n_a_nivel_de_valores","Programaci%C3%B3n_a_nivel_de_valores","John_Backus","Programas_como_objetos_matem%C3%A1ticos","Programaci%C3%B3n_a_nivel_funcional","Programaci%C3%B3n_orientada_a_objetos","Von_Neumann","C%C3%A1lculo_lambda","Lisp","ISWIM","Scheme","Programaci%C3%B3n_funcional","Programaci%C3%B3n_a_nivel_funcional","Programaci%C3%B3n_funcional","Paradigma_de_programaci%C3%B3n","Control_de_autoridades"]}
{"url":"Lenguaje_de_programaci%C3%B3n_esot%C3%A9rico","titulo":"Lenguaje de programacion esoterico","contenido":"Un lenguaje de programacion esoterico o exotico es un lenguaje de programacion minimalista, cuya utilidad para la programacion de proyectos de gran tama\u00f1o normalmente es dudosa debido a su naturaleza ofuscada y otra caracteristicas que no es comun en los demas lenguajes. Ademas normalmente se usan como prueba de concepto en la creacion de lenguajes de programacion Turing completos.  En general estos lenguajes poseen una sintaxis muy basica, con un alfabeto muy restringido, lo que los hace especialmente peculiares en su implementacion. En su creacion muchas veces ha primado la diversion por parte de los desarrolladores, sobre la utilidad. Sin embargo, al mismo tiempo se trata de lenguajes que funcionan como un desafio tanto para quienes los crean, como para aquellos que intentan programar con ellos.  Un lenguaje ejemplar de este tipo es P\u2032\u2032, creado por el informatico teorico italiano Corrado Bohm en 1964, y que se constituye como el primer lenguaje imperativo de la programacion estructurada cuya pertenencia a la clase de los Turing completos pudo ser demostrada sin necesidad del uso de la instruccion GOTO. ","snippet":"Un lenguaje de programacion esoterico o exotico es un lenguaje de programacion minimalista, cuya utilidad para la programacion de proyectos de gran tama\u00f1o normalmente es dudosa debido a su naturaleza ","enlaces_salientes":["Lenguaje_de_programaci%C3%B3n_esot%C3%A9rico","Lenguaje_de_programaci%C3%B3n_esot%C3%A9rico","Lenguaje_de_programaci%C3%B3n_esot%C3%A9rico","Lenguaje_de_programaci%C3%B3n","Minimalismo","Turing_completo","P%E2%80%B2%E2%80%B2","Inform%C3%A1tico_te%C3%B3rico","Corrado_B%C3%B6hm","Programaci%C3%B3n_estructurada","GOTO","INTERCAL","Befunge","Whitespace","Instrucci%C3%B3n_(inform%C3%A1tica)","Brainfuck","Turing_completo","Compilador","Malbolge","HQ9%2B","Unlambda","Ook!","Brainfuck","Orangut%C3%A1n","Oz_(lenguaje_de_programaci%C3%B3n)","Lenguaje_de_programaci%C3%B3n","LOLCODE","Instrucci%C3%B3n_(inform%C3%A1tica)","Lolcat","Piet_(lenguaje_de_programaci%C3%B3n)","Mapa_de_bits","Arte_abstracto","Lenguaje_de_programaci%C3%B3n","M%C3%A1quina_de_Turing","Control_de_autoridades"]}
{"url":"MediaWiki","titulo":"MediaWiki","contenido":"MediaWiki es un software para wikis libre programado en el lenguaje PHP. Es el software usado por Wikipedia y otros proyectos de la Fundacion Wikimedia (Wikcionario, Wikilibros, etc). Ha tenido una gran expansion desde 2005 y existe un gran numero de wikis basados en este software que no mantienen relacion con dicha fundacion, aunque si comparten la idea de la generacion de contenidos de manera colaborativa. Se encuentra bajo la licencia de software GNU General Public License.  MediaWiki puede ser instalado en los servidores web Apache, Internet Information Services, Cherokee, Hiawatha,\u200b LiteSpeed Standard\u200b (necesita la extension Math),\u200b\u200b nginx, y lighttpd y puede usar como motor de base de datos MySQL/MariaDB, PostgreSQL y SQLite.  Tambien se llama MediaWiki al espacio de nombres (ver mas abajo) donde se hallan entre otras cosas los mensajes de su interfaz listos para su traduccion a la lengua local de cada wiki, en caso de no estar todavia traducidos.  MediaWiki fue desarrollado originalmente para Wikipedia por Magnus Manske,\u200b con el fin de sustituir a UseModWiki como motor del wiki (al que los colaboradores de Wikipedia llamaron \"Fase I\"). A la primera version se la llamaba, simplemente \"software de Wikipedia fase II.\"  A mediados de 2002 el programa fue reescrito y mejorado, dando lugar a la llamada \"fase III\", y ha seguido desarrollandose desde entonces a partir de ese codigo. El 29 de agosto de 2003 se bautizo al programa, hasta ese momento sin un nombre oficial, como \"MediaWiki\", un juego de palabras con el nombre de la Fundacion Wikimedia, que patrocina su desarrollo. La primera version con este nombre se llamo, entonces, \"MediaWiki-stable 20030829\". Se empezo entonces a pensar las nuevas versiones pensando en posibles usuarios ajenos a Wikipedia, mejorando especialmente en aspectos como la instalacion del software.  El nombre \"MediaWiki\" es criticado en ocasiones por ser facil de confundir con el de la fundacion por parte de gente ajena a Wikipedia.  MediaWiki posee un servicio de alta disponibilidad que permite la edicion de articulos de distintos usuarios via HTTP siguiendo unas guias de estilo especificas. Es comun que un usuario empiece a editar un registro y lo cancele o cierre la sesion sin haberlo guardado, por lo que no son factibles los bloqueos, y que no acceda ningun usuario mientras, por esta razon, no se bloquea en servicios HTTP, ya que se prima que todos los usuarios puedan acceder, aunque un usuario este editando.  Esto lleva al punto de que dos usuarios puedan editar el mismo texto a la vez, lo que supondria un problema en caso de que ocurra, aunque no suele ser muy frecuente.  Por ello, la solucion que ha implementado MediaWiki es el control de concurrencia optimista (OCC), definiendose como un metodo de control de concurrencia que se aplica a sistemas transaccionales, es decir, se permite que un grupo de instrucciones de carga y almacenamiento se ejecuten en un camino atomico, proporcionando un alto nivel de abstraccion que permita la coordinacion de lecturas y escrituras simultaneas de datos compartidos en sistemas paralelos.  El funcionamiento de la OCC por definicion asume que multiples transacciones se pueden completar frecuentemente sin interferir entre si, mientras se ejecutan, las transacciones se van ejecutando con normalidad y antes de hacer commit, cada transaccion validara que ninguna otra ha modificado los datos que ha leido o escrito y en caso de entrar en conflicto, la transaccion que iba a hacer commit hara un rollback.  Por lo tanto, si suponemos que dos usuarios van a editar la misma pagina, en cada uno de ellos se grabara un timestamp que marcara el inicio de la transaccion, a continuacion, cada uno modificara los valores correspondientes y escribira nuevos datos, comprobara si hay otras transacciones que han modificado datos que se ha utilizado en dicha transaccion \u00a0y finalmente, a la hora de hacer commit, se comparara con la base de datos observara que hay un conflicto y normalmente anulara la transaccion, aunque puede seguir otros esquemas de resolucion como que se invoque a un algoritmo de resolucion de conflicto, que en este caso va a ser que el ultimo usuario concilie las diferencias entre el usuario anterior y el mismo.  Dada esta situacion vamos a suponer que tenemos dos usuarios llamados Natalia y Paco,\u200b van a editar una misma pagina de MediaWiki, lo que puede ocurrir es:  Por cada usuario que este modificando, aparecera un cuadro de edicion que contiene el texto que va a enviar \u2015subir\u2015 cada uno de los usuarios, por lo que se cree en la buena fe de los usuarios y que Natalia no pondra su texto en la parte superior perteneciente a Paco.  Normalmente, los problemas conflicto de edicion, se resuelven fusionando las contribuciones de los editores. ","snippet":"MediaWiki es un software para wikis libre programado en el lenguaje PHP. Es el software usado por Wikipedia y otros proyectos de la Fundacion Wikimedia (Wikcionario, Wikilibros, etc). Ha tenido una gr","enlaces_salientes":["MediaWiki","MediaWiki","MediaWiki","Fundaci%C3%B3n_Wikimedia","Desarrollador_de_software","Fundaci%C3%B3n_Wikimedia","Inseguridad_inform%C3%A1tica","Licencia_de_software","GNU_General_Public_License","Idioma","Lenguaje_de_programaci%C3%B3n","PHP","Ciclo_de_vida_del_lanzamiento_de_software","Ciclo_de_vida_del_lanzamiento_de_software","Software_para_wikis","Software_libre","Lenguaje_de_programaci%C3%B3n","PHP","Fundaci%C3%B3n_Wikimedia","Wikcionario","Licencia_de_software","GNU_General_Public_License","Servidor_web","Servidor_HTTP_Apache","Internet_Information_Services","Cherokee_(servidor_web)","Nginx","Lighttpd","Base_de_datos","MySQL","MariaDB","PostgreSQL","SQLite","Espacio_de_nombres","Magnus_Manske","UseModWiki","29_de_agosto","2003","Fundaci%C3%B3n_Wikimedia","CamelCase","TeX","Sistema_de_gesti%C3%B3n_de_contenidos","Groupware","Memoria_virtual","Memcached","Squid_(programa)","LocalSettings.php","DokuWiki","Edina","ISBN","Computaci%C3%B3n_distribuida","Universidad_de_Salamanca","Meta-Wiki","Control_de_autoridades","MediaWiki","Fichero_de_Autoridades_Virtual_Internacional","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Open_Hub","MediaWiki"]}
{"url":"Teorema_(desambiguaci%C3%B3n)","titulo":"Teorema (desambiguacion)","contenido":"Teorema puede designar a: ","snippet":"Teorema puede designar a: ","enlaces_salientes":["Teorema_(desambiguaci%C3%B3n)","Teorema_(desambiguaci%C3%B3n)","Teorema_(desambiguaci%C3%B3n)","Teorema","Axioma","Teorema_(revista)","Teorema_(pel%C3%ADcula)","Pier_Paolo_Pasolini"]}
{"url":"Tesis","titulo":"Tesis","contenido":"Una tesis (griego \u03b8\u03b5\u03c3\u03c2 thesis \u00abestablecimiento, proposicion, colocacion\u00bb, es informacion de \u00ablo propuesto, lo afirmado, lo que se propone\u00bb; originalmente de tithenai, \u00abarchivar\u00bb) es el inicio de un texto argumentativo, una afirmacion cuya veracidad ha sido argumentada, demostrada o justificada de alguna manera. Generalmente enuncia una proposicion cientifica, un axioma o un hecho demostrable.  Derivada del metodo cientifico, una tesis es la afirmacion concreta de una idea que se expone de manera abierta y fundamentada. Tambien puede llamarsela teoria cientifica, toda vez que un sustento teorico puede ser considerado como parte del conocimiento establecido. Normalmente en un texto argumentativo se conforma la opinion que tiene el articulista sobre el tema del que esta hablando. Despues de eso el articulista defiende su tesis con argumentos.  En la antigua Grecia, principalmente en el contexto de la medicina, se trataba de una afirmacion que el sustentante exponia. Sus ideas se sometian a un interrogatorio, una discusion o prueba dialectica para sostener en publico las posibles objeciones que le oponian los examinadores.[cita\u00a0requerida]  Una tesis se considera como la afirmacion culminada de una hipotesis para la cual puede incluso no existir ningun tipo de evidencia inicial y los hechos que la apoyan pueden estar en gran medida por descubrir. Una tesis se interpreta generalmente como una proposicion ya demostrable cuyo objetivo consiste en hacer valido, en un sentido eficazmente ya que pragmatico, lo \u00abesencial\u00bb de lo \u00abcomplejo de las proposiciones\u00bb.  Los pasos encaminados a validar o invalidar una hipotesis, para establecerla provisionalmente como una tesis justificada, dependen del tipo de reglas propicias para esto.  Literalmente la tesis es la opinion, el punto de vista del escritor, y a partir de ella, se crean los argumentos y como conclusion el texto argumentativo, muchas veces representado en cartas al director.  Una tesis es un documento de caracter expositivo, donde se presentan los resultados obtenidos por el aspirante en su trabajo de investigacion. Los resultados se deben conducir de forma sistematica, logica y objetiva, para la posible busqueda de soluciones al problema de estudio planteado. Existen muchas y diversas definiciones de lo que es una tesis.  La academica Claudia Gomez Haro propone esta caracterizacion:\u200b  Una tesis de investigacion es un informe que concierne a un problema o conjunto de problemas en un area definida de la ciencia y explica lo que se sabe de el brevemente, lo que se haria para resolverlo, lo que sus resultados significan, y donde o como se pueden proponer progresos, mas alla del campo delimitado por el trabajo.   Generalmente se elaboran tesis de grado por los estudiantes de termino para en caso de aprobarla, alcanzar los grados academicos universitarios de licenciatura, maestria y doctorado.  Una tesis cientifica es sometida a un sistema especial de reglas. Para aumentar la aceptacion de una tesis en el campo de las ciencias naturales, una tesis deberia: ","snippet":"Una tesis (griego \u03b8\u03b5\u03c3\u03c2 thesis \u00abestablecimiento, proposicion, colocacion\u00bb, es informacion de \u00ablo propuesto, lo afirmado, lo que se propone\u00bb; originalmente de tithenai, \u00abarchivar\u00bb) es el inicio de un te","enlaces_salientes":["Tesis","Tesis","Tesis","Tesis_(desambiguaci%C3%B3n)","Idioma_griego","Proposici%C3%B3n","Axioma","M%C3%A9todo_cient%C3%ADfico","Teor%C3%ADa_cient%C3%ADfica","Antigua_Grecia","Medicina","Dial%C3%A9ctica","Proposici%C3%B3n","Pragmatismo","Hip%C3%B3tesis_(m%C3%A9todo_cient%C3%ADfico)","Licenciatura","Maestr%C3%ADa","Doctorado","Lutero","Las_95_tesis","Indulgencia","Ant%C3%ADtesis","S%C3%ADntesis","Dial%C3%A9ctica","Hegel","Filosof%C3%ADa_de_la_ciencia","Hip%C3%B3tesis_(m%C3%A9todo_cient%C3%ADfico)","Griego_antiguo","Suposici%C3%B3n","Ciencia","Ciencias_naturales","Objetividad","Prejuicio","Contradicci%C3%B3n","Evidencia_(filosof%C3%ADa)","Tesis_doctoral","Hip%C3%B3tesis_(m%C3%A9todo_cient%C3%ADfico)","Teor%C3%ADa_cient%C3%ADfica","Stanford_University_Press","Wikcionario","Control_de_autoridades"]}
{"url":"Corolario","titulo":"Corolario","contenido":"Corolario (del latin corollarium) es un concepto referido a una proposicion tanto en matematica como en logica que se utiliza para designar la consistencia de un teorema  ya demostrado, sin necesidad de invertir esfuerzo adicional en su demostracion. En pocas palabras, es una consecuencia obvia que no necesita demostracion.  Siempre se  refiere a una inferencia escueta e inmediata, si bien la distincion entre teorema y corolario  es tan subjetiva como entre lema y teorema, siendo el lema una proposicion breve.\u200b  Una proposicion si es consecuencia de un teorema se denomina corolario.\u200b  El vocablo latina corollarium deriva de: a) corolla (petalos de las flores), que es diminutivo de corona: porque a los actores, en calidad de gratificacion adicional, se les entregaba una coronita. En Roma, asi mismo a los espectadores y a los invitados a los banquetes se les otorgaba un corollarium; b) -arium, sufijo abundancial (por las flores de la corona).  le sigue el corolario:  De a2 = b2 +c2 resulta b2 = a2 - c2. ","snippet":"Corolario (del latin corollarium) es un concepto referido a una proposicion tanto en matematica como en logica que se utiliza para designar la consistencia de un teorema  ya demostrado, sin necesidad ","enlaces_salientes":["Corolario","Corolario","Corolario","Lat%C3%ADn","Teorema","Inferencia","Lema_(matem%C3%A1ticas)","Diminutivo","Actor","Sufijo","Teorema_de_Pit%C3%A1goras","Teorema","Lema_(matem%C3%A1ticas)","Proposici%C3%B3n","Wikcionario","Control_de_autoridades","Wikcionario","Wikcionario"]}
{"url":"Postulado","titulo":"Postulado","contenido":" Un postulado es una proposicion no evidente por si misma ni demostrada, pero que se acepta, ya que no existe otro principio al que pueda ser referida.\u200b  Si la proposicion se considera evidente y es aceptada sin demostracion previa, se denomina axioma.\u200b  Tambien se denomina postulado a los principios sustentados por una determinada persona, un grupo o una organizacion.\u200b  Por ejemplo, en filosofia y en psicologia los diversos enfoques o escuelas suelen diferenciarse en una serie de proposiciones filosoficas. A estas se les nombra postulados, que actuan como definiciones opcionales que delimitan una concepcion de cada disciplina (tipo de metodo que utiliza, objetivo de estudio, etcetera).  Asi, los puntos de partida de la cognicion, la modificacion de conducta y Gestalt acerca de que son la mente, la personalidad y la conducta son distintos. A partir de estos postulados se desarrollo toda la teoria. En toda ciencia -incluso la Fisica, al considerar que existen reglas constantes definibles- se suele disponer de puntos de partida filosoficos.  Segun Immanuel Kant (filosofo del siglo\u00a0XVIII) los postulados de la razon practica son las proposiciones no demostrables desde la razon teorica pero que, si se quiere entender el factum moral, se les ha de admitir. Dichos postulados serian la libertad, la inmortalidad del alma y la existencia de Dios.  El existencialismo es un movimiento filosofico del siglo\u00a0XX. Su postulado fundamental es que cada ser humano crea el significado y la esencia de su propia  vida. Uno de sus pensadores fundamentales fue Jean-Paul Sartre.  Los postulados son formulas especificas de una teoria que se aceptan solamente por acuerdo. Razonando acerca de dos estructuras diferentes, por ejemplo los numeros naturales y los numeros enteros, pueden comprender los mismos axiomas. Sin embargo los postulados expresan lo que es esencial de una estructura, o un conjunto de estas. A diferencia de los axiomas logicos, los postulados no son tautologias.  Cualquier teoria matematica moderna se fundamenta en un conjunto de postulados. Aunque se pensaba que, en principio, toda teoria se podia axiomatizar y formulizar, posteriormente esto se demostro imposible.  En matematica son celebres los postulados de Euclides, expuestos en los Elementos, el tratado fundamental de la geometria clasica. Siglos despues, cuando se cuestiono el quinto postulado de Euclides, surgio la llamada Geometria no euclidiana.  Existen otros, como el postulado de Bertrand, referente a los numeros primos, y los postulados de Cauchy, enunciados por el matematico Augustin Louis Cauchy, relativos a vectores.  Un postulado fisico o principio fisico es una hipotesis que conduce a resultados compatibles con las observaciones experimentales aceptada provisionalmente como hipotesis de trabajo o conveniencia formal para obtener otros resultados. En fisica se formularon los postulados de Cauchy para la mecanica de solidos deformables, los dos postulados de la Relatividad Especial, referentes a la teoria de la relatividad de Albert Einstein, y los seis postulados de la mecanica cuantica (de la axiomatizacion de Von Neumann).  Los postulados en la ciencia resumen la experiencia disponible sobre un concepto en cuestion. Es decir, se fundamentan en la realidad y nunca son o han sido falsos a la luz de la experiencia existente, la resumen. Son la base del razonamiento y deduccion cientifica, con la cual se realiza su objeto: la prediccion de lo que pasara que ha de ser comprobable mediante experimentacion posterior. En la historia de la ciencia, mejores metodos de medida llevan a mas y mejores teorias que introducen mas precision en las predicciones y corrigen errores.  En infectologia, epidemiologia y microbiologia los postulados de Koch, aplicados por el fundador de la bacteriologia, Robert Koch, sirvieron para establecer la etiologia de la tuberculosis. Posteriormente se generalizaron para el resto de las enfermedades infecciosas. ","snippet":" Un postulado es una proposicion no evidente por si misma ni demostrada, pero que se acepta, ya que no existe otro principio al que pueda ser referida.\u200b  Si la proposicion se considera evidente y es a","enlaces_salientes":["Postulado","Postulado","Postulado","Proposici%C3%B3n","Axioma","Filosof%C3%ADa","Psicolog%C3%ADa","Cognici%C3%B3n","Modificaci%C3%B3n_de_conducta","Psicolog%C3%ADa_de_la_Gestalt","Immanuel_Kant","Libertad","Alma","Dios","Existencialismo","Jean-Paul_Sartre","N%C3%BAmeros_naturales","N%C3%BAmeros_enteros","Tautolog%C3%ADa","Teor%C3%ADa","Matem%C3%A1tica","Postulados_de_Euclides","Los_Elementos","Geometr%C3%ADa_cl%C3%A1sica","Quinto_postulado_de_Euclides","Geometr%C3%ADa_no_euclidiana","Postulado_de_Bertrand","N%C3%BAmeros_primos","Postulados_de_Cauchy","Augustin_Louis_Cauchy","F%C3%ADsica","Postulados_de_Cauchy","Mec%C3%A1nica_de_s%C3%B3lidos_deformables","Postulados_de_la_Relatividad_Especial","Teor%C3%ADa_de_la_relatividad","Albert_Einstein","Postulados_de_la_mec%C3%A1nica_cu%C3%A1ntica","Von_Neumann","Infectolog%C3%ADa","Epidemiolog%C3%ADa","Microbiolog%C3%ADa","Postulados_de_Koch","Bacteriolog%C3%ADa","Robert_Koch","Etiolog%C3%ADa","Tuberculosis","Axioma","Teorema","Control_de_autoridades"]}
{"url":"Postulados_de_Euclides","titulo":"Postulados de Euclides","contenido":"Los postulados de Euclides hacen referencia al tratado denominado Los Elementos, escrito por Euclides hacia el a\u00f1o 300 a.\u00a0C., exponiendo los conocimientos geometricos de la Grecia clasica deduciendolos a partir de cinco postulados, considerados los mas evidentes y sencillos.\u200b  Los postulados de Los Elementos son los siguientes...  Este ultimo postulado tiene un equivalente, que es el mas usado en los libros de geometria:  A principios del siglo\u00a0XIX Gauss, Lobachevsky y Janos Bolyai consideraron la posibilidad de una geometria sin el quinto postulado, descubriendo la Geometria hiperbolica.  En terminos actuales, estos postulados fueron enunciados por Hilbert en sus axiomas. ","snippet":"Los postulados de Euclides hacen referencia al tratado denominado Los Elementos, escrito por Euclides hacia el a\u00f1o 300 a.\u00a0C., exponiendo los conocimientos geometricos de la Grecia clasica deduciendolo","enlaces_salientes":["Postulados_de_Euclides","Postulados_de_Euclides","Postulados_de_Euclides","Los_Elementos","Euclides","Postulado","Postulado_de_las_paralelas","Carl_Friedrich_Gauss","Lobachevsky","J%C3%A1nos_Bolyai","Geometr%C3%ADa_hiperb%C3%B3lica","Hilbert","Axiomas_de_Hilbert","ISBN","Control_de_autoridades"]}
{"url":"%C3%81ngulos_interiores","titulo":"Angulo interior","contenido":"En geometria, un angulo interior o angulo interno es un angulo formado por dos lados de un poligono que comparten un vertice comun, esta contenido dentro del poligono. Un poligono simple tiene solo un angulo interno por cada vertice.  En el plano euclideo, si todos los angulos interiores de un poligono no superan los 180 grados sexagesimales o \u03c0 radianes, se clasifican como poligonos convexos. Si existe por lo menos un angulo interior superior a 180 grados o \u03c0 radianes, se trata de un poligono concavo.  Si unos de los angulos es menor a 180 grados se trata de angulos convexos.  Si todos los angulos interiores de un poligono simple y convexo son iguales y todos sus lados tienen la misma longitud, se trata de un poligono regular. En caso contrario, se trata de un poligono irregular.  En un poligono simple de n lados, o n angulos interiores \u03b1 1 , \u2026 , \u03b1 n ,\\dots ,\\alpha _{n}} :  Suma de angulos interiores = \u2211 i = 1 n \u03b1 i = 180 \u2218 \u22c5 ( n \u2212 2 ) ^{n}\\alpha _{i}=180^\\cdot (n-2)}  En un poligono regular, todos los angulos interiores son identicos por lo que, la medida en grados de un angulo interno es:  Angulo interior = \u03b1 i = \u22ef = \u03b1 n = 180 \u2218 \u22c5 ( n \u2212 2 ) n =\\dots =\\alpha _{n}=\\cdot (n-2)}{n}}}  El concepto de angulo interior puede extenderse de manera consistente a poligonos autointersecantes como las estrellas mediante el uso del concepto de angulos direccionados. En general, la suma del angulo interior en grados de cualquier poligono cerrado, incluidos los cruzados (que se intersecan a si mismos), viene dada por 180 (n-2k)\u00b0, donde n es el numero de vertices y el numero no negativo k es el numero de revoluciones totales de 360\u00b0 que se experimentan al recorrer el perimetro. En otras palabras, 360k\u00b0 representa la suma de todos los angulos exteriores. Por ejemplo, para poligonos convexos y concavos ordinarios k=1, ya que la suma de los angulos exteriores es 360\u00b0, y se realiza solo una revolucion completa recorriendo el perimetro. ","snippet":"En geometria, un angulo interior o angulo interno es un angulo formado por dos lados de un poligono que comparten un vertice comun, esta contenido dentro del poligono. Un poligono simple tiene solo un","enlaces_salientes":["%C3%81ngulo_interior","%C3%81ngulo_interior","%C3%81ngulo_interior","Tri%C3%A1ngulo","Geometr%C3%ADa","%C3%81ngulo","Segmento","Pol%C3%ADgono","V%C3%A9rtice_(geometr%C3%ADa)","Pol%C3%ADgono_simple","V%C3%A9rtice_(geometr%C3%ADa)","Plano_eucl%C3%ADdeo","Grado_sexagesimal","Radi%C3%A1n","Pol%C3%ADgono_convexo","Convexo","%C3%81ngulos_congruentes","Pol%C3%ADgono_regular","Pol%C3%ADgono","Pol%C3%ADgono_regular","Estrella_(figura_geom%C3%A9trica)","Per%C3%ADmetro","Pol%C3%ADgono_convexo","Pol%C3%ADgono_c%C3%B3ncavo","%C3%81ngulos_adyacentes","Java_(lenguaje_de_programaci%C3%B3n)","Control_de_autoridades"]}
{"url":"Geometr%C3%ADas_no_euclidianas","titulo":"Geometria no euclidiana","contenido":"Se denomina geometria no euclidiana, o no euclidea, a cualquier sistema formal de geometria cuyos postulados y proposiciones difieren en algun asunto de los establecidos por Euclides en su tratado Elementos. No existe un solo sistema de geometria no euclidea, sino muchos, aunque si se restringe la discusion a espacios homogeneos, en los que la curvatura del espacio es la misma en cada punto, en los que los puntos del espacio son indistinguibles, pueden distinguirse tres formulaciones\u200b de geometrias:  Todos estos son casos particulares de geometrias riemannianas, en los que la curvatura es constante, si se admite la posibilidad de que la curvatura intrinseca de la geometria varie de un punto a otro se tiene un caso de geometria riemanniana general, como sucede en la teoria de la relatividad general donde la gravedad causa una curvatura no homogenea en el espacio-tiempo, siendo mayor la curvatura cerca de las concentraciones de masa, lo cual es percibido como un campo gravitatorio atractivo.  La diferencia esencial entre las geometrias metricas es la naturaleza de las lineas paralelas. El quinto postulado de Euclides, el postulado de las paralelas, es equivalente al Postulado de Playfair, que afirma que, dentro de un plano bidimensional, para cualquier recta l dada y un punto A, que no esta en l, hay exactamente una recta que pasa por A que no interseca a l. En la geometria hiperbolica, por el contrario, hay infinitamente muchas lineas a traves de A que no intersecan l, mientras que en la geometria eliptica, cualquier linea a traves de A interseca l.  Otra forma de describir las diferencias entre estas geometrias es considerar dos lineas rectas indefinidamente extendidas en un plano bidimensional que son ambas  perpendiculares a una tercera linea (en el mismo plano):  La geometria euclidiana, llamada asi por el matematico griego Euclides, incluye algunas de las matematicas mas antiguas conocidas, y las geometrias que se desviaban de ella no fueron ampliamente aceptadas como legitimas hasta el siglo\u00a0XIX.  El debate que condujo finalmente al descubrimiento de las geometrias no euclidianas comenzo casi tan pronto como Euclides escribio Elementos de Euclides. En los Elementos, Euclides parte de un numero limitado de supuestos (23 definiciones, cinco nociones comunes y cinco postulados) y trata de demostrar todos los demas resultados (proposiciones) de la obra. El mas notorio de los postulados se conoce a menudo como \"el quinto postulado de Euclides\", o simplemente el  postulado paralelo, que en la formulacion original de Euclides es:  Si una recta cae sobre dos rectas de tal manera que los angulos interiores del mismo lado son juntos menores que dos angulos rectos, entonces las rectas, si se producen indefinidamente, se encuentran en aquel lado en el que estan los angulos menores que los dos angulos rectos. .  Otros matematicos han ideado formas mas sencillas de esta propiedad. Independientemente de la forma del postulado, sin embargo, parece consistentemente mas complicado que otros postulados de Euclides:  1. Trazar una linea recta desde cualquier punto a cualquier punto.  2. Producir [extender] una recta finita continuamente en linea recta.  3. Para describir un circulo con cualquier centro y distancia [radio].  4. Que todos los angulos rectos son iguales entre si.  Durante al menos mil a\u00f1os, los  geometras se inquietaron por la dispar complejidad del quinto postulado, y creyeron que podia demostrarse como un teorema a partir de los otros cuatro. Muchos intentaron encontrar una prueba por contradiccion, entre ellos Ibn al-Haytham (Alhazen, siglo\u00a0XI),\u200b Omar Khayyam (siglo\u00a0XII), Nasir al-Din al-Tusi (siglo\u00a0XIII), y Giovanni Girolamo Saccheri (siglo\u00a0XVIII).  Los teoremas de Ibn al-Haytham, Khayyam y al-Tusi sobre los cuadrilateros, incluidos el cuadrilatero de Lambert y el cuadrilatero de Saccheri, fueron \"los primeros teoremas de la hiperbolica y de las eliptica\". Estos teoremas, junto con sus postulados alternativos, como el axioma de Playfair, desempe\u00f1aron un papel importante en el desarrollo posterior de la geometria no euclidiana.  Estos primeros intentos de cuestionar el quinto postulado influyeron considerablemente en su desarrollo entre los geometras europeos posteriores, como Witelo, Levi ben Gerson, Alfonso, John Wallis y Saccheri.\u200b Sin embargo, todos estos primeros intentos de formular una geometria no euclidiana proporcionaron pruebas defectuosas del postulado de las paralelas, conteniendo suposiciones que eran esencialmente equivalentes al postulado de las paralelas.  Sin embargo, estos primeros intentos proporcionaron algunas de las primeras propiedades de las geometrias hiperbolica y eliptica.  Khayyam, por ejemplo, intento derivarlo de un postulado equivalente que formulo a partir de \"los principios del Filosofo\" (Aristoteles): \"Dos rectas convergentes se cruzan y es imposible que dos rectas convergentes diverjan en la direccion en la que convergen\".\u200b Khayyam considero entonces los tres casos recto, obtuso y agudo que pueden tomar los angulos cimeros de un cuadrilatero de Saccheri y tras demostrar una serie de teoremas sobre ellos, refuto correctamente los casos obtuso y agudo basandose en su postulado y de ahi derivo el postulado clasico de Euclides, del que no se dio cuenta de que era equivalente a su propio postulado. Otro ejemplo es el hijo de al-Tusi, Sadr al-Din (a veces conocido como \"Pseudo-Tusi\"), que escribio un libro sobre el tema en 1298, basado en los pensamientos posteriores de al-Tusi, en el que presentaba otra hipotesis equivalente al postulado paralelo. \"Reviso esencialmente tanto el sistema euclidiano de axiomas y postulados como las pruebas de muchas proposiciones de los Elementos.\"\u200b\u200b Su obra se publico en Roma en 1594 y fue estudiada por geometras europeos, entre ellos Saccheri\u200b quien critico este trabajo asi como el de Wallis.\u200b  Giordano Vitale, en su libro Euclide restituo (1680, 1686), utilizo el cuadrilatero de Saccheri para demostrar que si tres puntos equidistan de la base AB y de la cuspide CD, entonces AB y CD equidistan en todas partes.  En una obra titulada Euclides ab Omni Naevo Vindicatus (Euclides liberado de todos los defectos), publicada en 1733, Saccheri descarto rapidamente la geometria eliptica como posibilidad (algunos otros axiomas de Euclides deben modificarse para que la geometria eliptica funcione) y se dedico a demostrar un gran numero de resultados en geometria hiperbolica.  Finalmente llego a un punto en el que creia que sus resultados demostraban la imposibilidad de la geometria hiperbolica. Parece que su afirmacion se basaba en presupuestos euclidianos, ya que no existia ninguna contradiccion logica. En este intento de demostrar la geometria euclidiana, descubrio involuntariamente una nueva geometria viable, pero no se dio cuenta de ello.  En 1766 Johann Lambert escribio, pero no publico, Theorie der Parallellinien en la que intento, como Saccheri, demostrar el quinto postulado. Trabajo con una figura que ahora se conoce como cuadrilatero de Lambert, un cuadrilatero con tres angulos rectos (puede considerarse la mitad de un cuadrilatero de Saccheri). Rapidamente elimino la posibilidad de que el cuarto angulo fuera obtuso, como habian hecho Saccheri y Khayyam, y procedio a demostrar muchos teoremas bajo la suposicion de un angulo agudo. A diferencia de Saccheri, nunca sintio que hubiera llegado a una contradiccion con esta suposicion. Habia demostrado el resultado no euclidiano de que la suma de los angulos de un triangulo aumenta a medida que disminuye el area del triangulo, y esto le llevo a especular sobre la posibilidad de un modelo del caso agudo en una esfera de radio imaginario. No llevo esta idea mas lejos.\u200b  En esta epoca estaba muy extendida la creencia de que el universo funcionaba segun los principios de la geometria euclidiana.\u200b. El primer ejemplo de geometria no euclidiana fue la hiperbolica, teorizada inicialmente por Immanuel Kant,[cita\u00a0requerida] formalizada posteriormente (a principios del siglo\u00a0XIX) e independientemente por varios autores, tales como Carl Friedrich Gauss, Nikolai Lobachevski, Janos Bolyai, Eugenio Beltrami y Ferdinand Schweickard.  Los desarrollos de geometrias no euclideas se gestaron en sus comienzos con el objetivo de construir modelos explicitos en los que no se cumpliera el quinto postulado de Euclides.  La geometria euclidiana habia sido desarrollada por los griegos y expuesta por Euclides en la obra Los elementos.  En su primera obra publicada, Pensamientos sobre la verdadera estimacion de las fuerzas vivas (Gedanken von der wahren Schatzung der lebendigen Krafte und Beurteilung der Beweise derer sich Herr von Leibniz und anderer Mechaniker in dieser Streitsache bedient haben, de 1746), Immanuel Kant considera espacios de mas de tres dimensiones y afirma:  Esas posibles geometrias que Kant entreve son las que hoy se llaman geometrias euclidianas de dimension mayor que 3.  Por otra parte, ya desde la antiguedad se considero que el quinto postulado del libro de Euclides no era tan evidente como los otros cuatro pues, al afirmar que ciertas rectas (las paralelas) no se cortaran al prolongarlas indefinidamente, habla de una construccion mental un tanto abstracta. Por eso durante muchos siglos se intento sin exito demostrarlo a partir de los otros cuatro. A principios del siglo\u00a0XIX, se intento demostrarlo por reduccion al absurdo, suponiendo que es falso y tratando de obtener una contradiccion. Sin embargo, lejos de llegar a un absurdo se encontro que existian geometrias coherentes diferentes de la euclidea. Se habia descubierto asi la primera geometria no euclidea (en concreto el primer ejemplo que se logro era una geometria llamada hiperbolica).  A principios del siglo\u00a0XIX, y de modo independiente, Gauss (1777-1855), Lobachevsky (1792-1856), Janos Bolyai y Ferdinand Schweickard lograron construir la geometria hiperbolica, a partir del intento de negar el quinto postulado de Euclides y tratar de obtener una contradiccion. En lugar de obtener una contradiccion lo que obtuvieron fue una curiosa geometria en la que los tres angulos de un triangulo sumaban menos de 180\u00b0 sexagesimales (en la geometria euclidea los angulos de cualquier triangulo suman siempre exactamente 180\u00b0).  La naturalidad de esta geometria quedo confirmada a finales del siglo, cuando Beltrami demostro que la geometria hiperbolica coincide con la geometria intrinseca de cierta superficie y Klein dio la interpretacion proyectiva de la geometria hiperbolica. Ambos resultados prueban que es tan consistente como la geometria euclidea (es decir, si la geometria hiperbolica lleva a alguna contradiccion, entonces la geometria euclidea tambien).  Algunos afirman que Gauss fue el primero en considerar la posibilidad de que la geometria del Universo no fuera la euclidea. Sabiendo que en la geometria hiperbolica la suma de los angulos de cualquier triangulo es menor que dos angulos rectos, se dice que subio a la cima de tres monta\u00f1as con un teodolito, aunque la precision de sus instrumentos no fue suficiente para decidir la cuestion con tal experimento. Sin embargo, otros afirman que cuando escribio que trataba de corregir los efectos de posibles curvaturas se referia a corregir el efecto de la curvatura terrestre en los estudios cartograficos que estaba realizando.  La geometria eliptica es el segundo tipo de geometria no-euclidea homogenea, es decir, donde cualquier punto del espacio resulta indistinguible de cualquier otro. Una variedad de Riemann de curvatura positiva constante es un ejemplo de geometria eliptica. Un modelo clasico de geometria eliptica n-dimensional es la n-esfera.  En la geometria eliptica las lineas geodesicas tienen un papel similar a las lineas rectas de la geometria euclidea, con algunas importantes diferencias. Si bien la minima distancia posible entre dos puntos viene dada por una linea geodesica, que ademas son lineas de curvatura minima, el quinto postulado de Euclides no es valido para la geometria eliptica, ya que dada una \"recta\" de esta geometria (es decir, una linea geodesica) y un punto no contenido en la misma no se puede trazar ninguna geodesica que no corte a la primera.  La geometria euclidea es claramente un caso limite intermedio entre la geometria eliptica y la geometria hiperbolica. De hecho la geometria euclidea es una geometria de curvatura nula. Puede demostrarse que cualquier espacio geometrico o variedad de Riemann cuya curvatura es nula es localmente isometrico al espacio euclideo y por tanto es un espacio euclideo o identico a una porcion del mismo.  Los espacios de curvatura constante el tensor de curvatura de Riemann viene dado en componentes por la siguiente expresion:   R i j k l = C ( g i l g j k \u2212 g i k g j l ) =C(g_{il}g_{jk}-g_{ik}g_{jl})\\,}  donde g i j } es el tensor metrico expresado en coordenadas curvilineas cualesquiera. El tensor de Ricci R i j } y la curvatura escalar S son proporcionales respectivamente al tensor metrico y a la curvatura:   R i j = ( n \u2212 1 ) C g i j , S = n ( n \u2212 1 ) C =(n-1)Cg_{ij},\\qquad S=n(n-1)C}  y donde n es la dimension del espacio.  Otro aspecto interesante es que tanto en la geometria hiperbolica, como en la geometria eliptica homogeneas el grupo de isometria del espacio completo es un grupo de Lie de dimension n ( n + 1 ) / 2 , que coincide con la dimension del grupo de isometria de un espacio Euclideo de dimension n (aunque los tres grupos son diferentes).  A propuesta de Gauss, la disertacion de Riemann verso sobre la hipotesis de la Geometria. En su tesis, Riemann considera las posibles geometrias que infinitesimalmente (es decir, en regiones muy peque\u00f1as) sean euclideas, cuyo estudio se conoce hoy en dia como geometrias riemannianas. Estas geometrias resultan en general no-homogeneas: algunas de las propiedades del espacio pueden diferir de un punto a otro, en particular el valor de la curvatura.  Para el estudio de estas geometrias Riemann introdujo el formalismo del tensor de curvatura y demostro que la geometria euclidea, la geometria hiperbolica y la geometria eliptica son casos particulares de geometrias riemannianas, caracterizadas por valores constantes del tensor de curvatura. En una geometria riemanninana general, el tensor de curvatura tendra valores variables a lo largo de diferentes puntos de dicha geometria.  Eso hace que la geometria no sea homogenea, y permite distinguir unos puntos de otros. Esto es relevante en la teoria de la relatividad general, ya que en principio es posible hacer experimentos de medicion de distancias y angulos que permitan distinguir unos puntos del espacio de otros, tal como especifican numerosos experimentos mentales imaginados por Einstein y otros en los que un experimentador encerrado en una caja puede realizar experimentos para decidir la naturaleza del espacio-tiempo que le rodea.  Finalmente, un aspecto interesante de la geometria riemanniana es que si la curvatura no es constante, entonces el grupo de isometria del espacio tiene dimension estrictamente menor que n ( n + 1 ) / 2 , siendo n la dimension del espacio. En concreto segun la relatividad general un espacio-tiempo con una distribucion muy irregular de la materia podria tener un grupo de isometria trivial de dimension 0.  Basandose en las ideas y resultados de Riemann, hacia 1920 Einstein aborda en su teoria de la relatividad general la cuestion de la estructura geometrica del universo. En ella muestra como la geometria del espacio-tiempo tiene curvatura, que es precisamente lo que se observa como campo gravitatorio, y como, bajo la accion de la gravedad, los cuerpos siguen las lineas mas rectas posibles dentro de dicha geometria, lineas que se denominan geodesicas.  Ademas, la ecuacion de Einstein afirma que para cada observador, la curvatura media del espacio coincide, salvo un factor constante, con la densidad observada, dando cumplimiento asi a la fantastica vision de Gauss: la geometria desentra\u00f1ada por los griegos es la estructura infinitesimal del espacio; al generalizar dicha estructura geometrica, tiene curvatura.  Los modelos de geometria no euclidiana son modelos matematicos de geometrias que son no euclidianas en el sentido de que no es el caso que exactamente una linea se pueda trazar paralela a una linea dada l a traves de un punto que no esta en l. En modelos geometricos hiperbolicos, en cambio, hay infinitas lineas a traves de A paralelas a l, y en modelos geometricos elipticos, las lineas paralelas no existen. (Consulte las entradas sobre geometria hiperbolica y geometria eliptica para obtener mas informacion).  La geometria euclidiana se modela mediante nuestra nocion de un \"plano plano\". El modelo mas simple para la geometria eliptica es una esfera, donde las lineas son \"circulos grandes\" (como el ecuador o los meridianos en un globo), y se identifican los puntos opuestos entre si (se consideran iguales). La pseudoesfera tiene la curvatura adecuada para modelar la geometria hiperbolica.  La geometria euclidiana se modela mediante nuestra nocion de un \"plano plano\". El modelo mas simple para la geometria eliptica es una esfera, donde las lineas son \"circulos grandes\" (como el ecuador o los meridianos en un globo), y se identifican los puntos opuestos entre si (se consideran iguales). La pseudoesfera tiene la curvatura adecuada para modelar la geometria hiperbolica.  El modelo mas simple para la geometria eliptica es una esfera, donde las lineas son \"circulos grandes\" (como el ecuador o los meridianos en un globo), y se identifican los puntos opuestos entre si (llamados puntos antipodales, considerados iguales). Esto tambien es uno de los modelos estandar del plano proyectivo real. La diferencia es que, como modelo de la geometria eliptica, se introduce una metrica que permite la medicion de longitudes y angulos, mientras que como modelo del plano proyectivo no hay tal metrica.  Incluso despues del trabajo de Lobachevsky, Gauss y Bolyai, la pregunta seguia en pie: \"\u00bfExiste tal modelo para la geometria hiperbolica?\". El modelo para la geometria hiperbolica fue respondido por Eugenio Beltrami en 1868, quien mostro por primera vez que una superficie llamada pseudoesfera tiene la curvatura adecuada para modelar una porcion del espacio hiperbolico, y en un segundo articulo en el mismo a\u00f1o, definio el modelo de Klein, que modela la totalidad del espacio hiperbolico, y utilizo esto para demostrar que la geometria euclidiana y la geometria hiperbolica eran equiconsistentes, de modo que la geometria hiperbolica era logicamente consistente si y solo si la geometria euclidiana lo era. (La implicacion inversa se sigue del modelo de la horoesfera de la geometria euclidiana).  En el modelo hiperbolico, dentro de un plano bidimensional, para cualquier linea dada l y un punto A que no esta en l, existen infinitas lineas a traves de A que no se intersecan con l.  En estos modelos, los conceptos de las geometrias no euclidianas se representan mediante objetos euclidianos en un entorno euclidiano. Esto introduce una distorsion perceptual en la cual las lineas rectas de la geometria no euclidiana se representan mediante curvas euclidianas que se doblan visualmente. Esta \"curvatura\" no es una propiedad de las lineas no euclidianas, sino solo un artificio de la forma en que se representan.  \"Pero en un manuscrito probablemente escrito por su hijo Sadr al-Din en 1298, basado en los pensamientos posteriores de Nasir al-Din sobre el tema, hay un nuevo argumento basado en otra hipotesis, tambien equivalente a la de Euclides, [...] La importancia de este ultimo trabajo es que se publico en Roma en 1594 y fue estudiado por los geometras europeos. En particular, se convirtio en el punto de partida para el trabajo de Saccheri y, en ultima instancia, para el descubrimiento de la geometria no euclidiana\".","snippet":"Se denomina geometria no euclidiana, o no euclidea, a cualquier sistema formal de geometria cuyos postulados y proposiciones difieren en algun asunto de los establecidos por Euclides en su tratado Ele","enlaces_salientes":["Geometr%C3%ADa_no_euclidiana","Geometr%C3%ADa_no_euclidiana","Geometr%C3%ADa_no_euclidiana","Geometr%C3%ADa_el%C3%ADptica","Geometr%C3%ADa_hiperb%C3%B3lica","Variedad_riemanniana","Geometr%C3%ADa","Postulados_de_Euclides","Euclides","Elementos_de_Euclides","Plano_(geometr%C3%ADa)","Tri%C3%A1ngulo","Grado_sexagesimal","Variedad_de_Riemann","Teor%C3%ADa_de_la_relatividad_general","Espacio-tiempo","Paralelismo_(matem%C3%A1tica)","Euclides","Postulado_de_las_paralelas","Conjunto_infinito","Perpendicularidad","Distancia","Geometr%C3%ADa_hiperb%C3%B3lica#L\u00edneas_no_intersecantes_/_paralelas","Geometr%C3%ADa_euclidiana","Historia_de_la_geometr%C3%ADa","Geometr%C3%ADa_hiperb%C3%B3lica#Historia","Geometr%C3%ADa_euclidiana","Matem%C3%A1tica_griega","Euclides","Elementos_de_Euclides","Proposiciones","Quinto_postulado_de_Euclides","Geometr%C3%ADa_euclidiana#Axiomss","Geometr%C3%ADa","Prueba_por_contradicci%C3%B3n","Ibn_al-Haytham","Omar_Khayy%C3%A1m","Nas%C4%ABr_al-D%C4%ABn_al-T%C5%ABs%C4%AB","Giovanni_Girolamo_Saccheri","Cuadril%C3%A1tero_de_Lambert","Cuadril%C3%A1tero_de_Saccheri","Geometr%C3%ADa_hiperb%C3%B3lica","Geometr%C3%ADa_el%C3%ADptica","Axioma_de_Playfair","Witelo","Levi_ben_Gerson","Alfonso","John_Wallis","Arist%C3%B3teles","Roma","Giordano_Vitale","Johann_Heinrich_Lambert","Geometr%C3%ADa_hiperb%C3%B3lica","Immanuel_Kant","Siglo_XIX","Carl_Friedrich_Gauss","Nikol%C3%A1i_Lobachevski","J%C3%A1nos_Bolyai","Eugenio_Beltrami","Quinto_postulado_de_Euclides","Los_elementos","Gottfried_Leibniz","Immanuel_Kant","Postulados_de_Euclides","Reducci%C3%B3n_al_absurdo","Geometr%C3%ADa_hiperb%C3%B3lica","Carl_Friedrich_Gauss","Lobachevsky","J%C3%A1nos_Bolyai","Quinto_postulado_de_Euclides","Eugenio_Beltrami","Felix_Klein","Plano_proyectivo","Carl_Friedrich_Gauss","Teodolito","Meridiano","Geod%C3%A9sica","Paralelo","Geometr%C3%ADa_el%C3%ADptica","Esfera","Geometr%C3%ADa_eucl%C3%ADdea","Variedad_de_Riemann","Espacio_eucl%C3%ADdeo","Espacio_maximalmente_sim%C3%A9trico","Tensor_de_curvatura","Tensor_m%C3%A9trico","Coordenadas_curvil%C3%ADneas","Tensor_de_Ricci","Curvatura_escalar","Grupo_de_isometr%C3%ADa","Grupo_de_Lie","Riemann","Geometr%C3%ADa_de_Riemann","Curvatura","Tensor_de_curvatura","Curvatura_del_espacio-tiempo","Albert_Einstein","Relatividad_general","Espacio-tiempo","Campo_gravitatorio","Geod%C3%A9sica","Ecuaci%C3%B3n_de_Einstein","Densidad","Geometr%C3%ADa_el%C3%ADptica","Geometr%C3%ADa_hiperb%C3%B3lica","Geometr%C3%ADa_euclidiana","Geometr%C3%ADa_hiperb%C3%B3lica","Geometr%C3%ADa_de_Riemann","Geometr%C3%ADa_el%C3%ADptica","Rutgers_University","Routledge","Witelo","Libro_de_%C3%93ptica","Ibn_al-Haytham","Levi_ben_Gerson","Saccheri","Routledge","ISBN","Addison-Wesley","ISBN","Routledge","ISBN","H._S._M._Coxeter","University_of_Toronto_Press","Mathematical_Association_of_America","Clarendon_Press","American_Mathematical_Society","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Conjunto_(matem%C3%A1ticas)","titulo":"Conjunto","contenido":"En matematicas, un conjunto es una coleccion de elementos considerada en si misma como un objeto matematico. Los elementos de un conjunto, pueden ser las siguientes: personas, numeros, colores, letras, figuras, etc. Se dice que un elemento (o miembro) pertenece al conjunto si esta definido como incluido de algun modo dentro de el.  Ejemplo: el conjunto de los colores del arcoiris es:  Un conjunto suele definirse mediante una propiedad que todos sus elementos poseen. Por ejemplo, para los numeros naturales, si se considera la propiedad de ser un numero primo, el conjunto de los numeros primos es:  Formalmente, un conjunto es el tipo de objeto matematico del que tratan los axiomas de Zermelo-Fraenkel.  El concepto de conjunto como objeto abstracto no comenzo a emplearse en matematicas hasta el siglo\u00a0XIX, a medida que se despejaban las dudas sobre la nocion de infinito.\u200b Los trabajos de Bernard Bolzano y Bernhard Riemann ya contenian ideas relacionadas con una vision conjuntista de la matematica. Las contribuciones de Richard Dedekind al algebra estaban formuladas en terminos claramente conjuntistas, que aun prevalecen en la matematica moderna: relaciones de equivalencia, particiones, homomorfismos, etc., y el mismo explicito las hipotesis y operaciones relativas a conjuntos que necesito en su trabajo.  La teoria de conjuntos como disciplina independiente se atribuye usualmente a Georg Cantor. Comenzando con sus investigaciones sobre conjuntos numericos, desarrollo un estudio sobre los conjuntos infinitos y sus propiedades. La influencia de Dedekind y Cantor empezo a ser determinante a finales del siglo\u00a0XIX, en el proceso de \u00abaxiomatizacion\u00bb de la matematica, en el que todos los objetos matematicos, como los numeros, las funciones y las diversas estructuras, fueron construidos con base en los conjuntos.  Un conjunto es una coleccion bien definida de objetos,dichos objetos pueden ser cualquier cosa: numeros, personas, letras, etc. Algunos ejemplos son:  Los conjuntos se denotan habitualmente por letras mayusculas. Los objetos que componen el conjunto se llaman elementos o miembros. Se dice que \u00abpertenecen\u00bb al conjunto y se denota mediante el simbolo \u2208:[n 1]\u200b la expresion a \u2208 A se lee entonces como \u00aba esta en A\u00bb, \u00aba pertenece a A\u00bb, \u00abA contiene a a\u00bb, etc. Para la nocion contraria se usa el simbolo \u2208. Por ejemplo:  Existen varias maneras de referirse a un conjunto. En el ejemplo anterior, para los conjuntos A y D se usa una definicion intensiva o por comprension, donde se especifica una propiedad que todos sus elementos poseen. Sin embargo, para los conjuntos B y C se usa una definicion extensiva, listando todos sus elementos explicitamente.  Es habitual usar llaves para escribir los elementos de un conjunto, de modo que:  Esta notacion mediante llaves tambien se utiliza cuando los conjuntos se especifican de forma intensiva mediante una propiedad:  Otra notacion habitual para denotar por comprension es:  En estas expresiones los dos puntos (\u00ab:\u00bb) significan \u00abtal que\u00bb. Asi, el conjunto F es el conjunto de \u00ablos numeros de la forma n2 tal que n es un numero entero entre 1 y 10 (ambos inclusive)\u00bb, o sea, el conjunto de los diez primeros cuadrados de numeros naturales. En lugar de los dos puntos se utiliza tambien la barra vertical (\u00ab|\u00bb) u oblicua \u00ab/\u00bb .  Un conjunto esta totalmente determinado por sus elementos. Por ello, la igualdad de conjuntos se establece como:  Propiedad de la extensionalidad Dos conjuntos A y B que tengan los mismos elementos son el mismo conjunto, A = B.  Esta propiedad tiene varias consecuencias. Un mismo conjunto puede especificarse de muchas maneras distintas, en particular extensivas o intensivas. Por ejemplo, el conjunto A de los numeros naturales menores que 5 es el mismo conjunto que A\u2032, el conjunto de los numeros 1, 2, 3 y 4. Tambien:  El orden en el que se precisan los elementos tampoco se tiene en cuenta para comparar dos conjuntos:  Ademas, un conjunto no puede tener elementos \u00abrepetidos\u00bb, ya que un objeto solo puede o bien ser un elemento de dicho conjunto o no serlo. Se da entonces que, por ejemplo:  En ausencia de alguna caracteristica adicional que distinga los \u00ab1\u00bb repetidos, lo unico que puede decirse del conjunto de la derecha es que \u00ab1\u00bb es uno de sus elementos.  El conjunto que no contiene ningun elemento se llama el conjunto vacio y se denota por \u2205 o simplemente {}. Algunas teorias axiomaticas de conjuntos aseguran que el conjunto vacio existe incluyendo un axioma del conjunto vacio. En otras teorias, su existencia puede deducirse. Muchas posibles propiedades de conjuntos son trivialmente validas para el conjunto vacio.  En la teoria de conjuntos axiomatica estandar, por el Axioma de extensionalidad, dos conjuntos son iguales si tienen los mismos elementos; por lo tanto solo puede haber un conjunto sin ningun elemento. Por consiguiente, solo hay un unico conjunto vacio, y hablamos de \"el conjunto vacio\" en lugar de \"un conjunto vacio\".  Para cualquier conjunto A:  (Ver operaciones con conjuntos)  El conjunto vacio tiene las siguientes propiedades:  Un subconjunto A de un conjunto B, es un conjunto que contiene algunos de los elementos de B (o quiza todos):  Un conjunto A es un subconjunto del conjunto B si cada elemento de A es a su vez un elemento de B.  Cuando A es un subconjunto de B, se denota como A \u2286 B y se dice que \u00abA esta contenido en B\u00bb. Tambien puede escribirse B \u2287 A, y decirse que B es un superconjunto de A y tambien \u00abB contiene a A\u00bb o \u00abB incluye a A\u00bb.  Todo conjunto A es un subconjunto de si mismo, ya que siempre se cumple que \u00abcada elemento de A es a su vez un elemento de A\u00bb. Es habitual establecer una distincion mas fina mediante el concepto de subconjunto propio: A es un subconjunto propio de B si es un subconjunto de B pero no es igual a B. Se denota como A \u228a B, es decir: A \u2286 B pero A = B (y equivalentemente, para un superconjunto propio, B \u228b A).[n 2]\u200b  Ejemplos.  Dos conjuntos A y B son disjuntos si no tienen ningun elemento en comun. Por ejemplo, los conjuntos de los numeros racionales y los numeros irracionales son disjuntos: no hay ningun numero que sea a la vez racional e irracional. La interseccion de dos conjuntos disjuntos es el conjunto vacio.    Los conjuntos pueden ser finitos o infinitos. En el caso de un conjunto finito se pueden contar los elementos del conjunto:  El numero de elementos de un conjunto finito es su cardinal.  El cardinal se denota por |A|, card(A) o #A. Asi, en los ejemplos anteriores, se tiene que |A| = 4 (cuatro numeros), |B| = 3 (tres colores) y |F| = 10 (diez cuadrados). El unico conjunto cuyo cardinal es 0 es el conjunto vacio \u2205.  Existen, a su vez, determinadas propiedades de cardinalidad. Si tomamos como ejemplo dos conjuntos, A y B:  Y en el caso de tres conjuntos, A, B y C:  En un conjunto infinito no hay un numero finito de elementos. Es el caso por ejemplo de los numeros naturales: N = {1, 2, 3, \u2026}. Sin embargo, existe una manera de comparar conjuntos infinitos entre si, y se obtiene que existen conjuntos infinitos \u00abmas grandes\u00bb que otros. El \u00abnumero de elementos\u00bb de un conjunto infinito es un numero transfinito.  Uno de los resultados mas importantes de Georg Cantor fue que la cardinalidad de los reales ( c }} ) es mas grande que la de los numeros naturales ( \u2135 0 } ). Esto es, que hay mas numeros reales R que numeros enteros N. Concretamente, Cantor mostro que c = 2 \u2135 0 > \u2135 0 }=2^}>}\\,} .  La hipotesis del continuo afirma que no existen conjuntos con cardinalidades intermedias entre los naturales y los reales:  Si se asume el axioma de eleccion, la estructura de los cardinales infinitos es mas clara: todos los cardinales infinitos son alefs y estan bien ordenados, por lo que existe solo un cardinal inmediatamente superior a \u21350, denotado por \u21351. La hipotesis es equivalente entonces a:  Existen varias operaciones basicas que pueden realizarse, partiendo de ciertos conjuntos dados, para obtener nuevos conjuntos: ","snippet":"En matematicas, un conjunto es una coleccion de elementos considerada en si misma como un objeto matematico. Los elementos de un conjunto, pueden ser las siguientes: personas, numeros, colores, letras","enlaces_salientes":["Conjunto","Conjunto","Conjunto","Conjunto_(desambiguaci%C3%B3n)","Pol%C3%ADgonos","Diagrama_de_Venn","Pol%C3%ADgono_regular","Subconjunto","Matem%C3%A1ticas","Teor%C3%ADa_de_categor%C3%ADas","Personas","N%C3%BAmero","Color","Letra","Figura_geom%C3%A9trica","Elemento_de_un_conjunto","Arco%C3%ADris","N%C3%BAmeros_naturales","N%C3%BAmero_primo","Axiomas_de_Zermelo-Fraenkel","Siglo_XIX","Conjunto_infinito","Bernard_Bolzano","Bernhard_Riemann","Richard_Dedekind","Relaci%C3%B3n_de_equivalencia","Partici%C3%B3n_(matem%C3%A1tica)","Homomorfismo","Teor%C3%ADa_de_conjuntos","Georg_Cantor","Funci%C3%B3n_matem%C3%A1tica","Estructura_matem%C3%A1tica","Georg_Cantor","N%C3%BAmero","Palo_(naipe)","Baraja_francesa","Elemento_de_un_conjunto","Pol%C3%ADgono","Intenci%C3%B3n","Extensi%C3%B3n_(sem%C3%A1ntica)","Par%C3%A9ntesis","Dos_puntos","Cuadrado_(%C3%A1lgebra)","N%C3%BAmeros_naturales","Barra_vertical","Barra_(tipograf%C3%ADa)","Elemento_de_un_conjunto","Par%C3%A9ntesis","Diagrama_de_Venn","Axioma_de_extensionalidad","Vocales","Idioma_espa%C3%B1ol","Conjunto_vac%C3%ADo","Teor%C3%ADa_de_conjuntos#Teor.C3.ADa_axiom.C3.A1tica_de_conjuntos","Teor%C3%ADa_de_conjuntos#Teor\u00eda_axiom\u00e1tica_de_conjuntos","Axioma_de_extensionalidad","Subconjunto","Subconjunto","Subconjunto","Subconjunto_propio","Conjuntos_disjuntos","N%C3%BAmeros_racionales","N%C3%BAmeros_irracionales","Intersecci%C3%B3n_de_conjuntos","N%C3%BAmero_cardinal","Conjunto_finito","Conjunto_infinito","Conjunto_vac%C3%ADo","N%C3%BAmeros_naturales","N%C3%BAmero_transfinito","N%C3%BAmero_real","Georg_Cantor","N%C3%BAmero_natural","Numero_real","Axioma_de_elecci%C3%B3n","%C3%81lef_(cardinales)","Buen_orden","%C3%81lgebra_de_conjuntos","Uni%C3%B3n_de_conjuntos","Intersecci%C3%B3n_de_conjuntos","Diferencia_de_conjuntos","Complemento_de_un_conjunto","Conjunto_universal","Diferencia_sim%C3%A9trica","Producto_cartesiano","Pares_ordenados","Axiomas_de_Zermelo-Fraenkel","Relaci%C3%B3n_matem%C3%A1tica","Correspondencia_matem%C3%A1tica","Conjunto_de_Borel","Equipotencia","Diagrama_de_Venn","Estructura_algebraica","Funci%C3%B3n_matem%C3%A1tica","Grupo_(matem%C3%A1tica)","Georg_Cantor","Morfismo","Teor%C3%ADa_de_conjuntos","Subconjunto","The_Stanford_Encyclopedia_of_Philosophy","Georg_Cantor","ISBN","Oxford_University_Press","ISBN","The_Stanford_Encyclopedia_of_Philosophy","ISBN","Eric_W._Weisstein","MathWorld","Wolfram_Research","Control_de_autoridades","Gemeinsame_Normdatei","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Objetos_matem%C3%A1ticos","titulo":"Objeto matematico","contenido":"Un objeto matematico es un objeto abstracto estudiado en matematicas. Algunos ejemplos tipicos de objetos matematicos son los numeros, conjuntos, funciones y figuras geometricas.\u200b La existencia y naturaleza de los objetos matematicos es materia de debate en la filosofia de la matematica y ha dado lugar a corrientes de pensamiento como el logicismo, el platonismo matematico y el formalismo matematico. ","snippet":"Un objeto matematico es un objeto abstracto estudiado en matematicas. Algunos ejemplos tipicos de objetos matematicos son los numeros, conjuntos, funciones y figuras geometricas.\u200b La existencia y natu","enlaces_salientes":["Objeto_matem%C3%A1tico","Objeto_matem%C3%A1tico","Objeto_matem%C3%A1tico","Objeto_abstracto","Matem%C3%A1ticas","N%C3%BAmero","Conjunto","Funci%C3%B3n_matem%C3%A1tica","Figura_geom%C3%A9trica","Filosof%C3%ADa_de_la_matem%C3%A1tica","Logicismo","Platonismo_matem%C3%A1tico","Formalismo_matem%C3%A1tico","Objeto_abstracto","Universal_(filosof%C3%ADa)","Platonismo_matem%C3%A1tico","ISBN","Control_de_autoridades","Gemeinsame_Normdatei"]}
{"url":"Teor%C3%ADa_de_conjuntos_de_Zermelo-Fraenkel","titulo":"Axiomas de Zermelo-Fraenkel","contenido":"En logica y matematicas, los axiomas de Zermelo-Fraenkel, formulados por Ernst Zermelo y Adolf Fraenkel, son un sistema axiomatico concebido para formular la teoria de conjuntos. Normalmente se abrevian como ZF o en su forma mas comun, complementados por el axioma de eleccion (axiom of Choice), como ZFC.  Durante el siglo\u00a0XIX algunos matematicos trataron de llevar a cabo un proceso de formalizacion de la matematica a partir de la teoria de conjuntos. Gottlob Frege intento culminar este proceso creando una axiomatica de la teoria de conjuntos. Bertrand Russell descubrio en 1901 una contradiccion, la llamada paradoja de Russell. Consecuentemente, a principios del siglo\u00a0XX se realizaron varios intentos alternativos y hoy en dia ZFC se ha convertido en el estandar de las teorias axiomaticas de conjuntos.  La teoria de conjuntos es una rama de la matematica relativamente moderna cuyo proposito es estudiar unas entidades llamadas conjuntos, aunque otra parte de esta teoria es reconocida como los fundamentos mismos de las matematicas. La teoria de conjuntos fue desarrollada por el matematico aleman Georg Cantor a finales del siglo\u00a0XIX a partir de ciertas conclusiones hechas por el mismo al reflexionar en unos detalles de las series trigonometricas de Fourier. La teoria de conjuntos fue expuesta por Cantor en una serie de articulos y libros, de los cuales pueden destacarse sus Beitrage zur Begrundung der transfiniten Mengenlehre.  El proposito de Cantor era proporcionar un metodo para lidiar con asuntos relacionados al infinito actual, un concepto que fue rehuido y rechazado por algunos matematicos (Kronecker) por considerarlo sin significado. Ciertamente Cantor tuvo exito, si bien su teoria debia ser precisada y sometida a un sistema axiomatico, un proyecto que luego fue llevado a cabo principalmente por Frege, Russell, Zermelo, Albert Skolem y Adolf Fraenkel.  Cantor partio de la conviccion platonista de que era posible \u201ccomprimir\u201d una coleccion o conjunto de objetos y considerarla como un todo (o mejor dicho, como una sola entidad), y al parecer, aceptando implicitamente los supuestos siguientes:  (i) Un conjunto es una reunion de objetos que cumplen con cierta propiedad (llamados los elementos de ese conjunto) y que, por tanto, queda definido por tal propiedad.  (ii) Un conjunto es una sola entidad matematica, de modo que puede a su vez ser contenido por otro conjunto.  (iii) Dos conjuntos que tengan los mismos elementos son iguales. Asi, puede decirse que un conjunto esta determinado por sus elementos.  De este modo, Cantor pudo desarrollar su teoria de una forma que en aquel entonces parecia lo suficientemente satisfactoria. Sin embargo, el sistema de Cantor era tan permisivo que dio lugar a resultados contradictorios. Gottlob Frege, que ideo un sistema mas preciso, intento fundamentar adecuadamente la teoria de conjuntos (y por tanto todas las matematicas), pero, para su desaliento, Bertrand Russell descubrio una paradoja en la teoria de aquel (hoy llamada paradoja de Russell), con lo que el sistema de Frege parecia desbaratarse. A principios del siglo\u00a0XX, fue el matematico aleman Ernst Zermelo quien puso la teoria de conjuntos sobre una base aceptable reduciendola a un sistema axiomatico mas restringido que no permitia la obtencion de la Paradoja de Russell. Las ideas de Zermelo fueron despues precisadas por Thoralf Skolem y Abraham Fraenkel, resultando de ello la primera teoria axiomatica de conjuntos, conocida como teoria de Zermelo-Fraenkel, aunque seria mas adecuada llamarla teoria de Zermelo-Fraenkel-Skolem. John von Neumann, Paul Bernays y Kurt Godel desarrollaron despues otra teoria de conjuntos que evitaba las paradojas de la teoria cantoriana: la teoria de von Neumann-Bernays-Godel.  El concepto de conjunto se encuentra a un nivel tan elemental que no es posible dar una definicion precisa del mismo. Palabras como coleccion, reunion, agrupacion, y algunas otras de significado similar, se usan en un intento de describir a los conjuntos, pero no pueden constituir una definicion, pues son simplemente un reemplazo de la palabra conjunto. Con todo, en la teoria intuitiva de conjuntos lo anterior es admisible, y se acepta la existencia de un universo o dominio de objetos a partir del cual se construyen los conjuntos, asi como tambien permite tratar conjuntos como una entidad singular. No es de importancia la naturaleza de los objetos, sino el comportamiento de un conjunto como entidad matematica.  De lo dicho anteriormente, parece natural introducir una relacion diadica de pertenencia. El simbolo usual para representar esta relacion es el simbolo \u2208 , una version de la letra griega \u03f5 (epsilon). Los segundos argumentos de la relacion \u2208 son llamados conjuntos, y los primeros argumentos son llamados elementos. Asi, si la formula  se cumple, se dice que a es un elemento del conjunto X . Si aceptamos que todo es un conjunto, entonces los primeros y segundos argumentos de \u2208 pertenecen al mismo dominio.  La negacion de a \u2208 X se escribe a \u2208 X .  Bajo estos supuestos puede desarrollarse un poco la teoria de conjuntos. Sin embargo, la concepcion intuitiva de conjuntos no permite llegar tan lejos como pudiera desearse, pues llega un momento en que, como sucede en otras areas de las matematicas, la intuicion es de poca o ninguna ayuda (por ejemplo como pasa al hablar de la hipotesis del continuo, de espacios de dimension mayor que tres, etc.). Es en momentos como ese en que se hace evidente la necesidad de axiomatizar y formalizar la teoria de conjuntos para poder llegar a resultados mas profundos. Esto implica renunciar a una definicion intuitiva de conjunto, y en su lugar postular una serie de principios que determinen el comportamiento de este, de tal forma que los resultados obtenidos no son ya consecuencia de razonamientos intuitivos flojos, sino que se obtienen a partir de tales principios.     Asi, por ejemplo, considerando la formula a = a , se obtiene el conjunto          La teoria de conjuntos de Zermelo-Fraenkel toma como primitivos los conceptos de conjunto y de pertenencia y consta de los diez axiomas siguientes:  1. Axioma de extensionalidad. Dos conjuntos X e Y son iguales (lo que se representa por X = Y ) unicamente si contienen los mismos elementos. Mas formalmente, y en la simbologia usual, \u2200 a , ( a \u2208 X \u2194 a \u2208 Y ) \u21d2 X = Y  2. Axioma del conjunto vacio. Existe un conjunto (representado por \u00d8) sin elementos. Esto es, \u2203 \u2205 : \u2200 a , a \u2208 \u2205 .  3. Axioma de pares. Dados cualesquiera conjuntos x e y , existe otro conjunto, representado por { x , y } } , cuyos elementos son unicamente x e y . Esto es, \u2200 x , y \u2203 z / ( \u2200 a , a \u2208 z \u2194 a = x \u2228 a = y ) .  4. Axioma de la union. Dado cualquier conjunto C , existe un conjunto, representado por \u22c3 C y llamado union de C , que contiene todos los elementos de cada elemento de C . Esto es, \u2200X,\u2203Y/(\u2200a:a\u2208Y\u2194\u2203Z\u2208X\u2227a\u2208Z)  5. Axioma del conjunto potencia Para cualquier conjunto x existe otro conjunto, representado por P ( x ) }(x)} , que contiene todos los subconjuntos de x . En simbolos, \u2200X\u2203Y/(\u2200Z:Z\u2208Y\u2194(\u2200a\u2208Z\u2192a\u2208X))  6. Esquema axiomatico de especificacion. Sea \u03d5 ( v ) una formula de un lenguaje de primer orden que contenga una variable libre v . Entonces, para cualquier conjunto x existe un conjunto y cuyos elementos son aquellos elementos a de x que cumplen \u03d5 ( a ) . Formalmente, \u2200X\u2203Y/(\u2200a:a\u2208Y\u2194a\u2208X\u2227P(a))  7. Esquema axiomatico de reemplazo. Si \u03d5 ( a , b ) es una sentencia tal que para cualquier elemento a de un conjunto x el conjunto y = { b \u2223 \u03d5 ( a , b ) } } existe, entonces existe una funcion f:x\u2192y tal que f(a)=b. Formalmente, si P(x,y)/(\u2200x\u2208A\u2203y:P(x,y)) entonces \u2200A,\u2203B/(\u2200x\u2208A\u2203y\u2208B/P(x,y)cierta)  8. Axioma de infinitud. Existe un conjunto x tal que \u2205 \u2208 x y tal que si y \u2208 x , entonces y \u222a { y } \u2208 x \\in x} . En simbolos, \u2203X/(\u00d8\u2208X\u2227(\u2200Y\u2208X:S(Y)\u2208X))  9. Axioma de regularidad. Para todo conjunto no vacio x existe un conjunto y \u2208 x tal que x \u2229 y = \u2205 . Esto es, en terminos formales, \u2200X\u2203Y/(Y\u2208X\u2227X\u2229Y=\u2205)  10. Lema de Zorn. Dado un conjunto ordenado no vacio tal que todas sus cadenas tienen una cota superior, contiene al menos un elemento maximal.  En un principio Zermelo trato de probar el \"Lema de Zorn\" a partir de los otros nueve axiomas, pero no lo consiguio, ademas, posteriormente los Teoremas de Incompletitud de Godel probaron que el Lema de Zorn no era demostrable a partir de los restantes axiomas. Por lo tanto se a\u00f1adio como decimo axioma de la teoria.  Es equivalente a  Axioma de eleccion. Dada una familia de conjuntos no vacios podemos elegir un elemento de cada conjunto. Este axioma puede expresarse de manera equivalente a, dado un conjunto cualquiera x, existe una funcion f que elige un elemento de cada conjunto no vacio de x:   \u2200 x \u2203 f : x \u2192 \u222a x , \u2200 a ( a \u2208 x \u2227 a = \u2205 \u2192 f ( a ) \u2208 a ) .  El axioma de extensionalidad dice que dos conjuntos son iguales si y solo si tienen los mismos elementos. En otras palabras, afirma que un conjunto esta determinado por su extension (todos sus elementos). Una relacion mas general que la igualdad es la inclusion ( \u2286 ), que se define como sigue:   x \u2286 y \u2261 \u2200 a ( a \u2208 x \u2192 a \u2208 y )  A diferencia del signo de la igualdad, el simbolo \u2286 no figura dentro del lenguaje de primer orden con el que se construye la teoria ZF, pues la definicion antes dada deberia en ese caso ser introducida como un axioma que establezca el empleo de \u2286 , cosa que no se ha hecho aqui. En su lugar, la simbologia x \u2286 y se emplea simplemente para representar la formula \u2200 a ( a \u2208 x \u2192 a \u2208 y ) del lenguaje de la teoria de conjuntos.  En vista del axioma de extensionalidad y de la definicion anterior, resulta que puede probarse que dos conjuntos x e y son iguales si puede probarse que x \u2286 y e y \u2286 x .  El axioma del conjunto vacio nos da un conjunto sin elementos. Este axioma se presento usando el simbolo \u2205 . Esto esta justificado, pues el axioma de extensionalidad nos dice que este conjunto es unico.   \u2200 a , a \u2208 \u2205 \u2194 a \u2208 \u2205 \u2032 ,  de modo que, por el axioma de extensionalidad, \u2205 = \u2205 \u2032 .  El axioma del conjunto vacio puede deducirse de otro axioma mas debil, que afirma la existencia de un conjunto, digamos x , y del esquema de especificacion con la formula a = a aplicada a este conjunto x . Asi, el conjunto vacio es el conjunto     con el termino a \u2208 x \u2223 a = a una descripcion impropia.  EL axioma de pares, un axioma de la teoria de Zermelo-Fraenkel, establece que, dados cualesquiera dos conjuntos x e y , existe otro conjunto, representado por { x , y } } , cuyos elementos son unicamente x e y . Esto es,  (3) \u2200 x , y \u2203 z \u2200 a ( a \u2208 z \u2194 a = x \u2228 a = y ) .  Del axioma de pares se tiene, a partir de dos conjuntos X e Y , el conjunto { x , y }. Este conjunto se llama par desordenado de X e Y . Si se aplica el axioma de pares a un solo conjunto X , se obtiene el par { x , x } cuyo unico elemento es, obviamente, x , y por ello puede representarse como { x } } .  A este ultimo conjunto puede aplicarsele de nuevo el axioma de pares, dando lugar al conjunto {{ x }}, conjunto al cual puede aplicarse tambien el axioma de pares, obteniendose el conjunto {{{ x }}}, y asi sucesivamente. Este proceso de construccion de conjuntos puede aplicarse al unico conjunto dado y conocido explicitamente, \u2205 , obteniendose una serie infinita de conjuntos    Si A es una coleccion de conjuntos, entonces la union \u22c3 A contiene aquellos y solo aquellos elementos que estan en algun conjunto de A . Si A = { x 1 , x 2 \u2026 x n } ,x_{2}\\ldots x_{n}\\}} , un conjunto con n elementos, entonces es comun escribir     para representar la union de los conjuntos de A . Es facil ver que     de modo que el axioma de union y el axioma de pares garantizan la existencia del conjunto x \u222a y = { a \u2223 a \u2208 x \u2228 a \u2208 y } } para cualesquiera conjuntos x e y , un hecho que no puede deducirse simplemente del esquema de especificacion junto con los axiomas restantes. A diferencia de la union, la interseccion de conjuntos es deducible a partir del axioma de pares y el esquema de especificacion. Efectivamente, pues se define el conjunto x \u2229 y mediante     y por tanto x \u2229 y existe. Mas general, se define el conjunto    El axioma del conjunto potencia nos da un conjunto que contiene a todos los subconjuntos de cualquier conjunto. Por tanto, P ( \u2205 ) = { \u2205 } }(\\emptyset )=\\} . Puesto que x \u2208 P ( x ) }(x)} para cualquiera que sea el conjunto x , puede hacerse uso del esquema de especificacion para obtener el conjunto        El esquema de especificacion resulta ser una version limitada o debil del axioma de Frege. Para este ultimo, era posible tener un conjunto cuyos elementos satisfacian cierta propiedad. Con ello Frege garantizaba demasiado y daba lugar en su sistema a paradojas como la de Russell, entre otras. Por otra parte, el esquema de especificacion va de acuerdo con una doctrina de reduccion del tama\u00f1o. Permite obtener conjuntos a partir de otros, y cuyo tama\u00f1o es menor que el de aquellos de los que han sido obtenidos. Esto implica que, necesariamente, contemos con conjuntos previamente dados. Por tanto, nunca es posible pensar en la formula x \u2208 x , pues el conjunto x no puede ser obtenido sin mas que si mismo. La paradoja de Russell surge precisamente de considerar que conjuntos muy grandes pueden ser obtenidos de forma gratuita sin mas que especificar cuales son sus elementos. Otras paradojas que tienen que ver con el gran tama\u00f1o de los conjuntos, quedan excluidas de ZF mediante el esquema de especificacion. Ahora bien, el calificativo de esquema se debe a que no es un unico axioma, sino que este afirma (metamatematicamente) que cualquier expresion de la forma     donde \u03d5 ( a ) es una formula del lenguaje de la teoria de conjuntos es un axioma de ZF. Asi, si consideramos la existencia de un conjunto x como un axioma, el conjunto vacio seria tambien un axioma resultante de aplicar el esquema de especificacion al conjunto x con la formula a = a .  El esquema de especificacion no es independiente en ZF, pues se deduce del esquema de reemplazo, introducido por Fraenkel y Skolem el mismo a\u00f1o y de forma independiente.  El esquema axiomatico de reemplazo dice que si v es un conjunto y \u03b8 es una formula con dos variables libres x e y , tales que para cada x \u2208 v existe un unico y tal que \u03b8 ( x , y ) se cumple, entonces existe un conjunto w tal que y \u2208 w si y solo si \u03b8 ( x , y ) .  Para mostrar como el esquema de especificacion se deduce del esquema de reemplazo, se considera la formula     donde x cualquier elemento de un conjunto v . Si \u03d5 ( x ) , entonces ciertamente existe un unico y tal que \u03d5 ( x ) \u2227 x = y (pues es x mismo), por lo que la hipotesis del esquema de reemplazo se cumple, con lo que existe un conjunto w tal que     lo que es logicamente equivalente a que existe un conjunto w tal que     La formulacion que se ha dado del axioma de reemplazo fue introducida por primera vez por Fraenkel , y aparecio tambien en los trabajos de Church . Una forma mas debil de este esquema axiomatico a parece en los trabajos de Tarski . La formulacion original, dada por Fraenkel [1921/22 y 1927] y Skolem [1922/23 y 1929], es en esencia como sigue:  El esquema de reemplazo fue introducido por Fraenkel y Skolem con la finalidad de extender la fuerza del esquema de especificacion, asi como tambien posibilitar el conteo de numeros ordinales mas alla de lo que permite el axioma de infinitud.  El axioma de infinitud, introducido (aunque no en la forma en que se ha presentado aqui) por Zermelo 1908, permite la obtencion de los numeros naturales como conjuntos dentro de ZF. En terminos generales, este axioma da un conjunto infinito segun Dedekind, pues garantiza la existencia de un conjunto X sobre el cual existe al menos una funcion f : X \u2192 X inyectiva y no sobreyectiva (que claramente no existe para un conjunto finito). Es decir, la funcion f es tal que D f = X }f=X} y R f \u2282 X }f\\subset X} , por lo que el rango de f es un subconjunto propio de su dominio, X . Pero, en ese caso, la aplicacion   g : X \u2192 R ( f ) }(f)}  dada por g ( x ) = f ( x ) , es biyectiva. La conclusion es que existe una biyeccion entre X y uno de sus subconjuntos propios. Ahora bien, el conjunto X cuya existencia garantiza el axioma de infinitud, cumple:   i) \u2205 \u2208 X ii) x \u2208 X \u2192 x \u222a { x } \u2208 X {l}}\\emptyset \\in X\\\\}x\\in X\\to x\\cup \\{x\\}\\in X\\end{array}}}  Pero es posible que subconjuntos de X cumplan esto mismo (un subconjunto asi de X se denomina conjunto inductivo). Si Y es el conjunto de todos los subconjuntos inductivos de X , Y es no vacio, pues X \u2208 Y . Asi, puede formarse la interseccion     de todos los conjuntos inductivos. Este conjunto es claramente inductivo, y sus elementos son     mismos que pueden ser considerados los numeros naturales en ZF, y puede llamarse \u22c2 Y = N } . Se observa que, de este modo, un numero natural es un conjunto que contiene a todos los numeros naturales anteriores a el. El conjunto de numeros naturales queda de esta forma bien ordenado por la inclusion. Cualquier numero natural de la forma n \u222a { n } } para algun n \u2208 N } se llama sucesor de n , y se representa por n + } o por s ( n ) . Mediante esta definicion de N } pueden probarse los axiomas de Peano, con lo que en ZF estos se convierten en teoremas (mas exactamente, cuatro teoremas y un metateorema) sencillos:   La forma en que se ha presentado el axioma de infinitud se debe a Fraenkel, y permite la construccion de los numeros naturales como numeros ordinales en el sentido de von Neumann. En esta forma fue utilizado por R. M. Robinson en su The thory of classes  (en donde presenta una modificacion del sistema de von Neumann), asi como tambien por Bernays .   Zermelo introdujo el axioma de infinitud  de forma esencialmente similar a la siguiente:  ( i ) \u2205 \u2208 X  ( ii ) x \u2208 X \u2192 { x } \u2208 X \\in X}   Asi, puede obtenerse el conjunto de numeros naturales cuyos elementos son     El orden que se establece entre estos elementos es el de la inclusion.  Este axioma de infinitud de Zermelo no tiene las ventajas que tiene el axioma de infinitud de Fraenkel.  El axioma de regularidad dado aqui se debe a Zermelo , si bien von Neumann presento uno equivalente  , aunque mas complicado. Este axioma prohibe la existencia de conjuntos extra\u00f1os, tales como conjuntos que cumplan: x\u2208x; o un par de conjuntos con x\u2208y \u2227 y\u2208x; asi como tambien la existencia de cadenas descendientes infinitas:   \u2026 \u2208 x 2 \u2208 x 1 \u2208 x 0 . \\in x_{1}\\in x_{0}.}  Existen teorias de conjuntos donde se excluye este axioma. La teoria que resulta de a\u00f1adir un contrario del axioma de regularidad se conoce como teoria de conjuntos no bien fundados.  A diferencia de los axiomas de ZF, el axioma de eleccion es un axioma no constructivo, en el sentido de que no determina un conjunto unico a partir de su informacion. Ademas, como puede observarse, carece de la obviedad que (aunque la complejidad notacional de estos haga en algunos casos pensar lo contrario) caracteriza a todos los otros axiomas. Esto llevo a algunos matematicos al intento de probar el axioma de eleccion a partir de los demas axiomas, cosa en lo que todos ellos fracasaron. Estos intentos vanos de probar el axioma de eleccion despues de grandes esfuerzos, y ciertas peculiaridades del mismo, algunos matematicos pensaban ya en la posible independencia del axioma de eleccion respecto de los axiomas de ZF, aunque no sabian en que direccion se encontraba la prueba de ello. Godel probo [1930/1940] que el axioma de eleccion era consistente con los axiomas de ZF, por lo que podia emplearse junto con ellos sin temor de obtener contradicciones.  El axioma de eleccion fue presentado por Russell en 1906 de manera esencialmente similar a la siguiente:  Russell llamo a este principio Axioma multiplicativo. El nombre de Axioma de eleccion (Auswahlaxiom) fue dado por Zermelo al principio mas general que el de Russell:  El nombre del axioma se debe al hecho de que la funcion f elige un elemento de cada elemento (conjunto) x de X .  Zermelo introdujo el axioma de eleccion para probar el teorema de buena ordenacion que afirma que todo conjunto puede ser bien ordenado. Mostro tambien que el lema de Kuratowski-Zorn se deduce del axioma de eleccion. En realidad, el axioma de eleccion es equivalente tanto al teorema de buena ordenacion como al lema de Kuratowski-Zorn (la mayoria de las veces simplemente llamado Lema de Zorn). La siguiente lista enumera algunos principios equivalentes en ZF al axioma de eleccion:  Wac\u0142aw Sierpinski probo en 1947 que la hipotesis del continuo (un principio ad hoc que debe ser aceptado como axioma de la teoria de conjuntos) implica el axioma de eleccion, si bien lo reciproco no es cierto. Otro principio que implica el axioma de eleccion es el axioma de conjuntos inaccesibles de Tarski [1938/1939].  El sistema axiomatico de ZFC admite las demostraciones por reduccion al absurdo como metodo para demostrar teoremas. Dado un (presunto) conjunto nos basta con llegar a una contradiccion con el resto de la teoria despues de haber supuesto su existencia para demostrar que no existe tal conjunto. un ejemplo tipico es la no existencia del conjunto de todos los conjuntos.   \u2203 X , ( \u2200 u : ( u \u2208 X ) )  De existir este conjunto V, podriamos definir el conjunto Y = { x \u2208 V | x \u2208 x } } , lo que irremisiblemente lleva a la Paradoja de Russell, por lo cual V no es un conjunto.  Procedimiento igual nos llevara a demostrar la no existencia de conjunto conjugado (conjunto de los elementos no pertenecientes al conjunto) dado un conjunto cualquiera, ya que de ser asi existiria su union, por el axioma de la union, y esta seria igual a V.  Kurt Godel probo que la consistencia logica de los axiomas de ZFC es indemostrable. A lo sumo se pueden demostrar afirmaciones como si ZFC es consistente, entonces \"T\" tambien lo es, es decir la consistencia relativa. En cuanto a la completitud, el propio Godel en sus teoremas de incompletitud demostro que si un sistema axiomatico es lo suficientemente fuerte como para construir una aritmetica recursiva, dicho sistema no puede ser completo y consistente. ","snippet":"En logica y matematicas, los axiomas de Zermelo-Fraenkel, formulados por Ernst Zermelo y Adolf Fraenkel, son un sistema axiomatico concebido para formular la teoria de conjuntos. Normalmente se abrevi","enlaces_salientes":["Axiomas_de_Zermelo-Fraenkel","Axiomas_de_Zermelo-Fraenkel","Axiomas_de_Zermelo-Fraenkel","L%C3%B3gica","Matem%C3%A1ticas","Ernst_Zermelo","Adolf_Fraenkel","Sistema_axiom%C3%A1tico","Teor%C3%ADa_de_conjuntos","Axioma_de_elecci%C3%B3n","Teor%C3%ADa_de_conjuntos","Gottlob_Frege","Axioma","Bertrand_Russell","1901","Paradoja_de_Russell","Teor%C3%ADa_de_conjuntos","Matem%C3%A1tica","Conjunto","Georg_Cantor","Serie_de_Fourier","Infinito_potencial_e_infinito_actual","Leopold_Kronecker","Gottlob_Frege","Bertrand_Russell","Ernst_Zermelo","Adolf_Fraenkel","Gottlob_Frege","Bertrand_Russell","Paradoja_de_Russell","Ernst_Zermelo","Abraham_Fraenkel","John_von_Neumann","Paul_Bernays","Kurt_G%C3%B6del","Teor%C3%ADa_de_conjuntos_de_Von_Neumann-Bernays-G%C3%B6del","Hip%C3%B3tesis_del_continuo","Conjunto_universal","Paradoja_de_Russell","Principia_Mathematica","Axioma_de_extensionalidad","Esquema_axiom%C3%A1tico_de_reemplazo","Axioma_de_regularidad","Lema_de_Zorn","Axioma_de_elecci%C3%B3n","Conjunto_vac%C3%ADo","Axiom%C3%A1tica_de_Zermelo-Fraenkel","Conjunto","Axioma_de_uni%C3%B3n","Conjunto_potencia","Esquema_axiom%C3%A1tico_de_reemplazo","Axioma_del_infinito","1908","Conjunto_infinito","Axioma_de_regularidad","Axioma_de_elecci%C3%B3n","Wac%C5%82aw_Sierpi%C5%84ski","Hip%C3%B3tesis_del_continuo","Paradoja_de_Russell","Teoremas_de_incompletitud_de_G%C3%B6del","Kurt_G%C3%B6del","Consistencia_l%C3%B3gica","Axioma","Teor%C3%ADa_de_conjuntos_de_Morse-Kelley","Teor%C3%ADa_de_conjuntos_de_Von_Neumann-Bernays-G%C3%B6del","Lenguaje_formal","L%C3%B3gica_matem%C3%A1tica","Noci%C3%B3n_primitiva","Sistema_formal","Teor%C3%ADa_de_conjuntos","Control_de_autoridades","Enciclopedia_Brit%C3%A1nica"]}
{"url":"C%C3%A1lculo_proposicional","titulo":"Logica proposicional","contenido":"La logica proposicional, tambien llamada logica de enunciados, logica de orden cero o calculo proposicional, es un sistema formal cuyos elementos mas simples representan proposiciones o enunciados, y cuyas constantes logicas, llamadas conectivas logicas, representan operaciones sobre proposiciones, capaces de formar otras proposiciones de mayor complejidad.\u200b  Las logicas proposicionales carecen de cuantificadores o variables de individuo, pero tienen variables proposicionales (es decir, que se pueden interpretar como proposiciones con un valor de verdad definido), de ahi el nombre proposicional. Los sistemas de logica proposicional incluyen ademas conectivas logicas, por lo que dentro de este tipo de logica se puede analizar la inferencia logica de proposiciones a partir de proposiciones, pero sin tener en cuenta la estructura interna de las proposiciones mas simples.\u200b  Como las logicas proposicionales no tienen cuantificadores o variables de individuo, cualquier secuencia de signos que constituya una formula bien formada admite una valoracion en la proposicion es verdadera o falsa dependiendo del valor de verdad asignado a las proposiciones que la compongan. Esto implica que cualquier formula bien formada define una funcion proposicional. Por tanto, cualquier sistema logico basado en la logica proposicional es decidible y en un numero finito de pasos se puede determinar la verdad o falsedad semantica de una proposicion. Esto hace que la logica proposicional sea completa y con una semantica muy sencilla.  Considerese el siguiente argumento:  Es un argumento valido. Quiere decir que es imposible que las premisas (1) y (2) sean verdaderas y la conclusion (3) falsa.  Sin embargo, a pesar de que el argumento sea valido, esto no quiere decir que la conclusion sea verdadera. En otras palabras, si las premisas son falsas, entonces la conclusion tambien podria serlo. Pero si las premisas son verdaderas, entonces la conclusion tambien lo es. La validez del argumento no depende del significado de las expresiones \u00abma\u00f1ana es miercoles\u00bb ni \u00abma\u00f1ana es jueves\u00bb, sino de la estructura misma del argumento. Estas premisas podrian cambiarse por otras y el argumento permaneceria valido. Por ejemplo:  La validez de los dos argumentos anteriores depende del significado de las expresiones \u00abo\u00bb y \u00abno\u00bb. Si alguna de estas expresiones se cambia por otra, entonces los argumentos podrian dejar de ser validos. Por ejemplo, considerese el siguiente argumento invalido:  Estas expresiones como \u00abo\u00bb y \u00abno\u00bb, de las que depende la validez de los argumentos, se llaman conectivas logicas. En cuanto a expresiones como \u00abesta nublado\u00bb y \u00abma\u00f1ana es jueves\u00bb, lo unico que importa de ellas es que tengan un valor de verdad. Es por esto que se las reemplaza por simples letras, cuya intencion es simbolizar una expresion con valor de verdad cualquiera. A estas letras se las llama variables proposicionales, y en general se toman del alfabeto latino, empezando por la letra p (de \u00abproposicion\u00bb) luego q, r, s, etc. Es asi que los dos primeros argumentos de esta seccion se podrian reescribir asi:  Y el tercer argumento, a pesar de no ser valido, se puede reescribir asi:  A continuacion hay una tabla que despliega todas las conectivas logicas que ocupan a la logica proposicional, incluyendo ejemplos de su uso en el lenguaje natural y los simbolos que se utilizan para representarlas en lenguaje formal.  En la logica proposicional, las conectivas logicas se tratan como funciones de verdad. Es decir, como funciones que toman conjuntos de valores de verdad y devuelven valores de verdad. Por ejemplo, la conectiva logica \u00abno\u00bb es una funcion que si toma el valor de verdad V, devuelve F, y si toma el valor de verdad F, devuelve V. Por lo tanto, si se aplica la funcion \u00abno\u00bb a una letra que represente una proposicion falsa, el resultado sera algo verdadero. Si es falso que \u00abesta lloviendo\u00bb, entonces sera verdadero que \u00abno esta lloviendo\u00bb.  El significado de las conectivas logicas no es nada mas que su comportamiento como funciones de verdad. Cada conectiva logica se distingue de las otras por los valores de verdad que devuelve frente a las distintas combinaciones de valores de verdad que puede recibir. Esto quiere decir que el significado de cada conectiva logica puede ilustrarse mediante una tabla que despliegue los valores de verdad que la funcion devuelve frente a todas las combinaciones posibles de valores de verdad que puede recibir.   \u03d5 \u00ac \u03d5 F V V F {c||c}\\phi &\\neg \\phi \\\\\\hline F&V\\\\V&F\\\\\\end{array}}}   \u03d5 \u03c8 \u03d5 \u2227 \u03c8 V V V F V F V F F F F F {c|c||c}\\phi &\\psi &\\phi \\land \\psi \\\\\\hline V&V&V\\\\F&V&F\\\\V&F&F\\\\F&F&F\\\\\\end{array}}}   \u03d5 \u03c8 \u03d5 \u2228 \u03c8 V V V F V V V F V F F F {c|c||c}\\phi &\\psi &\\phi \\lor \\psi \\\\\\hline V&V&V\\\\F&V&V\\\\V&F&V\\\\F&F&F\\\\\\end{array}}}   \u03d5 \u03c8 \u03d5 \u2192 \u03c8 V V V F V V V F F F F V {c|c||c}\\phi &\\psi &\\phi \\to \\psi \\\\\\hline V&V&V\\\\F&V&V\\\\V&F&F\\\\F&F&V\\\\\\end{array}}}   \u03d5 \u03c8 \u03d5 \u2194 \u03c8 V V V F V F V F F F F V {c|c||c}\\phi &\\psi &\\phi \\leftrightarrow \\psi \\\\\\hline V&V&V\\\\F&V&F\\\\V&F&F\\\\F&F&V\\\\\\end{array}}}   \u03d5 \u03c8 \u03d5 \u2194 \u03c8 V V F F V V V F V F F F {c|c||c}\\phi &\\psi &\\phi \\nleftrightarrow \\psi \\\\\\hline V&V&F\\\\F&V&V\\\\V&F&V\\\\F&F&F\\\\\\end{array}}}  Entre las reglas de la logica proposicional clasica algunas de la mas notables son listadas a continuacion:  Otras leyes como el principio del tercero excluido son admisibles en logica clasica, pero en logica intuicionista y con fines a sus aplicaciones matematicas no existe un equivalente del tercero excluido.  La maquinaria de la logica proposicional permite formalizar y teorizar sobre la validez de una gran cantidad de argumentos. Sin embargo, tambien existen argumentos que son intuitivamente validos, pero cuya validez no se puede probar por la logica proposicional. Por ejemplo, considerese el siguiente argumento:  Como este argumento no contiene ninguna de las conectivas \u00abno\u00bb, \u00aby\u00bb, \u00abo\u00bb, etc., segun la logica proposicional, su formalizacion sera la siguiente:  Pero esta es una forma de argumento invalida, y eso contradice nuestra intuicion de que el argumento es valido. Para teorizar sobre la validez de este tipo de argumentos, se necesita investigar la estructura interna de las variables proposicionales. De esto se ocupa la logica de primer orden. Otros sistemas formales permiten teorizar sobre otros tipos de argumentos. Por ejemplo la logica de segundo orden, la logica modal y la logica temporal.  A continuacion se presentan dos sistemas formales estandar para la logica proposicional. El primero es un sistema axiomatico simple, y el segundo es un sistema sin axiomas, de deduccion natural.  El alfabeto de un sistema formal es el conjunto de simbolos que pertenecen al lenguaje del sistema. Si L es el nombre de este sistema axiomatico de logica proposicional, entonces el alfabeto de L consiste en:  Una vez definido el alfabeto, el siguiente paso es determinar que combinaciones de simbolos pertenecen al lenguaje del sistema. Esto se logra mediante una gramatica formal. La misma consiste en un conjunto de reglas que definen recursivamente las cadenas de caracteres que pertenecen al lenguaje. A las cadenas de caracteres construidas segun estas reglas se las llama formulas bien formadas. Las reglas del sistema L son:  Segun estas reglas, las siguientes cadenas de caracteres son ejemplos de formulas bien formadas:  Y los siguientes son ejemplos de formulas mal formadas[cita\u00a0requerida]:  Por otra parte, dado que la unica funcion de los parentesis es desambiguar las formulas, en general se acostumbra omitir los parentesis externos de cada formula, ya que estos no cumplen ninguna funcion. Asi por ejemplo, las siguientes formulas generalmente se consideran bien formadas:  Otra convencion acerca del uso de los parentesis es que las conjunciones y las disyunciones tienen \u00abmenor jerarquia\u00bb que los condicionales materiales y los bicondicionales. Esto significa que dada una formula sin parentesis, las conjunciones y las disyunciones deben agruparse antes que los condicionales materiales y los bicondicionales. Por ejemplo:  Estas convenciones son analogas a las que existen en el algebra elemental, donde la multiplicacion y la division siempre deben resolverse antes que la suma y la resta. Asi por ejemplo, la ecuacion 2 + 2 \u00d7 2 podria interpretarse como (2 + 2) \u00d7 2 o como 2 + (2 \u00d7 2). En el primer caso el resultado seria 8, y en el segundo caso seria 6. Pero como la multiplicacion siempre debe resolverse antes que la suma, el resultado correcto en este caso es 6, no 8.  Los axiomas de un sistema formal son un conjunto de formulas bien formadas que se toman como punto de partida para demostraciones ulteriores. Un conjunto de axiomas estandar es el que descubrio Jan \u0141ukasiewicz:  Una regla de inferencia es una funcion que va de conjuntos de formulas a formulas. Al conjunto de formulas que la funcion toma como argumento se lo llama premisas, mientras que a la formula que devuelve como valor se la llama conclusion. En general se busca que las reglas de inferencia transmitan la verdad de las premisas a la conclusion. Es decir, que sea imposible que las premisas sean verdaderas y la conclusion falsa. En el caso de L, la unica regla de inferencia es el modus ponens, el cual dice:  Recordando que \u03d5 y \u03c8 no son formulas, sino metavariables que pueden ser reemplazadas por cualquier formula bien formada.  Sea L 2 = L ( A , \u03a9 , Z , I ) }_{2}=}(\\mathrm {A} ,\\Omega ,\\mathrm {Z} ,\\mathrm {I} )} , donde A } , \u03a9 , Z } , I } , se define como:  En el siguiente ejemplo es de un calculo proposicional, las reglas presentadas de transformacion tienen que ser interpretadas como reglas de inferencia de un sistema de deduccion natural. El sistema particular aqui presentado no tiene puntos iniciales, lo que significa que su interpretacion para las aplicaciones logicas deriva de un teorema de conjuntos de axiomas vacios.  *El conjunto de puntos iniciales esta vacio, este es I = \u2205 =\\varnothing } .  *El conjunto de reglas de transformacion Z } se describe como\u00a0:  Nuestro calculo proposicional tiene diez reglas de inferencia. Estas reglas nos permiten derivar otras formulas verdaderas dado un conjunto de formulas que se supone que son verdaderas. Las primeros nueve simplemente declaran que podemos inferir ciertas formulas bien formadas de otras formulas bien formadas; y la ultima regla utiliza el razonamiento hipotetico en el sentido de que la premisa de la regla asuma temporalmente una hipotesis( no probada) para formar parte del conjunto de formulas deducidas para ver si podemos inferir alguna otra formula. Dado que las primeras nueve reglas no son hipoteticas , usualmente se describirian como reglas no hipoteticas, y la ultima regla como una regla hipotetica.  Al describir las reglas de transformacion, podemos introducir un simbolo de metalenguaje \u22a2 . Es basicamente una taquigrafia conveniente para decir \" inferir que \". El formato es \u0393 \u22a2 \u03c8 , en el cual \u0393 es un conjunto de formulas llamadas premisas, y \u03c8 es una formula para hallar la conclusion. La regla de tranformacion \u0393 \u22a2 \u03c8 significa que si toda proposicion en\u0393 es un teorema ( o tiene el mismo valor de verdad que los axiomas ), entonces \u03c8 es tambien un teorema. Tenga en cuenta que teniendo en cuenta la siguiente regla la introduccion de conjuncion \u0393 tiene mas de una formula, siempre podemos reducirla con seguridad en una formula usando una conjuncion. Asi que para abreviar, a partir de ese momento podemos representar \u0393 como una formula en lugar de un conjunto. Otra omision por conveniencia es cuando \u0393 es un conjunto vacio, en cuyo caso \u0393 puede no aparecer.  Un sistema de logica proposicional tambien puede construirse a partir de un conjunto vacio de axiomas. Para ello se especifican una serie de reglas de inferencia que intentan capturar el modo en que naturalmente razonamos acerca de las conectivas logicas.  Demostrar: A \u2192 A  Una posible prueba de esto (que, aunque valida, pasa a contener mas pasos de los necesarios) se puede disponer de la siguiente manera:  Interpretar A \u22a2 A como: \"Asumiendo que A , inferire A \". Leer \u22a2 A \u2192 A como \"Suponiendo nada, inferir que A implica A \", o \"Es una tautologia que A implica A \", o \"Siempre es cierto que A implica A \".  El lenguaje formal de la logica proposicional se puede generar con la gramatica formal descrita usando la notacion BNF como sigue:  La gramatica anterior define la precedencia de operadores de la siguiente manera:  Una interpretacion para un sistema de logica proposicional es una asignacion de valores de verdad para cada variable proposicional, sumada a la asignacion usual de significados para los operadores logicos. A cada variable proposicional se le asigna uno de dos posibles valores de verdad: o V (verdadero) o F (falso). Esto quiere decir que si hay n variables proposicionales en el sistema, el numero de interpretaciones distintas es de 2n.  Partiendo de esto es posible definir una cantidad de nociones semanticas. Si A y B son formulas cualquiera de un lenguaje L, \u0393 es un conjunto de formulas de L, y M es una interpretacion de L, entonces:  La tabla de verdad de una formula es una tabla en la que se presentan todas las posibles interpretaciones de las variables proposicionales que constituye la formula y el valor de verdad de la formula completa para cada interpretacion. Por ejemplo, la tabla de verdad para la formula \u00ac ( p \u2228 q ) \u2192 ( p \u2192 r ) es:  Como se ve, esta formula tiene 2n interpretaciones posibles \u2014una por cada linea de la tabla\u2014 donde n es el numero de variables proposicionales (en este caso 3, es decir p, q, r) y resulta ser una tautologia, es decir que bajo todas las interpretaciones posibles de las variables proposicionales, el valor de verdad de la formula completa termina siendo V.  A menudo es necesario transformar una formula en otra, sobre todo transformar una formula a su forma normal. Esto se consigue transformando la formula en otra equivalente y repitiendo el proceso hasta conseguir una formula que solo use los conectivos basicos ( \u2227 , \u2228 , \u00ac ). Para lograr esto se utilizan las equivalencias logicas:  Por ejemplo, considerese la siguiente formula:  La misma puede desarrollarse asi:  Se dice que una formula esta en forma normal disyuntiva (FND) si y solo si tiene la siguiente forma:  donde cada A es una conjuncion de formulas. Por ejemplo, la siguiente formula esta en forma normal disyuntiva:  Se dice que una formula esta en forma normal conjuntiva (FNC) si y solo si tiene la siguiente forma:  donde cada A es una disyuncion de formulas. Por ejemplo, la siguiente formula esta en forma normal conjuntiva:  Por las leyes de De Morgan, es posible pasar de una forma normal disyuntiva a una forma normal conjuntiva y viceversa:  Las FNC y FND son mutuamente duales. La demostracion hace uso de las leyes de De Morgan y de la propiedad distributiva de la conjuncion y la disyuncion. Se debe cumplir que:  Y viceversa:  La logica es conocida como una de las ciencias mas antiguas, tanto es asi que se le atribuye a Aristoteles la paternidad de esta disciplina. Partiendo de que corresponde a Aristoteles haber sido el primero en tratar con todo detalle la logica, se le considera su fundador. En un principio se llamo Analitica, en virtud del titulo de las obras en que trato los problemas logicos. Mas tarde los escritos de Aristoteles relativos a estos eventos fueron recopilados por sus discipulos con el titulo de Organon, por considerar que la logica era un instrumento para el conocimiento de la verdad.  Aristoteles se planteo como es posible probar y demostrar que un conocimiento es verdadero, es decir, que tiene una validez universal. Aristoteles encuentra el fundamento de la demostracion en la deduccion, procedimiento que consiste en derivar un hecho particular de algo universal. La forma en que se afecta esa derivacion es el silogismo, por cuya razon la silogistica llega a ser el centro de la logica aristotelica.  Aunque la logica proposicional (que es intercambiable con el calculo proposicional) habia sido insinuada por los filosofos anteriores, fue desarrollada como un sistema formal por el filosofo estoico Crisipo en el siglo\u00a0III\u00a0a.\u00a0C. y ampliada por sus sucesores de la misma escuela. La logica proposicional se centro en proposiciones. Este avance fue diferente de la logica silogistica tradicional que se centro en los terminos. Sin embargo, mas tarde en la antiguedad, la logica proposicional desarrollada por los estoicos no se comprendia. En consecuencia de ello, el sistema fue reinventado esencialmente por Pedro Abelardo en el siglo\u00a0XII.  La logica proposicional fue finalmente refinada usando la logica simbolica, se acredito ser el fundador de la logica simbolica el matematico Gottfried Leibniz siglo\u00a0XVII/XVIII, por su trabajo ratiocinator del calculo. Aunque su trabajo era unos de los primeros, era desconocido para la comunidad logica mas grande. En consecuencia, muchos de los avances logrados por Leibniz fueron recreados por logicos como George Boole y Augustus De Morgan completamente independientes a Leibniz.  Asi como la logica proposicional puede considerarse un avance de la logica silogista anterior, la logica de predicados de Gottlob Frege era un avance de la logica proposicional anterior. Un autor describe esta logica como la combinacion de los rasgos distintivos de la logica silogistica y la logica proposicional. Por lo tanto, la logica predicativa marco el comienzo de una nueva era en la historia de la logica; sin embargo, los avances en la logica proposicional se hicieron aun despues de Frege, incluyendo Deduccion Natural, Arboles de la Verdad y Tablas de Verdad. La deduccion natural fue inventada por Gerhard Gentzen y Jan Lukasiewicz. Los arboles de la verdad fueron inventados por Evert Willem Beth. La invencion de las tablas de la verdad, sin embargo, es de atribucion controvertida.  Dentro de las obras de Frege y Bertrand Russell, hay ideas que influyen en la invencion de las tablas de la verdad. La estructura tabular real se acredita generalmente a Ludwig Wittgenstein o a Emil Post ( o ambos independientemente). Adeam de Frege y Russell, otros acreditados con ideas anteriores a las tablas de la verdad incluyen a Philo, Boole, Charles Sanders Peirce. Otros acreditados de la estructura tabular incluyen Lukasiewicz, Alfred North Whitehead, Guillermo Stanley Jevons, John Venn, y Clarence Irving Lewis. En ultima instancia, algunos han llegado a la conclusion, como John Shosky, de que \" esta lejos de estar claro que a cualquier persona se le debe dar el titulo de 'inventor' de las tablas de la verdad\".   ","snippet":"La logica proposicional, tambien llamada logica de enunciados, logica de orden cero o calculo proposicional, es un sistema formal cuyos elementos mas simples representan proposiciones o enunciados, y ","enlaces_salientes":["L%C3%B3gica_proposicional","L%C3%B3gica_proposicional","L%C3%B3gica_proposicional","Sistema_formal","Constante_l%C3%B3gica","Conectivas_l%C3%B3gicas","Operaci%C3%B3n_matem%C3%A1tica","Variable_proposicional","Conectiva_l%C3%B3gica","Inferencia","F%C3%B3rmula_bien_formada","Decidibilidad","Completitud_(l%C3%B3gica)","Argumento","Validez_l%C3%B3gica","Premisa","Conclusi%C3%B3n","Conectiva_l%C3%B3gica","Valor_de_verdad","Variables_proposicionales","Conectiva_l%C3%B3gica","Conectiva_l%C3%B3gica","Tautolog%C3%ADa","Conjunci%C3%B3n_opuesta","Implicaci%C3%B3n_opuesta","Condicional_material","Disyunci%C3%B3n_l%C3%B3gica","Negaci%C3%B3n_l%C3%B3gica","Disyunci%C3%B3n_exclusiva","Bicondicional","Afirmaci%C3%B3n_l%C3%B3gica","Disyunci%C3%B3n_opuesta","Adjunci%C3%B3n_l%C3%B3gica","Adjunci%C3%B3n_opuesta","Conjunci%C3%B3n_l%C3%B3gica","Contradicci%C3%B3n","Lenguaje_natural","Lenguaje_formal","Negaci%C3%B3n_l%C3%B3gica","Conjunci%C3%B3n_l%C3%B3gica","Disyunci%C3%B3n_l%C3%B3gica","Condicional_material","Bicondicional","Disyunci%C3%B3n_opuesta","Disyunci%C3%B3n_exclusiva","Funci%C3%B3n_de_verdad","Funci%C3%B3n_matem%C3%A1tica","Ley_de_doble_negaci%C3%B3n","Leyes_de_De_Morgan","Principio_del_tercero_excluido","L%C3%B3gica_intuicionista","L%C3%B3gica_de_primer_orden","L%C3%B3gica_de_segundo_orden","L%C3%B3gica_modal","L%C3%B3gica_temporal","Sistema_formal","Proposici%C3%B3n","Operador","Par%C3%A9ntesis","Gram%C3%A1tica_formal","Recursi%C3%B3n","Cadena_de_caracteres","F%C3%B3rmula_bien_formada","%C3%81lgebra_elemental","Axioma","Jan_%C5%81ukasiewicz","Reglas_de_inferencia","Reglas_de_inferencia","Modus_tollendo_tollens","Modus_tollendo_ponens","Modus_ponendo_ponens","Modus_ponendo_tollens","Introducci%C3%B3n_del_bicondicional","Eliminaci%C3%B3n_del_bicondicional","Introducci%C3%B3n_de_la_conjunci%C3%B3n","Simplificaci%C3%B3n","Introducci%C3%B3n_de_la_disyunci%C3%B3n","Eliminaci%C3%B3n_de_la_disyunci%C3%B3n","Modus_tollendo_ponens","Silogismo_hipot%C3%A9tico","Dilema_constructivo","Dilema_destructivo","Absorci%C3%B3n_(l%C3%B3gica)","Reglas_de_reemplazo","Asociatividad_(%C3%A1lgebra)","Conmutatividad","Distributividad","Doble_negaci%C3%B3n_(l%C3%B3gica)","Leyes_de_De_Morgan","Transposici%C3%B3n_(l%C3%B3gica)","Implicaci%C3%B3n_material_(regla_de_inferencia)","Exportaci%C3%B3n_(l%C3%B3gica)","Tautolog%C3%ADa_(regla_de_inferencia)","Introducci%C3%B3n_de_la_negaci%C3%B3n","L%C3%B3gica_de_primer_orden","Generalizaci%C3%B3n_universal","Instanciaci%C3%B3n_universal","Generalizaci%C3%B3n_existencial","Instanciaci%C3%B3n_existencial","L%C3%B3gica_modal","Regla_de_inferencia","Funci%C3%B3n_matem%C3%A1tica","Modus_ponens","Deducci%C3%B3n_natural","Conjunto","Axioma","Inferencia","Introducci%C3%B3n_de_la_negaci%C3%B3n","Eliminaci%C3%B3n_de_la_negaci%C3%B3n","Eliminaci%C3%B3n_de_la_doble_negaci%C3%B3n","Introducci%C3%B3n_de_la_conjunci%C3%B3n","Simplificaci%C3%B3n","Introducci%C3%B3n_de_la_disyunci%C3%B3n","Eliminaci%C3%B3n_de_la_disyunci%C3%B3n","Introducci%C3%B3n_del_bicondicional","Eliminaci%C3%B3n_del_bicondicional","Modus_ponens","Prueba_condicional","Modus_ponens","Modus_tollens","Silogismo_hipot%C3%A9tico","Silogismo_disyuntivo","Dilema_constructivo","Dilema_destructivo","Ley_de_De_Morgan","Doble_negaci%C3%B3n_(l%C3%B3gica)","Transposici%C3%B3n_(l%C3%B3gica)","Implicaci%C3%B3n_material","Equivalencia_material","Tautolog%C3%ADa","Principio_del_tercero_excluido","Principio_de_no_contradicci%C3%B3n","Quod_erat_demonstrandum","Lenguaje_formal","Gram%C3%A1tica_formal","Backus-Naur_form","Operador","Interpretaci%C3%B3n_(l%C3%B3gica)","Valor_de_verdad","Operador","Tautolog%C3%ADa","Verdad_l%C3%B3gica","Contradicci%C3%B3n","Consistencia_(l%C3%B3gica)","Consecuencia_sem%C3%A1ntica","Verdad_l%C3%B3gica","Tablas_de_verdad","Tautolog%C3%ADa","Leyes_de_De_Morgan","Propiedad_distributiva","Historia_de_la_l%C3%B3gica","Crisipo_de_Solos","Pedro_Abelardo","%C3%81lgebra_de_Boole","C%C3%A1lculo_l%C3%B3gico","C%C3%A1lculo_proposicional_de_Frege","Gr%C3%A1ficos_existenciales","L%C3%B3gica_matem%C3%A1tica","L%C3%B3gica_de_primer_orden","L%C3%B3gica_modal","Tabla_de_verdad","Teor%C3%ADa_de_grafos","Silogismo","Valor_de_verdad","Razonamiento_diagram%C3%A1tico","Oxford_University_Press","Old_Dominion_University","Control_de_autoridades","Gemeinsame_Normdatei","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Enciclopedia_Brit%C3%A1nica"]}
{"url":"%C3%9Altimo_teorema_de_Fermat","titulo":"Ultimo teorema de Fermat","contenido":"En teoria de numeros, el ultimo teorema de Fermat, o teorema de Fermat-Wiles, es uno de los teoremas mas famosos en la historia de las matematicas. Utilizando la notacion moderna, se puede enunciar de la siguiente manera:  Si n es un numero entero mayor o igual que 3, entonces no existen numeros enteros positivos x, y y z, tales que se cumpla la igualdad    Esto es asi salvo el caso de las soluciones triviales (0,1,1), (1,0,1) y (0,0,0). Es importante recalcar que han de ser positivos ya que si pudiese ser alguno de ellos negativo, no es dificil encontrar soluciones no triviales para algun caso en el que n es mayor que 2. Por ejemplo si n fuese cualquier numero impar, las ternas de la forma (a, -a, 0) con a un numero entero positivo, son solucion.  Este teorema fue conjeturado por Pierre de Fermat en 1637, pero no fue demostrado hasta 1995 por Andrew Wiles ayudado por el matematico Richard Taylor. La busqueda de una demostracion estimulo el desarrollo de la teoria algebraica de numeros en el siglo\u00a0XIX y la demostracion del teorema de la modularidad en el siglo\u00a0XX.  La proposicion fue enunciada por primera vez como teorema por Pierre de Fermat hacia 1637 en el margen de una copia de Arithmetica. Fermat a\u00f1adio que tenia una demostracion que era demasiado grande para caber en el margen. Aunque otras afirmaciones de Fermat sin demostracion fueron posteriormente demostradas por otros y acreditadas como teoremas de Fermat (por ejemplo,  el teorema de Fermat sobre sumas de dos cuadrados), el Ultimo Teorema de Fermat se resistio a la demostracion, lo que llevo a dudar de que Fermat tuviera alguna vez una demostracion correcta. En consecuencia, la proposicion paso a denominarse conjetura en lugar de teorema. Tras 358 a\u00f1os de esfuerzos por parte de los matematicos, la primera prueba exitosa fue dada a conocer en 1994 por Andrew Wiles y publicada formalmente en 1995. Fue descrita como un \"avance asombroso\" en la citacion para el Premio Abel de Wiles en 2016.\u200b Tambien demostro gran parte de la conjetura de Taniyama-Shimura, posteriormente conocida como teorema de la modularidad, y abrio enfoques completamente nuevos a otros numerosos problemas y tecnicas de elevacion de la modularidad matematicamente potentes.  El problema sin resolver estimulo el desarrollo de la teoria algebraica de numeros en los siglos XIX y XX. Se encuentra entre los teoremas mas notables de la historia de las matematicas y antes de su demostracion figuraba en el Libro Guinness de los Records como el \"problema matematico mas dificil\", en parte porque el teorema tiene el mayor numero de demostraciones fallidas.\u200b  La ecuacion de Pitagoras, x2 + y2 = z2, tiene un numero infinito de soluciones  enteras positivas para x, y y z; estas soluciones se conocen como  triples pitagoricos (con el ejemplo mas simple 3,4,5). Hacia 1637, Fermat escribio en el margen de un libro que la ecuacion mas general an + bn = cn no tenia soluciones en enteros positivos si n es un entero mayor que 2. Aunque afirmo tener una prueba general de su conjetura, Fermat no dejo detalles de su prueba, y nunca se ha encontrado ninguna prueba suya. Su afirmacion fue descubierta unos 30 a\u00f1os mas tarde, despues de su muerte. Esta afirmacion, que paso a conocerse como El ultimo teorema de Fermat, quedo sin resolver durante los tres siglos y medio siguientes.\u200b  Con el tiempo, la afirmacion se convirtio en uno de los problemas sin resolver mas notables de las matematicas. Los intentos de demostrarlo impulsaron un desarrollo sustancial de la teoria de numeros, y con el tiempo el Ultimo Teorema de Fermat gano prominencia como  problema sin resolver en matematicas.  El caso especial n = 4, demostrado por el propio Fermat, es suficiente para establecer que si el teorema es falso para algun exponente n que no sea un numero primo, tambien debe ser falso para algun n mas peque\u00f1o, por lo que solo los valores primos de n necesitan mas investigacion.[note 1]\u200b Durante los dos siglos siguientes (1637-1839), la conjetura se demostro solo para los primos 3, 5 y 7, aunque Sophie Germain innovo y demostro una aproximacion que era relevante para toda una clase de primos. A mediados del siglo XIX, Ernst Kummer amplio este enfoque y demostro el teorema para todos los primos regulares, dejando los primos irregulares para ser analizados individualmente. Basandose en el trabajo de Kummer y utilizando sofisticados estudios informaticos, otros matematicos fueron capaces de ampliar la demostracion para cubrir todos los exponentes primos hasta cuatro millones,\u200b pero una demostracion para todos los exponentes era inaccesible (lo que significa que los matematicos generalmente consideraban una demostracion imposible, excesivamente dificil o inalcanzable con los conocimientos actuales).\u200b.  Por separado, alrededor de 1955, los matematicos japoneses Goro Shimura y Yutaka Taniyama sospecharon que podria existir un vinculo entre las curvas elipticas y las formas modulares, dos areas completamente diferentes de las matematicas. Conocida en su momento como conjetura de Taniyama-Shimura (posteriormente como teorema de la modularidad), se trataba de una conjetura independiente, sin conexion aparente con el ultimo teorema de Fermat. En general, se consideraba significativa e importante por si misma, pero (al igual que el teorema de Fermat) se consideraba completamente inaccesible a la demostracion.\u200b  En 1984, Gerhard Frey se percato de una aparente relacion entre estos dos problemas no relacionados ni resueltos hasta entonces. Frey dio un esbozo que sugeria que esto podia demostrarse. La prueba completa de que los dos problemas estaban estrechamente relacionados fue realizada en 1986 por Ken Ribet, basandose en una prueba parcial de Jean-Pierre Serre, que demostro toda la parte menos una conocida como la \"conjetura epsilon\" (vease: Teorema de Ribet y curva de Frey).\u200b Estos trabajos de Frey, Serre y Ribet demostraron que si se podia demostrar la conjetura de Taniyama-Shimura para al menos la clase semiestable de curvas elipticas, se obtendria automaticamente una demostracion del Ultimo Teorema de Fermat. La conexion se describe a continuacion: cualquier solucion que pudiera contradecir el Ultimo Teorema de Fermat tambien podria utilizarse para contradecir la conjetura Taniyama-Shimura. Asi pues, si el teorema de la modularidad fuera cierto, por definicion no podria existir ninguna solucion que contradijera el Ultimo Teorema de Fermat, que por tanto tambien tendria que ser cierto.  Aunque ambos problemas eran desalentadores y en su momento se consideraron \"completamente inaccesibles\" para su demostracion,\u200b esta fue la primera sugerencia de una ruta por la que el Ultimo Teorema de Fermat podria extenderse y demostrarse para todos los numeros, no solo para algunos. A diferencia del ultimo teorema de Fermat, la conjetura Taniyama-Shimura era un area de investigacion activa importante y se consideraba mas al alcance de las matematicas contemporaneas.\u200b Sin embargo, la opinion general era que esto simplemente demostraba la impracticabilidad de demostrar la conjetura Taniyama-Shimura.\u200b La reaccion citada del matematico John Coates fue comun:\u200b  Al enterarse de que Ribet habia demostrado que la conexion de Frey era correcta, el matematico ingles Andrew Wiles, que habia sentido fascinacion durante su infancia por el Ultimo Teorema de Fermat y tenia experiencia trabajando con curvas elipticas y campos relacionados, decidio intentar demostrar la conjetura Taniyama-Shimura como una forma de demostrar el Ultimo Teorema de Fermat. En 1993, tras seis a\u00f1os trabajando en secreto en el problema, Wiles logro demostrar una parte suficiente de la conjetura para demostrar el Ultimo Teorema de Fermat. El documento de Wiles era enorme en tama\u00f1o y alcance. Se descubrio un fallo en una parte de su articulo original durante la revision por pares y fue necesario un a\u00f1o mas de colaboracion con un antiguo alumno, Richard Taylor, para resolverlo. Como resultado, la demostracion final de 1995 fue acompa\u00f1ada de un articulo conjunto mas peque\u00f1o que mostraba que los pasos fijos eran validos. El logro de Wiles se divulgo ampliamente en la prensa popular y se popularizo en libros y programas de television. Las partes restantes de la conjetura Taniyama-Shimura-Weil, ahora demostradas y conocidas como el teorema de la modularidad, fueron demostradas posteriormente por otros matematicos, que se basaron en el trabajo de Wiles entre 1996 y 2001.\u200b\u200b\u200b Por su demostracion, Wiles fue honrado y recibio numerosos premios, entre ellos el Premio Abel de 2016.\u200b\u200b\u200b  Pierre de Fermat poseia una edicion bilingue (griego y latin) de la Arithmetica de Diofanto, traducida por Claude Gaspar Bachet. Fermat escribio un comentario, de hecho, un acertijo, en el margen de cada problema, y uno por uno han sido resueltos por personalidades como Leibniz, Newton, etc. Solo quedo sin resolver el acertijo que propuso debajo del problema VIII, que trata sobre escribir un numero cuadrado como suma de dos cuadrados (es decir, encontrar ternas pitagoricas). Ahi, Fermat escribio:  \u200b  El primer matematico que consiguio avanzar sobre este teorema fue el propio Fermat, que demostro el caso n=4 usando la tecnica del descenso infinito, una variante del principio de induccion.  Leonhard Euler demostro el caso n = 3. El 4 de agosto de 1753 Euler escribio a Goldbach reclamando tener una demostracion para el caso n = 3. En Algebra (1770) se encontro una falacia en la demostracion de Euler. Corregirla directamente era demasiado dificil, pero otros aportes anteriores de Euler permitian encontrar una solucion correcta por medios mas simples. Por esto se considero que Euler habia demostrado ese caso. Del analisis de la demostracion fallida de Euler surgio la evidencia de que ciertos conjuntos de numeros complejos no se comportaban de igual manera que los enteros.  El siguiente mayor paso fue hecho por la matematica Sophie Germain. Un caso especial dice que si p y 2p + 1 son ambos primos, entonces la expresion de la conjetura de Fermat para la potencia p implica que uno de los x, y o z es divisible por p. En consecuencia la conjetura se divide en dos casos:  Sophie Germain probo el caso 1 para todo p menor que 100 y Adrien-Marie Legendre extendio sus metodos a todos los numeros menores que 197. Aqui se encontro que el caso 2 no estaba demostrado ni siquiera para p = 5, por lo que fue evidente que era en el caso 2 en el que habia que concentrarse. Este caso tambien se dividia entre varios casos posibles.  No fue hasta 1825 cuando Peter Gustav Lejeune Dirichlet y Legendre generalizaron para n=5 la demostracion de Euler. Lame demostro el caso n=7 en 1839.  Entre 1844 y 1846 Ernst Kummer demostro que la factorizacion no unica podia ser salvada mediante la introduccion de numeros complejos ideales. Un a\u00f1o despues Kummer afirma que el numero 37 no es un primo regular (Ver: Numeros de Bernoulli). Luego se encuentra que tampoco 59 y 67 lo son. Kummer, Mirimanoff, Wieferich, Furtwanger, Vandiver y otros extienden la investigacion a numeros mas grandes. En 1915 Jensen demuestra que existen infinitos primos irregulares. La investigacion se estanca por esta via de la divisibilidad, a pesar de que se logran comprobaciones para n menor o igual a 4 000 000.  En el a\u00f1o 1995 el matematico Andrew Wiles, en un articulo de 98 paginas publicado en Annals of mathematics, demostro el caso semiestable del teorema de Taniyama-Shimura, anteriormente una conjetura, que engarza las formas modulares y las curvas elipticas. De este trabajo, combinado con ideas de Frey y con el teorema de Ribet, se desprende la demostracion del ultimo teorema de Fermat.\u200b Aunque una version anterior (no publicada) del trabajo de Wiles contenia un error, este pudo ser corregido en la version publicada, que consta de dos articulos, el segundo en colaboracion con el matematico Richard Taylor. En estos trabajos por primera vez se establecen resultados de modularidad a partir de modularidad residual, por lo cual los resultados del tipo de los probados por Wiles y Taylor son denominados \u00abteoremas de levantamiento modular\u00bb. En la actualidad, resultados de este tipo, mucho mas generales y poderosos, han sido probados por varios matematicos: ademas de generalizaciones probadas por Wiles en colaboracion con C. Skinner y de Taylor en colaboracion con M. Harris, los mas generales en la actualidad se deben a Mark Kisin. En el trabajo de 1995 de Wiles se abrio una nueva via, practicamente una nueva area: la de la modularidad. Con estas tecnicas, de las que este trabajo fue pionero, se han resuelto mas recientemente otras importantes conjeturas, como la conjetura de Serre y la de Sato-Tate. Curiosamente, la resolucion de los primeros casos de la conjetura de Serre (trabajos de Khare, Wintenberger y Dieulefait), como observara el propio Serre al formular la conjetura, permite una nueva demostracion del ultimo teorema de Fermat.\u200b  Los trabajos de Wiles por lo tanto tienen una importancia que trasciende ampliamente su aplicacion al ultimo teorema de Fermat: se consideran centrales en la geometria aritmetica moderna y se espera que sigan jugando un rol vital en la demostracion de resultados de modularidad que se enmarcan en el programa de Langlands.    Error en la cita: Existen etiquetas <ref> para un grupo llamado \u00abnote\u00bb, pero no se encontro la etiqueta <references group=\"note\"/> correspondiente. ","snippet":"En teoria de numeros, el ultimo teorema de Fermat, o teorema de Fermat-Wiles, es uno de los teoremas mas famosos en la historia de las matematicas. Utilizando la notacion moderna, se puede enunciar de","enlaces_salientes":["%C3%9Altimo_teorema_de_Fermat","%C3%9Altimo_teorema_de_Fermat","%C3%9Altimo_teorema_de_Fermat","Pierre_de_Fermat","Teor%C3%ADa_de_n%C3%BAmeros","Matem%C3%A1tica","N%C3%BAmero_entero","Pierre_de_Fermat","Teorema","Conjetura","Pierre_de_Fermat","1995","Andrew_Wiles","Richard_Lawrence_Taylor","Teor%C3%ADa_algebraica_de_n%C3%BAmeros","Teorema_de_la_modularidad","Pierre_de_Fermat","Arithmetica","Teorema_de_Fermat_sobre_la_suma_de_dos_cuadrados","Conjetura","Andrew_Wiles","Premio_Abel","Teorema_de_la_modularidad","Teor%C3%ADa_algebraica_de_n%C3%BAmeros","Historia_de_las_matem%C3%A1ticas","Libro_Guinness_de_los_R%C3%A9cords","Teorema_de_Pit%C3%A1goras","N%C3%BAmero_entero","Terna_pitag%C3%B3rica","Prueba_matem%C3%A1tica","Teor%C3%ADa_de_n%C3%BAmeros","Exponente","N%C3%BAmero_primo","Sophie_Germain","Ernst_Kummer","Primo_regular","Goro_Shimura","Yutaka_Taniyama","Curvas_el%C3%ADpticas","Conjetura_de_Taniyama-Shimura","Gerhard_Frey","Ken_Ribet","Jean-Pierre_Serre","Teorema_de_Ribet","Curva_de_Frey","Andrew_Wiles","Revisi%C3%B3n_por_pares","Richard_Taylor_(matem%C3%A1tico)","Premio_Abel","Arithmetica","Diofanto","1670","Pierre_de_Fermat","Arithmetica","Diofanto_de_Alejandr%C3%ADa","Claude_Gaspard_Bachet_de_M%C3%A9ziriac","Leibniz","Isaac_Newton","Terna_pitag%C3%B3rica","Descenso_infinito","Inducci%C3%B3n_matem%C3%A1tica","Leonhard_Euler","Falacia","Sophie_Germain","Sophie_Germain","Adrien-Marie_Legendre","1665","1753","Leonhard_Euler","1825","Adrien-Marie_Legendre","1839","Gabriel_Lam%C3%A9","1843","Ernst_Kummer","Peter_Gustav_Lejeune_Dirichlet","1995","Andrew_Wiles","Peter_Gustav_Lejeune_Dirichlet","Legendre","Gabriel_Lam%C3%A9","Ernst_Kummer","Ideal_(teor%C3%ADa_de_anillos)","Primo_regular","N%C3%BAmeros_de_Bernoulli","1995","Andrew_Wiles","Teorema_de_Taniyama-Shimura","Forma_modular","Teorema_de_Ribet","Richard_Lawrence_Taylor","Conjetura_de_Serre","Programa_de_Langlands","Pierre_de_Fermat","Peque%C3%B1o_teorema_de_Fermat","N%C3%BAmero_primo_de_Fermat","Espiral_de_Fermat","Conjetura_de_Beal","ISBN","JSTOR","ISSN","ISSN","Nature_(journal)","Bibcode","PubMed_Identifier","Semantic_Scholar","Digital_object_identifier","ISBN","Simon_Singh","Simon_Singh","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Antecedente_(l%C3%B3gica)","titulo":"Antecedente (logica)","contenido":"Un antecedente es la primera parte de una proposicion hipotetica, siempre que la clausula \"si\" preceda a la clausula \"entonces\". En algunos contextos el antecedente se llama protasis.  Esta es una formulacion no logica de una proposicion hipotetica. En este caso, el antecedente es P , y el consecuente es Q . En una implicacion, si \u03d5 implica \u03c8 entonces \u03d5 se llama el antecedente y \u03c8 el consecuente.\u200b  \" X es un hombre\" es el antecedente para esta proposicion.  Aqui, \"a 2016 hay hombres en la Luna\" es el antecedente. ","snippet":"Un antecedente es la primera parte de una proposicion hipotetica, siempre que la clausula \"si\" preceda a la clausula \"entonces\". En algunos contextos el antecedente se llama protasis.  Esta es una for","enlaces_salientes":["Antecedente_(l%C3%B3gica)","Antecedente_(l%C3%B3gica)","Antecedente_(l%C3%B3gica)","Proposici%C3%B3n","Hip%C3%B3tesis_(m%C3%A9todo_cient%C3%ADfico)","Ap%C3%B3dosis","Condicional_material","Afirmaci%C3%B3n_del_consecuente","Negaci%C3%B3n_del_antecedente","Bicondicional","Control_de_autoridades","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Consecuente","titulo":"Consecuente","contenido":"En logica matematica, un consecuente es un tipo muy general de afirmacion condicional.  Un consecuente puede tener cualquier numero m de las formulas de condicion Ai (llamadas \"antecedentes\") y cualquier numero n de formulas Bj declaradas (llamadas \"sucedentes\" o \"secuentes\"). Se entiende que un consecuente significa que si todas las condiciones antecedentes son verdaderas, entonces al menos una de las formulas consecuentes es verdadera. Este estilo de asercion condicional esta casi siempre asociado con el marco conceptual del calculo de consecuentes.  Los consecuentes se comprenden mejor en el contexto de los siguientes tres tipos de juicios logicos:  Asi, los consecuentes son una generalizacion de afirmaciones condicionales simples, que son una generalizacion de aserciones incondicionales.  La palabra \"O\" aqui es el OR inclusivo.\u200b La motivacion para la semantica disjuntiva en el lado derecho de un consecuente trae consigo tres ventajas principales.  Estos tres  beneficios fueron identificados en el documento de fundacion de Gentzen\u00a0(1934, p.\u00a0194).  No todos los autores se adhirieron al significado original de Gentzen para la palabra \"consecuente\". Por ejemplo,Lemmon\u00a0(1965) uso la palabra \"consecuente\" estrictamente para afirmaciones condicionales simples con una y solo una formula consecuente.\u200b La misma definicion consecutiva para un secuente es dada por Huth y Ryan, 2004, p.\u00a05.  El consecuente tiene la forma:  donde tanto \u0393 como \u03a3 son secuencias de formulas logicas, no conjuntos. Por lo tanto son significativos tanto el numero como el orden de apariciones de las formulas. En particular, la misma formula puede aparecer dos veces en la misma secuencia. El conjunto completo de reglas de inferencia de calculo secuencial contiene reglas para intercambiar formulas adyacentes a la izquierda y a la derecha del simbolo de asercion (y por lo tanto permutar arbitrariamente los consecuentes de la izquierda y de la derecha), y tambien para insertar formulas arbitrarias y eliminar copias duplicadas dentro de la izquierda y los consecuentes correctos. (Sin embargo, Smullyan (1995, pp. 107-108), utiliza conjuntos de formulas en secuencias en lugar de secuencias de formulas. En consecuencia, no se requieren los tres pares de reglas estructurales llamadas \"adelgazamiento\", \"contraccion\" e \"intercambio\".)  El simbolo ' \u22a2 ' se refiere a veces como  \"torniquete\", \"tachuela derecha\", \"tee\", \"signo de asercion\" o \"simbolo de asercion\". Por lo general se lee, sugestivamente, como \"produce\", \"demuestra\" o \"implica\".  Puesto que cada formula en el antecedente (el lado izquierdo) debe ser verdadera para concluir la verdad de por lo menos una formula en el sucediente (el lado derecho), agregando las formulas a cada lado da lugar a un consecuente mas debil, mientras que quitando de ambos lados da uno mas fuerte. Esta es una de las ventajas de simetria que se deriva del uso de la semantica disyuntiva en el lado derecho del simbolo de la asercion, mientras que la semantica conjuntiva se inserta en el lado izquierdo.  En el caso extremo donde la lista de formulas antecedentes de un consecuente esta vacia, el consecuente es incondicional. Esto difiere de la simple afirmacion incondicional porque el numero de consecuentes es arbitrario, no necesariamente un solo consecuente. Por ejemplo, ' \u22a2 B1, B2 significa que B1, o  B2, o ambos, deben ser verdaderos. Una lista de formulas antecedentes vacias es equivalente a la proposicion \"siempre verdadera\", llamada \"tautologia\", denominada \"\u22a4\". (Vease T (simbolo).)  En el caso extremo donde la lista de formulas consecuentes de un consecuente este vacia, la regla es que al menos un termino a la derecha es verdadero, lo cual es claramente imposible. Esto es significado por la proposicion \"siempre falsa\", llamada \"contradiccion, o absurdo\", que se denomina \"\u22a5\". Como consecuencia es falsa, al menos uno de los antecedentes debe ser falso. Por ejemplo, ' A1, A2 \u22a2 ' significa que al menos uno de los antecedentes A1 A2 debe ser falso.  Se ve aqui de nuevo una simetria a causa de la semantica disyuntiva en el lado derecho. Si el lado izquierdo esta vacio, entonces una o mas proposiciones del lado derecho deben ser verdaderas. Si el lado derecho esta vacio, entonces una o mas de las proposiciones del lado izquierdo deben ser falsas.  El caso doblemente extremo '\u22a2', donde las listas de formulas antecedentes y consecuentes esten vacias, es \"no satifactorio, ni  fiable \".\u200b En este caso, el significado del consecuente es efectivamente '\u22a4 \u22a2 \u22a5'. Esto es equivalente al siguiente '\u22a2 \u22a5', que claramente no puede ser valido.  Una secuencia de la forma '\u03b1, \u03b2', para las formulas logicas \u03b1 y \u03b2, significa que \u03b1 es verdadera o \u03b2 es verdadera. Pero no significa que \u03b1 o \u03b2 sean tautologias. Para aclarar esto, considerar el ejemplo ' \u22a2 B \u2228 A, C \u2228 \u00acA'. Esta es una secuencia valida ya sea porque B \u2228 A es verdadero o C \u2228 \u00acA es verdadero. Pero ninguna de estas expresiones es una tautologia aislada. Es la disyuncion de estas dos expresiones la que es una tautologia.  Del mismo modo, un consecuente con la forma '\u03b1, \u03b2 \u22a2', para las formulas logicas \u03b1 y \u03b2, significa que \u03b1 es falso o \u03b2 es falso. Pero esto no significa que \u03b1 es una contradiccion o \u03b2 es una contradiccion. Para aclarar esto, considere el ejemplo 'B \u2227 A, C \u2227 \u00acA \u22a2'. Este es un consecuente valido porque B \u2227 A es falso o C \u2227 \u00acA es falso. Pero ninguna de estas expresiones es una contradiccion aislada. La conjuncion de estas dos expresiones es una contradiccion.  La mayoria de los sistemas de demostracion proporcionan maneras de deducir una consecuente de otro. Estas reglas de inferencia se escriben con una lista de secuencias por encima y por debajo de una linea. Esta regla indica que si todo lo que esta por encima de la linea es verdadero, tambien lo es todo lo que esta bajo la linea.  Una regla tipica es:  Esto indica que, si es posible deducir que \u0393 , \u03b1 lleva a \u03a3 y que \u0393 lleva a \u03a3 , \u03b1 , entonces tambien es posible deducir que \u0393 lleva a \u03a3 . (Vease tambien el conjunto completo de reglas de inferencia de calculo secuencial.)  El simbolo de asercion en consecuentes originalmente significaba exactamente lo mismo que el operador de implicacion. Pero con el tiempo, su significado ha cambiado para significar demostrabilidad dentro de una teoria mas que la verdad semantica en todos los modelos.  En 1934, Gentzen no definio el simbolo de asercion '\u22a2' en un consecuente para significar probabilidad. El lo definio para significar exactamente igual que el operador de la implicacion \"\u21d2\". Usando '\u2192' en lugar de '\u22a2' y '\u2283' en lugar de '\u21d2', escribio: \"El consecuente A1, ..., A\u03bc \u2192 B1, ..., B\u03bd significa, en cuanto al contenido, exactamente igual que la formula (A1 & ... & A\u03bc) \u2283 (B1 \u2228 ... \u2228 B\u03bd)\".\u200b (Gentzen empleo el simbolo de la flecha derecha entre los antecedentes y los consecuentes de los sucesivos, empleando el simbolo ' \u2283 ' para el operador de la implicacion logica).  Asimismo, en 1939, Hilbert y Bernays declararon que un consecuente tiene el mismo significado que la correspondiente formula de implicacion.\u200b  Numerosas publicaciones despues de este tiempo han declarado que el simbolo de asercion en secuentes si significa probabilidad dentro de la teoria donde se formulan los consecuentes. Curry en 1963,\u200b Lemmon en 1965,\u200b and Huth and Ryan en 2004\u200b todos los estados que el simbolo de asercion consecuente significa probabilidad. Sin embargo,Ben-Ari\u00a0(2012, p.\u00a069) afirmo que el simbolo de asercion en los consecuencias del sistema de Gentzen, que denoto como ' \u21d2 ', es parte del lenguaje de objetos, no del metalenguaje.\u200b  Segun Prawitz (1965): \"Los calculos de consecuentes pueden ser entendidos como meta-calculos para la relacion de deducibilidad en los sistemas correspondientes de deduccion natural.\"\u200b Y ademas: \"Una prueba en un calculo de consecuentes puede ser vista como una instruccion sobre como construir una deduccion natural correspondiente.\"\u200b En otras palabras, el simbolo de asercion es parte del lenguaje de objetos para el calculo secuencial, que es una especie de meta-calculo, pero simultaneamente significa deducibilidad en un sistema de deduccion natural subyacente.  El significado intuitivo de un subsiguiente \u0393 \u22a2 \u03a3 es tal que, bajo el supuesto de \u0393, es demostrabe la conclusion de \u03a3. Clasicamente, las formulas a la izquierda del trinquete pueden ser interpretadas como una conjuncion, mientras que las formulas de la derecha pueden considerse como una disyuncion. Esto significa que si todas las formulas en el conjunto \u0393 fueran verdaderas, entonces por lo menos una formula \u03a3 tambien tiene que ser verdadera. Si el sucedente esta vacio, se interpreta esta situacion como una falsedad, es decir, \u0393 \u22a2 significa que \u0393/implica falsedad y por lo tanto es inconsistente. Por otro lado, asumimos un vacio como verdadero, es decir, \u22a2 \u03a3 significa que \u03a3 procede sin ningun supuesto, o sea, la disyuncion es siempre verdadera. Una afirmacion logica se ve como un secuente en el formato \u22a2 \u03a3 .  Son posibles otras explicaciones intuitivas equivalentes. Por ejemplo, \u0393 \u22a2 \u03a3 puede leerse como una afirmacion de que no es probable que se produzca un caso en el que todas las formulas de \u0393 sean verdaderas y todas las formulas de \u03a3 sean falsas (esto esta relacionado con la regla de inferencia de la doble negacion).  En cualquier caso, estas lecturas intuitivas son de proposito meramente pedagogico. Como las pruebas formales en teoria de la prueba son puramente sintactica, la semantica de (o derivacion de) un subsiguiente se da solo por las propiedades del calculo que determina las reglas de inferencia.  Salvo cualquier contradiccion en la definicion tecnica dada anteriormente, podemos describir consecuentes en la misma forma logica. La expresion \u0393 representa un conjunto de suposiciones con las cuales comenzamos nuestro proceso logico. Por ejemplo: \"Socrates es humano\" y \"Todos los humanos son mortales\". El simbolo \u03a3 representa una conclusion logica es fruto del resultado de esas premisas. Por ejemplo, la conclusion \"Socrates es mortal\" es fruto del resultado de una formalizacion razonable de los supuestos mencionados anteriormente, y por lo tanto se puede insertar en el lado derecho, \u03a3 , del trinquete. Por lo tanto, el simbolo \u22a2 puede ser interpretado como el proceso de razonamiento, o \"por lo tanto\" en espa\u00f1ol.  La nocion general de un consecuente, introducida en este articulo, puede ser especializada en diversas formas. Un consecuente se llama intuitivo si existe a lo sumo una formula en el sucedente. Este forma es requisito para obtener metodos de calculo para la logica intuicionista.  Del mismo modo, se pueden obtener los metodos de calculo para la logica intuicionista dual, que es una tipo de logica paraconsistente, exigiendo que los consecuentes tengan una formula en el antecedente.  En muchos casos, tambien se asume que los consecuentes consisten en multiconjuntos o conjuntos en lugar de secuencias matematicas. Por lo tanto, es posible no tener en cuenta el orden e incluso el numero de ocurrencias de las formulas. Para la logica proposicional, esto no es un problema, ya que las conclusiones que se pueden extraer de la coleccion de premisas no dependen de estos datos. En la logica subestrutural, sin embargo, estos datos pueden tener cierta importancia.  Los sistemas de deduccion natural usan afirmaciones condicionales de una sola consecuencia, pero no son tipicamente usados los mismos conjuntos de reglas de inferencia que Gentzen introdujo en 1934. En particular, los sistemas de deduccion natural tabulares, que son muy convenientes para probar teoremas practicos en calculo proposicional y de predicado, fueron aplicados por Suppes\u00a0(1957) y Lemmon\u00a0(1965) para ense\u00f1ar introduccion a la logica en los libros de texto.  Historicamente, los consecuentes fueron introducidos por Gerhard Gentzen, con el objetivo de especificar el famoso calculo de consecuentes.\u200b La palabra usada originalmente fue la palabra alemana Sequenz. En ingles, sin embargo, la palabra Sequence es ahora considerada como una traduccion de la palabra alemana Folge, y que, muchas veces, es utilizada en matematicas. El termino Sequent, por lo tanto, se creo como una traduccion alternativa de la expresion alemana.  Kleene\u200b hace el siguiente comentario sobre la traduccion al ingles: \"Gentzen dice 'Sequenz', que se traduce como 'secuent' (consecuente), porque se ha usado 'secuencia' para cualquier sucesion de objetos, donde el aleman es 'Folge'.\" ","snippet":"En logica matematica, un consecuente es un tipo muy general de afirmacion condicional.  Un consecuente puede tener cualquier numero m de las formulas de condicion Ai (llamadas \"antecedentes\") y cualqu","enlaces_salientes":["Consecuente","Consecuente","Consecuente","L%C3%B3gica_matem%C3%A1tica","F%C3%B3rmula_bien_formada","Antecedente_(l%C3%B3gica)","Ap%C3%B3dosis","C%C3%A1lculo_de_secuentes","Juicio_(pensamiento)","Disyunci%C3%B3n_l%C3%B3gica","Intuicionismo","Conjunto","C%C3%A1lculo_de_secuentes","Permutaci%C3%B3n","Trinquete_(s%C3%ADmbolo)","Tautolog%C3%ADa","Falso_(l%C3%B3gica)","Interpretaci%C3%B3n_(l%C3%B3gica)","Coplanaridad","David_Hilbert","Paul_Bernays","Teorema_de_la_deducci%C3%B3n","Haskell_Curry","Metalenguaje","Sistema_deductivo","Conjunci%C3%B3n_l%C3%B3gica","Disyunci%C3%B3n_l%C3%B3gica","Falsedad","Afirmaci%C3%B3n_l%C3%B3gica","Doble_negaci%C3%B3n","Teor%C3%ADa_de_la_prueba","Sintaxis","Sem%C3%A1ntica","Regla_de_inferencia","Forma_l%C3%B3gica","S%C3%B3crates","L%C3%B3gica_intuicionista","L%C3%B3gica_paraconsistente","Multiconjunto","Conjunto","Secuencia_(matem%C3%A1ticas)","L%C3%B3gica_proposicional","Deducci%C3%B3n_natural","Gerhard_Gentzen","L%C3%B3gica_intuicionista","Gerhard_Gentzen","Deducci%C3%B3n_natural","ISBN","Alonzo_Church","Princeton_University_Press","ISBN","Haskell_Curry","ISBN","Gerhard_Gentzen","Digital_object_identifier","Gerhard_Gentzen","Digital_object_identifier","David_Hilbert","Paul_Bernays","ISBN","Cambridge_University_Press","ISBN","Stephen_Cole_Kleene","ISBN","Stephen_Cole_Kleene","ISBN","ISBN","ISBN","Raymond_Smullyan","ISBN","ISBN","Gaisi_Takeuti","ISBN","Encyclopaedia_of_Mathematics","ISBN","Control_de_autoridades"]}
{"url":"Teor%C3%ADa_de_la_prueba","titulo":"Teoria de la demostracion","contenido":"La teoria de la demostracion o teoria de la prueba es una rama de la logica matematica que trata a las demostraciones como objetos matematicos, facilitando su analisis mediante tecnicas matematicas. Las demostraciones suelen presentarse como estructuras de datos inductivamente definidas que se construyen de acuerdo con los axiomas y reglas de inferencia de los sistemas logicos. En este sentido, la teoria de la demostracion se ocupa de la sintaxis, en contraste con la teoria de modelos, que trata con la semantica. Junto con la teoria de modelos, la teoria de conjuntos axiomatica y la teoria de la computabilidad, la teoria de la demostracion es uno de los \u00abcuatro pilares\u00bb de los fundamentos de las matematicas.[cita\u00a0requerida]  Dentro de la teoria de la demostracion es muy importante distinguir entre las demostraciones \u00abinformales\u00bb encontradas en la practica cotidiana de los matematicos y en los libros comunes sobre matematicas, de las demostraciones puramente \u00abformales\u00bb de la teoria de la demostracion formal. Las primeras tienen el objetivo de mostrar rigurosamente un resultado matematico de manera clara, pero al mismo tiempo intuitiva e inteligible, las segundas de estas demostraciones son como una especie de esquemas de alto-nivel escritos en lenguaje formal, que en principio, pueden permitir a un experto o un logico construir una demostracion puramente formal del mismo resultado, dado el suficiente tiempo y paciencia. Para la mayoria de los matematicos, escribir una demostracion completamente formal es un gasto de tiempo innecesario como para ser practica comun.  Las demostraciones formales pueden ser construidas con ayuda de ordenadores mediante metodos de demostracion de teoremas interactivos u otras tecnicas. Es significativo, que estas demostraciones puramente formales basadas en la manipulacion de signos pueden ser verificadas automaticamente, tambien por ordenador. Verificar una demostracion puramente formal es simple, mientras que encontrar demostraciones es generalmente mucho mas dificil. Una demostracion informal en un articulo matematico, por el contrario, requiere semanas de revision por pares para ser verificada, y frecuentemente puede contener errores que pasen inadvertidos incluso para matematicos profesionales en temas de investigacion suficientemente complejos.  La teoria de la demostracion formal se ocupa de las propiedades de los sistemas deductivos, su complejidad, el poder expresivo de dichos sistemas y esta intimamente conectada a la logica matematica, la teoria de modelos y la fundamentacion de las matematicas. Por el contrario el desarrollo de demostraciones informales es un terreno altamente creativo y si bien existen familias enteras de esquemas de demostracion en diferentes areas, son un ejercicio basicamente humano en el que no existen algoritmos generales para construir demostraciones.  La teoria de la demostracion formal comenzo con la crisis sobre los fundamentos de las matematicas de las primeras decadas del siglo\u00a0XX. A principios de ese siglo, y como reaccion a la explosion del conocimiento matematico, comenzaron esfuerzos para proporcionar al creciente cuerpo de conocimientos un fundamento formal firme. Si bien en las aplicaciones de las matematicas esta fundamentacion no era importante, en otras  areas de la matematica, como la filosofia de la matematica  se estaba haciendo necesaria una clarificacion de los conceptos fundamentales, ya que estaban apareciendo problemas logicos como los identificados por B. Russell y A. N. Whitehead en el trabajo de Gottlob Frege y otras personas que habian tratado de fundamentar solidamente las matematicas.  Entre los problemas de fundamentacion por ejemplo estaba el uso de los \"infinitesimales\"\u200b que vagamente relacionados con algo \"infinitamente peque\u00f1o\" (lo cual era una nocion demasiado imprecisa). La eliminiacion de los infinitesimales mediante el uso de limites significo un gran progreso para establecer las matematicas existentes sobre un fundamento mas firme y claro. Otro problema sin fudamentar era lo \"infinitamente grande\". Las investigaciones sobre unicidad de representacion de Georg Cantor forzaron a este matematico a desarrollar una nueva teoria de lo infinitamente grande. Uno de los puntos centrales de la teoria de Cantor era la posibilidad de considerar incluso una coleccion no finita de objetos y formar un \"objeto matematico\" con esta coleccion. Estos \"objetos\" fueron denominados por Cantor en aleman como Mengen y el termino se tradujo como 'conjunto' en espa\u00f1ol. Debido a eso Cantor denomino a su teoria Mengenlehre que es el origen de la teoria de conjuntos. La posibilidad de formar conjuntos sin restricciones, producia ciertas contradicciones o antinomias. Un ejemplo notable de estas antinomias es la paradoja de Russell sobre el conjunto de conjuntos que no son miembros de si mismos. Asi si se pudiera definir el conjunto:   R := { x | x \u2208 x } }  seria una contradiccion, ya que por construccion se tendria:   R \u2208 R \u21d4 R \u2208 R  Estas paradojas y probablemente tambien el hecho aparentemente paradojico de que el axioma de eleccion ofrecia la posibilidad de que cualquier conjunto pudiera ser un conjunto bien ordenado, crearon la sensacion de incertidumbre entre la comunidad matematica. Hermann Weyl en su articulo \"Uber die neue Grundlagenkrise der Mathematik\"\u200b apunto que la circularidad de las definiciones causaban paradojas y antinomias tambien en la teoria de conjuntos que se usaba en analisis matematico. Este matematico introdujo el termino \"nueva crisis de fundamentos\" en la discusion de la epoca. En su libro Das Kontinuum ya habia propuesto desarrollar matematicas libres de definiciones circulares.\u200b  Las diversas paradojas surgidas en la teoria de conjuntos y los problemas de fundamentacion del concepto de infinito, llevaron a la llamada crisis fundacional de las matematicas a principios del siglo\u00a0XX. Frente a este debate entre los matematicos, David Hilbert y algunos de sus colaboradores consideraron elaborar un programa de formalizacion completo, para demostrar la consistencia de numerosas ramas de la matematica. Esta propuesta de formalizacion se conocio como programa de Hilbert.  Este enfoque formalista pretendia axiomatizar de manera explicita los supuestos usados en diversas ramas de las matematicas mediante un conjunto de axiomas expresables en un lenguaje formal bien definido y de manera que se pudiera probar la consistencia de las matematicas asi formalizadas. Hilbert y muchos otros matematicos tenian confianza en que este programa tendria exito para cualquier area de las matematicas y siempre seria posible construir un conjunto de reglas que permitieran demostrar en un numero finito de pasos si una proposicion era una proposicion valida (Entscheidungsproblem). Sin embargo, K. Godel pudo demostrar en 1931 que este enfoque tenia limitaciones esenciales, incluso en un sistema tan central para las matematicas como era la aritmetica de los numeros naturales.  El teorema de incompletitud de Godel establece que ninguna teoria consistente, con un numero finito de axiomas recursivamente enumerable (en un lenguaje por lo menos tan potente como la aritmetica), puede incluir todos las proposiciones verdaderas. Sin embargo, la aritmetica es una teoria completable a\u00f1adiendo un conjunto de axiomas infinito y no recursivo. En otras palabras el teorema de Godel solo establece que si T ( A ) })} es un tipo de teoria aritmetica:   ( T ( A ) recursiva \u2227 T ( A ) consistente ) \u21d2 T ( A ) incompleta })\\ }\\land T(})\\ })\\Rightarrow T(})\\ }}  O equivalentemente:   ( T ( A ) completa \u2227 T ( A ) consistente ) \u21d2 \u00ac ( T ( A ) recursiva ) })\\ }\\land T(})\\ })\\Rightarrow \\neg (T(})\\ })}  En 1934 Gerhard Gentzen introdujo las nociones basicas que llevaron al desarrollo de la moderna teoria de la demostracion. ","snippet":"La teoria de la demostracion o teoria de la prueba es una rama de la logica matematica que trata a las demostraciones como objetos matematicos, facilitando su analisis mediante tecnicas matematicas. L","enlaces_salientes":["Teor%C3%ADa_de_la_demostraci%C3%B3n","Teor%C3%ADa_de_la_demostraci%C3%B3n","Teor%C3%ADa_de_la_demostraci%C3%B3n","Demostraci%C3%B3n","L%C3%B3gica_matem%C3%A1tica","Demostraci%C3%B3n_matem%C3%A1tica","Objeto_matem%C3%A1tico","Estructura_de_datos","Axioma","Regla_de_inferencia","Sintaxis","Teor%C3%ADa_de_modelos","Sem%C3%A1ntica","Teor%C3%ADa_de_modelos","Teor%C3%ADa_de_conjuntos","Teor%C3%ADa_de_la_computabilidad","Fundamentos_de_las_matem%C3%A1ticas","Rigor_matem%C3%A1tico","Lenguaje_formal","Revisi%C3%B3n_por_pares","L%C3%B3gica_matem%C3%A1tica","Teor%C3%ADa_de_modelos","Fundamentos_de_las_matem%C3%A1ticas","Filosof%C3%ADa_de_la_matem%C3%A1tica","Bertrand_Russell","Alfred_North_Whitehead","Gottlob_Frege","Infinitesimal","Georg_Cantor","Teor%C3%ADa_de_conjuntos","Antinomia","Paradoja_de_Russell","Axioma_de_elecci%C3%B3n","Conjunto_bien_ordenado","Hermann_Weyl","An%C3%A1lisis_matem%C3%A1tico","Programa_de_Hilbert","Paradoja","Teor%C3%ADa_de_conjuntos","Infinito","David_Hilbert","Lenguaje_formal","Bien_definido","Consistencia_(l%C3%B3gica)","Entscheidungsproblem","Kurt_G%C3%B6del","1931","N%C3%BAmero_natural","Teoremas_de_incompletitud_de_G%C3%B6del","Teorema_de_incompletitud_de_G%C3%B6del","Consistencia_(l%C3%B3gica)","Lenguaje","Aritm%C3%A9tica","Proposici%C3%B3n","Verdad","Gerhard_Gentzen","Jerarqu%C3%ADa_aritm%C3%A9tica","Jerarqu%C3%ADa_anal%C3%ADtica","ISBN","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel"]}
{"url":"Plano_(matem%C3%A1ticas)","titulo":"Plano (geometria)","contenido":"En geometria, un plano es un objeto ideal que solo posee dos dimensiones, y contiene infinitos puntos y rectas; es un concepto  fundamental de la geometria junto con el punto y la recta.  Cuando se habla de un plano de polina, se esta hablando del objeto geometrico que no posee volumen, es decir bidimensional, y que contiene un numero infinito de rectas y puntos. Sin embargo, cuando el termino se utiliza en plural, se esta hablando de aquel objeto elaborado como una representacion grafica de superficies en diferentes posiciones. Los planos son especialmente utilizados en ingenieria, arquitectura y dise\u00f1o, ya que sirven para diagramar en una superficie plana o en otras superficies que son regularmente tridimensionales.  Un plano queda definido por los siguientes elementos geometricos:  Los planos suelen nombrarse con una letra del alfabeto griego.  Suele representarse graficamente, para su mejor visualizacion, como una figura delimitada por bordes irregulares (para indicar que el dibujo es una parte de una superficie infinita).  En un sistema de coordenadas cartesianas, un punto del plano queda determinado por un par ordenado, llamados abscisa y ordenada del punto. Mediante ese procedimiento, a todo punto del plano corresponden siempre dos numeros reales ordenados (abscisa y ordenada), y reciprocamente, a un par ordenado de numeros corresponde un unico punto del plano. Consecuentemente, el sistema cartesiano establece una correspondencia biunivoca entre un concepto geometrico como es el de los puntos del plano y un concepto algebraico como son los pares ordenados de numeros. En coordenadas polares, por un angulo y una distancia. Esta correspondencia constituye el fundamento de la geometria analitica.  El area es una medida de extension de una superficie, o de una figura geometrica plana, expresada en unidades de medida denominadas unidades de superficie. Para superficies planas el concepto es mas intuitivo. Cualquier superficie plana de lados rectos, por ejemplo un poligono, puede triangularse y se puede calcular su area como suma de las areas de dichos triangulos. Ocasionalmente se usa el termino \"area\" como sinonimo de superficie, cuando no existe confusion entre el concepto geometrico en si mismo (superficie) y la magnitud metrica asociada al concepto geometrico (area).  Los libros I a IV y VI de Elementos de Euclides trataban de la geometria bidimensional, desarrollando nociones como la semejanza de formas, el teorema de Pitagoras (Proposicion 47), la igualdad de angulos y area, el paralelismo, la suma de los angulos de un triangulo y los tres casos en que los triangulos son \"iguales\" (tienen la misma area), entre otros muchos temas.  Posteriormente, el plano se describio en el llamado sistema de coordenadas cartesianas, un sistema de coordenadas que especifica cada punto de forma unica en un plano mediante un par de numericos coordenadas, que son las signos distancias desde el punto a dos  rectas perpendiculares fijas, medidas en la misma unidad de longitud. Cada linea de referencia se llama eje de coordenadas o simplemente eje del sistema, y el punto donde se encuentran es su origen', normalmente en el par ordenado (0,\u00a00). Las coordenadas tambien pueden definirse como las posiciones de las proyecciones perpendiculares del punto sobre los dos ejes, expresadas como distancias con signo desde el origen.  La idea de este sistema fue desarrollada en 1637 en escritos de Descartes e independientemente por Pierre de Fermat, aunque Fermat tambien trabajaba en tres dimensiones, y no publico el descubrimiento.\u200b Ambos autores utilizaron un unico eje en sus tratamientos[cita\u00a0requerida] y tienen una longitud variable medida en referencia a este eje. El concepto de utilizar un par de ejes se introdujo mas tarde, despues de que La Geometrie de Descartes fuera traducida al latin en 1649 por Frans van Schooten y sus alumnos. Estos comentaristas introdujeron varios conceptos al tiempo que intentaban aclarar las ideas contenidas en la obra de Descartes.\u200b  Mas tarde, se penso en el plano como un campo, en el que dos puntos cualesquiera podian multiplicarse y, excepto 0, dividirse. Esto se conocio como plano complejo. El plano complejo se denomina a veces plano de Argand porque se utiliza en los diagramas de Argand. Estos reciben su nombre de Jean-Robert Argand (1768-1822), aunque fueron descritos por primera vez por el topografo y matematico danes-noruego Caspar Wessel (1745-1818).\u200b Los diagramas de Argand se utilizan frecuentemente para trazar las posiciones del polos y del ceroes de una funcion en el plano complejo.  En matematicas, la geometria analitica (tambien llamada geometria cartesiana) describe cada punto del espacio bidimensional mediante dos coordenadas.  Se dan dos  ejes de coordenadas perpendiculares que se cruzan en el origen.  Suelen denominarse x e y. En relacion con estos ejes, la posicion de cualquier punto en el espacio bidimensional viene dada por un par ordenado de numeros reales, cada numero dando la distancia de ese punto desde el origen medido a lo largo del eje dado, que es igual a la distancia de ese punto desde el otro eje.  Otro sistema de coordenadas ampliamente utilizado es el sistema de coordenadas polares, que especifica un punto en terminos de su distancia desde el origen y su angulo relativo a un rayo de referencia hacia la derecha.  Sistema de coordenadas cartesianas  Sistema de coordenadas polares  En geometria euclidiana, un plano es una superficie plana de dos dimensiones  que se extiende indefinidamente. Los  planos euclideos surgen a menudo como subespacios del espacio tridimensional. R 3 ^{3}} . Un ejemplo prototipico es una de las paredes de una habitacion, infinitamente extendida y que se supone infinitesimal delgada. Mientras que un par de numeros reales R 2 ^{2}} basta para describir puntos en un plano, la relacion con puntos fuera del plano requiere una consideracion especial para su incrustacion en el espacio ambiente R 3 ^{3}} .  En dos dimensiones, existen infinitos politopos: los poligonos. A continuacion se muestran los primeros regulares:  El simbolo de Schlafli { n } } representa un n-agono regular.  El monogono (o henagono) regular {1} y el digon regular {2} {2} pueden considerarse poligonos regulares degenerados y existen de forma no degenerada en espacios no euclidianos como una 2-esfera, un 2-toro, o un cilindro circular recto.  Existen infinitos poligonos regulares no convexos en dos dimensiones, cuyos simbolos de Schlafli consisten en numeros racionales {n/m}. Se llaman poligonos estrella y comparten la misma disposicion de vertices de los poligonos regulares convexos.  En general, para cualquier numero natural n, existen estrellas poligonales regulares no convexas de n puntas con simbolos de Schlafli {n/m} para todo m tal que m < n/2 (estrictamente hablando {n/m} = {n/(n - m)}) y m y n son coprimos.  La hiperesfera en 2 dimensiones es un circulo, a veces llamado 1-esfera (S1) porque es un colector unidimensional. En un plano euclideo, tiene la longitud 2\u03c0r y el area de su interior es  donde r es el radio.  Existen infinidad de otras formas curvas en dos dimensiones, entre las que destacan las secciones conicas: la elipse, la  parabola y la hiperbola.  En un espacio euclidiano tridimensional \u211d3, podemos hallar los siguientes hechos (los cuales no son necesariamente validos para dimensiones mayores):  Un plano queda definido por los siguientes elementos geometricos: un punto y dos vectores:  Punto P = (x1, y1, z1)Vector u = (ux, uy, uz)Vector v = (a2, b2, c2)   donde m y n son escalares.  Esta es la forma vectorial del plano; sin embargo, la forma mas utilizada es la reducida, resultado de igualar a cero el determinante formado por los dos vectores y el punto generico X = (x, y, z) con el punto dado. De esta manera la ecuacion del plano es:  Donde (A, B, C) es un vector perpendicular al plano y coincide con el producto vectorial de los vectores u y v. La formula para hallar la ecuacion cuando no esta en el origen es:  P = P0 + mA + nB es la ecuacion del plano determinado por un punto fijo y dos vectores A y B no colineales.\u200b  a.x = 0, donde a es un vector ortogonal y x un punto del plano.  Si tenemos un plano 1 con un punto A y un vector normal 1, y tambien tenemos un plano 2 con un punto B y un vector normal 2.  Sus posiciones relativas pueden ser:  Para un plano cualquiera \u03a0 : a x + b y + c z + d = 0 y un punto cualquiera p 1 = ( x 1 , y 1 , z 1 ) _{1}=(x_{1},y_{1},z_{1})} no necesariamente contenido en dicho plano \u03a0, la menor distancia entre P1 y el plano \u03a0 es:  De lo anterior se deduce que el punto P1 pertenecera al plano \u03a0 si y solo si D=0.  Si los coeficientes a, b y c de la ecuacion canonica de un plano cualquiera estan normalizados, esto es cuando a 2 + b 2 + c 2 = 1 +b^{2}+c^{2}}}=1} , entonces la formula anterior de la distancia D se reduce a:  Se llama semiplano, en geometria, cada una de las dos partes en que un plano queda dividido por una recta.  En cada pareja de semiplanos que una recta r determina sobre un plano existen infinitos puntos tales que:  En topologia, el plano se caracteriza por ser el unico espacio contractil  bidimensional.  Su dimension se caracteriza por el hecho de que la eliminacion de un punto del plano deja un espacio que esta conectado, pero no  simplemente conectado.  En teoria de grafos, un grafo plano es un grafo que se puede  incrustar en el plano, es decir, que se puede dibujar en el plano de tal manera que sus aristas se crucen solo en sus puntos extremos.  En otras palabras, se puede dibujar de forma que ninguna arista se cruce con otra.\u200b Tal dibujo se llama un grafo plano o incrustacion plana del grafo. Un grafo plano puede definirse como un grafo plano con un mapeado desde cada nodo a un punto en un plano, y desde cada arista a una curva plana en ese plano, de tal forma que los puntos extremos de cada curva son los puntos mapeados desde sus nodos extremos, y todas las curvas son disjuntas excepto en sus puntos extremos. ","snippet":"En geometria, un plano es un objeto ideal que solo posee dos dimensiones, y contiene infinitos puntos y rectas; es un concepto  fundamental de la geometria junto con el punto y la recta.  Cuando se ha","enlaces_salientes":["Plano_(geometr%C3%ADa)","Plano_(geometr%C3%ADa)","Plano_(geometr%C3%ADa)","Gr%C3%A1fica_de_una_funci%C3%B3n","Hip%C3%A9rbola","As%C3%ADntotas","Plano_cartesiano","Geometr%C3%ADa","Bidimensional","Punto_(geometr%C3%ADa)","Recta","Bidimensional","Definici%C3%B3n_(matem%C3%A1tica)","Paralelismo_(matem%C3%A1tica)","Coordenadas_cartesianas","Punto_(geometr%C3%ADa)","Par_ordenado","Abscisa","Ordenada","N%C3%BAmero_real","Par_ordenado","Biun%C3%ADvoca","Concepto","Coordenadas_polares","%C3%81ngulo","Distancia","Geometr%C3%ADa_anal%C3%ADtica","%C3%81rea","Superficie_(matem%C3%A1tica)","Figura_geom%C3%A9trica","Unidades_de_medida","Unidades_de_superficie","Pol%C3%ADgono","Triangulaci%C3%B3n","Geometr%C3%ADa_euclidiana#Historia","Elementos_de_Euclides","Teorema_de_Pit%C3%A1goras","%C3%81rea","Sistema_de_coordenadas_cartesianas","Sistema_de_coordenadas","Punto_(geometr%C3%ADa)","N%C3%BAmeros","Perpendicularidad","Unidad_de_longitud","Origen_(matem%C3%A1ticas)","Proyecci%C3%B3n_ortogonal","Pierre_de_Fermat","La_G%C3%A9om%C3%A9trie","Frans_van_Schooten","Campo_(matem%C3%A1ticas)","Plano_complejo","Jean-Robert_Argand","Caspar_Wessel","Polo_(an%C3%A1lisis_complejo)","Cero_(an%C3%A1lisis_complejo)","Funci%C3%B3n_matem%C3%A1tica","Geometr%C3%ADa_euclidiana","Coordenadas_cartesianas","Sistema_de_coordenadas_polares","Geometr%C3%ADa_anal%C3%ADtica","Sistema_de_coordenadas","Origen_(matem%C3%A1ticas)","Origen_(matem%C3%A1tica)","Sistema_de_coordenadas_polares","Sistema_de_coordenadas_cartesianas","Sistema_de_coordenadas_polares","Geometr%C3%ADa_euclidiana","Dimensiones","Plano_eucl%C3%ADdeo","Variedad_lineal","Espacio_tridimensional","Incrustaci%C3%B3n","Pol%C3%ADgono","S%C3%ADmbolo_de_Schl%C3%A4fli","Pol%C3%ADgono_regular","Tri%C3%A1ngulo_equil%C3%A1tero","Simplex","Hipercubo","Pent%C3%A1gono","Hex%C3%A1gono","Hept%C3%A1gono","Oct%C3%B3gono","S%C3%ADmbolo_de_Schl%C3%A4fli","Non%C3%A1gono","Dec%C3%A1gono","Undec%C3%A1gono","Dodec%C3%A1gono","Tridec%C3%A1gono","Tetradec%C3%A1gono","Pentadec%C3%A1gono","Hexadec%C3%A1gono","Heptadec%C3%A1gono","Octadec%C3%A1gono","Eneadec%C3%A1gono","Icos%C3%A1gono","Pol%C3%ADgono_regular","Mon%C3%B3gono","Digon","Esfera","Toroide","Mon%C3%B3gono","D%C3%ADgono","S%C3%ADmbolo_de_Schl%C3%A4fli","Disposici%C3%B3n_de_v%C3%A9rtices","Coprimos","Estrella_pentagonal","Heptagrama","Octagrama","Eneagrama","Decagrama","Estrella_(figura_geom%C3%A9trica)","S%C3%ADmbolo_de_Schl%C3%A4fli","C%C3%ADrculo","Hiperesfera","C%C3%ADrculo","Colector","%C3%81rea","Interior_(topolog%C3%ADa)","Secciones_c%C3%B3nicas","Elipse","Par%C3%A1bola_(matem%C3%A1tica)","Hip%C3%A9rbola","Espacio_euclidiano","Tridimensional","Determinante_(matem%C3%A1tica)","Bicondicional","Vector_unitario","Semiplano","Papel_milimetrado","Geometr%C3%ADa","Recta","Recta","Punto_(geometr%C3%ADa)","Segmento","Topolog%C3%ADa","Espacio_contr%C3%A1ctil","Superficie_(topolog%C3%ADa)","Conjunto_simplemente_conexo","Teor%C3%ADa_de_grafos","Grafo_plano","Grafo","Grafo_embebido","Curva_plana","Geometr%C3%ADa_plana","Geometr%C3%ADa_anal%C3%ADtica","Espacio_eucl%C3%ADdeo","Recta","Punto_(geometr%C3%ADa)","Superficie_(matem%C3%A1tica)","Superficie_(f%C3%ADsica)","Plano_proyectivo","ISBN","ISBN","Eric_W._Weisstein","MathWorld","Wolfram_Research","Control_de_autoridades","Gemeinsame_Normdatei","Art_%26_Architecture_Thesaurus"]}
{"url":"%C3%9Altimo_Teorema_de_Fermat","titulo":"Ultimo teorema de Fermat","contenido":"En teoria de numeros, el ultimo teorema de Fermat, o teorema de Fermat-Wiles, es uno de los teoremas mas famosos en la historia de las matematicas. Utilizando la notacion moderna, se puede enunciar de la siguiente manera:  Si n es un numero entero mayor o igual que 3, entonces no existen numeros enteros positivos x, y y z, tales que se cumpla la igualdad    Esto es asi salvo el caso de las soluciones triviales (0,1,1), (1,0,1) y (0,0,0). Es importante recalcar que han de ser positivos ya que si pudiese ser alguno de ellos negativo, no es dificil encontrar soluciones no triviales para algun caso en el que n es mayor que 2. Por ejemplo si n fuese cualquier numero impar, las ternas de la forma (a, -a, 0) con a un numero entero positivo, son solucion.  Este teorema fue conjeturado por Pierre de Fermat en 1637, pero no fue demostrado hasta 1995 por Andrew Wiles ayudado por el matematico Richard Taylor. La busqueda de una demostracion estimulo el desarrollo de la teoria algebraica de numeros en el siglo\u00a0XIX y la demostracion del teorema de la modularidad en el siglo\u00a0XX.  La proposicion fue enunciada por primera vez como teorema por Pierre de Fermat hacia 1637 en el margen de una copia de Arithmetica. Fermat a\u00f1adio que tenia una demostracion que era demasiado grande para caber en el margen. Aunque otras afirmaciones de Fermat sin demostracion fueron posteriormente demostradas por otros y acreditadas como teoremas de Fermat (por ejemplo,  el teorema de Fermat sobre sumas de dos cuadrados), el Ultimo Teorema de Fermat se resistio a la demostracion, lo que llevo a dudar de que Fermat tuviera alguna vez una demostracion correcta. En consecuencia, la proposicion paso a denominarse conjetura en lugar de teorema. Tras 358 a\u00f1os de esfuerzos por parte de los matematicos, la primera prueba exitosa fue dada a conocer en 1994 por Andrew Wiles y publicada formalmente en 1995. Fue descrita como un \"avance asombroso\" en la citacion para el Premio Abel de Wiles en 2016.\u200b Tambien demostro gran parte de la conjetura de Taniyama-Shimura, posteriormente conocida como teorema de la modularidad, y abrio enfoques completamente nuevos a otros numerosos problemas y tecnicas de elevacion de la modularidad matematicamente potentes.  El problema sin resolver estimulo el desarrollo de la teoria algebraica de numeros en los siglos XIX y XX. Se encuentra entre los teoremas mas notables de la historia de las matematicas y antes de su demostracion figuraba en el Libro Guinness de los Records como el \"problema matematico mas dificil\", en parte porque el teorema tiene el mayor numero de demostraciones fallidas.\u200b  La ecuacion de Pitagoras, x2 + y2 = z2, tiene un numero infinito de soluciones  enteras positivas para x, y y z; estas soluciones se conocen como  triples pitagoricos (con el ejemplo mas simple 3,4,5). Hacia 1637, Fermat escribio en el margen de un libro que la ecuacion mas general an + bn = cn no tenia soluciones en enteros positivos si n es un entero mayor que 2. Aunque afirmo tener una prueba general de su conjetura, Fermat no dejo detalles de su prueba, y nunca se ha encontrado ninguna prueba suya. Su afirmacion fue descubierta unos 30 a\u00f1os mas tarde, despues de su muerte. Esta afirmacion, que paso a conocerse como El ultimo teorema de Fermat, quedo sin resolver durante los tres siglos y medio siguientes.\u200b  Con el tiempo, la afirmacion se convirtio en uno de los problemas sin resolver mas notables de las matematicas. Los intentos de demostrarlo impulsaron un desarrollo sustancial de la teoria de numeros, y con el tiempo el Ultimo Teorema de Fermat gano prominencia como  problema sin resolver en matematicas.  El caso especial n = 4, demostrado por el propio Fermat, es suficiente para establecer que si el teorema es falso para algun exponente n que no sea un numero primo, tambien debe ser falso para algun n mas peque\u00f1o, por lo que solo los valores primos de n necesitan mas investigacion.[note 1]\u200b Durante los dos siglos siguientes (1637-1839), la conjetura se demostro solo para los primos 3, 5 y 7, aunque Sophie Germain innovo y demostro una aproximacion que era relevante para toda una clase de primos. A mediados del siglo XIX, Ernst Kummer amplio este enfoque y demostro el teorema para todos los primos regulares, dejando los primos irregulares para ser analizados individualmente. Basandose en el trabajo de Kummer y utilizando sofisticados estudios informaticos, otros matematicos fueron capaces de ampliar la demostracion para cubrir todos los exponentes primos hasta cuatro millones,\u200b pero una demostracion para todos los exponentes era inaccesible (lo que significa que los matematicos generalmente consideraban una demostracion imposible, excesivamente dificil o inalcanzable con los conocimientos actuales).\u200b.  Por separado, alrededor de 1955, los matematicos japoneses Goro Shimura y Yutaka Taniyama sospecharon que podria existir un vinculo entre las curvas elipticas y las formas modulares, dos areas completamente diferentes de las matematicas. Conocida en su momento como conjetura de Taniyama-Shimura (posteriormente como teorema de la modularidad), se trataba de una conjetura independiente, sin conexion aparente con el ultimo teorema de Fermat. En general, se consideraba significativa e importante por si misma, pero (al igual que el teorema de Fermat) se consideraba completamente inaccesible a la demostracion.\u200b  En 1984, Gerhard Frey se percato de una aparente relacion entre estos dos problemas no relacionados ni resueltos hasta entonces. Frey dio un esbozo que sugeria que esto podia demostrarse. La prueba completa de que los dos problemas estaban estrechamente relacionados fue realizada en 1986 por Ken Ribet, basandose en una prueba parcial de Jean-Pierre Serre, que demostro toda la parte menos una conocida como la \"conjetura epsilon\" (vease: Teorema de Ribet y curva de Frey).\u200b Estos trabajos de Frey, Serre y Ribet demostraron que si se podia demostrar la conjetura de Taniyama-Shimura para al menos la clase semiestable de curvas elipticas, se obtendria automaticamente una demostracion del Ultimo Teorema de Fermat. La conexion se describe a continuacion: cualquier solucion que pudiera contradecir el Ultimo Teorema de Fermat tambien podria utilizarse para contradecir la conjetura Taniyama-Shimura. Asi pues, si el teorema de la modularidad fuera cierto, por definicion no podria existir ninguna solucion que contradijera el Ultimo Teorema de Fermat, que por tanto tambien tendria que ser cierto.  Aunque ambos problemas eran desalentadores y en su momento se consideraron \"completamente inaccesibles\" para su demostracion,\u200b esta fue la primera sugerencia de una ruta por la que el Ultimo Teorema de Fermat podria extenderse y demostrarse para todos los numeros, no solo para algunos. A diferencia del ultimo teorema de Fermat, la conjetura Taniyama-Shimura era un area de investigacion activa importante y se consideraba mas al alcance de las matematicas contemporaneas.\u200b Sin embargo, la opinion general era que esto simplemente demostraba la impracticabilidad de demostrar la conjetura Taniyama-Shimura.\u200b La reaccion citada del matematico John Coates fue comun:\u200b  Al enterarse de que Ribet habia demostrado que la conexion de Frey era correcta, el matematico ingles Andrew Wiles, que habia sentido fascinacion durante su infancia por el Ultimo Teorema de Fermat y tenia experiencia trabajando con curvas elipticas y campos relacionados, decidio intentar demostrar la conjetura Taniyama-Shimura como una forma de demostrar el Ultimo Teorema de Fermat. En 1993, tras seis a\u00f1os trabajando en secreto en el problema, Wiles logro demostrar una parte suficiente de la conjetura para demostrar el Ultimo Teorema de Fermat. El documento de Wiles era enorme en tama\u00f1o y alcance. Se descubrio un fallo en una parte de su articulo original durante la revision por pares y fue necesario un a\u00f1o mas de colaboracion con un antiguo alumno, Richard Taylor, para resolverlo. Como resultado, la demostracion final de 1995 fue acompa\u00f1ada de un articulo conjunto mas peque\u00f1o que mostraba que los pasos fijos eran validos. El logro de Wiles se divulgo ampliamente en la prensa popular y se popularizo en libros y programas de television. Las partes restantes de la conjetura Taniyama-Shimura-Weil, ahora demostradas y conocidas como el teorema de la modularidad, fueron demostradas posteriormente por otros matematicos, que se basaron en el trabajo de Wiles entre 1996 y 2001.\u200b\u200b\u200b Por su demostracion, Wiles fue honrado y recibio numerosos premios, entre ellos el Premio Abel de 2016.\u200b\u200b\u200b  Pierre de Fermat poseia una edicion bilingue (griego y latin) de la Arithmetica de Diofanto, traducida por Claude Gaspar Bachet. Fermat escribio un comentario, de hecho, un acertijo, en el margen de cada problema, y uno por uno han sido resueltos por personalidades como Leibniz, Newton, etc. Solo quedo sin resolver el acertijo que propuso debajo del problema VIII, que trata sobre escribir un numero cuadrado como suma de dos cuadrados (es decir, encontrar ternas pitagoricas). Ahi, Fermat escribio:  \u200b  El primer matematico que consiguio avanzar sobre este teorema fue el propio Fermat, que demostro el caso n=4 usando la tecnica del descenso infinito, una variante del principio de induccion.  Leonhard Euler demostro el caso n = 3. El 4 de agosto de 1753 Euler escribio a Goldbach reclamando tener una demostracion para el caso n = 3. En Algebra (1770) se encontro una falacia en la demostracion de Euler. Corregirla directamente era demasiado dificil, pero otros aportes anteriores de Euler permitian encontrar una solucion correcta por medios mas simples. Por esto se considero que Euler habia demostrado ese caso. Del analisis de la demostracion fallida de Euler surgio la evidencia de que ciertos conjuntos de numeros complejos no se comportaban de igual manera que los enteros.  El siguiente mayor paso fue hecho por la matematica Sophie Germain. Un caso especial dice que si p y 2p + 1 son ambos primos, entonces la expresion de la conjetura de Fermat para la potencia p implica que uno de los x, y o z es divisible por p. En consecuencia la conjetura se divide en dos casos:  Sophie Germain probo el caso 1 para todo p menor que 100 y Adrien-Marie Legendre extendio sus metodos a todos los numeros menores que 197. Aqui se encontro que el caso 2 no estaba demostrado ni siquiera para p = 5, por lo que fue evidente que era en el caso 2 en el que habia que concentrarse. Este caso tambien se dividia entre varios casos posibles.  No fue hasta 1825 cuando Peter Gustav Lejeune Dirichlet y Legendre generalizaron para n=5 la demostracion de Euler. Lame demostro el caso n=7 en 1839.  Entre 1844 y 1846 Ernst Kummer demostro que la factorizacion no unica podia ser salvada mediante la introduccion de numeros complejos ideales. Un a\u00f1o despues Kummer afirma que el numero 37 no es un primo regular (Ver: Numeros de Bernoulli). Luego se encuentra que tampoco 59 y 67 lo son. Kummer, Mirimanoff, Wieferich, Furtwanger, Vandiver y otros extienden la investigacion a numeros mas grandes. En 1915 Jensen demuestra que existen infinitos primos irregulares. La investigacion se estanca por esta via de la divisibilidad, a pesar de que se logran comprobaciones para n menor o igual a 4 000 000.  En el a\u00f1o 1995 el matematico Andrew Wiles, en un articulo de 98 paginas publicado en Annals of mathematics, demostro el caso semiestable del teorema de Taniyama-Shimura, anteriormente una conjetura, que engarza las formas modulares y las curvas elipticas. De este trabajo, combinado con ideas de Frey y con el teorema de Ribet, se desprende la demostracion del ultimo teorema de Fermat.\u200b Aunque una version anterior (no publicada) del trabajo de Wiles contenia un error, este pudo ser corregido en la version publicada, que consta de dos articulos, el segundo en colaboracion con el matematico Richard Taylor. En estos trabajos por primera vez se establecen resultados de modularidad a partir de modularidad residual, por lo cual los resultados del tipo de los probados por Wiles y Taylor son denominados \u00abteoremas de levantamiento modular\u00bb. En la actualidad, resultados de este tipo, mucho mas generales y poderosos, han sido probados por varios matematicos: ademas de generalizaciones probadas por Wiles en colaboracion con C. Skinner y de Taylor en colaboracion con M. Harris, los mas generales en la actualidad se deben a Mark Kisin. En el trabajo de 1995 de Wiles se abrio una nueva via, practicamente una nueva area: la de la modularidad. Con estas tecnicas, de las que este trabajo fue pionero, se han resuelto mas recientemente otras importantes conjeturas, como la conjetura de Serre y la de Sato-Tate. Curiosamente, la resolucion de los primeros casos de la conjetura de Serre (trabajos de Khare, Wintenberger y Dieulefait), como observara el propio Serre al formular la conjetura, permite una nueva demostracion del ultimo teorema de Fermat.\u200b  Los trabajos de Wiles por lo tanto tienen una importancia que trasciende ampliamente su aplicacion al ultimo teorema de Fermat: se consideran centrales en la geometria aritmetica moderna y se espera que sigan jugando un rol vital en la demostracion de resultados de modularidad que se enmarcan en el programa de Langlands.    Error en la cita: Existen etiquetas <ref> para un grupo llamado \u00abnote\u00bb, pero no se encontro la etiqueta <references group=\"note\"/> correspondiente. ","snippet":"En teoria de numeros, el ultimo teorema de Fermat, o teorema de Fermat-Wiles, es uno de los teoremas mas famosos en la historia de las matematicas. Utilizando la notacion moderna, se puede enunciar de","enlaces_salientes":["%C3%9Altimo_teorema_de_Fermat","%C3%9Altimo_teorema_de_Fermat","%C3%9Altimo_teorema_de_Fermat","Pierre_de_Fermat","Teor%C3%ADa_de_n%C3%BAmeros","Matem%C3%A1tica","N%C3%BAmero_entero","Pierre_de_Fermat","Teorema","Conjetura","Pierre_de_Fermat","1995","Andrew_Wiles","Richard_Lawrence_Taylor","Teor%C3%ADa_algebraica_de_n%C3%BAmeros","Teorema_de_la_modularidad","Pierre_de_Fermat","Arithmetica","Teorema_de_Fermat_sobre_la_suma_de_dos_cuadrados","Conjetura","Andrew_Wiles","Premio_Abel","Teorema_de_la_modularidad","Teor%C3%ADa_algebraica_de_n%C3%BAmeros","Historia_de_las_matem%C3%A1ticas","Libro_Guinness_de_los_R%C3%A9cords","Teorema_de_Pit%C3%A1goras","N%C3%BAmero_entero","Terna_pitag%C3%B3rica","Prueba_matem%C3%A1tica","Teor%C3%ADa_de_n%C3%BAmeros","Exponente","N%C3%BAmero_primo","Sophie_Germain","Ernst_Kummer","Primo_regular","Goro_Shimura","Yutaka_Taniyama","Curvas_el%C3%ADpticas","Conjetura_de_Taniyama-Shimura","Gerhard_Frey","Ken_Ribet","Jean-Pierre_Serre","Teorema_de_Ribet","Curva_de_Frey","Andrew_Wiles","Revisi%C3%B3n_por_pares","Richard_Taylor_(matem%C3%A1tico)","Premio_Abel","Arithmetica","Diofanto","1670","Pierre_de_Fermat","Arithmetica","Diofanto_de_Alejandr%C3%ADa","Claude_Gaspard_Bachet_de_M%C3%A9ziriac","Leibniz","Isaac_Newton","Terna_pitag%C3%B3rica","Descenso_infinito","Inducci%C3%B3n_matem%C3%A1tica","Leonhard_Euler","Falacia","Sophie_Germain","Sophie_Germain","Adrien-Marie_Legendre","1665","1753","Leonhard_Euler","1825","Adrien-Marie_Legendre","1839","Gabriel_Lam%C3%A9","1843","Ernst_Kummer","Peter_Gustav_Lejeune_Dirichlet","1995","Andrew_Wiles","Peter_Gustav_Lejeune_Dirichlet","Legendre","Gabriel_Lam%C3%A9","Ernst_Kummer","Ideal_(teor%C3%ADa_de_anillos)","Primo_regular","N%C3%BAmeros_de_Bernoulli","1995","Andrew_Wiles","Teorema_de_Taniyama-Shimura","Forma_modular","Teorema_de_Ribet","Richard_Lawrence_Taylor","Conjetura_de_Serre","Programa_de_Langlands","Pierre_de_Fermat","Peque%C3%B1o_teorema_de_Fermat","N%C3%BAmero_primo_de_Fermat","Espiral_de_Fermat","Conjetura_de_Beal","ISBN","JSTOR","ISSN","ISSN","Nature_(journal)","Bibcode","PubMed_Identifier","Semantic_Scholar","Digital_object_identifier","ISBN","Simon_Singh","Simon_Singh","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Rep%C3%BAblica_Checa","Biblioteca_Nacional_de_Israel","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Conjetura_de_Kepler","titulo":"Conjetura de Kepler","contenido":"La conjetura de Kepler fue formulada por el fisico, matematico y astronomo aleman Johannes Kepler en 1611. Esta conjetura afirma que si apilamos esferas iguales, la densidad maxima se alcanza con una apilamiento piramidal de caras centradas. Esta densidad es aproximadamente del 74%.  En 1998 Thomas Hales anuncio que habia demostrado la conjetura de Kepler. Fue publicada en Annals of Mathematics. La comprobacion de Hales es una demostracion por casos en la que se prueban agrupamientos mediante complejos calculos de computadora. Hales formulo una ecuacion de 150 variables que recogia cinco mil posibles agrupamientos de esferas iguales.  Los doce cientificos seleccionados por Annals para realizar la revision por pares comentaron que estaban al \"99% seguros\" de la exactitud de la prueba de Hales, pero que era imposible revisar los tres gigabytes de codigos. Sin embargo, el metodo utilizado por Hales en la demostracion no es exhaustivo, por lo que no esta dilucidado el problema. Por tanto, la conjetura de Kepler esta mas cerca de convertirse en un teorema.  El autor de la solucion se dedico a crear el proyecto Flyspeck, consistente en un programa que verifica paso a paso todas las afirmaciones logicas de la solucion matematica, verificandola en lugar de los propios matematicos. El 9 de agosto de 2014, el equipo de Hales anuncio que el programa que crearon logro verificar la solucion de la Conjetura de Kepler propuesta por Hales, y que no encontro errores.  \u201cEsta tecnologia excluye a los arbitros matematicos del proceso de verificacion. Su opinion sobre la correccion de las pruebas ya no importa mas\u201d, afirma Hales, citado por la revista \u2018New Scientist\u2018. La prueba del problema, verificada por una computadora, puede abrir una nueva era en las matematicas donde las maquinas haran el \u201ctrabajo pesado\u201d liberando a los cientificos para que se puedan dedicar al \u201cpensamiento mas profundo\u201d.  En junio de 2017, la demostracion formal de la Conjetura de Kepler fue aceptada en la revista Forum of Mathematics.\u200b  Imagine llenar un recipiente grande con esferas peque\u00f1as del mismo tama\u00f1o. La densidad de la disposicion es igual al volumen colectivo de las esferas dividido por el volumen del contenedor. Maximizar el numero de esferas en el contenedor significa crear una disposicion con la mayor densidad posible, de modo que las esferas se empaqueten juntas lo mas cerca posible.  El experimento muestra que soltar las esferas al azar alcanzara una densidad de alrededor del 65%.\u200b Sin embargo, se puede lograr una mayor densidad organizando cuidadosamente las esferas de la siguiente manera. Comience con una capa de esferas en una red hexagonal, luego coloque la siguiente capa de esferas en los puntos mas bajos que pueda encontrar sobre la primera capa, y asi sucesivamente. En cada paso hay dos opciones de donde colocar la siguiente capa, por lo que este metodo natural de apilar las esferas crea un numero infinitamente infinito de empaques igualmente densos, los mas conocidos se denominan empaquetamiento cerrado cubico y empaque cerrado hexagonal. Cada uno de estos arreglos tiene una densidad promedio de  La conjetura de Kepler dice que esto es lo mejor que se puede hacer: ninguna otra disposicion de esferas tiene una densidad promedio mas alta.  La conjetura fue declarada por primera vez por Johannes Kepler en su articulo \"On the six-cornered snowflake\" (Sobre el copo de nieve de seis picos). Habia comenzado a estudiar los arreglos de las esferas como resultado de su correspondencia con el matematico y astronomo ingles Thomas Harriot en 1606. Harriot era amigo y asistente de Sir Walter Raleigh, quien le habia planteado a Harriot el problema de determinar la mejor manera de apilar balas de ca\u00f1on en las cubiertas de sus barcos. Harriot publico un estudio de varios patrones de apilamiento en 1591 y desarrollo una version temprana de la teoria atomica.  Kepler no tenia una prueba de la conjetura, y Carl Friedrich Gauss (1831) dio el siguiente paso, quien demostro que la conjetura de Kepler es cierta si las esferas tienen que organizarse en una red regular.  Esto significaba que cualquier arreglo de empaque que refutara la conjetura de Kepler tendria que ser irregular. Pero eliminar todos los arreglos irregulares posibles es muy dificil, y esto es lo que hizo que la conjetura de Kepler fuera tan dificil de probar. De hecho, hay disposiciones irregulares que son mas densas que la disposicion de empaquetado cubico cerrado en un volumen lo suficientemente peque\u00f1o, pero ahora se sabe que cualquier intento de extender estas disposiciones para llenar un volumen mayor siempre reduce su densidad.  Despues de Gauss, no se hicieron mas progresos para probar la conjetura de Kepler en el siglo\u00a0XIX. En 1900, David Hilbert lo incluyo en su lista de veintitres problemas matematicos no resueltos; forma parte del decimoctavo problema de Hilbert.  Siguiendo el enfoque sugerido por Fejes Toth\u00a0(1953), Thomas Hales, entonces en la Universidad de Michigan, determino que la densidad maxima de todos los arreglos se podia encontrar minimizando una funcion con 150 variables. En 1992, asistido por su estudiante graduado Samuel Ferguson, se embarco en un programa de investigacion para aplicar sistematicamente metodos de programacion lineal para encontrar un limite inferior en el valor de esta funcion para cada uno de un conjunto de mas de 5.000 configuraciones diferentes de esferas. Si se pudiera encontrar un limite inferior (para el valor de la funcion) para cada una de estas configuraciones que fuera mayor que el valor de la funcion para la disposicion de empaquetado cubico cercano, entonces se demostraria la conjetura de Kepler. Encontrar limites inferiores para todos los casos involucrados en la resolucion de aproximadamente 100.000 problemas de programacion lineal.  Al presentar el progreso de su proyecto en 1996, Hales dijo que el final estaba a la vista, pero que podria llevar \"uno o dos a\u00f1os\" completarlo. En agosto de 1998, Hales anuncio que la prueba estaba completa. En esa etapa, constaba de 250 paginas de notas y 3 gigabytes de programas informaticos, datos y resultados.  A pesar de la naturaleza inusual de la prueba, los editores de Annals of Mathematics acordaron publicarla, siempre que fuera aceptada por un panel de doce arbitros. En 2003, despues de cuatro a\u00f1os de trabajo, el jefe del panel de arbitros, Gabor Fejes Toth, informo que el panel estaba \"99% seguro\" de la exactitud de la prueba, pero no pudieron certificar la exactitud de todos los calculos de la computadora.Hales\u00a0(2005) publico un articulo de 100 paginas que describe en detalle la parte no informatica de su prueba.Hales\u00a0y Ferguson (2006) y varios articulos posteriores describieron las porciones computacionales. Hales y Ferguson recibieron el Premio Fulkerson por trabajos sobresalientes en el area de las matematicas discretas para 2009.  En enero de 2003, Hales anuncio el inicio de un proyecto de colaboracion para producir una prueba formal completa de la conjetura de Kepler. El objetivo era eliminar cualquier incertidumbre restante sobre la validez de la prueba mediante la creacion de una prueba formal que pueda verificarse mediante un software de verificacion de pruebas automatizado como HOL Light e Isabelle. Este proyecto se llama Flyspeck, la F, P y K que significa Prueba Formal de Kepler. Hales estimo que producir una prueba formal completa tomaria alrededor de 20 a\u00f1os de trabajo. Hales publico por primera vez un \"plan\" para la prueba formal en 2012;\u200b El proyecto se anuncio terminado el 10 de agosto de 2014.\u200b En enero de 2015, Hales y 21 colaboradores presentaron un documento titulado \"Una prueba formal de la conjetura de Kepler\" a arXiv, alegando haber probado la conjetura.\u200b En 2017, la prueba formal fue aceptada en la revista Forum of Mathematics. ","snippet":"La conjetura de Kepler fue formulada por el fisico, matematico y astronomo aleman Johannes Kepler en 1611. Esta conjetura afirma que si apilamos esferas iguales, la densidad maxima se alcanza con una ","enlaces_salientes":["Conjetura_de_Kepler","Conjetura_de_Kepler","Conjetura_de_Kepler","F%C3%ADsico","Matem%C3%A1tico","Astr%C3%B3nomo","Johannes_Kepler","Esfera","Densidad","Conjetura","Annals_of_Mathematics","Demostraci%C3%B3n_por_casos","C%C3%A1lculo","Computadora","Cient%C3%ADfico","Revisi%C3%B3n_por_pares","Gigabyte","Teorema","New_Scientist","Volumen","Thomas_Harriot","Walter_Raleigh","Teor%C3%ADa_at%C3%B3mica","Carl_Friedrich_Gauss","Problemas_de_Hilbert","D%C3%A9cimo_problema_de_Hilbert","Universidad_de_M%C3%ADchigan","Gigabyte","Annals_of_Mathematics","Premio_Fulkerson","Matem%C3%A1ticas_discretas","Incertidumbre_de_calibraci%C3%B3n","Software","Isabelle","ArXiv","Empaquetamiento_de_esferas","Problemas_de_Hilbert","3-variedad","ISBN","Google_Code","Thomas_Callister_Hales","ArXiv","ISBN","Mathematical_Reviews","Digital_object_identifier","Carl_Friedrich_Gauss","Annals_of_Mathematics","ISSN","Mathematical_Reviews","ArXiv","Digital_object_identifier","Notices_of_the_American_Mathematical_Society","ISSN","Mathematical_Reviews","ISSN","Mathematical_Reviews","Digital_object_identifier","ISSN","Mathematical_Reviews","Semantic_Scholar","ArXiv","Digital_object_identifier","ISBN","ISBN","ISSN","Mathematical_Reviews","Digital_object_identifier","The_Mathematical_Intelligencer","ISSN","Mathematical_Reviews","Semantic_Scholar","Digital_object_identifier","ISBN","Mathematical_Reviews","Digital_object_identifier","ISBN","Mathematical_Reviews","Bibcode","ArXiv","Digital_object_identifier","Semantic_Scholar","Digital_object_identifier","Proceedings_of_the_London_Mathematical_Society","ISSN","Mathematical_Reviews","Digital_object_identifier","John_Wiley_%26_Sons","ISBN","Mathematical_Reviews","Springer-Verlag","Mathematical_Reviews","Wayback_Machine","Wayback_Machine","Control_de_autoridades","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Doron_Zeilberger","titulo":"Doron Zeilberger","contenido":"Doron Zeilberger, en hebreo original \u05d3\u05d5\u05e8\u05d5\u05df \u05e6\u05d9\u05d9\u05dc\u05d1\u05e8\u05d2\u05e8 (Haifa, 2 de julio de 1950 - ) es un matematico israeloestadounidense conocido por su trabajo en el campo de la combinatoria.  Zeilberger obtuvo el doctorado en matematicas en el Instituto Weizmann (Rehovot, Israel) en 1976, bajo la direccion de Harry Dym. Actualmente es catedratico de matematicas del \"Board of Governors\" de la Universidad Rutgers (Nueva Jersey, Estados Unidos).  Zeilberger ha realizado multiples  contribuciones importantes en combinatoria, igualdades hipergeometricas y series q. Fue el primero en demostrar la conjetura de la matriz de signo alternante.  En 2011, en colaboracion con Manuel Kauers y Christoph Koutschan, demostro la conjetura q-TSPP que habia sido enunciada en 1983 por George Andrews y David P. Robbins. Zeilberger se considera ultrafinitista y es conocido por haber dado credito como coautora a su computadora \"Shalosh B. Ekhad\" (\"Shalosh\" y \"Ekhad\" significan \"tres\" y \"uno\", respectivamente, en hebreo, en referencia a su computadora AT&T 3B1).  Junto a Herbert Wilf recibio el Premio Leroy P. Steele de la American Mathematical Society para contribuciones seminales a la investigacion por el desarrollo de la Teoria WZ, que revoluciono el area de las series hipergeometricas. En 2004 recibio la Medalla Euler como \"campeon del uso de computadoras y algoritmos para hacer matematicas rapida y eficientemente\" y en 2012 fue admitido como miembro numerario (\"Fellow\" en ingles) de la American Mathematical Society. ","snippet":"Doron Zeilberger, en hebreo original \u05d3\u05d5\u05e8\u05d5\u05df \u05e6\u05d9\u05d9\u05dc\u05d1\u05e8\u05d2\u05e8 (Haifa, 2 de julio de 1950 - ) es un matematico israeloestadounidense conocido por su trabajo en el campo de la combinatoria.  Zeilberger obtuvo el ","enlaces_salientes":["Doron_Zeilberger","Doron_Zeilberger","Doron_Zeilberger","Haifa","2_de_julio","1950","Combinatoria","Instituto_Weizmann","Rehovot","Universidad_Rutgers","David_P._Robbins","Herbert_Wilf","Premio_Leroy_P._Steele","American_Mathematical_Society","Series_hipergeom%C3%A9tricas","Medalla_Euler","Control_de_autoridades","Fichero_de_Autoridades_Virtual_Internacional","International_Standard_Name_Identifier","Biblioteca_Nacional_de_Francia","Gemeinsame_Normdatei","Library_of_Congress_Control_Number","Biblioteca_Nacional_de_la_Dieta","Biblioteca_Nacional_de_Israel","Syst%C3%A8me_universitaire_de_documentation","Mathematics_Genealogy_Project","Deutsche_Biographie"]}
{"url":"Lema_(matem%C3%A1ticas)","titulo":"Lema (matematicas)","contenido":"En matematicas, un lema es una proposicion demostrada, utilizada para establecer un teorema menor o una premisa auxiliar que forma parte de un teorema mas general. El termino proviene del griego \u03bb\u03b7\u03bc\u03bc\u03b1 lemma, que significa cualquier cosa que es recibida, tal como un regalo, una dadiva o un soborno.  Ciertos lemas demostrados son mas famosos que el teorema para el que fueron creados, desempe\u00f1ando a veces la funcion de teorema. Muchos lemas son de hecho muy celebrados y generales y se usan por doquier como resultados auxiliares en muchas ramas de la matematica. ","snippet":"En matematicas, un lema es una proposicion demostrada, utilizada para establecer un teorema menor o una premisa auxiliar que forma parte de un teorema mas general. El termino proviene del griego \u03bb\u03b7\u03bc\u03bc\u03b1","enlaces_salientes":["Lema_(matem%C3%A1ticas)","Lema_(matem%C3%A1ticas)","Lema_(matem%C3%A1ticas)","Matem%C3%A1ticas","Proposici%C3%B3n_(l%C3%B3gica)","Teorema","Idioma_griego","Teorema","Corolario","Axioma","Postulado","Doron_Zeilberger","PlanetMath","Control_de_autoridades"]}
{"url":"Lema_de_Gauss","titulo":"Lema de Gauss","contenido":"En la teoria de polinomios, el lema de Gauss, o Criterio de la irreducibilidad de Gauss, afirma que si D es un dominio de factorizacion unica (DFU) y K } es su cuerpo de cocientes (o cuerpo de fracciones), entonces el contenido de dos polinomios dados con coeficientes en D es el producto de contenidos y todo polinomio primitivo p \u2208 D [ x ] es irreducible en D [ x ] si y solo si lo es en K [ x ] [x]} .  El Criterio de irreducibilidad de Gauss proporciona un resultado muy util para demostrar ciertas propiedades de divisibilidad en anillos de polinomios: por la equivalencia que se\u00f1ala el criterio entre la irreducibilidad de un polinomio primitivo en D [ x ] y la irreducibilidad del mismo polinomio en K [ x ] [x]} , puede demostrarse que al ser K [ x ] [x]} un DFU tambien lo es D [ x ] .  Asi, se tiene como corolario que si D es un DFU entonces tambien lo es D [ x ] , sea o no este ultimo anillo un dominio de ideales principales (DIP). Por ejemplo, Z [ x ] [x]} no es un DIP pero si es un DFU.  Tambien se puede usar el lema para demostrar el criterio de Eisenstein, muy util para identificar polinomios irreducibles en los racionales.  Hallemos las raices racionales del polinomio racional  Limpiando los denominadores de f se obtiene el polinomio entero g con las mismas raices:  Claramente, 0 es raiz de multiplicidad 3 de g (y de f ), y las restantes raices racionales son las de  Aqui, a 0 = \u2212 4 =-4} y a n = 3 =3} .  Los divisores de a 0 } son \u00b1 1 , \u00b1 2 , \u00b1 4 y los divisores de a n } son \u00b1 1 , \u00b1 3 , luego las raices racionales se buscan en el conjunto:  Chequeando uno obtiene que h ( \u2212 1 ) = 0 y h ( \u2212 2 / 3 ) = 0 . Asi, las raices racionales distintas de h son \u2212 1 y \u2212 2 / 3 , para conocer con que multiplicidad, se puede o bien dividir h por ( x + 1 ) ( x + 2 / 3 ) y volver a evaluar el cociente en \u2212 1 y \u2212 2 / 3 . O bien tambien se puede derivar h :  y se tiene que h \u2032 ( \u2212 1 ) = 0 mientras que h \u2032 ( \u2212 2 / 3 ) = 0 . O sea \u2212 1 es raiz de multiplicidad \u2265 2 y \u2212 2 / 3 es raiz simple.  Volviendo a derivar h : h \u2033 = 60 x 3 + 96 x + 6 x \u2212 28 +96x+6x-28} y h \u2033 ( \u2212 1 ) = 0 .  Se concluye que -1 es raiz doble de h .  Finalmente la factorizacion de h en Q [ X ] [X]} es:  Y dado que f = 1 / 3 x 3 h h} , resulta la siguiente factorizacion de f en Q [ X ] [X]} : ","snippet":"En la teoria de polinomios, el lema de Gauss, o Criterio de la irreducibilidad de Gauss, afirma que si D es un dominio de factorizacion unica (DFU) y K } es su cuerpo de cocientes (o cuerpo de fraccio","enlaces_salientes":["Lema_de_Gauss","Lema_de_Gauss","Lema_de_Gauss","Carl_Friedrich_Gauss","Dominio_de_factorizaci%C3%B3n_%C3%BAnica","Cuerpo_de_cocientes","Polinomio","Polinomio_primitivo","Anillo_de_polinomios","Polinomio_primitivo","Corolario","Dominio_de_ideales_principales","Criterio_de_Eisenstein","Polinomio_irreducible","Universidad_de_Buenos_Aires","Control_de_autoridades"]}
{"url":"Lema_de_Zorn","titulo":"Lema de Zorn","contenido":"El lema de Zorn, tambien llamado de Kuratowski-Zorn, es una proposicion de la teoria de conjuntos que afirma lo siguiente:  Debe su nombre al matematico Max Zorn.  Los terminos se definen como sigue.  Dado un conjunto X , un orden en ese conjunto es una relacion \u2264 definida entre elementos del conjunto con las tres propiedades siguientes:  En este caso, diremos que ( X , \u2264 ) es un conjunto parcialmente ordenado. Si ademas se tiene la siguiente propiedad:  diremos que ( X , \u2264 ) es un conjunto totalmente ordenado.  Notese que el orden mas habital (en los numeros enteros, reales, etc.) es total, pero hay otros ordenes que no tienen por que serlo. Por ejemplo, en Z + ^{+}} , se puede comprobar que la relacion de divisibilidad es un orden: n \u2264 m \u21d4 n | m (tiene las tres propiedades anteriores). Sin embargo, no es un orden total, pues hay elementos que no son comparables. Por ejemplo, el 3 y el 5 no son comparables por ese orden, pues ni uno divide al otro, ni el otro al uno.  Diremos que un subconjunto Y de X tiene una cota superior u si y \u2264 u para cualquier y \u2208 Y ; no se necesita que u sea miembro de Y . Por ejemplo, 10 es una cota superior de { 1 , 2 , 4 , 6 } } con el orden habitual en Z } , sin embargo no lo es con el orden de divisibilidad, pues 10 \u2265 4 , 6 . En este caso, una cota podria ser, por ejemplo, 24 .  Un elemento m \u2208 Y es maximal si el unico y \u2208 Y tal que m \u2264 y es m mismo. Notese la diferencia entre maximal y maximo: un elemento es maximal de un conjunto si no existe ningun elemento mas grande en el conjunto, y es maximo si es mas grande que todos los elementos del conjunto. Por ejemplo, en Z + ^{+}} con el orden de divisibilidad, el conjunto { 1 , 2 , 4 , 6 } } tiene dos maximales: el 4 y el 6, pues ninguno divide a ningun otro elemento del conjunto. Sin embargo, ninguno de ellos es un maximo, pues ninguno es mas grande (es multiplo) que todos los demas.  Con esto ya estamos en condiciones de entender el enunciado:  El axioma de eleccion dice que dada una familia (posiblemente infinita) de conjuntos no vacios podemos definir una aplicacion que tome un elemento de cada conjunto:   \u2200 A : \u2205 \u2208 A \u27f9 \u2203 ( f : A \u2192 \u22c3 A ) : \u2200 B \u2208 A , f ( B ) \u2208 B .  Con este axioma podemos demostrar el lema de Zorn:  Sea que X el conjunto parcialmente ordenado del enunciado. Suponemos que X no tiene ningun elemento maximal y llegaremos a contradiccion.  Por hipotesis, cada subconjunto A \u2286 X totalmente ordenado tiene una cota superior. Por el axioma de eleccion podemos definir una funcion g que dado cada uno de estos subconjuntos devuelva su cota superior. Ademas, como estamos suponiendo que X no tiene ningun elemento maximal, se puede pedir que la cota de cada uno de estos subconjuntos no este dentro del subconjunto. Es decir, dado A \u2286 X totalmente ordenado, g ( A ) \u2208 X \u2216 A nos da una cota superior. Para cada A \u2286 X y a \u2208 A , denotamos A < a = { x \u2208 A : x < a } =\\{x\\in A:x<a\\}} (notamos que, en particular, a \u2208 A < a } )  Diremos que A \u2286 X es un g -conjunto si:  (i) Es totalmente ordenado.  (ii) No contiene secuencias infinitamente descendientes, es decir, no existen secuencias a 1 > a 2 > \u2026 >a_{2}>\\dots } infinitas en A .  (iii) Para cada a \u2208 A , g ( A < a ) = a )=a} (esta bien definido porque a \u2208 A < a } ).  Observamos que:  (i) A \u222a { g ( A ) } } es totalmente ordenado porque A ya lo era y, por definicion, g ( A ) > x \u2200 x \u2208 A .  (ii) Las longitudes de las secuencias descendientes ha aumentado en uno al a\u00f1adir g ( A ) , pero si eran finitas, lo siguen siendo.  Afirmamos que si A , B \u2286 X son g -conjuntos diferentes, entonces A = B < b } para cierto b \u2208 B o bien B = A < a } para cierto a \u2208 A . ( 2 )  Sea ahora E = \u22c3 A \u2208 X A g -conjunto A }}{A\\in X}}{A}} . Entonces, \u2200 a \u2208 E , si A es un g -conjunto que contiene a a , tenemos que A < a = E < a =E_{<a}} . ( 3 )   ( \u2286 ) Claramente, A < a \u2286 E < a \\subseteq E_{<a}} , porque x \u2208 A < a \u21d4 { x \u2208 A \u21d2 def E x \u2208 E x < a } \u21d2 x \u2208 E < a \\Leftrightarrow \\left\\{x\\in A}E}}x\\in E\\\\x<a\\end{matrix}}\\right\\}\\Rightarrow x\\in E_{<a}} .   ( \u2287 ) Sea x \u2208 E < a } y supongamos que B es un g -conjunto tal que x \u2208 B .  En cualquier caso, x \u2208 A < a } , como queriamos.  Por ultimo, E es un g -conjunto. ( 4 )  (ii) No existen secuencias descendientes infinitas: Supongamos que existe una: a 1 > a 2 > \u2026 >a_{2}>\\dots } . Sea A un g -conjunto con a 1 \u2208 A \u21d2 \u2200 i \u2265 2 a i \u2208 E < a 1 = ( 3 ) A < a 1 \u2286 A \u21d2 A \\in A\\Rightarrow \\forall i\\geq 2\\quad a_{i}\\in E_{<a_{1}}{=}}A_{<a_{1}}\\subseteq A\\Rightarrow A} tiene una secuencia descendiente infinita, lo cual es contradictorio con que A es un g -conjunto.  (iii) g ( E < a ) = a )=a} . Sea A un g -conjunto con a \u2208 A . Entonces, a = g ( A < a ) = ( 3 ) g ( E < a ) ){=}}g(E_{<a})} .  Por tanto, E es, por definicion y por ( 4 ) , el g -conjunto mas grande, pero g ( E ) \u2208 E y, por ( 1 ) , E \u222a { g ( E ) } } es un g -conjunto mas grande que E , lo que es contradictorio. La contradccion proviene de haber supuesto que X no tiene ningun elemento maximal. Por tanto, si que tiene, que es lo que queriamos demostrar. \u25fb  Al igual que el teorema del buen orden, el lema de Zorn es equivalente al axioma de eleccion, en el sentido de que cualquiera de ellos, junto con los axiomas de Zermelo-Fraenkel, basta para probar los otros. Aparece en las demostraciones de varios teoremas importantes, tales como el teorema de Hahn-Banach en analisis funcional, el teorema de que todo espacio vectorial tiene una base, el teorema de Tychonoff en topologia, y los teoremas en algebra abstracta que afirman que todo anillo con elemento unitario tiene un ideal maximal y que todo cuerpo tiene clausura algebraica.  Se considerara una aplicacion usual del lema de Zorn: la prueba de que todo anillo R con unidad contiene un ideal maximal. Sea P el conjunto de todos los ideales bilaterales de R excepto R mismo, que no es vacio pues incluye al menos al ideal trivial {0} de R. Este conjunto esta parcialmente ordenado por inclusion.  Sea entonces T un subconjunto totalmente ordenado de P; se demostrara que T tiene cota superior, es decir, hay un ideal I \u2286 R que contiene a todos los miembros de T, pero que no es igual a R (de lo contrario no estaria en P). Sea I la union de todos los ideales en T. Esta es tambien un ideal: para cualquier a, b \u2208 I, existen J, K \u2208 T tales que a \u2208 J y b \u2208 K. Como T esta totalmente ordenado, K \u2286 J o J \u2286 K. En el primer caso, b \u2208 J y por lo tanto, como J es un ideal, a + b, ar, ra \u2208 J \u2286 I para cualquier r \u2208 R. En el segundo caso se razona de manera similar.  Para demostrar que I es distinto de R, basta con observar que un ideal es igual a R si y solo si incluye a 1. Es evidente que si es igual a R debe incluir a 1; reciprocamente, si incluye a 1 debe incluir a 1r = r para cualquier r \u2208 R, y por lo tanto debe contener a R. Ahora bien, si I = R deberia incluir a 1, con lo que habria un J \u2208 T tal que 1 \u2208 J, y por lo tanto J = R, contradiciendo la definicion de P, que no lo incluia.  Se demostro que T tiene una cota superior en P. Aplicando el lema de Zorn, se tiene que P debe tener un elemento maximal, y por lo tanto, R tiene un ideal maximal.  Es de notar que la demostracion depende del hecho de que R tenga un elemento unitario 1. De lo contrario, no solo la prueba fallaria, el mismo enunciado del teorema seria falso. ","snippet":"El lema de Zorn, tambien llamado de Kuratowski-Zorn, es una proposicion de la teoria de conjuntos que afirma lo siguiente:  Debe su nombre al matematico Max Zorn.  Los terminos se definen como sigue. ","enlaces_salientes":["Lema_de_Zorn","Lema_de_Zorn","Lema_de_Zorn","Kuratowski","Max_Zorn","Teor%C3%ADa_de_conjuntos","Conjunto_parcialmente_ordenado","Conjunto_vac%C3%ADo","Orden_total","Subconjunto","Orden_total","Cota_superior","Elemento_maximal","Max_Zorn","Conjunto","Orden_parcial","Relaci%C3%B3n_matem%C3%A1tica","Relaci%C3%B3n_reflexiva","Relaci%C3%B3n_antisim%C3%A9trica","Relaci%C3%B3n_transitiva","Conjunto_parcialmente_ordenado","Conjunto_totalmente_ordenado","N%C3%BAmero_entero","N%C3%BAmero_real","Divisibilidad","Elementos_maximal_y_minimal","Elemento_m%C3%A1ximo_y_m%C3%ADnimo","Conjunto_parcialmente_ordenado","Conjunto_vac%C3%ADo","Orden_total","Subconjunto","Orden_total","Cota_superior","Elemento_maximal","Axioma_de_elecci%C3%B3n","Conjunto_vac%C3%ADo","Teorema_del_buen_orden","Axioma_de_elecci%C3%B3n","Axiomas_de_Zermelo-Fraenkel","Teorema_de_Hahn-Banach","An%C3%A1lisis_funcional","Espacio_vectorial","Base_(%C3%A1lgebra)","Teorema_de_Tychonoff","Topolog%C3%ADa","%C3%81lgebra_abstracta","Anillo_(%C3%A1lgebra)","Elemento_unitario","Ideal_(teor%C3%ADa_de_anillos)#Casos_particulares","Cuerpo_(matem%C3%A1ticas)","Clausura_algebraica","Ideal_(teor%C3%ADa_de_anillos)#Casos_particulares","Ideal_de_un_anillo","Subconjunto","Uni%C3%B3n_de_conjuntos","Axiomas_de_Zermelo-Fraenkel","Axioma_de_elecci%C3%B3n","Axiomas_de_Von_Neumann-Bernays-G%C3%B6del","Principio_maximal_de_Hausdorff","Teor%C3%ADa_axiom%C3%A1tica_de_conjuntos","Max_Zorn","Control_de_autoridades","Enciclopedia_Brit%C3%A1nica"]}
{"url":"Conjetura_matem%C3%A1tica","titulo":"Conjetura","contenido":"Por conjetura se entiende el juicio que se forma (moral, etico o matematico) de las cosas o sucesos por indicios u observaciones.\u200b  En matematicas, el concepto de conjetura se refiere a una afirmacion  o una proposicion  que se supone cierta, pero que no ha sido demostrada ni refutada hasta la fecha.\u200b\u200b\u200b\u200b Una vez que se demuestra la veracidad de una conjetura, esta pasa a ser considerada un teorema de pleno derecho y puede utilizarse como tal para construir otras demostraciones formales. Algunas conjeturas, como la hipotesis de Riemann (todavia una conjetura) o el ultimo teorema de Fermat (una conjetura hasta que Andrew Wiles lo demostro en 1995), han dado forma a gran parte de la historia matematica como nuevas areas de las matematicas se desarrollan con el fin de demostralos.  Hasta hace poco la conjetura mas conocida era el llamado ultimo teorema de Fermat, mal llamado asi porque, aunque Pierre de Fermat afirmo haber encontrado una demostracion, no se ha podido encontrar ninguna entre sus escritos tras su muerte. Esta conjetura burlo a la comunidad matematica durante mas de tres siglos hasta que Andrew Wiles la demostro al fin en 1993 y la elevo al rango de teorema.  Estas son algunas de las conjeturas mas famosas:  En teoria de numeros, el ultimo teorema de Fermat (a veces llamado conjetura de Fermat, especialmente en textos mas antiguos) establece que no hay tres numeros enteros positivos a , b , y c que puedan satisfacer la ecuacion a n + b n = c n +b^{n}=c^{n}} para cualquier valor entero de n mayor que dos.  Este teorema fue conjeturado por primera vez por Pierre de Fermat en 1637 en el margen de una copia de Arithmetica, donde afirmo que tenia una prueba que era demasiado grande para caber en el margen.\u200b La primera prueba exitosa fue lanzada en 1994 por Andrew Wiles, y publicada formalmente en 1995, despues de 358 a\u00f1os de esfuerzo por parte de los matematicos. El problema no resuelto estimulo el desarrollo de la teoria algebraica de numeros en el siglo\u00a0XIX y la demostracion del teorema de modularidad en el siglo\u00a0XX. Es uno de los teoremas mas notables de la historia de las matematicas, y antes de su demostracion estaba en el Libro Guinness de los Records Mundiales como uno de  \"los problemas matematicos mas dificiles\".\u200b  En matematicas, el teorema de los cuatro colores, o el teorema del mapa de cuatro colores, establece que dada cualquier separacion de un plano en regiones contiguas, para producir una figura llamada mapa, no se requieren mas de cuatro colores para colorear las regiones del mapa, por lo que no hay dos regiones adyacentes que tengan el mismo color. Dos regiones se denominan adyacentes si comparten un limite comun que no es una esquina, donde las esquinas son los puntos compartidos por tres o mas regiones.\u200b Por ejemplo, en el mapa de los Estados Unidos de America, Utah y Arizona son adyacentes, pero Utah y Nuevo Mexico, que solo comparten un punto que tambien pertenece a Arizona y Colorado, no lo son.  Mobius menciono el problema en sus conferencias ya en 1840.\u200b La conjetura se propuso por primera vez el 23 de octubre de 1852\u200b cuando Francis Guthrie, mientras intentaba colorear el mapa de las regiones de Inglaterra, noto que solo cuatro colores diferentes eran necesario. El teorema de los cinco colores, que tiene una breve demostracion elemental, establece que cinco colores son suficientes para colorear un mapa y fue probado a finales del siglo\u00a0XIX;\u200b sin embargo, demostrar que cuatro colores son suficientes resulto ser significativamente mas dificil. Han aparecido varias demostraciones falsas y contraejemplos falsos desde la primera declaracion del teorema de los cuatro colores en 1852.  El teorema de los cuatro colores fue finalmente probado en 1976 por Kenneth Appel y Wolfgang Haken. Fue el primer teorema importante que se demostro utilizando una computadora. El enfoque de Appel y Haken comenzo mostrando que hay un conjunto particular de 1936 mapas, cada uno de los cuales no puede ser parte de un contraejemplo de menor tama\u00f1o para el teorema de los cuatro colores (es decir, si aparecieran, se podria hacer un contraejemplo mas peque\u00f1o). Appel y Haken utilizaron un programa informatico de proposito especial para confirmar que cada uno de estos mapas tenia esta propiedad. Ademas, cualquier mapa que pueda ser un contraejemplo debe tener una parte que se parezca a uno de estos 1.936 mapas. Mostrando esto con cientos de paginas de analisis a mano, Appel y Haken concluyeron que no existe un contraejemplo mas peque\u00f1o porque cualquiera debe contener, pero no contener, uno de estos 1.936 mapas. Esta contradiccion significa que no hay contraejemplos en absoluto y que, por lo tanto, el teorema es verdadero. Inicialmente, la demostracion asistida por computadora no era factible para que un humano la verificara a mano.\u200b Sin embargo, la demostracion ha ganado desde entonces una aceptacion mas amplia, aunque aun quedan dudas.\u200b  En matematicas, la conjetura de Poincare es un teorema sobre la caracterizacion de la 3-esfera, que es la hiperesfera que delimita la bola unitaria en el espacio de cuatro dimensiones. La conjetura establece que:  La esfera cuatridimensional, tambien llamada 3-esfera o hiperesfera, es la unica variedad compacta cuatridimensional en la que todo lazo o circulo cerrado (1-esfera) se puede deformar (transformar) en un punto. Este ultimo enunciado es equivalente a decir que solo hay una variedad cerrada y simplemente conexa de dimension 3: la esfera cuatridimensional.\u200b  Una forma equivalente de la conjetura implica una forma de equivalencia mas burda que el homeomorfismo llamado equivalencia de homotopia: si una variedad 3 es homotopia equivalente a la esfera 3, entonces es necesariamente homeomorfica para ella.  Conjeturado originalmente por Henri Poincare, el teorema se refiere a un espacio que localmente se parece a un espacio tridimensional ordinario, pero esta conectado, es de tama\u00f1o finito y carece de cualquier limite (una variedad tridimensional cerrada). La conjetura de Poincare afirma que si tal espacio tiene la propiedad adicional de que cada bucle en el espacio puede ajustarse continuamente a un punto, entonces es necesariamente una esfera tridimensional. Un resultado analogo se conoce desde hace algun tiempo en dimensiones superiores.  Despues de casi un siglo de esfuerzo por parte de los matematicos, Grigori Perelman presento una demostracion de la conjetura en tres articulos disponibles en 2002 y 2003 en arXiv. La demostracion esta basada en el programa de Richard S. Hamilton para utilizar el flujo de Ricci para intentar resolver el problema. Mas tarde, Hamilton introdujo una modificacion del flujo de Ricci estandar, llamado flujo de Ricci con cirugia para extirpar sistematicamente regiones singulares a medida que se desarrollan, de forma controlada, pero no pudo probar que este metodo \"convergia\" en tres dimensiones.\u200b Perelman completo esta parte de la demostracion. Varios equipos de matematicos han verificado que la demostracion de Perelman es correcta.  La conjetura de Poincare, antes de ser probada, era una de las cuestiones abiertas mas importantes en topologia.  Las matematicas formales se basan en verdades demostrables. En matematicas, cualquier numero de casos que apoyen una conjetura cuantificada universalmente, sin importar cuan grande sea, es insuficiente para establecer la veracidad de la conjetura, ya que un solo contraejemplo podria derribar la conjetura inmediatamente. Las revistas de matematicas a veces publican los resultados menores de los equipos de investigacion que han extendido la busqueda de un contraejemplo mas alla de lo que se habia hecho anteriormente. Por ejemplo, la conjetura de Collatz, que se refiere a si ciertas secuencias de numeros enteros terminan o no, ha sido probada para todos los numeros enteros hasta 1.2 \u00d7 10 12 (mas de un billon). Sin embargo, el hecho de no encontrar un contraejemplo despues de una busqueda extensa no constituye una prueba de que la conjetura sea verdadera, porque la conjetura podria ser falsa pero con un contraejemplo minimo muy grande.  Sin embargo, los matematicos a menudo consideran que una conjetura esta fuertemente respaldada por evidencia, aunque aun no haya sido probada. Esa evidencia puede ser de varios tipos, como la verificacion de sus consecuencias o fuertes interconexiones con resultados conocidos.\u200b  Una conjetura se considera probada solo cuando se ha demostrado que es logicamente imposible que sea falsa. Existen varios metodos para hacerlo; ver metodos de demostracion matematica para mas detalles.  Un metodo de demostracion, aplicable cuando solo hay un numero finito de casos que podrian dar lugar a contraejemplos, se conoce como \" fuerza bruta \": en este enfoque, se consideran todos los casos posibles y se demuestra que no dan contraejemplos. En algunas ocasiones, el numero de casos es bastante grande, en cuyo caso una prueba de fuerza bruta puede requerir en la practica el uso de un algoritmo informatico para verificar todos los casos. Por ejemplo, inicialmente se puso en duda la validez de las pruebas de fuerza bruta de 1976 y 1997 del teorema de los cuatro colores por computadora, pero finalmente se confirmo en 2005 mediante un software de demostracion de teoremas.  Cuando una conjetura ha sido demostraba, ya no es una conjetura sino un teorema. Muchos teoremas importantes fueron alguna vez conjeturas, como el teorema de geometrizacion (que resolvio la conjetura de Poincare), el ultimo teorema de Fermat y otros.  Las conjeturas refutadas mediante contraejemplos a veces se denominan conjeturas falsas (cf. la conjetura de Polya y la conjetura de la suma de poderes de Euler ). En el caso de este ultimo, el primer contraejemplo encontrado para el caso n = 4 involucro numeros en millones, aunque posteriormente se ha encontrado que el contraejemplo minimo es en realidad mas peque\u00f1o.  Conjeturas independientes No todas las conjeturas terminan siendo verdaderas o falsas. La hipotesis del continuo , que trata de determinar la relacion de cardinalidad de ciertos conjuntos infinitos , fue finalmente demostrado ser independiente del conjunto generalmente aceptada de axiomas Zermelo-Fraenkel de la teoria de conjuntos. Por lo tanto, es posible adoptar este enunciado, o su negacion, como un nuevo axioma de manera consistente (tanto como el postulado paralelo de Euclides puede tomarse como verdadero o falso en un sistema axiomatico para la geometria).  En este caso, si una prueba usa esta declaracion, los investigadores a menudo buscaran una nueva prueba que no requiera la hipotesis (de la misma manera que es deseable que las declaraciones en geometria euclidiana se prueben usando solo los axiomas de geometria neutra, es decir, sin el postulado paralelo). La unica excepcion importante a esto en la practica es el axioma de eleccion , ya que la mayoria de los investigadores generalmente no se preocupan si un resultado lo requiere, a menos que esten estudiando este axioma en particular.  A veces, una conjetura se llama hipotesis cuando se usa con frecuencia y repetidamente como suposicion en las demostraciones de otros resultados.\u200b Por ejemplo, la hipotesis de Riemann es una conjetura de la teoria de numeros que, entre otras cosas, hace predicciones sobre la distribucion de numeros primos. Pocos teoricos de los numeros dudan de que la hipotesis de Riemann sea cierta. De hecho, en prevision de su eventual prueba, algunos incluso han procedido a desarrollar mas pruebas que dependen de la verdad de esta conjetura. Estas se denominan demostraciones condicionales: las conjeturas asumidas aparecen en las hipotesis del teorema, por el momento.  Estas \"demostraciones\", sin embargo, se desmoronarian si resultara que la hipotesis es falsa, por lo que existe un interes considerable en verificar la veracidad o falsedad de conjeturas de este tipo.   ","snippet":"Por conjetura se entiende el juicio que se forma (moral, etico o matematico) de las cosas o sucesos por indicios u observaciones.\u200b  En matematicas, el concepto de conjetura se refiere a una afirmacion","enlaces_salientes":["Conjetura","Conjetura","Conjetura","Matem%C3%A1ticas","Demostraci%C3%B3n_matem%C3%A1tica","Teorema","Demostraci%C3%B3n_matem%C3%A1tica","Hip%C3%B3tesis_de_Riemann","%C3%9Altimo_teorema_de_Fermat","Andrew_Wiles","%C3%9Altimo_teorema_de_Fermat","Pierre_de_Fermat","Matem%C3%A1tico","Andrew_Wiles","N%C3%BAmero_perfecto","Conjetura_de_Goldbach","Conjetura_de_los_n%C3%BAmeros_primos_gemelos","Conjetura_de_Collatz","Hip%C3%B3tesis_de_Riemann","Clases_de_complejidad_P_y_NP","Conjetura_de_Poincar%C3%A9","Grigori_Perelm%C3%A1n","Conjetura_abc","Teor%C3%ADa_de_n%C3%BAmeros","%C3%9Altimo_teorema_de_Fermat","Pierre_de_Fermat","Andrew_Wiles","Teor%C3%ADa_de_n%C3%BAmeros_algebraicos","Historia_de_las_matem%C3%A1ticas","Libro_Guinness_de_los_R%C3%A9cords_Mundiales","Teorema_de_los_cuatro_colores","Teorema_de_los_cuatro_colores","Mapa","Estados_Unidos","Utah","Arizona","Utah","Nuevo_M%C3%A9xico","August_Ferdinand_M%C3%B6bius","Inglaterra","Wolfgang_Haken","Conjetura_de_Poincar%C3%A9","3-esfera","Hiperesfera","3-esfera","Hiperesfera","Variedad_compacta_(matem%C3%A1tica)","Lazo_(topolog%C3%ADa)","C%C3%ADrculo","1-esfera","Punto_(geometr%C3%ADa)","Simplemente_conexa","Esfera","Homeomorfismo","Homotop%C3%ADa","Henri_Poincar%C3%A9","Espacio_tridimensional","Grigori_Perelman","ArXiv","Flujo_de_Ricci","Topolog%C3%ADa","Conjetura_de_Collatz","Teorema_de_los_cuatro_colores","Conjetura_de_Poincar%C3%A9","%C3%9Altimo_teorema_de_Fermat","Contraejemplo","Hip%C3%B3tesis_del_continuo","Axioma","Geometr%C3%ADa_euclidiana","Hip%C3%B3tesis_de_Riemann","Hip%C3%B3tesis_(l%C3%B3gica)","Futurolog%C3%ADa","Experimento_mental","ISBN","ISBN","W._W._Rouse_Ball","ISSN","JSTOR","Digital_object_identifier","ISBN","OCLC","Mathematical_Reviews","Zentralblatt_MATH","Digital_object_identifier","Digital_object_identifier","Karl_Popper","ISBN","Control_de_autoridades"]}
